"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[3805],{30876:(t,n,e)=>{e.d(n,{Zo:()=>l,kt:()=>h});var o=e(2784);function p(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function r(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,o)}return e}function s(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?r(Object(e),!0).forEach((function(n){p(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function c(t,n){if(null==t)return{};var e,o,p=function(t,n){if(null==t)return{};var e,o,p={},r=Object.keys(t);for(o=0;o<r.length;o++)e=r[o],n.indexOf(e)>=0||(p[e]=t[e]);return p}(t,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)e=r[o],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(p[e]=t[e])}return p}var i=o.createContext({}),a=function(t){var n=o.useContext(i),e=n;return t&&(e="function"==typeof t?t(n):s(s({},n),t)),e},l=function(t){var n=a(t.components);return o.createElement(i.Provider,{value:n},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var n=t.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(t,n){var e=t.components,p=t.mdxType,r=t.originalType,i=t.parentName,l=c(t,["components","mdxType","originalType","parentName"]),u=a(e),d=p,h=u["".concat(i,".").concat(d)]||u[d]||m[d]||r;return e?o.createElement(h,s(s({ref:n},l),{},{components:e})):o.createElement(h,s({ref:n},l))}));function h(t,n){var e=arguments,p=n&&n.mdxType;if("string"==typeof t||p){var r=e.length,s=new Array(r);s[0]=d;var c={};for(var i in n)hasOwnProperty.call(n,i)&&(c[i]=n[i]);c.originalType=t,c[u]="string"==typeof t?t:p,s[1]=c;for(var a=2;a<r;a++)s[a]=e[a];return o.createElement.apply(null,s)}return o.createElement.apply(null,e)}d.displayName="MDXCreateElement"},83851:(t,n,e)=>{e.d(n,{Z:()=>u});var o=e(7896),p=e(2784),r=e(6277),s=e(1077),c=e(97683),i=e(89817);const a="anchorWithStickyNavbar_fF9Z",l="anchorWithHideOnScrollNavbar_Yh18";function u(t){let{as:n,id:e,...u}=t;const{navbar:{hideOnScroll:m}}=(0,c.L)();if("h1"===n||!e)return p.createElement(n,(0,o.Z)({},u,{id:void 0}));const d=(0,s.I)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:"string"==typeof u.children?u.children:e});return p.createElement(n,(0,o.Z)({},u,{className:(0,r.Z)("anchor",m?l:a,u.className),id:e}),u.children,p.createElement(i.Z,{className:"hash-link",to:`#${e}`,"aria-label":d,title:d},"\u200b"))}},52665:(t,n,e)=>{e.d(n,{Z:()=>k});var o=e(2784);const p="container_lQCo",r="small_As57",s="banner_A4QS",c="player_tELG",i="link_BTzN",a="icon_wSGd";var l=e(7896);function u(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0},p),o.createElement("path",{d:"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z",fill:"currentColor"}))}var m=e(89817),d=e(6277);function h(t){let{name:n}=t;const e=`https://github.com/motion-canvas/motion-canvas/blob/main/packages/examples/src/scenes/${n}.tsx`;return o.createElement(m.Z,{to:e,className:(0,d.Z)("padding--sm",i)},o.createElement("span",null,"View source code"),o.createElement(u,{className:a}))}function k(t){let{name:n,banner:e,small:i,link:a}=t;return o.createElement("div",{className:(0,d.Z)(p,e&&s,i&&r)},o.createElement("motion-canvas-player",{class:c,src:`/examples/${n}.js`,auto:e}),o.createElement(h,{name:a||n}))}e(31263).Z.canUseDOM&&e.e(5483).then(e.bind(e,85483))},42072:(t,n,e)=>{e.d(n,{Z:()=>s});var o=e(2784),p=e(88617),r=e(31930);function s(t){let{url:n}=t;const e=(0,p.rG)()(n);return o.createElement(r.Z,{reflection:e,headless:!0})}},30956:(t,n,e)=>{e.d(n,{Z:()=>xgn});var o={};e.r(o),e.d(o,{content_0_0:()=>i,content_0_10:()=>M,content_0_100:()=>tn,content_0_1000:()=>Ef,content_0_1002:()=>Gf,content_0_1004:()=>Uf,content_0_1006:()=>qf,content_0_1008:()=>jf,content_0_1010:()=>Qf,content_0_1012:()=>Yf,content_0_1014:()=>Jf,content_0_1016:()=>nM,content_0_1018:()=>oM,content_0_102:()=>en,content_0_1020:()=>rM,content_0_1022:()=>cM,content_0_1024:()=>aM,content_0_1026:()=>uM,content_0_1028:()=>dM,content_0_1030:()=>kM,content_0_1032:()=>fM,content_0_1034:()=>DM,content_0_1036:()=>_M,content_0_1038:()=>gM,content_0_104:()=>pn,content_0_1040:()=>xM,content_0_1042:()=>vM,content_0_1044:()=>ZM,content_0_1046:()=>NM,content_0_1048:()=>AM,content_0_1050:()=>RM,content_0_1052:()=>SM,content_0_1054:()=>EM,content_0_1056:()=>GM,content_0_1058:()=>UM,content_0_106:()=>sn,content_0_1060:()=>qM,content_0_1062:()=>jM,content_0_1064:()=>QM,content_0_1066:()=>YM,content_0_1068:()=>JM,content_0_1070:()=>nD,content_0_1072:()=>oD,content_0_1074:()=>rD,content_0_1076:()=>cD,content_0_1078:()=>aD,content_0_108:()=>an,content_0_1080:()=>uD,content_0_1082:()=>dD,content_0_1084:()=>kD,content_0_1086:()=>fD,content_0_1088:()=>DD,content_0_1090:()=>_D,content_0_1092:()=>gD,content_0_1094:()=>xD,content_0_1096:()=>vD,content_0_1098:()=>ZD,content_0_110:()=>un,content_0_1100:()=>ND,content_0_1102:()=>AD,content_0_1104:()=>RD,content_0_1106:()=>SD,content_0_1108:()=>ED,content_0_1110:()=>GD,content_0_1112:()=>UD,content_0_1114:()=>qD,content_0_1116:()=>jD,content_0_112:()=>dn,content_0_114:()=>kn,content_0_116:()=>fn,content_0_118:()=>Dn,content_0_12:()=>w,content_0_120:()=>_n,content_0_122:()=>gn,content_0_124:()=>xn,content_0_126:()=>vn,content_0_128:()=>Zn,content_0_130:()=>Nn,content_0_132:()=>An,content_0_134:()=>Rn,content_0_136:()=>Sn,content_0_138:()=>En,content_0_14:()=>X,content_0_140:()=>Gn,content_0_142:()=>Un,content_0_144:()=>qn,content_0_146:()=>jn,content_0_148:()=>Qn,content_0_150:()=>Yn,content_0_152:()=>Jn,content_0_154:()=>ne,content_0_156:()=>oe,content_0_158:()=>re,content_0_16:()=>T,content_0_160:()=>ce,content_0_162:()=>ae,content_0_164:()=>ue,content_0_166:()=>de,content_0_168:()=>ke,content_0_170:()=>fe,content_0_172:()=>De,content_0_174:()=>_e,content_0_176:()=>ge,content_0_178:()=>xe,content_0_18:()=>C,content_0_180:()=>ve,content_0_182:()=>Ze,content_0_184:()=>Ne,content_0_186:()=>Ae,content_0_188:()=>Re,content_0_190:()=>Se,content_0_192:()=>Ee,content_0_194:()=>Ge,content_0_196:()=>Ue,content_0_198:()=>qe,content_0_2:()=>l,content_0_20:()=>L,content_0_200:()=>je,content_0_202:()=>Qe,content_0_204:()=>Ye,content_0_206:()=>Je,content_0_208:()=>no,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>co,content_0_216:()=>ao,content_0_218:()=>uo,content_0_22:()=>b,content_0_220:()=>ho,content_0_222:()=>yo,content_0_224:()=>Mo,content_0_226:()=>wo,content_0_228:()=>Xo,content_0_230:()=>To,content_0_232:()=>Co,content_0_234:()=>Lo,content_0_236:()=>bo,content_0_238:()=>zo,content_0_24:()=>z,content_0_240:()=>Wo,content_0_242:()=>Io,content_0_244:()=>Po,content_0_246:()=>Bo,content_0_248:()=>Oo,content_0_250:()=>Fo,content_0_252:()=>Vo,content_0_254:()=>Ho,content_0_256:()=>$o,content_0_258:()=>Ko,content_0_26:()=>W,content_0_260:()=>tp,content_0_262:()=>ep,content_0_264:()=>pp,content_0_266:()=>sp,content_0_268:()=>ip,content_0_270:()=>lp,content_0_272:()=>mp,content_0_274:()=>hp,content_0_276:()=>yp,content_0_278:()=>Mp,content_0_28:()=>I,content_0_280:()=>wp,content_0_282:()=>Xp,content_0_284:()=>Tp,content_0_286:()=>Cp,content_0_288:()=>Lp,content_0_290:()=>bp,content_0_292:()=>zp,content_0_294:()=>Wp,content_0_296:()=>Ip,content_0_298:()=>Pp,content_0_30:()=>P,content_0_300:()=>Bp,content_0_302:()=>Op,content_0_304:()=>Fp,content_0_306:()=>Vp,content_0_308:()=>Hp,content_0_310:()=>$p,content_0_312:()=>Kp,content_0_314:()=>tr,content_0_316:()=>er,content_0_318:()=>pr,content_0_32:()=>B,content_0_320:()=>sr,content_0_322:()=>ir,content_0_324:()=>lr,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>yr,content_0_332:()=>Mr,content_0_334:()=>wr,content_0_336:()=>Xr,content_0_338:()=>Tr,content_0_34:()=>O,content_0_340:()=>Cr,content_0_342:()=>Lr,content_0_344:()=>br,content_0_346:()=>zr,content_0_348:()=>Wr,content_0_350:()=>Ir,content_0_352:()=>Pr,content_0_354:()=>Br,content_0_356:()=>Or,content_0_358:()=>Fr,content_0_36:()=>F,content_0_360:()=>Vr,content_0_362:()=>Hr,content_0_364:()=>$r,content_0_366:()=>Kr,content_0_368:()=>ts,content_0_370:()=>es,content_0_372:()=>ps,content_0_374:()=>ss,content_0_376:()=>is,content_0_378:()=>ls,content_0_38:()=>V,content_0_380:()=>ms,content_0_382:()=>hs,content_0_384:()=>ys,content_0_386:()=>Ms,content_0_388:()=>ws,content_0_390:()=>Xs,content_0_392:()=>Ts,content_0_394:()=>Cs,content_0_396:()=>Ls,content_0_398:()=>bs,content_0_4:()=>m,content_0_40:()=>H,content_0_400:()=>zs,content_0_402:()=>Ws,content_0_404:()=>Is,content_0_406:()=>Ps,content_0_408:()=>Bs,content_0_410:()=>Os,content_0_412:()=>Fs,content_0_414:()=>Vs,content_0_416:()=>Hs,content_0_418:()=>$s,content_0_42:()=>$,content_0_420:()=>Ks,content_0_422:()=>tc,content_0_424:()=>ec,content_0_426:()=>pc,content_0_428:()=>sc,content_0_430:()=>ic,content_0_432:()=>lc,content_0_434:()=>mc,content_0_436:()=>hc,content_0_438:()=>yc,content_0_44:()=>K,content_0_440:()=>Mc,content_0_442:()=>wc,content_0_444:()=>Xc,content_0_446:()=>Tc,content_0_448:()=>Cc,content_0_450:()=>Lc,content_0_452:()=>bc,content_0_454:()=>zc,content_0_456:()=>Wc,content_0_458:()=>Ic,content_0_46:()=>tt,content_0_460:()=>Pc,content_0_462:()=>Bc,content_0_464:()=>Oc,content_0_466:()=>Fc,content_0_468:()=>Vc,content_0_470:()=>Hc,content_0_472:()=>$c,content_0_474:()=>Kc,content_0_476:()=>ti,content_0_478:()=>ei,content_0_48:()=>et,content_0_480:()=>pi,content_0_482:()=>si,content_0_484:()=>ii,content_0_486:()=>li,content_0_488:()=>mi,content_0_490:()=>hi,content_0_492:()=>yi,content_0_494:()=>Mi,content_0_496:()=>wi,content_0_498:()=>Xi,content_0_50:()=>pt,content_0_500:()=>Ti,content_0_502:()=>Ci,content_0_504:()=>Li,content_0_506:()=>bi,content_0_508:()=>zi,content_0_510:()=>Wi,content_0_512:()=>Ii,content_0_514:()=>Pi,content_0_516:()=>Bi,content_0_518:()=>Oi,content_0_52:()=>st,content_0_520:()=>Fi,content_0_522:()=>Vi,content_0_524:()=>Hi,content_0_526:()=>$i,content_0_528:()=>Ki,content_0_530:()=>ta,content_0_532:()=>ea,content_0_534:()=>pa,content_0_536:()=>sa,content_0_538:()=>ia,content_0_54:()=>it,content_0_540:()=>la,content_0_542:()=>ma,content_0_544:()=>ha,content_0_546:()=>ya,content_0_548:()=>Ma,content_0_550:()=>wa,content_0_552:()=>Xa,content_0_554:()=>Ta,content_0_556:()=>Ca,content_0_558:()=>La,content_0_56:()=>lt,content_0_560:()=>ba,content_0_562:()=>za,content_0_564:()=>Wa,content_0_566:()=>Ia,content_0_568:()=>Pa,content_0_570:()=>Ba,content_0_572:()=>Oa,content_0_574:()=>Fa,content_0_576:()=>Va,content_0_578:()=>Ha,content_0_58:()=>mt,content_0_580:()=>$a,content_0_582:()=>Ka,content_0_584:()=>tl,content_0_586:()=>el,content_0_588:()=>pl,content_0_590:()=>sl,content_0_592:()=>il,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>yl,content_0_602:()=>Ml,content_0_604:()=>wl,content_0_606:()=>Xl,content_0_608:()=>Tl,content_0_610:()=>Cl,content_0_612:()=>Ll,content_0_614:()=>bl,content_0_616:()=>zl,content_0_618:()=>Wl,content_0_62:()=>yt,content_0_620:()=>Il,content_0_622:()=>Pl,content_0_624:()=>Bl,content_0_626:()=>Ol,content_0_628:()=>Fl,content_0_630:()=>Vl,content_0_632:()=>Hl,content_0_634:()=>$l,content_0_636:()=>Kl,content_0_638:()=>tu,content_0_64:()=>Mt,content_0_640:()=>eu,content_0_642:()=>pu,content_0_644:()=>su,content_0_646:()=>iu,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>yu,content_0_656:()=>Mu,content_0_658:()=>wu,content_0_66:()=>wt,content_0_660:()=>Xu,content_0_662:()=>Tu,content_0_664:()=>Cu,content_0_666:()=>Lu,content_0_668:()=>bu,content_0_670:()=>zu,content_0_672:()=>Wu,content_0_674:()=>Iu,content_0_676:()=>Pu,content_0_678:()=>Bu,content_0_68:()=>Xt,content_0_680:()=>Ou,content_0_682:()=>Fu,content_0_684:()=>Vu,content_0_686:()=>Hu,content_0_688:()=>$u,content_0_690:()=>Ku,content_0_692:()=>tm,content_0_694:()=>em,content_0_696:()=>pm,content_0_698:()=>sm,content_0_70:()=>Tt,content_0_700:()=>im,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>ym,content_0_710:()=>Mm,content_0_712:()=>wm,content_0_714:()=>Xm,content_0_716:()=>Tm,content_0_718:()=>Cm,content_0_72:()=>Ct,content_0_720:()=>Lm,content_0_722:()=>bm,content_0_724:()=>zm,content_0_726:()=>Wm,content_0_728:()=>Im,content_0_730:()=>Pm,content_0_732:()=>Bm,content_0_734:()=>Om,content_0_736:()=>Fm,content_0_738:()=>Vm,content_0_74:()=>Lt,content_0_740:()=>Hm,content_0_742:()=>$m,content_0_744:()=>Km,content_0_746:()=>td,content_0_748:()=>ed,content_0_750:()=>pd,content_0_752:()=>sd,content_0_754:()=>id,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>bt,content_0_760:()=>hd,content_0_762:()=>yd,content_0_764:()=>Md,content_0_766:()=>wd,content_0_768:()=>Xd,content_0_770:()=>Td,content_0_772:()=>Cd,content_0_774:()=>Ld,content_0_776:()=>bd,content_0_778:()=>zd,content_0_78:()=>zt,content_0_780:()=>Wd,content_0_782:()=>Id,content_0_784:()=>Pd,content_0_786:()=>Bd,content_0_788:()=>Od,content_0_790:()=>Fd,content_0_792:()=>Vd,content_0_794:()=>Hd,content_0_796:()=>$d,content_0_798:()=>Kd,content_0_8:()=>y,content_0_80:()=>Wt,content_0_800:()=>th,content_0_802:()=>eh,content_0_804:()=>ph,content_0_806:()=>sh,content_0_808:()=>ih,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>yh,content_0_818:()=>Mh,content_0_82:()=>It,content_0_820:()=>wh,content_0_822:()=>Xh,content_0_824:()=>Th,content_0_826:()=>Ch,content_0_828:()=>Lh,content_0_830:()=>bh,content_0_832:()=>zh,content_0_834:()=>Wh,content_0_836:()=>Ih,content_0_838:()=>Ph,content_0_84:()=>Pt,content_0_840:()=>Bh,content_0_842:()=>Oh,content_0_844:()=>Fh,content_0_846:()=>Vh,content_0_848:()=>Hh,content_0_850:()=>$h,content_0_852:()=>Kh,content_0_854:()=>tk,content_0_856:()=>ek,content_0_858:()=>pk,content_0_86:()=>Bt,content_0_860:()=>sk,content_0_862:()=>ik,content_0_864:()=>lk,content_0_866:()=>mk,content_0_868:()=>hk,content_0_870:()=>yk,content_0_872:()=>Mk,content_0_874:()=>wk,content_0_876:()=>Xk,content_0_878:()=>Tk,content_0_88:()=>Ot,content_0_880:()=>Ck,content_0_882:()=>Lk,content_0_884:()=>bk,content_0_886:()=>zk,content_0_888:()=>Wk,content_0_890:()=>Ik,content_0_892:()=>Pk,content_0_894:()=>Bk,content_0_896:()=>Ok,content_0_898:()=>Fk,content_0_90:()=>Ft,content_0_900:()=>Vk,content_0_902:()=>Hk,content_0_904:()=>$k,content_0_906:()=>Kk,content_0_908:()=>ty,content_0_910:()=>ey,content_0_912:()=>py,content_0_914:()=>sy,content_0_916:()=>iy,content_0_918:()=>ly,content_0_92:()=>Vt,content_0_920:()=>my,content_0_922:()=>hy,content_0_924:()=>yy,content_0_926:()=>My,content_0_928:()=>wy,content_0_930:()=>Xy,content_0_932:()=>Ty,content_0_934:()=>Cy,content_0_936:()=>Ly,content_0_938:()=>by,content_0_94:()=>Ht,content_0_940:()=>zy,content_0_942:()=>Wy,content_0_944:()=>Iy,content_0_946:()=>Py,content_0_948:()=>By,content_0_950:()=>Oy,content_0_952:()=>Fy,content_0_954:()=>Vy,content_0_956:()=>Hy,content_0_958:()=>$y,content_0_96:()=>$t,content_0_960:()=>Ky,content_0_962:()=>tf,content_0_964:()=>ef,content_0_966:()=>pf,content_0_968:()=>sf,content_0_970:()=>af,content_0_972:()=>uf,content_0_974:()=>df,content_0_976:()=>kf,content_0_978:()=>ff,content_0_98:()=>Kt,content_0_980:()=>Df,content_0_982:()=>_f,content_0_984:()=>gf,content_0_986:()=>xf,content_0_988:()=>vf,content_0_990:()=>Zf,content_0_992:()=>Nf,content_0_994:()=>Af,content_0_996:()=>Rf,content_0_998:()=>Sf,content_2321_0:()=>QD,content_2321_10:()=>rw,content_2321_100:()=>G_,content_2321_1000:()=>gP,content_2321_1002:()=>xP,content_2321_1004:()=>vP,content_2321_1006:()=>ZP,content_2321_1008:()=>NP,content_2321_1010:()=>AP,content_2321_1012:()=>RP,content_2321_1014:()=>SP,content_2321_1016:()=>EP,content_2321_1018:()=>GP,content_2321_102:()=>U_,content_2321_1020:()=>UP,content_2321_1022:()=>qP,content_2321_1024:()=>jP,content_2321_1026:()=>QP,content_2321_1028:()=>YP,content_2321_1030:()=>JP,content_2321_1032:()=>nE,content_2321_1034:()=>oE,content_2321_1036:()=>rE,content_2321_1038:()=>cE,content_2321_104:()=>q_,content_2321_1040:()=>aE,content_2321_1042:()=>uE,content_2321_1044:()=>dE,content_2321_1046:()=>kE,content_2321_1048:()=>fE,content_2321_1050:()=>DE,content_2321_1052:()=>_E,content_2321_1054:()=>gE,content_2321_1056:()=>xE,content_2321_1058:()=>vE,content_2321_106:()=>j_,content_2321_1060:()=>ZE,content_2321_1062:()=>NE,content_2321_1064:()=>AE,content_2321_1066:()=>RE,content_2321_1068:()=>SE,content_2321_1070:()=>EE,content_2321_1072:()=>GE,content_2321_1074:()=>UE,content_2321_1076:()=>qE,content_2321_1078:()=>jE,content_2321_108:()=>Q_,content_2321_1080:()=>QE,content_2321_1082:()=>YE,content_2321_1084:()=>JE,content_2321_1086:()=>nB,content_2321_1088:()=>oB,content_2321_1090:()=>rB,content_2321_1092:()=>cB,content_2321_1094:()=>aB,content_2321_1096:()=>uB,content_2321_1098:()=>dB,content_2321_110:()=>Y_,content_2321_1100:()=>kB,content_2321_1102:()=>fB,content_2321_1104:()=>DB,content_2321_1106:()=>_B,content_2321_1108:()=>gB,content_2321_1110:()=>xB,content_2321_1112:()=>vB,content_2321_1114:()=>ZB,content_2321_1116:()=>NB,content_2321_1118:()=>AB,content_2321_112:()=>J_,content_2321_1120:()=>RB,content_2321_1122:()=>SB,content_2321_1124:()=>EB,content_2321_1126:()=>GB,content_2321_1128:()=>UB,content_2321_1130:()=>qB,content_2321_1132:()=>jB,content_2321_1134:()=>QB,content_2321_1136:()=>YB,content_2321_1138:()=>JB,content_2321_114:()=>nX,content_2321_1140:()=>nG,content_2321_1142:()=>oG,content_2321_1144:()=>rG,content_2321_1146:()=>cG,content_2321_1148:()=>aG,content_2321_1150:()=>uG,content_2321_1152:()=>dG,content_2321_1154:()=>kG,content_2321_1156:()=>fG,content_2321_1158:()=>DG,content_2321_116:()=>oX,content_2321_1160:()=>_G,content_2321_1162:()=>gG,content_2321_1164:()=>xG,content_2321_1166:()=>vG,content_2321_1168:()=>ZG,content_2321_1170:()=>NG,content_2321_1172:()=>AG,content_2321_1174:()=>RG,content_2321_1176:()=>SG,content_2321_1178:()=>EG,content_2321_118:()=>rX,content_2321_1180:()=>GG,content_2321_1182:()=>UG,content_2321_1184:()=>qG,content_2321_1186:()=>jG,content_2321_1188:()=>QG,content_2321_1190:()=>YG,content_2321_1192:()=>JG,content_2321_1194:()=>nO,content_2321_1196:()=>oO,content_2321_1198:()=>rO,content_2321_12:()=>cw,content_2321_120:()=>cX,content_2321_1200:()=>cO,content_2321_1202:()=>aO,content_2321_1204:()=>uO,content_2321_1206:()=>dO,content_2321_1208:()=>kO,content_2321_1210:()=>fO,content_2321_1212:()=>DO,content_2321_1214:()=>_O,content_2321_1216:()=>gO,content_2321_1218:()=>xO,content_2321_122:()=>aX,content_2321_1220:()=>vO,content_2321_1222:()=>ZO,content_2321_1224:()=>NO,content_2321_1226:()=>AO,content_2321_1228:()=>RO,content_2321_1230:()=>SO,content_2321_1232:()=>EO,content_2321_1234:()=>GO,content_2321_1236:()=>UO,content_2321_1238:()=>qO,content_2321_124:()=>uX,content_2321_1240:()=>jO,content_2321_1242:()=>QO,content_2321_1244:()=>YO,content_2321_1246:()=>JO,content_2321_1248:()=>nU,content_2321_1250:()=>oU,content_2321_1252:()=>rU,content_2321_1254:()=>cU,content_2321_1256:()=>aU,content_2321_1258:()=>uU,content_2321_126:()=>dX,content_2321_1260:()=>dU,content_2321_1262:()=>kU,content_2321_1264:()=>fU,content_2321_1266:()=>DU,content_2321_1268:()=>_U,content_2321_1270:()=>gU,content_2321_1272:()=>xU,content_2321_1274:()=>vU,content_2321_1276:()=>ZU,content_2321_1278:()=>NU,content_2321_128:()=>kX,content_2321_1280:()=>AU,content_2321_1282:()=>RU,content_2321_1284:()=>SU,content_2321_1286:()=>EU,content_2321_1288:()=>GU,content_2321_1290:()=>UU,content_2321_1292:()=>qU,content_2321_1294:()=>jU,content_2321_1296:()=>QU,content_2321_1298:()=>YU,content_2321_130:()=>fX,content_2321_1300:()=>JU,content_2321_1302:()=>nF,content_2321_1304:()=>oF,content_2321_1306:()=>rF,content_2321_1308:()=>cF,content_2321_1310:()=>aF,content_2321_1312:()=>uF,content_2321_1314:()=>dF,content_2321_1316:()=>kF,content_2321_1318:()=>fF,content_2321_132:()=>DX,content_2321_1320:()=>DF,content_2321_1322:()=>_F,content_2321_1324:()=>gF,content_2321_1326:()=>xF,content_2321_1328:()=>vF,content_2321_1330:()=>ZF,content_2321_1332:()=>NF,content_2321_1334:()=>AF,content_2321_1336:()=>RF,content_2321_1338:()=>SF,content_2321_134:()=>_X,content_2321_1340:()=>EF,content_2321_1342:()=>GF,content_2321_1344:()=>UF,content_2321_1346:()=>qF,content_2321_1348:()=>jF,content_2321_1350:()=>QF,content_2321_1352:()=>YF,content_2321_1354:()=>JF,content_2321_1356:()=>nq,content_2321_1358:()=>oq,content_2321_136:()=>gX,content_2321_1360:()=>rq,content_2321_1362:()=>cq,content_2321_1364:()=>aq,content_2321_1366:()=>uq,content_2321_1368:()=>dq,content_2321_1370:()=>kq,content_2321_1372:()=>fq,content_2321_1374:()=>Dq,content_2321_1376:()=>_q,content_2321_1378:()=>gq,content_2321_138:()=>xX,content_2321_1380:()=>xq,content_2321_1382:()=>vq,content_2321_1384:()=>Zq,content_2321_1386:()=>Nq,content_2321_1388:()=>Aq,content_2321_1390:()=>Rq,content_2321_1392:()=>Sq,content_2321_1394:()=>Eq,content_2321_1396:()=>Gq,content_2321_1398:()=>Uq,content_2321_14:()=>aw,content_2321_140:()=>vX,content_2321_1400:()=>qq,content_2321_1402:()=>jq,content_2321_1404:()=>Qq,content_2321_1406:()=>Yq,content_2321_1408:()=>Jq,content_2321_1410:()=>nV,content_2321_1412:()=>oV,content_2321_1414:()=>rV,content_2321_1416:()=>cV,content_2321_1418:()=>aV,content_2321_142:()=>ZX,content_2321_1420:()=>uV,content_2321_1422:()=>dV,content_2321_1424:()=>kV,content_2321_1426:()=>fV,content_2321_1428:()=>DV,content_2321_1430:()=>_V,content_2321_1432:()=>gV,content_2321_1434:()=>xV,content_2321_1436:()=>vV,content_2321_1438:()=>ZV,content_2321_144:()=>NX,content_2321_1440:()=>NV,content_2321_1442:()=>AV,content_2321_1444:()=>RV,content_2321_1446:()=>SV,content_2321_1448:()=>EV,content_2321_1450:()=>GV,content_2321_1452:()=>UV,content_2321_1454:()=>qV,content_2321_1456:()=>jV,content_2321_1458:()=>QV,content_2321_146:()=>AX,content_2321_1460:()=>YV,content_2321_1462:()=>JV,content_2321_1464:()=>nj,content_2321_1466:()=>oj,content_2321_1468:()=>rj,content_2321_1470:()=>cj,content_2321_1472:()=>aj,content_2321_1474:()=>uj,content_2321_1476:()=>dj,content_2321_1478:()=>kj,content_2321_148:()=>RX,content_2321_1480:()=>fj,content_2321_1482:()=>Dj,content_2321_1484:()=>_j,content_2321_1486:()=>gj,content_2321_1488:()=>xj,content_2321_1490:()=>vj,content_2321_1492:()=>Zj,content_2321_1494:()=>Nj,content_2321_1496:()=>Aj,content_2321_1498:()=>Rj,content_2321_150:()=>SX,content_2321_1500:()=>Sj,content_2321_1502:()=>Ej,content_2321_1504:()=>Gj,content_2321_1506:()=>Uj,content_2321_1508:()=>qj,content_2321_1510:()=>jj,content_2321_1512:()=>Qj,content_2321_1514:()=>Yj,content_2321_1516:()=>Jj,content_2321_1518:()=>nH,content_2321_152:()=>EX,content_2321_1520:()=>oH,content_2321_1522:()=>rH,content_2321_1524:()=>cH,content_2321_1526:()=>aH,content_2321_1528:()=>uH,content_2321_1530:()=>dH,content_2321_1532:()=>kH,content_2321_1534:()=>fH,content_2321_1536:()=>DH,content_2321_1538:()=>_H,content_2321_154:()=>GX,content_2321_1540:()=>gH,content_2321_1542:()=>xH,content_2321_1544:()=>vH,content_2321_1546:()=>ZH,content_2321_1548:()=>NH,content_2321_1550:()=>AH,content_2321_1552:()=>RH,content_2321_1554:()=>SH,content_2321_1556:()=>EH,content_2321_1558:()=>GH,content_2321_156:()=>UX,content_2321_1560:()=>UH,content_2321_1562:()=>qH,content_2321_1564:()=>jH,content_2321_1566:()=>QH,content_2321_1568:()=>YH,content_2321_1570:()=>JH,content_2321_1572:()=>nQ,content_2321_1574:()=>oQ,content_2321_1576:()=>rQ,content_2321_1578:()=>cQ,content_2321_158:()=>qX,content_2321_1580:()=>aQ,content_2321_1582:()=>uQ,content_2321_1584:()=>dQ,content_2321_1586:()=>kQ,content_2321_1588:()=>fQ,content_2321_1590:()=>DQ,content_2321_1592:()=>_Q,content_2321_1594:()=>gQ,content_2321_1596:()=>xQ,content_2321_1598:()=>vQ,content_2321_16:()=>uw,content_2321_160:()=>jX,content_2321_1600:()=>ZQ,content_2321_1602:()=>NQ,content_2321_1604:()=>AQ,content_2321_1606:()=>RQ,content_2321_1608:()=>SQ,content_2321_1610:()=>EQ,content_2321_1612:()=>GQ,content_2321_1614:()=>UQ,content_2321_1616:()=>qQ,content_2321_1618:()=>jQ,content_2321_162:()=>QX,content_2321_1620:()=>QQ,content_2321_1622:()=>YQ,content_2321_1624:()=>JQ,content_2321_1626:()=>n$,content_2321_1628:()=>o$,content_2321_1630:()=>r$,content_2321_1632:()=>c$,content_2321_1634:()=>a$,content_2321_1636:()=>u$,content_2321_1638:()=>d$,content_2321_164:()=>YX,content_2321_1640:()=>k$,content_2321_1642:()=>f$,content_2321_1644:()=>D$,content_2321_1646:()=>_$,content_2321_1648:()=>g$,content_2321_1650:()=>x$,content_2321_1652:()=>v$,content_2321_1654:()=>Z$,content_2321_1656:()=>N$,content_2321_1658:()=>A$,content_2321_166:()=>JX,content_2321_1660:()=>R$,content_2321_1662:()=>S$,content_2321_1664:()=>E$,content_2321_1666:()=>G$,content_2321_1668:()=>U$,content_2321_1670:()=>q$,content_2321_1672:()=>j$,content_2321_1674:()=>Q$,content_2321_1676:()=>Y$,content_2321_1678:()=>J$,content_2321_168:()=>ng,content_2321_1680:()=>nY,content_2321_1682:()=>oY,content_2321_1684:()=>rY,content_2321_1686:()=>cY,content_2321_1688:()=>aY,content_2321_1690:()=>uY,content_2321_1692:()=>dY,content_2321_1694:()=>kY,content_2321_1696:()=>fY,content_2321_1698:()=>DY,content_2321_170:()=>og,content_2321_1700:()=>_Y,content_2321_1702:()=>gY,content_2321_1704:()=>xY,content_2321_1706:()=>vY,content_2321_1708:()=>ZY,content_2321_1710:()=>NY,content_2321_1712:()=>AY,content_2321_1714:()=>RY,content_2321_1716:()=>SY,content_2321_1718:()=>EY,content_2321_172:()=>rg,content_2321_1720:()=>GY,content_2321_1722:()=>UY,content_2321_1724:()=>qY,content_2321_1726:()=>jY,content_2321_1728:()=>QY,content_2321_1730:()=>YY,content_2321_1732:()=>JY,content_2321_1734:()=>nK,content_2321_1736:()=>oK,content_2321_1738:()=>rK,content_2321_174:()=>cg,content_2321_1740:()=>cK,content_2321_1742:()=>aK,content_2321_1744:()=>uK,content_2321_1746:()=>dK,content_2321_1748:()=>kK,content_2321_1750:()=>fK,content_2321_1752:()=>DK,content_2321_1754:()=>_K,content_2321_1756:()=>gK,content_2321_1758:()=>xK,content_2321_176:()=>ag,content_2321_1760:()=>vK,content_2321_1762:()=>ZK,content_2321_1764:()=>NK,content_2321_1766:()=>AK,content_2321_1768:()=>RK,content_2321_1770:()=>SK,content_2321_1772:()=>EK,content_2321_1774:()=>GK,content_2321_1776:()=>UK,content_2321_1778:()=>qK,content_2321_178:()=>ug,content_2321_1780:()=>jK,content_2321_1782:()=>QK,content_2321_1784:()=>YK,content_2321_1786:()=>JK,content_2321_1788:()=>nJ,content_2321_1790:()=>oJ,content_2321_1792:()=>rJ,content_2321_1794:()=>cJ,content_2321_1796:()=>aJ,content_2321_1798:()=>uJ,content_2321_18:()=>dw,content_2321_180:()=>dg,content_2321_1800:()=>dJ,content_2321_1802:()=>kJ,content_2321_1804:()=>fJ,content_2321_1806:()=>DJ,content_2321_1808:()=>_J,content_2321_1810:()=>gJ,content_2321_1812:()=>xJ,content_2321_1814:()=>vJ,content_2321_1816:()=>ZJ,content_2321_1818:()=>NJ,content_2321_182:()=>kg,content_2321_1820:()=>AJ,content_2321_1822:()=>RJ,content_2321_1824:()=>SJ,content_2321_1826:()=>EJ,content_2321_1828:()=>GJ,content_2321_1830:()=>UJ,content_2321_1832:()=>qJ,content_2321_1834:()=>jJ,content_2321_1836:()=>QJ,content_2321_1838:()=>YJ,content_2321_184:()=>fg,content_2321_1840:()=>JJ,content_2321_1842:()=>n0,content_2321_1844:()=>o0,content_2321_1846:()=>r0,content_2321_1848:()=>c0,content_2321_1850:()=>a0,content_2321_1852:()=>u0,content_2321_1854:()=>d0,content_2321_1856:()=>k0,content_2321_1858:()=>f0,content_2321_186:()=>Dg,content_2321_1860:()=>D0,content_2321_1862:()=>_0,content_2321_1864:()=>g0,content_2321_1866:()=>x0,content_2321_1868:()=>v0,content_2321_1870:()=>Z0,content_2321_1872:()=>N0,content_2321_1874:()=>A0,content_2321_1876:()=>R0,content_2321_1878:()=>S0,content_2321_188:()=>_g,content_2321_1880:()=>E0,content_2321_1882:()=>G0,content_2321_1884:()=>U0,content_2321_1886:()=>q0,content_2321_1888:()=>j0,content_2321_1890:()=>Q0,content_2321_1892:()=>Y0,content_2321_1894:()=>J0,content_2321_1896:()=>n2,content_2321_1898:()=>o2,content_2321_190:()=>gg,content_2321_1900:()=>r2,content_2321_1902:()=>c2,content_2321_1904:()=>a2,content_2321_1906:()=>u2,content_2321_1908:()=>d2,content_2321_1910:()=>k2,content_2321_1912:()=>f2,content_2321_1914:()=>D2,content_2321_1916:()=>_2,content_2321_1918:()=>g2,content_2321_192:()=>xg,content_2321_1920:()=>x2,content_2321_1922:()=>v2,content_2321_1924:()=>Z2,content_2321_1926:()=>N2,content_2321_1928:()=>A2,content_2321_1930:()=>R2,content_2321_1932:()=>S2,content_2321_1934:()=>E2,content_2321_1936:()=>G2,content_2321_1938:()=>U2,content_2321_194:()=>vg,content_2321_1940:()=>q2,content_2321_1942:()=>j2,content_2321_1944:()=>Q2,content_2321_1946:()=>Y2,content_2321_1948:()=>J2,content_2321_1950:()=>n1,content_2321_1952:()=>o1,content_2321_1954:()=>r1,content_2321_1956:()=>c1,content_2321_1958:()=>a1,content_2321_196:()=>Zg,content_2321_1960:()=>u1,content_2321_1962:()=>d1,content_2321_1964:()=>k1,content_2321_1966:()=>f1,content_2321_1968:()=>D1,content_2321_1970:()=>_1,content_2321_1972:()=>g1,content_2321_1974:()=>x1,content_2321_1976:()=>v1,content_2321_1978:()=>Z1,content_2321_198:()=>Ng,content_2321_1980:()=>N1,content_2321_1982:()=>A1,content_2321_1984:()=>R1,content_2321_1986:()=>S1,content_2321_1988:()=>E1,content_2321_1990:()=>G1,content_2321_1992:()=>U1,content_2321_1994:()=>q1,content_2321_1996:()=>j1,content_2321_1998:()=>Q1,content_2321_2:()=>YD,content_2321_20:()=>kw,content_2321_200:()=>Ag,content_2321_2000:()=>Y1,content_2321_2002:()=>J1,content_2321_2004:()=>n3,content_2321_2006:()=>o3,content_2321_2008:()=>r3,content_2321_2010:()=>c3,content_2321_2012:()=>a3,content_2321_2014:()=>u3,content_2321_2016:()=>d3,content_2321_2018:()=>k3,content_2321_202:()=>Rg,content_2321_2020:()=>f3,content_2321_2022:()=>D3,content_2321_2024:()=>_3,content_2321_2026:()=>g3,content_2321_2028:()=>x3,content_2321_2030:()=>v3,content_2321_2032:()=>Z3,content_2321_2034:()=>N3,content_2321_2036:()=>A3,content_2321_2038:()=>R3,content_2321_204:()=>Sg,content_2321_2040:()=>S3,content_2321_2042:()=>E3,content_2321_2044:()=>G3,content_2321_2046:()=>U3,content_2321_2048:()=>q3,content_2321_2050:()=>j3,content_2321_2052:()=>Q3,content_2321_2054:()=>Y3,content_2321_2056:()=>J3,content_2321_2058:()=>n6,content_2321_206:()=>Eg,content_2321_2060:()=>o6,content_2321_2062:()=>r6,content_2321_2064:()=>c6,content_2321_2066:()=>a6,content_2321_2068:()=>u6,content_2321_2070:()=>d6,content_2321_2072:()=>k6,content_2321_2074:()=>f6,content_2321_2076:()=>D6,content_2321_2078:()=>_6,content_2321_208:()=>Gg,content_2321_2080:()=>g6,content_2321_2082:()=>x6,content_2321_2084:()=>v6,content_2321_2086:()=>Z6,content_2321_2088:()=>N6,content_2321_2090:()=>A6,content_2321_2092:()=>R6,content_2321_2094:()=>S6,content_2321_2096:()=>E6,content_2321_2098:()=>G6,content_2321_210:()=>Ug,content_2321_2100:()=>U6,content_2321_2102:()=>q6,content_2321_2104:()=>j6,content_2321_2106:()=>Q6,content_2321_2108:()=>Y6,content_2321_2110:()=>J6,content_2321_2112:()=>n4,content_2321_2114:()=>o4,content_2321_2116:()=>r4,content_2321_2118:()=>c4,content_2321_212:()=>qg,content_2321_2120:()=>a4,content_2321_2122:()=>u4,content_2321_2124:()=>d4,content_2321_2126:()=>k4,content_2321_2128:()=>f4,content_2321_2130:()=>D4,content_2321_2132:()=>_4,content_2321_2134:()=>g4,content_2321_2136:()=>x4,content_2321_2138:()=>v4,content_2321_214:()=>jg,content_2321_2140:()=>Z4,content_2321_2142:()=>N4,content_2321_2144:()=>A4,content_2321_2146:()=>R4,content_2321_2148:()=>S4,content_2321_2150:()=>E4,content_2321_2152:()=>G4,content_2321_2154:()=>U4,content_2321_2156:()=>q4,content_2321_2158:()=>j4,content_2321_216:()=>Qg,content_2321_2160:()=>Q4,content_2321_2162:()=>Y4,content_2321_2164:()=>J4,content_2321_2166:()=>n8,content_2321_2168:()=>o8,content_2321_2170:()=>r8,content_2321_2172:()=>c8,content_2321_2174:()=>a8,content_2321_2176:()=>u8,content_2321_2178:()=>d8,content_2321_218:()=>Yg,content_2321_2180:()=>k8,content_2321_2182:()=>f8,content_2321_2184:()=>D8,content_2321_2186:()=>_8,content_2321_2188:()=>g8,content_2321_2190:()=>x8,content_2321_2192:()=>v8,content_2321_2194:()=>Z8,content_2321_2196:()=>N8,content_2321_2198:()=>A8,content_2321_22:()=>fw,content_2321_220:()=>Jg,content_2321_2200:()=>R8,content_2321_2202:()=>S8,content_2321_2204:()=>E8,content_2321_2206:()=>G8,content_2321_2208:()=>U8,content_2321_2210:()=>q8,content_2321_2212:()=>j8,content_2321_2214:()=>Q8,content_2321_2216:()=>Y8,content_2321_2218:()=>J8,content_2321_222:()=>nT,content_2321_2220:()=>n5,content_2321_2222:()=>o5,content_2321_2224:()=>r5,content_2321_2226:()=>c5,content_2321_2228:()=>a5,content_2321_2230:()=>u5,content_2321_2232:()=>d5,content_2321_2234:()=>k5,content_2321_2236:()=>f5,content_2321_2238:()=>D5,content_2321_224:()=>oT,content_2321_2240:()=>_5,content_2321_2242:()=>g5,content_2321_2244:()=>x5,content_2321_2246:()=>v5,content_2321_2248:()=>Z5,content_2321_2250:()=>N5,content_2321_2252:()=>A5,content_2321_2254:()=>R5,content_2321_2256:()=>S5,content_2321_2258:()=>E5,content_2321_226:()=>rT,content_2321_2260:()=>G5,content_2321_2262:()=>U5,content_2321_2264:()=>q5,content_2321_2266:()=>j5,content_2321_2268:()=>Q5,content_2321_2270:()=>Y5,content_2321_2272:()=>J5,content_2321_2274:()=>n7,content_2321_2276:()=>o7,content_2321_2278:()=>r7,content_2321_228:()=>cT,content_2321_2280:()=>c7,content_2321_2282:()=>a7,content_2321_2284:()=>u7,content_2321_2286:()=>d7,content_2321_2288:()=>k7,content_2321_2290:()=>f7,content_2321_2292:()=>D7,content_2321_2294:()=>_7,content_2321_2296:()=>g7,content_2321_2298:()=>x7,content_2321_230:()=>aT,content_2321_2300:()=>v7,content_2321_2302:()=>Z7,content_2321_2304:()=>N7,content_2321_2306:()=>A7,content_2321_2308:()=>R7,content_2321_2310:()=>S7,content_2321_2312:()=>E7,content_2321_2314:()=>G7,content_2321_2316:()=>U7,content_2321_2318:()=>q7,content_2321_232:()=>uT,content_2321_2320:()=>j7,content_2321_2322:()=>Q7,content_2321_2324:()=>Y7,content_2321_2326:()=>J7,content_2321_2328:()=>n9,content_2321_2330:()=>o9,content_2321_2332:()=>r9,content_2321_2334:()=>c9,content_2321_2336:()=>a9,content_2321_2338:()=>u9,content_2321_234:()=>dT,content_2321_2340:()=>d9,content_2321_2342:()=>k9,content_2321_2344:()=>f9,content_2321_2346:()=>D9,content_2321_2348:()=>_9,content_2321_2350:()=>g9,content_2321_2352:()=>x9,content_2321_2354:()=>v9,content_2321_2356:()=>Z9,content_2321_2358:()=>N9,content_2321_236:()=>kT,content_2321_2360:()=>A9,content_2321_2362:()=>R9,content_2321_2364:()=>S9,content_2321_2366:()=>E9,content_2321_2368:()=>G9,content_2321_2370:()=>U9,content_2321_2372:()=>q9,content_2321_2374:()=>j9,content_2321_2376:()=>Q9,content_2321_2378:()=>Y9,content_2321_238:()=>fT,content_2321_2380:()=>J9,content_2321_2382:()=>ntt,content_2321_2384:()=>ott,content_2321_2386:()=>rtt,content_2321_2388:()=>ctt,content_2321_2390:()=>att,content_2321_2392:()=>utt,content_2321_2394:()=>dtt,content_2321_2396:()=>ktt,content_2321_2398:()=>ftt,content_2321_24:()=>Dw,content_2321_240:()=>DT,content_2321_2400:()=>Dtt,content_2321_2402:()=>_tt,content_2321_2404:()=>gtt,content_2321_2406:()=>xtt,content_2321_2408:()=>vtt,content_2321_2410:()=>Ztt,content_2321_2412:()=>Ntt,content_2321_2414:()=>Att,content_2321_2416:()=>Rtt,content_2321_2418:()=>Stt,content_2321_242:()=>_T,content_2321_2420:()=>Ett,content_2321_2422:()=>Gtt,content_2321_2424:()=>Utt,content_2321_2426:()=>qtt,content_2321_2428:()=>jtt,content_2321_2430:()=>Qtt,content_2321_2432:()=>Ytt,content_2321_2434:()=>Jtt,content_2321_2436:()=>nnt,content_2321_2438:()=>ont,content_2321_244:()=>gT,content_2321_2440:()=>rnt,content_2321_2442:()=>cnt,content_2321_2444:()=>ant,content_2321_2446:()=>unt,content_2321_2448:()=>dnt,content_2321_2450:()=>knt,content_2321_2452:()=>fnt,content_2321_2454:()=>Dnt,content_2321_2456:()=>_nt,content_2321_2458:()=>gnt,content_2321_246:()=>xT,content_2321_2460:()=>xnt,content_2321_2462:()=>vnt,content_2321_2464:()=>Znt,content_2321_2466:()=>Nnt,content_2321_2468:()=>Ant,content_2321_2470:()=>Rnt,content_2321_2472:()=>Snt,content_2321_2474:()=>Ent,content_2321_2476:()=>Gnt,content_2321_2478:()=>Unt,content_2321_248:()=>vT,content_2321_2480:()=>qnt,content_2321_2482:()=>jnt,content_2321_2484:()=>Qnt,content_2321_2486:()=>Ynt,content_2321_2488:()=>Jnt,content_2321_2490:()=>net,content_2321_2492:()=>oet,content_2321_2494:()=>ret,content_2321_2496:()=>cet,content_2321_2498:()=>aet,content_2321_250:()=>ZT,content_2321_2500:()=>met,content_2321_2502:()=>het,content_2321_2504:()=>yet,content_2321_2506:()=>Met,content_2321_2508:()=>wet,content_2321_2510:()=>Xet,content_2321_2512:()=>Tet,content_2321_2514:()=>Cet,content_2321_2516:()=>Let,content_2321_2518:()=>bet,content_2321_252:()=>NT,content_2321_2520:()=>zet,content_2321_2522:()=>Wet,content_2321_2524:()=>Iet,content_2321_2526:()=>Pet,content_2321_2528:()=>Bet,content_2321_2530:()=>Oet,content_2321_2532:()=>Fet,content_2321_2534:()=>Vet,content_2321_2536:()=>Het,content_2321_2538:()=>$et,content_2321_254:()=>AT,content_2321_2540:()=>Ket,content_2321_2542:()=>tot,content_2321_2544:()=>eot,content_2321_2546:()=>pot,content_2321_2548:()=>sot,content_2321_2550:()=>iot,content_2321_2552:()=>lot,content_2321_2554:()=>mot,content_2321_2556:()=>hot,content_2321_2558:()=>yot,content_2321_256:()=>RT,content_2321_2560:()=>Mot,content_2321_2562:()=>wot,content_2321_2564:()=>Xot,content_2321_2566:()=>Tot,content_2321_2568:()=>Cot,content_2321_2570:()=>Lot,content_2321_2572:()=>bot,content_2321_2574:()=>zot,content_2321_2576:()=>Wot,content_2321_2578:()=>Iot,content_2321_258:()=>ST,content_2321_2580:()=>Pot,content_2321_2582:()=>Bot,content_2321_2584:()=>Oot,content_2321_2586:()=>Fot,content_2321_2588:()=>Vot,content_2321_2590:()=>Hot,content_2321_2592:()=>$ot,content_2321_2594:()=>Kot,content_2321_2596:()=>tpt,content_2321_2598:()=>ept,content_2321_26:()=>_w,content_2321_260:()=>ET,content_2321_2600:()=>ppt,content_2321_2602:()=>spt,content_2321_2604:()=>ipt,content_2321_2606:()=>lpt,content_2321_2608:()=>mpt,content_2321_2610:()=>hpt,content_2321_2612:()=>ypt,content_2321_2614:()=>Mpt,content_2321_2616:()=>wpt,content_2321_2618:()=>Xpt,content_2321_262:()=>GT,content_2321_2620:()=>Tpt,content_2321_2622:()=>Cpt,content_2321_2624:()=>Lpt,content_2321_2626:()=>bpt,content_2321_2628:()=>zpt,content_2321_2630:()=>Wpt,content_2321_2632:()=>Ipt,content_2321_2634:()=>Ppt,content_2321_2636:()=>Bpt,content_2321_2638:()=>Opt,content_2321_264:()=>UT,content_2321_2640:()=>Fpt,content_2321_2642:()=>Vpt,content_2321_2644:()=>Hpt,content_2321_2646:()=>$pt,content_2321_2648:()=>Kpt,content_2321_2650:()=>trt,content_2321_2652:()=>ert,content_2321_2654:()=>prt,content_2321_2656:()=>srt,content_2321_2658:()=>irt,content_2321_266:()=>qT,content_2321_2660:()=>lrt,content_2321_2662:()=>mrt,content_2321_2664:()=>hrt,content_2321_2666:()=>yrt,content_2321_2668:()=>Mrt,content_2321_2670:()=>wrt,content_2321_2672:()=>Xrt,content_2321_2674:()=>Trt,content_2321_2676:()=>Crt,content_2321_2678:()=>Lrt,content_2321_268:()=>jT,content_2321_2680:()=>brt,content_2321_2682:()=>zrt,content_2321_2684:()=>Wrt,content_2321_2686:()=>Irt,content_2321_2688:()=>Prt,content_2321_2690:()=>Brt,content_2321_2692:()=>Ort,content_2321_2694:()=>Frt,content_2321_2696:()=>Vrt,content_2321_2698:()=>Hrt,content_2321_270:()=>QT,content_2321_2700:()=>$rt,content_2321_2702:()=>Krt,content_2321_2704:()=>tst,content_2321_2706:()=>est,content_2321_2708:()=>pst,content_2321_2710:()=>sst,content_2321_2712:()=>ist,content_2321_2714:()=>lst,content_2321_2716:()=>mst,content_2321_2718:()=>hst,content_2321_272:()=>YT,content_2321_2720:()=>yst,content_2321_2722:()=>Mst,content_2321_2724:()=>wst,content_2321_2726:()=>Xst,content_2321_2728:()=>Tst,content_2321_2730:()=>Cst,content_2321_2732:()=>Lst,content_2321_2734:()=>bst,content_2321_2736:()=>zst,content_2321_2738:()=>Wst,content_2321_274:()=>JT,content_2321_2740:()=>Ist,content_2321_2742:()=>Pst,content_2321_2744:()=>Bst,content_2321_2746:()=>Ost,content_2321_2748:()=>Fst,content_2321_2750:()=>Vst,content_2321_2752:()=>Hst,content_2321_2754:()=>$st,content_2321_2756:()=>Kst,content_2321_2758:()=>tct,content_2321_276:()=>nx,content_2321_2760:()=>ect,content_2321_2762:()=>pct,content_2321_2764:()=>sct,content_2321_2766:()=>ict,content_2321_2768:()=>lct,content_2321_2770:()=>mct,content_2321_2772:()=>hct,content_2321_2774:()=>yct,content_2321_2776:()=>Mct,content_2321_2778:()=>wct,content_2321_278:()=>ox,content_2321_2780:()=>Xct,content_2321_2782:()=>Tct,content_2321_2784:()=>Cct,content_2321_2786:()=>Lct,content_2321_2788:()=>bct,content_2321_2790:()=>zct,content_2321_2792:()=>Wct,content_2321_2794:()=>Ict,content_2321_2796:()=>Pct,content_2321_2798:()=>Bct,content_2321_28:()=>gw,content_2321_280:()=>rx,content_2321_2800:()=>Oct,content_2321_2802:()=>Fct,content_2321_2804:()=>Vct,content_2321_2806:()=>Hct,content_2321_2808:()=>$ct,content_2321_2810:()=>Kct,content_2321_2812:()=>tit,content_2321_2814:()=>eit,content_2321_2816:()=>pit,content_2321_2818:()=>sit,content_2321_282:()=>cx,content_2321_2820:()=>iit,content_2321_2822:()=>lit,content_2321_2824:()=>mit,content_2321_2826:()=>hit,content_2321_2828:()=>yit,content_2321_2830:()=>Mit,content_2321_2832:()=>wit,content_2321_2834:()=>Xit,content_2321_2836:()=>Tit,content_2321_2838:()=>Cit,content_2321_284:()=>ax,content_2321_2840:()=>Lit,content_2321_2842:()=>bit,content_2321_2844:()=>zit,content_2321_2846:()=>Wit,content_2321_2848:()=>Iit,content_2321_2850:()=>Pit,content_2321_2852:()=>Bit,content_2321_2854:()=>Oit,content_2321_2856:()=>Fit,content_2321_2858:()=>Vit,content_2321_286:()=>ux,content_2321_2860:()=>Hit,content_2321_2862:()=>$it,content_2321_2864:()=>Kit,content_2321_2866:()=>tat,content_2321_2868:()=>eat,content_2321_2870:()=>pat,content_2321_2872:()=>sat,content_2321_2874:()=>iat,content_2321_2876:()=>lat,content_2321_2878:()=>mat,content_2321_288:()=>dx,content_2321_2880:()=>hat,content_2321_2882:()=>yat,content_2321_2884:()=>Mat,content_2321_2886:()=>wat,content_2321_2888:()=>Xat,content_2321_2890:()=>Tat,content_2321_2892:()=>Cat,content_2321_2894:()=>Lat,content_2321_2896:()=>bat,content_2321_2898:()=>zat,content_2321_290:()=>kx,content_2321_2900:()=>Wat,content_2321_2902:()=>Iat,content_2321_2904:()=>Pat,content_2321_2906:()=>Bat,content_2321_2908:()=>Oat,content_2321_2910:()=>Fat,content_2321_2912:()=>Vat,content_2321_2914:()=>Hat,content_2321_2916:()=>$at,content_2321_2918:()=>Kat,content_2321_292:()=>fx,content_2321_2920:()=>tlt,content_2321_2922:()=>elt,content_2321_2924:()=>plt,content_2321_2926:()=>slt,content_2321_2928:()=>ilt,content_2321_2930:()=>llt,content_2321_2932:()=>mlt,content_2321_2934:()=>hlt,content_2321_2936:()=>ylt,content_2321_2938:()=>Mlt,content_2321_294:()=>Dx,content_2321_2940:()=>wlt,content_2321_2942:()=>Xlt,content_2321_2944:()=>Tlt,content_2321_2946:()=>Clt,content_2321_2948:()=>Llt,content_2321_2950:()=>blt,content_2321_2952:()=>zlt,content_2321_2954:()=>Wlt,content_2321_2956:()=>Ilt,content_2321_2958:()=>Plt,content_2321_296:()=>_x,content_2321_2960:()=>Blt,content_2321_2962:()=>Olt,content_2321_2964:()=>Flt,content_2321_2966:()=>Vlt,content_2321_2968:()=>Hlt,content_2321_2970:()=>$lt,content_2321_2972:()=>Klt,content_2321_2974:()=>tut,content_2321_2976:()=>eut,content_2321_2978:()=>put,content_2321_298:()=>gx,content_2321_2980:()=>sut,content_2321_2982:()=>iut,content_2321_2984:()=>lut,content_2321_2986:()=>mut,content_2321_2988:()=>hut,content_2321_2990:()=>yut,content_2321_2992:()=>Mut,content_2321_2994:()=>wut,content_2321_2996:()=>Xut,content_2321_2998:()=>Tut,content_2321_30:()=>xw,content_2321_300:()=>xx,content_2321_3000:()=>Cut,content_2321_3002:()=>Lut,content_2321_3004:()=>but,content_2321_3006:()=>zut,content_2321_3008:()=>Wut,content_2321_3010:()=>Iut,content_2321_3012:()=>Put,content_2321_3014:()=>But,content_2321_3016:()=>Out,content_2321_3018:()=>Fut,content_2321_302:()=>vx,content_2321_3020:()=>Vut,content_2321_3022:()=>Hut,content_2321_3024:()=>$ut,content_2321_3026:()=>Kut,content_2321_3028:()=>tmt,content_2321_3030:()=>emt,content_2321_3032:()=>pmt,content_2321_3034:()=>smt,content_2321_3036:()=>imt,content_2321_3038:()=>lmt,content_2321_304:()=>Zx,content_2321_3040:()=>mmt,content_2321_3042:()=>hmt,content_2321_3044:()=>ymt,content_2321_3046:()=>Mmt,content_2321_3048:()=>wmt,content_2321_3050:()=>Xmt,content_2321_3052:()=>Tmt,content_2321_3054:()=>Cmt,content_2321_3056:()=>Lmt,content_2321_3058:()=>bmt,content_2321_306:()=>Nx,content_2321_3060:()=>zmt,content_2321_3062:()=>Wmt,content_2321_3064:()=>Imt,content_2321_3066:()=>Pmt,content_2321_3068:()=>Bmt,content_2321_3070:()=>Omt,content_2321_3072:()=>Fmt,content_2321_3074:()=>Vmt,content_2321_3076:()=>Hmt,content_2321_3078:()=>$mt,content_2321_308:()=>Ax,content_2321_3080:()=>Kmt,content_2321_3082:()=>tdt,content_2321_3084:()=>edt,content_2321_3086:()=>pdt,content_2321_3088:()=>sdt,content_2321_3090:()=>idt,content_2321_3092:()=>ldt,content_2321_3094:()=>mdt,content_2321_3096:()=>hdt,content_2321_3098:()=>ydt,content_2321_310:()=>Rx,content_2321_3100:()=>Mdt,content_2321_3102:()=>wdt,content_2321_3104:()=>Xdt,content_2321_3106:()=>Tdt,content_2321_3108:()=>Cdt,content_2321_3110:()=>Ldt,content_2321_3112:()=>bdt,content_2321_3114:()=>zdt,content_2321_3116:()=>Wdt,content_2321_3118:()=>Idt,content_2321_312:()=>Sx,content_2321_3120:()=>Pdt,content_2321_3122:()=>Bdt,content_2321_3124:()=>Odt,content_2321_3126:()=>Fdt,content_2321_3128:()=>Vdt,content_2321_3130:()=>Hdt,content_2321_3132:()=>$dt,content_2321_3134:()=>Kdt,content_2321_3136:()=>tht,content_2321_3138:()=>eht,content_2321_314:()=>Ex,content_2321_3140:()=>pht,content_2321_3142:()=>sht,content_2321_3144:()=>iht,content_2321_3146:()=>lht,content_2321_3148:()=>mht,content_2321_3150:()=>hht,content_2321_3152:()=>yht,content_2321_3154:()=>Mht,content_2321_3156:()=>wht,content_2321_3158:()=>Xht,content_2321_316:()=>Gx,content_2321_3160:()=>Tht,content_2321_3162:()=>Cht,content_2321_3164:()=>Lht,content_2321_3166:()=>bht,content_2321_3168:()=>zht,content_2321_3170:()=>Wht,content_2321_3172:()=>Iht,content_2321_3174:()=>Pht,content_2321_3176:()=>Bht,content_2321_3178:()=>Oht,content_2321_318:()=>Ux,content_2321_3180:()=>Fht,content_2321_3182:()=>Vht,content_2321_3184:()=>Hht,content_2321_3186:()=>$ht,content_2321_3188:()=>Kht,content_2321_3190:()=>tkt,content_2321_3192:()=>ekt,content_2321_3194:()=>pkt,content_2321_3196:()=>skt,content_2321_3198:()=>ikt,content_2321_32:()=>vw,content_2321_320:()=>qx,content_2321_3200:()=>lkt,content_2321_3202:()=>mkt,content_2321_3204:()=>hkt,content_2321_3206:()=>ykt,content_2321_3208:()=>Mkt,content_2321_3210:()=>wkt,content_2321_3212:()=>Xkt,content_2321_3214:()=>Tkt,content_2321_3216:()=>Ckt,content_2321_3218:()=>Lkt,content_2321_322:()=>jx,content_2321_3220:()=>bkt,content_2321_3222:()=>zkt,content_2321_3224:()=>Wkt,content_2321_3226:()=>Ikt,content_2321_3228:()=>Pkt,content_2321_3230:()=>Bkt,content_2321_3232:()=>Okt,content_2321_3234:()=>Fkt,content_2321_3236:()=>Vkt,content_2321_3238:()=>Hkt,content_2321_324:()=>Qx,content_2321_3240:()=>$kt,content_2321_3242:()=>Kkt,content_2321_3244:()=>tyt,content_2321_3246:()=>eyt,content_2321_3248:()=>pyt,content_2321_3250:()=>syt,content_2321_3252:()=>iyt,content_2321_3254:()=>lyt,content_2321_3256:()=>myt,content_2321_3258:()=>hyt,content_2321_326:()=>Yx,content_2321_3260:()=>yyt,content_2321_3262:()=>Myt,content_2321_3264:()=>wyt,content_2321_3266:()=>Xyt,content_2321_3268:()=>Tyt,content_2321_3270:()=>Cyt,content_2321_3272:()=>Lyt,content_2321_3274:()=>byt,content_2321_3276:()=>zyt,content_2321_3278:()=>Wyt,content_2321_328:()=>Jx,content_2321_3280:()=>Iyt,content_2321_3282:()=>Pyt,content_2321_3284:()=>Byt,content_2321_3286:()=>Oyt,content_2321_3288:()=>Fyt,content_2321_3290:()=>Vyt,content_2321_3292:()=>Hyt,content_2321_3294:()=>$yt,content_2321_3296:()=>Kyt,content_2321_3298:()=>tft,content_2321_330:()=>nC,content_2321_3300:()=>eft,content_2321_3302:()=>pft,content_2321_3304:()=>sft,content_2321_3306:()=>ift,content_2321_3308:()=>lft,content_2321_3310:()=>mft,content_2321_3312:()=>hft,content_2321_3314:()=>yft,content_2321_3316:()=>Mft,content_2321_3318:()=>wft,content_2321_332:()=>oC,content_2321_3320:()=>Xft,content_2321_3322:()=>Tft,content_2321_3324:()=>Cft,content_2321_3326:()=>Lft,content_2321_3328:()=>bft,content_2321_3330:()=>zft,content_2321_3332:()=>Wft,content_2321_3334:()=>Ift,content_2321_3336:()=>Pft,content_2321_3338:()=>Bft,content_2321_334:()=>rC,content_2321_3340:()=>Oft,content_2321_3342:()=>Fft,content_2321_3344:()=>Vft,content_2321_3346:()=>Hft,content_2321_3348:()=>$ft,content_2321_3350:()=>Kft,content_2321_3352:()=>tMt,content_2321_3354:()=>eMt,content_2321_3356:()=>pMt,content_2321_3358:()=>sMt,content_2321_336:()=>cC,content_2321_3360:()=>iMt,content_2321_3362:()=>lMt,content_2321_3364:()=>mMt,content_2321_3366:()=>hMt,content_2321_3368:()=>yMt,content_2321_3370:()=>MMt,content_2321_3372:()=>wMt,content_2321_3374:()=>XMt,content_2321_3376:()=>TMt,content_2321_3378:()=>CMt,content_2321_338:()=>aC,content_2321_3380:()=>LMt,content_2321_3382:()=>bMt,content_2321_3384:()=>zMt,content_2321_3386:()=>WMt,content_2321_3388:()=>IMt,content_2321_3390:()=>PMt,content_2321_3392:()=>BMt,content_2321_3394:()=>OMt,content_2321_3396:()=>FMt,content_2321_3398:()=>VMt,content_2321_34:()=>Zw,content_2321_340:()=>uC,content_2321_3400:()=>HMt,content_2321_3402:()=>$Mt,content_2321_3404:()=>KMt,content_2321_3406:()=>tDt,content_2321_3408:()=>eDt,content_2321_3410:()=>pDt,content_2321_3412:()=>sDt,content_2321_3414:()=>iDt,content_2321_3416:()=>lDt,content_2321_3418:()=>mDt,content_2321_342:()=>dC,content_2321_3420:()=>hDt,content_2321_3422:()=>yDt,content_2321_3424:()=>MDt,content_2321_3426:()=>wDt,content_2321_3428:()=>XDt,content_2321_3430:()=>TDt,content_2321_3432:()=>CDt,content_2321_3434:()=>LDt,content_2321_3436:()=>bDt,content_2321_3438:()=>zDt,content_2321_344:()=>kC,content_2321_3440:()=>WDt,content_2321_3442:()=>IDt,content_2321_3444:()=>PDt,content_2321_3446:()=>BDt,content_2321_3448:()=>ODt,content_2321_3450:()=>FDt,content_2321_3452:()=>VDt,content_2321_3454:()=>HDt,content_2321_3456:()=>$Dt,content_2321_3458:()=>KDt,content_2321_346:()=>fC,content_2321_3460:()=>twt,content_2321_3462:()=>ewt,content_2321_3464:()=>pwt,content_2321_3466:()=>swt,content_2321_3468:()=>iwt,content_2321_3470:()=>lwt,content_2321_3472:()=>mwt,content_2321_3474:()=>hwt,content_2321_3476:()=>ywt,content_2321_3478:()=>Mwt,content_2321_348:()=>DC,content_2321_3480:()=>wwt,content_2321_3482:()=>Xwt,content_2321_3484:()=>Twt,content_2321_3486:()=>Cwt,content_2321_3488:()=>Lwt,content_2321_3490:()=>bwt,content_2321_3492:()=>zwt,content_2321_3494:()=>Wwt,content_2321_3496:()=>Iwt,content_2321_3498:()=>Pwt,content_2321_350:()=>_C,content_2321_3500:()=>Bwt,content_2321_3502:()=>Owt,content_2321_3504:()=>Fwt,content_2321_3506:()=>Vwt,content_2321_3508:()=>Hwt,content_2321_3510:()=>$wt,content_2321_3512:()=>Kwt,content_2321_3514:()=>t_t,content_2321_3516:()=>e_t,content_2321_3518:()=>p_t,content_2321_352:()=>gC,content_2321_3520:()=>s_t,content_2321_3522:()=>i_t,content_2321_3524:()=>l_t,content_2321_3526:()=>m_t,content_2321_3528:()=>h_t,content_2321_3530:()=>y_t,content_2321_3532:()=>M_t,content_2321_3534:()=>w_t,content_2321_3536:()=>X_t,content_2321_3538:()=>T_t,content_2321_354:()=>xC,content_2321_3540:()=>C_t,content_2321_3542:()=>L_t,content_2321_3544:()=>b_t,content_2321_3546:()=>z_t,content_2321_3548:()=>W_t,content_2321_3550:()=>I_t,content_2321_3552:()=>P_t,content_2321_3554:()=>B_t,content_2321_3556:()=>O_t,content_2321_3558:()=>F_t,content_2321_356:()=>vC,content_2321_3560:()=>V_t,content_2321_3562:()=>H_t,content_2321_3564:()=>$_t,content_2321_3566:()=>K_t,content_2321_3568:()=>tXt,content_2321_3570:()=>eXt,content_2321_3572:()=>pXt,content_2321_3574:()=>sXt,content_2321_3576:()=>iXt,content_2321_3578:()=>lXt,content_2321_358:()=>ZC,content_2321_3580:()=>mXt,content_2321_3582:()=>hXt,content_2321_3584:()=>yXt,content_2321_3586:()=>MXt,content_2321_3588:()=>wXt,content_2321_3590:()=>XXt,content_2321_3592:()=>TXt,content_2321_3594:()=>CXt,content_2321_3596:()=>LXt,content_2321_3598:()=>bXt,content_2321_36:()=>Nw,content_2321_360:()=>NC,content_2321_3600:()=>zXt,content_2321_3602:()=>WXt,content_2321_3604:()=>IXt,content_2321_3606:()=>PXt,content_2321_3608:()=>BXt,content_2321_3610:()=>OXt,content_2321_3612:()=>FXt,content_2321_3614:()=>VXt,content_2321_3616:()=>HXt,content_2321_3618:()=>$Xt,content_2321_362:()=>AC,content_2321_3620:()=>KXt,content_2321_3622:()=>tgt,content_2321_3624:()=>egt,content_2321_3626:()=>pgt,content_2321_3628:()=>sgt,content_2321_3630:()=>igt,content_2321_3632:()=>lgt,content_2321_3634:()=>mgt,content_2321_3636:()=>hgt,content_2321_3638:()=>ygt,content_2321_364:()=>RC,content_2321_3640:()=>Mgt,content_2321_3642:()=>wgt,content_2321_3644:()=>Xgt,content_2321_3646:()=>Tgt,content_2321_3648:()=>Cgt,content_2321_3650:()=>Lgt,content_2321_3652:()=>bgt,content_2321_3654:()=>zgt,content_2321_3656:()=>Wgt,content_2321_3658:()=>Igt,content_2321_366:()=>SC,content_2321_3660:()=>Pgt,content_2321_3662:()=>Bgt,content_2321_3664:()=>Ogt,content_2321_3666:()=>Fgt,content_2321_3668:()=>Vgt,content_2321_3670:()=>Hgt,content_2321_3672:()=>$gt,content_2321_3674:()=>Kgt,content_2321_3676:()=>tTt,content_2321_3678:()=>eTt,content_2321_368:()=>EC,content_2321_3680:()=>pTt,content_2321_3682:()=>sTt,content_2321_3684:()=>iTt,content_2321_3686:()=>lTt,content_2321_3688:()=>mTt,content_2321_3690:()=>hTt,content_2321_3692:()=>yTt,content_2321_3694:()=>MTt,content_2321_3696:()=>wTt,content_2321_3698:()=>XTt,content_2321_370:()=>GC,content_2321_3700:()=>TTt,content_2321_3702:()=>CTt,content_2321_3704:()=>LTt,content_2321_3706:()=>bTt,content_2321_3708:()=>zTt,content_2321_3710:()=>WTt,content_2321_3712:()=>ITt,content_2321_3714:()=>PTt,content_2321_3716:()=>BTt,content_2321_3718:()=>OTt,content_2321_372:()=>UC,content_2321_3720:()=>FTt,content_2321_3722:()=>VTt,content_2321_3724:()=>HTt,content_2321_3726:()=>$Tt,content_2321_3728:()=>KTt,content_2321_3730:()=>txt,content_2321_3732:()=>ext,content_2321_3734:()=>pxt,content_2321_3736:()=>sxt,content_2321_3738:()=>ixt,content_2321_374:()=>qC,content_2321_3740:()=>lxt,content_2321_3742:()=>mxt,content_2321_3744:()=>hxt,content_2321_3746:()=>yxt,content_2321_3748:()=>Mxt,content_2321_3750:()=>wxt,content_2321_3752:()=>Xxt,content_2321_3754:()=>Txt,content_2321_3756:()=>Cxt,content_2321_3758:()=>Lxt,content_2321_376:()=>jC,content_2321_3760:()=>bxt,content_2321_3762:()=>zxt,content_2321_3764:()=>Wxt,content_2321_3766:()=>Ixt,content_2321_3768:()=>Pxt,content_2321_3770:()=>Bxt,content_2321_3772:()=>Oxt,content_2321_3774:()=>Fxt,content_2321_3776:()=>Vxt,content_2321_3778:()=>Hxt,content_2321_378:()=>QC,content_2321_3780:()=>$xt,content_2321_3782:()=>Kxt,content_2321_3784:()=>tCt,content_2321_3786:()=>eCt,content_2321_3788:()=>pCt,content_2321_3790:()=>sCt,content_2321_3792:()=>iCt,content_2321_3794:()=>lCt,content_2321_3796:()=>mCt,content_2321_3798:()=>hCt,content_2321_38:()=>Aw,content_2321_380:()=>YC,content_2321_3800:()=>yCt,content_2321_3802:()=>MCt,content_2321_3804:()=>wCt,content_2321_3806:()=>XCt,content_2321_3808:()=>TCt,content_2321_3810:()=>CCt,content_2321_3812:()=>LCt,content_2321_3814:()=>bCt,content_2321_3816:()=>zCt,content_2321_3818:()=>WCt,content_2321_382:()=>JC,content_2321_3820:()=>ICt,content_2321_3822:()=>PCt,content_2321_3824:()=>BCt,content_2321_3826:()=>OCt,content_2321_3828:()=>FCt,content_2321_3830:()=>VCt,content_2321_3832:()=>HCt,content_2321_3834:()=>$Ct,content_2321_3836:()=>KCt,content_2321_3838:()=>tvt,content_2321_384:()=>nv,content_2321_3840:()=>evt,content_2321_3842:()=>pvt,content_2321_3844:()=>svt,content_2321_3846:()=>ivt,content_2321_3848:()=>lvt,content_2321_3850:()=>mvt,content_2321_3852:()=>hvt,content_2321_3854:()=>yvt,content_2321_3856:()=>Mvt,content_2321_3858:()=>wvt,content_2321_386:()=>ov,content_2321_3860:()=>Xvt,content_2321_3862:()=>Tvt,content_2321_3864:()=>Cvt,content_2321_3866:()=>Lvt,content_2321_3868:()=>bvt,content_2321_3870:()=>zvt,content_2321_3872:()=>Wvt,content_2321_3874:()=>Ivt,content_2321_3876:()=>Pvt,content_2321_3878:()=>Bvt,content_2321_388:()=>rv,content_2321_3880:()=>Ovt,content_2321_3882:()=>Fvt,content_2321_3884:()=>Vvt,content_2321_3886:()=>Hvt,content_2321_3888:()=>$vt,content_2321_3890:()=>Kvt,content_2321_3892:()=>tLt,content_2321_3894:()=>eLt,content_2321_3896:()=>pLt,content_2321_3898:()=>sLt,content_2321_390:()=>cv,content_2321_3900:()=>iLt,content_2321_3902:()=>lLt,content_2321_3904:()=>mLt,content_2321_3906:()=>hLt,content_2321_3908:()=>yLt,content_2321_3910:()=>MLt,content_2321_3912:()=>wLt,content_2321_3914:()=>XLt,content_2321_3916:()=>TLt,content_2321_3918:()=>CLt,content_2321_392:()=>av,content_2321_3920:()=>LLt,content_2321_3922:()=>bLt,content_2321_3924:()=>zLt,content_2321_3926:()=>WLt,content_2321_3928:()=>ILt,content_2321_3930:()=>PLt,content_2321_3932:()=>BLt,content_2321_3934:()=>OLt,content_2321_3936:()=>FLt,content_2321_3938:()=>VLt,content_2321_394:()=>uv,content_2321_3940:()=>HLt,content_2321_3942:()=>$Lt,content_2321_3944:()=>KLt,content_2321_3946:()=>tZt,content_2321_3948:()=>eZt,content_2321_3950:()=>pZt,content_2321_3952:()=>sZt,content_2321_3954:()=>iZt,content_2321_3956:()=>lZt,content_2321_3958:()=>mZt,content_2321_396:()=>dv,content_2321_3960:()=>hZt,content_2321_3962:()=>yZt,content_2321_3964:()=>MZt,content_2321_3966:()=>wZt,content_2321_3968:()=>XZt,content_2321_3970:()=>TZt,content_2321_3972:()=>CZt,content_2321_3974:()=>LZt,content_2321_3976:()=>bZt,content_2321_3978:()=>zZt,content_2321_398:()=>kv,content_2321_3980:()=>WZt,content_2321_3982:()=>IZt,content_2321_3984:()=>PZt,content_2321_3986:()=>BZt,content_2321_3988:()=>OZt,content_2321_3990:()=>FZt,content_2321_3992:()=>VZt,content_2321_3994:()=>HZt,content_2321_3996:()=>$Zt,content_2321_3998:()=>KZt,content_2321_4:()=>JD,content_2321_40:()=>Rw,content_2321_400:()=>fv,content_2321_4000:()=>tbt,content_2321_4002:()=>ebt,content_2321_4004:()=>pbt,content_2321_4006:()=>sbt,content_2321_4008:()=>ibt,content_2321_4010:()=>lbt,content_2321_4012:()=>mbt,content_2321_4014:()=>hbt,content_2321_4016:()=>ybt,content_2321_4018:()=>Mbt,content_2321_402:()=>Dv,content_2321_4020:()=>wbt,content_2321_4022:()=>Xbt,content_2321_4024:()=>Tbt,content_2321_4026:()=>Cbt,content_2321_4028:()=>Lbt,content_2321_4030:()=>bbt,content_2321_4032:()=>zbt,content_2321_4034:()=>Wbt,content_2321_4036:()=>Ibt,content_2321_4038:()=>Pbt,content_2321_404:()=>_v,content_2321_4040:()=>Bbt,content_2321_4042:()=>Obt,content_2321_4044:()=>Fbt,content_2321_4046:()=>Vbt,content_2321_4048:()=>Hbt,content_2321_4050:()=>$bt,content_2321_4052:()=>Kbt,content_2321_4054:()=>tNt,content_2321_4056:()=>eNt,content_2321_4058:()=>pNt,content_2321_406:()=>gv,content_2321_4060:()=>sNt,content_2321_4062:()=>iNt,content_2321_4064:()=>lNt,content_2321_4066:()=>mNt,content_2321_4068:()=>hNt,content_2321_4070:()=>yNt,content_2321_4072:()=>MNt,content_2321_4074:()=>wNt,content_2321_4076:()=>XNt,content_2321_4078:()=>TNt,content_2321_408:()=>xv,content_2321_4080:()=>CNt,content_2321_4082:()=>LNt,content_2321_4084:()=>bNt,content_2321_4086:()=>zNt,content_2321_4088:()=>WNt,content_2321_4090:()=>INt,content_2321_4092:()=>PNt,content_2321_4094:()=>BNt,content_2321_4096:()=>ONt,content_2321_4098:()=>FNt,content_2321_410:()=>vv,content_2321_4100:()=>VNt,content_2321_4102:()=>HNt,content_2321_4104:()=>$Nt,content_2321_4106:()=>KNt,content_2321_4108:()=>tzt,content_2321_4110:()=>ezt,content_2321_4112:()=>pzt,content_2321_4114:()=>szt,content_2321_4116:()=>izt,content_2321_4118:()=>lzt,content_2321_412:()=>Zv,content_2321_4120:()=>mzt,content_2321_4122:()=>hzt,content_2321_4124:()=>yzt,content_2321_4126:()=>Mzt,content_2321_4128:()=>wzt,content_2321_4130:()=>Xzt,content_2321_4132:()=>Tzt,content_2321_4134:()=>Czt,content_2321_4136:()=>Lzt,content_2321_4138:()=>bzt,content_2321_414:()=>Nv,content_2321_4140:()=>zzt,content_2321_4142:()=>Wzt,content_2321_4144:()=>Izt,content_2321_4146:()=>Pzt,content_2321_4148:()=>Bzt,content_2321_4150:()=>Ozt,content_2321_4152:()=>Fzt,content_2321_4154:()=>Vzt,content_2321_4156:()=>Hzt,content_2321_4158:()=>$zt,content_2321_416:()=>Av,content_2321_4160:()=>Kzt,content_2321_4162:()=>tAt,content_2321_4164:()=>eAt,content_2321_4166:()=>pAt,content_2321_4168:()=>sAt,content_2321_4170:()=>iAt,content_2321_4172:()=>lAt,content_2321_4174:()=>mAt,content_2321_4176:()=>hAt,content_2321_4178:()=>yAt,content_2321_418:()=>Rv,content_2321_4180:()=>MAt,content_2321_4182:()=>wAt,content_2321_4184:()=>XAt,content_2321_4186:()=>TAt,content_2321_4188:()=>CAt,content_2321_4190:()=>LAt,content_2321_4192:()=>bAt,content_2321_4194:()=>zAt,content_2321_4196:()=>WAt,content_2321_4198:()=>IAt,content_2321_42:()=>Sw,content_2321_420:()=>Sv,content_2321_4200:()=>PAt,content_2321_4202:()=>BAt,content_2321_4204:()=>OAt,content_2321_4206:()=>FAt,content_2321_4208:()=>VAt,content_2321_4210:()=>HAt,content_2321_4212:()=>$At,content_2321_4214:()=>KAt,content_2321_4216:()=>tWt,content_2321_4218:()=>eWt,content_2321_422:()=>Ev,content_2321_4220:()=>pWt,content_2321_4222:()=>sWt,content_2321_4224:()=>iWt,content_2321_4226:()=>lWt,content_2321_4228:()=>mWt,content_2321_4230:()=>hWt,content_2321_4232:()=>yWt,content_2321_4234:()=>MWt,content_2321_4236:()=>wWt,content_2321_4238:()=>XWt,content_2321_424:()=>Gv,content_2321_4240:()=>TWt,content_2321_4242:()=>CWt,content_2321_4244:()=>LWt,content_2321_4246:()=>bWt,content_2321_4248:()=>zWt,content_2321_4250:()=>WWt,content_2321_4252:()=>IWt,content_2321_4254:()=>PWt,content_2321_4256:()=>BWt,content_2321_4258:()=>OWt,content_2321_426:()=>Uv,content_2321_4260:()=>FWt,content_2321_4262:()=>VWt,content_2321_4264:()=>HWt,content_2321_4266:()=>$Wt,content_2321_4268:()=>KWt,content_2321_4270:()=>tRt,content_2321_4272:()=>eRt,content_2321_4274:()=>pRt,content_2321_4276:()=>sRt,content_2321_4278:()=>iRt,content_2321_428:()=>qv,content_2321_4280:()=>lRt,content_2321_4282:()=>mRt,content_2321_4284:()=>hRt,content_2321_4286:()=>yRt,content_2321_4288:()=>MRt,content_2321_4290:()=>wRt,content_2321_4292:()=>XRt,content_2321_4294:()=>TRt,content_2321_4296:()=>CRt,content_2321_4298:()=>LRt,content_2321_430:()=>jv,content_2321_4300:()=>bRt,content_2321_4302:()=>zRt,content_2321_4304:()=>WRt,content_2321_4306:()=>IRt,content_2321_4308:()=>PRt,content_2321_4310:()=>BRt,content_2321_4312:()=>ORt,content_2321_4314:()=>FRt,content_2321_4316:()=>VRt,content_2321_4318:()=>HRt,content_2321_432:()=>Qv,content_2321_4320:()=>$Rt,content_2321_4322:()=>KRt,content_2321_4324:()=>tIt,content_2321_4326:()=>eIt,content_2321_4328:()=>pIt,content_2321_4330:()=>sIt,content_2321_4332:()=>iIt,content_2321_4334:()=>lIt,content_2321_4336:()=>mIt,content_2321_4338:()=>hIt,content_2321_434:()=>Yv,content_2321_4340:()=>yIt,content_2321_4342:()=>MIt,content_2321_4344:()=>wIt,content_2321_4346:()=>XIt,content_2321_4348:()=>TIt,content_2321_4350:()=>CIt,content_2321_4352:()=>LIt,content_2321_4354:()=>bIt,content_2321_4356:()=>zIt,content_2321_4358:()=>WIt,content_2321_436:()=>Jv,content_2321_4360:()=>IIt,content_2321_4362:()=>PIt,content_2321_4364:()=>BIt,content_2321_4366:()=>OIt,content_2321_4368:()=>FIt,content_2321_4370:()=>VIt,content_2321_4372:()=>HIt,content_2321_4374:()=>$It,content_2321_4376:()=>KIt,content_2321_4378:()=>tSt,content_2321_438:()=>nL,content_2321_4380:()=>eSt,content_2321_4382:()=>pSt,content_2321_4384:()=>sSt,content_2321_4386:()=>iSt,content_2321_4388:()=>lSt,content_2321_4390:()=>mSt,content_2321_4392:()=>hSt,content_2321_4394:()=>ySt,content_2321_4396:()=>MSt,content_2321_4398:()=>wSt,content_2321_44:()=>Ew,content_2321_440:()=>oL,content_2321_4400:()=>XSt,content_2321_4402:()=>TSt,content_2321_4404:()=>CSt,content_2321_4406:()=>LSt,content_2321_4408:()=>bSt,content_2321_4410:()=>zSt,content_2321_4412:()=>WSt,content_2321_4414:()=>ISt,content_2321_4416:()=>PSt,content_2321_4418:()=>BSt,content_2321_442:()=>rL,content_2321_4420:()=>OSt,content_2321_4422:()=>FSt,content_2321_4424:()=>VSt,content_2321_4426:()=>HSt,content_2321_4428:()=>$St,content_2321_4430:()=>KSt,content_2321_4432:()=>tPt,content_2321_4434:()=>ePt,content_2321_4436:()=>pPt,content_2321_4438:()=>sPt,content_2321_444:()=>cL,content_2321_4440:()=>iPt,content_2321_4442:()=>lPt,content_2321_4444:()=>mPt,content_2321_4446:()=>hPt,content_2321_4448:()=>yPt,content_2321_4450:()=>MPt,content_2321_4452:()=>wPt,content_2321_4454:()=>XPt,content_2321_4456:()=>TPt,content_2321_4458:()=>CPt,content_2321_446:()=>aL,content_2321_4460:()=>LPt,content_2321_4462:()=>bPt,content_2321_4464:()=>zPt,content_2321_4466:()=>WPt,content_2321_4468:()=>IPt,content_2321_4470:()=>PPt,content_2321_4472:()=>BPt,content_2321_4474:()=>OPt,content_2321_4476:()=>FPt,content_2321_4478:()=>VPt,content_2321_448:()=>uL,content_2321_4480:()=>HPt,content_2321_4482:()=>$Pt,content_2321_4484:()=>KPt,content_2321_4486:()=>tEt,content_2321_4488:()=>eEt,content_2321_4490:()=>pEt,content_2321_4492:()=>sEt,content_2321_4494:()=>iEt,content_2321_4496:()=>lEt,content_2321_4498:()=>mEt,content_2321_450:()=>dL,content_2321_4500:()=>hEt,content_2321_4502:()=>yEt,content_2321_4504:()=>MEt,content_2321_4506:()=>wEt,content_2321_4508:()=>XEt,content_2321_4510:()=>TEt,content_2321_4512:()=>CEt,content_2321_4514:()=>LEt,content_2321_4516:()=>bEt,content_2321_4518:()=>zEt,content_2321_452:()=>kL,content_2321_4520:()=>WEt,content_2321_4522:()=>IEt,content_2321_4524:()=>PEt,content_2321_4526:()=>BEt,content_2321_4528:()=>OEt,content_2321_4530:()=>FEt,content_2321_4532:()=>VEt,content_2321_4534:()=>HEt,content_2321_4536:()=>$Et,content_2321_4538:()=>KEt,content_2321_454:()=>fL,content_2321_4540:()=>tBt,content_2321_4542:()=>eBt,content_2321_4544:()=>pBt,content_2321_4546:()=>sBt,content_2321_4548:()=>iBt,content_2321_4550:()=>lBt,content_2321_4552:()=>mBt,content_2321_4554:()=>hBt,content_2321_4556:()=>yBt,content_2321_4558:()=>MBt,content_2321_456:()=>DL,content_2321_4560:()=>wBt,content_2321_4562:()=>XBt,content_2321_4564:()=>TBt,content_2321_4566:()=>CBt,content_2321_4568:()=>LBt,content_2321_4570:()=>bBt,content_2321_4572:()=>zBt,content_2321_4574:()=>WBt,content_2321_4576:()=>IBt,content_2321_4578:()=>PBt,content_2321_458:()=>_L,content_2321_4580:()=>BBt,content_2321_4582:()=>OBt,content_2321_4584:()=>FBt,content_2321_4586:()=>VBt,content_2321_4588:()=>HBt,content_2321_4590:()=>$Bt,content_2321_4592:()=>KBt,content_2321_4594:()=>tGt,content_2321_4596:()=>eGt,content_2321_4598:()=>pGt,content_2321_46:()=>Gw,content_2321_460:()=>gL,content_2321_4600:()=>sGt,content_2321_4602:()=>iGt,content_2321_4604:()=>lGt,content_2321_4606:()=>mGt,content_2321_4608:()=>hGt,content_2321_4610:()=>yGt,content_2321_4612:()=>MGt,content_2321_4614:()=>wGt,content_2321_4616:()=>XGt,content_2321_4618:()=>TGt,content_2321_462:()=>xL,content_2321_4620:()=>CGt,content_2321_4622:()=>LGt,content_2321_4624:()=>bGt,content_2321_4626:()=>zGt,content_2321_4628:()=>WGt,content_2321_4630:()=>IGt,content_2321_4632:()=>PGt,content_2321_4634:()=>BGt,content_2321_4636:()=>OGt,content_2321_4638:()=>FGt,content_2321_464:()=>vL,content_2321_4640:()=>VGt,content_2321_4642:()=>HGt,content_2321_4644:()=>$Gt,content_2321_4646:()=>KGt,content_2321_4648:()=>tOt,content_2321_4650:()=>eOt,content_2321_4652:()=>pOt,content_2321_4654:()=>sOt,content_2321_4656:()=>iOt,content_2321_4658:()=>lOt,content_2321_466:()=>ZL,content_2321_4660:()=>mOt,content_2321_4662:()=>hOt,content_2321_4664:()=>yOt,content_2321_4666:()=>MOt,content_2321_4668:()=>wOt,content_2321_4670:()=>XOt,content_2321_4672:()=>TOt,content_2321_4674:()=>COt,content_2321_4676:()=>LOt,content_2321_4678:()=>bOt,content_2321_468:()=>NL,content_2321_4680:()=>zOt,content_2321_4682:()=>WOt,content_2321_4684:()=>IOt,content_2321_4686:()=>POt,content_2321_4688:()=>BOt,content_2321_4690:()=>OOt,content_2321_4692:()=>FOt,content_2321_4694:()=>VOt,content_2321_4696:()=>HOt,content_2321_4698:()=>$Ot,content_2321_470:()=>AL,content_2321_4700:()=>KOt,content_2321_4702:()=>tUt,content_2321_4704:()=>eUt,content_2321_4706:()=>pUt,content_2321_4708:()=>sUt,content_2321_4710:()=>iUt,content_2321_4712:()=>lUt,content_2321_4714:()=>mUt,content_2321_4716:()=>hUt,content_2321_4718:()=>yUt,content_2321_472:()=>RL,content_2321_4720:()=>MUt,content_2321_4722:()=>wUt,content_2321_4724:()=>XUt,content_2321_4726:()=>TUt,content_2321_4728:()=>CUt,content_2321_4730:()=>LUt,content_2321_4732:()=>bUt,content_2321_4734:()=>zUt,content_2321_4736:()=>WUt,content_2321_4738:()=>IUt,content_2321_474:()=>SL,content_2321_4740:()=>PUt,content_2321_4742:()=>BUt,content_2321_4744:()=>OUt,content_2321_4746:()=>FUt,content_2321_4748:()=>VUt,content_2321_4750:()=>HUt,content_2321_4752:()=>$Ut,content_2321_4754:()=>KUt,content_2321_4756:()=>tFt,content_2321_4758:()=>eFt,content_2321_476:()=>EL,content_2321_4760:()=>pFt,content_2321_4762:()=>sFt,content_2321_4764:()=>iFt,content_2321_4766:()=>lFt,content_2321_4768:()=>mFt,content_2321_4770:()=>hFt,content_2321_4772:()=>yFt,content_2321_4774:()=>MFt,content_2321_4776:()=>wFt,content_2321_4778:()=>XFt,content_2321_478:()=>GL,content_2321_4780:()=>TFt,content_2321_4782:()=>CFt,content_2321_4784:()=>LFt,content_2321_4786:()=>bFt,content_2321_4788:()=>zFt,content_2321_4790:()=>WFt,content_2321_4792:()=>IFt,content_2321_4794:()=>PFt,content_2321_4796:()=>BFt,content_2321_4798:()=>OFt,content_2321_48:()=>Uw,content_2321_480:()=>UL,content_2321_4800:()=>FFt,content_2321_4802:()=>VFt,content_2321_4804:()=>HFt,content_2321_4806:()=>$Ft,content_2321_4808:()=>KFt,content_2321_4810:()=>tqt,content_2321_4812:()=>eqt,content_2321_4814:()=>pqt,content_2321_4816:()=>sqt,content_2321_4818:()=>iqt,content_2321_482:()=>qL,content_2321_4820:()=>lqt,content_2321_4822:()=>mqt,content_2321_4824:()=>hqt,content_2321_4826:()=>yqt,content_2321_4828:()=>Mqt,content_2321_4830:()=>wqt,content_2321_4832:()=>Xqt,content_2321_4834:()=>Tqt,content_2321_4836:()=>Cqt,content_2321_4838:()=>Lqt,content_2321_484:()=>jL,content_2321_4840:()=>bqt,content_2321_4842:()=>zqt,content_2321_4844:()=>Wqt,content_2321_4846:()=>Iqt,content_2321_4848:()=>Pqt,content_2321_4850:()=>Bqt,content_2321_4852:()=>Oqt,content_2321_4854:()=>Fqt,content_2321_4856:()=>Vqt,content_2321_4858:()=>Hqt,content_2321_486:()=>QL,content_2321_4860:()=>$qt,content_2321_4862:()=>Kqt,content_2321_4864:()=>tVt,content_2321_4866:()=>eVt,content_2321_4868:()=>pVt,content_2321_4870:()=>sVt,content_2321_4872:()=>iVt,content_2321_4874:()=>lVt,content_2321_4876:()=>mVt,content_2321_4878:()=>hVt,content_2321_488:()=>YL,content_2321_4880:()=>yVt,content_2321_4882:()=>MVt,content_2321_4884:()=>wVt,content_2321_4886:()=>XVt,content_2321_4888:()=>TVt,content_2321_4890:()=>CVt,content_2321_4892:()=>LVt,content_2321_4894:()=>bVt,content_2321_4896:()=>zVt,content_2321_4898:()=>WVt,content_2321_490:()=>JL,content_2321_4900:()=>IVt,content_2321_4902:()=>PVt,content_2321_4904:()=>BVt,content_2321_4906:()=>OVt,content_2321_4908:()=>FVt,content_2321_4910:()=>VVt,content_2321_4912:()=>HVt,content_2321_4914:()=>$Vt,content_2321_4916:()=>KVt,content_2321_4918:()=>tjt,content_2321_492:()=>nZ,content_2321_4920:()=>ejt,content_2321_4922:()=>pjt,content_2321_4924:()=>sjt,content_2321_4926:()=>ijt,content_2321_4928:()=>ljt,content_2321_4930:()=>mjt,content_2321_4932:()=>hjt,content_2321_4934:()=>yjt,content_2321_4936:()=>Mjt,content_2321_4938:()=>wjt,content_2321_494:()=>oZ,content_2321_4940:()=>Xjt,content_2321_4942:()=>Tjt,content_2321_4944:()=>Cjt,content_2321_4946:()=>Ljt,content_2321_4948:()=>bjt,content_2321_4950:()=>zjt,content_2321_4952:()=>Wjt,content_2321_4954:()=>Ijt,content_2321_4956:()=>Pjt,content_2321_4958:()=>Bjt,content_2321_496:()=>rZ,content_2321_4960:()=>Ojt,content_2321_4962:()=>Fjt,content_2321_4964:()=>Vjt,content_2321_4966:()=>Hjt,content_2321_4968:()=>$jt,content_2321_4970:()=>Kjt,content_2321_4972:()=>tHt,content_2321_4974:()=>eHt,content_2321_4976:()=>pHt,content_2321_4978:()=>sHt,content_2321_498:()=>cZ,content_2321_4980:()=>iHt,content_2321_4982:()=>lHt,content_2321_4984:()=>mHt,content_2321_4986:()=>hHt,content_2321_4988:()=>yHt,content_2321_4990:()=>MHt,content_2321_4992:()=>wHt,content_2321_4994:()=>XHt,content_2321_4996:()=>THt,content_2321_4998:()=>CHt,content_2321_50:()=>qw,content_2321_500:()=>aZ,content_2321_5000:()=>LHt,content_2321_5002:()=>bHt,content_2321_5004:()=>zHt,content_2321_5006:()=>WHt,content_2321_5008:()=>IHt,content_2321_5010:()=>PHt,content_2321_5012:()=>BHt,content_2321_5014:()=>OHt,content_2321_5016:()=>FHt,content_2321_5018:()=>VHt,content_2321_502:()=>uZ,content_2321_5020:()=>HHt,content_2321_5022:()=>$Ht,content_2321_5024:()=>KHt,content_2321_5026:()=>tQt,content_2321_5028:()=>eQt,content_2321_5030:()=>pQt,content_2321_5032:()=>sQt,content_2321_5034:()=>iQt,content_2321_5036:()=>lQt,content_2321_5038:()=>mQt,content_2321_504:()=>dZ,content_2321_5040:()=>hQt,content_2321_5042:()=>yQt,content_2321_5044:()=>MQt,content_2321_5046:()=>wQt,content_2321_5048:()=>XQt,content_2321_5050:()=>TQt,content_2321_5052:()=>CQt,content_2321_5054:()=>LQt,content_2321_5056:()=>bQt,content_2321_5058:()=>zQt,content_2321_506:()=>kZ,content_2321_5060:()=>WQt,content_2321_5062:()=>IQt,content_2321_5064:()=>PQt,content_2321_5066:()=>BQt,content_2321_5068:()=>OQt,content_2321_5070:()=>FQt,content_2321_5072:()=>VQt,content_2321_5074:()=>HQt,content_2321_5076:()=>$Qt,content_2321_5078:()=>KQt,content_2321_508:()=>fZ,content_2321_5080:()=>t$t,content_2321_5082:()=>e$t,content_2321_5084:()=>p$t,content_2321_5086:()=>s$t,content_2321_5088:()=>i$t,content_2321_5090:()=>l$t,content_2321_5092:()=>m$t,content_2321_5094:()=>h$t,content_2321_5096:()=>y$t,content_2321_5098:()=>M$t,content_2321_510:()=>DZ,content_2321_5100:()=>w$t,content_2321_5102:()=>X$t,content_2321_5104:()=>T$t,content_2321_5106:()=>C$t,content_2321_5108:()=>L$t,content_2321_5110:()=>b$t,content_2321_5112:()=>z$t,content_2321_5114:()=>W$t,content_2321_5116:()=>I$t,content_2321_5118:()=>P$t,content_2321_512:()=>_Z,content_2321_5120:()=>B$t,content_2321_5122:()=>O$t,content_2321_5124:()=>F$t,content_2321_5126:()=>V$t,content_2321_5128:()=>H$t,content_2321_5130:()=>$$t,content_2321_5132:()=>K$t,content_2321_5134:()=>tYt,content_2321_5136:()=>eYt,content_2321_5138:()=>pYt,content_2321_514:()=>gZ,content_2321_5140:()=>sYt,content_2321_5142:()=>iYt,content_2321_5144:()=>lYt,content_2321_5146:()=>mYt,content_2321_5148:()=>hYt,content_2321_5150:()=>yYt,content_2321_5152:()=>MYt,content_2321_5154:()=>wYt,content_2321_5156:()=>XYt,content_2321_5158:()=>TYt,content_2321_516:()=>xZ,content_2321_5160:()=>CYt,content_2321_5162:()=>LYt,content_2321_5164:()=>bYt,content_2321_5166:()=>zYt,content_2321_5168:()=>WYt,content_2321_5170:()=>IYt,content_2321_5172:()=>PYt,content_2321_5174:()=>BYt,content_2321_5176:()=>OYt,content_2321_5178:()=>FYt,content_2321_518:()=>vZ,content_2321_5180:()=>VYt,content_2321_5182:()=>HYt,content_2321_5184:()=>$Yt,content_2321_5186:()=>KYt,content_2321_5188:()=>tKt,content_2321_5190:()=>eKt,content_2321_5192:()=>pKt,content_2321_5194:()=>sKt,content_2321_5196:()=>iKt,content_2321_5198:()=>lKt,content_2321_52:()=>jw,content_2321_520:()=>ZZ,content_2321_5200:()=>mKt,content_2321_5202:()=>hKt,content_2321_5204:()=>yKt,content_2321_5206:()=>MKt,content_2321_5208:()=>wKt,content_2321_5210:()=>XKt,content_2321_5212:()=>TKt,content_2321_5214:()=>CKt,content_2321_5216:()=>LKt,content_2321_5218:()=>bKt,content_2321_522:()=>NZ,content_2321_5220:()=>zKt,content_2321_5222:()=>WKt,content_2321_5224:()=>IKt,content_2321_5226:()=>PKt,content_2321_5228:()=>BKt,content_2321_5230:()=>OKt,content_2321_5232:()=>FKt,content_2321_5234:()=>VKt,content_2321_5236:()=>HKt,content_2321_5238:()=>$Kt,content_2321_524:()=>AZ,content_2321_5240:()=>KKt,content_2321_5242:()=>tJt,content_2321_5244:()=>eJt,content_2321_5246:()=>pJt,content_2321_5248:()=>sJt,content_2321_5250:()=>iJt,content_2321_5252:()=>lJt,content_2321_5254:()=>mJt,content_2321_5256:()=>hJt,content_2321_5258:()=>yJt,content_2321_526:()=>RZ,content_2321_5260:()=>MJt,content_2321_5262:()=>wJt,content_2321_5264:()=>XJt,content_2321_5266:()=>TJt,content_2321_5268:()=>CJt,content_2321_5270:()=>LJt,content_2321_5272:()=>bJt,content_2321_5274:()=>zJt,content_2321_5276:()=>WJt,content_2321_5278:()=>IJt,content_2321_528:()=>SZ,content_2321_5280:()=>PJt,content_2321_5282:()=>BJt,content_2321_5284:()=>OJt,content_2321_5286:()=>FJt,content_2321_5288:()=>VJt,content_2321_5290:()=>HJt,content_2321_5292:()=>$Jt,content_2321_5294:()=>KJt,content_2321_5296:()=>t0t,content_2321_5298:()=>e0t,content_2321_530:()=>EZ,content_2321_5300:()=>p0t,content_2321_5302:()=>s0t,content_2321_5304:()=>i0t,content_2321_5306:()=>l0t,content_2321_5308:()=>m0t,content_2321_5310:()=>h0t,content_2321_5312:()=>y0t,content_2321_5314:()=>M0t,content_2321_5316:()=>w0t,content_2321_5318:()=>X0t,content_2321_532:()=>GZ,content_2321_5320:()=>T0t,content_2321_5322:()=>C0t,content_2321_5324:()=>L0t,content_2321_5326:()=>b0t,content_2321_5328:()=>z0t,content_2321_5330:()=>W0t,content_2321_5332:()=>I0t,content_2321_5334:()=>P0t,content_2321_5336:()=>B0t,content_2321_5338:()=>O0t,content_2321_534:()=>UZ,content_2321_5340:()=>F0t,content_2321_5342:()=>V0t,content_2321_5344:()=>H0t,content_2321_5346:()=>$0t,content_2321_5348:()=>K0t,content_2321_5350:()=>t2t,content_2321_5352:()=>e2t,content_2321_5354:()=>p2t,content_2321_5356:()=>s2t,content_2321_5358:()=>i2t,content_2321_536:()=>qZ,content_2321_5360:()=>l2t,content_2321_5362:()=>m2t,content_2321_5364:()=>h2t,content_2321_5366:()=>y2t,content_2321_5368:()=>M2t,content_2321_5370:()=>w2t,content_2321_5372:()=>X2t,content_2321_5374:()=>T2t,content_2321_5376:()=>C2t,content_2321_5378:()=>L2t,content_2321_538:()=>jZ,content_2321_5380:()=>b2t,content_2321_5382:()=>z2t,content_2321_5384:()=>W2t,content_2321_5386:()=>I2t,content_2321_5388:()=>P2t,content_2321_5390:()=>B2t,content_2321_5392:()=>O2t,content_2321_5394:()=>F2t,content_2321_5396:()=>V2t,content_2321_5398:()=>H2t,content_2321_54:()=>Qw,content_2321_540:()=>QZ,content_2321_5400:()=>$2t,content_2321_5402:()=>K2t,content_2321_5404:()=>t1t,content_2321_5406:()=>e1t,content_2321_5408:()=>p1t,content_2321_5410:()=>s1t,content_2321_5412:()=>i1t,content_2321_5414:()=>l1t,content_2321_5416:()=>m1t,content_2321_5418:()=>h1t,content_2321_542:()=>YZ,content_2321_5420:()=>y1t,content_2321_5422:()=>M1t,content_2321_5424:()=>w1t,content_2321_5426:()=>X1t,content_2321_5428:()=>T1t,content_2321_5430:()=>C1t,content_2321_5432:()=>L1t,content_2321_5434:()=>b1t,content_2321_5436:()=>z1t,content_2321_5438:()=>W1t,content_2321_544:()=>JZ,content_2321_5440:()=>I1t,content_2321_5442:()=>P1t,content_2321_5444:()=>B1t,content_2321_5446:()=>O1t,content_2321_5448:()=>F1t,content_2321_5450:()=>V1t,content_2321_5452:()=>H1t,content_2321_5454:()=>$1t,content_2321_5456:()=>K1t,content_2321_5458:()=>t3t,content_2321_546:()=>nb,content_2321_5460:()=>e3t,content_2321_5462:()=>p3t,content_2321_5464:()=>s3t,content_2321_5466:()=>i3t,content_2321_5468:()=>l3t,content_2321_5470:()=>m3t,content_2321_5472:()=>h3t,content_2321_5474:()=>y3t,content_2321_5476:()=>M3t,content_2321_5478:()=>w3t,content_2321_548:()=>ob,content_2321_5480:()=>X3t,content_2321_5482:()=>T3t,content_2321_5484:()=>C3t,content_2321_5486:()=>L3t,content_2321_5488:()=>b3t,content_2321_5490:()=>z3t,content_2321_5492:()=>W3t,content_2321_5494:()=>I3t,content_2321_5496:()=>P3t,content_2321_5498:()=>B3t,content_2321_550:()=>rb,content_2321_5500:()=>O3t,content_2321_5502:()=>F3t,content_2321_5504:()=>V3t,content_2321_5506:()=>H3t,content_2321_5508:()=>$3t,content_2321_5510:()=>K3t,content_2321_5512:()=>t6t,content_2321_5514:()=>e6t,content_2321_5516:()=>p6t,content_2321_5518:()=>s6t,content_2321_552:()=>cb,content_2321_5520:()=>i6t,content_2321_5522:()=>l6t,content_2321_5524:()=>m6t,content_2321_5526:()=>h6t,content_2321_5528:()=>y6t,content_2321_5530:()=>M6t,content_2321_5532:()=>w6t,content_2321_5534:()=>X6t,content_2321_5536:()=>T6t,content_2321_5538:()=>C6t,content_2321_554:()=>ab,content_2321_5540:()=>L6t,content_2321_5542:()=>b6t,content_2321_5544:()=>z6t,content_2321_5546:()=>W6t,content_2321_5548:()=>I6t,content_2321_5550:()=>P6t,content_2321_5552:()=>B6t,content_2321_5554:()=>O6t,content_2321_5556:()=>F6t,content_2321_5558:()=>V6t,content_2321_556:()=>ub,content_2321_5560:()=>H6t,content_2321_5562:()=>$6t,content_2321_5564:()=>K6t,content_2321_5566:()=>t4t,content_2321_5568:()=>e4t,content_2321_5570:()=>p4t,content_2321_5572:()=>s4t,content_2321_5574:()=>i4t,content_2321_5576:()=>l4t,content_2321_5578:()=>m4t,content_2321_558:()=>db,content_2321_5580:()=>h4t,content_2321_5582:()=>y4t,content_2321_5584:()=>M4t,content_2321_5586:()=>w4t,content_2321_5588:()=>X4t,content_2321_5590:()=>T4t,content_2321_5592:()=>C4t,content_2321_5594:()=>L4t,content_2321_5596:()=>b4t,content_2321_5598:()=>z4t,content_2321_56:()=>Yw,content_2321_560:()=>kb,content_2321_5600:()=>W4t,content_2321_5602:()=>I4t,content_2321_5604:()=>P4t,content_2321_5606:()=>B4t,content_2321_5608:()=>O4t,content_2321_5610:()=>F4t,content_2321_5612:()=>V4t,content_2321_5614:()=>H4t,content_2321_5616:()=>$4t,content_2321_5618:()=>K4t,content_2321_562:()=>fb,content_2321_5620:()=>t8t,content_2321_5622:()=>e8t,content_2321_5624:()=>p8t,content_2321_5626:()=>s8t,content_2321_5628:()=>i8t,content_2321_5630:()=>l8t,content_2321_5632:()=>m8t,content_2321_5634:()=>h8t,content_2321_5636:()=>y8t,content_2321_5638:()=>M8t,content_2321_564:()=>Db,content_2321_5640:()=>w8t,content_2321_5642:()=>X8t,content_2321_5644:()=>T8t,content_2321_5646:()=>C8t,content_2321_5648:()=>L8t,content_2321_5650:()=>b8t,content_2321_5652:()=>z8t,content_2321_5654:()=>W8t,content_2321_5656:()=>I8t,content_2321_5658:()=>P8t,content_2321_566:()=>_b,content_2321_5660:()=>B8t,content_2321_5662:()=>O8t,content_2321_5664:()=>F8t,content_2321_5666:()=>V8t,content_2321_5668:()=>H8t,content_2321_5670:()=>$8t,content_2321_5672:()=>K8t,content_2321_5674:()=>t5t,content_2321_5676:()=>e5t,content_2321_5678:()=>p5t,content_2321_568:()=>gb,content_2321_5680:()=>s5t,content_2321_5682:()=>i5t,content_2321_5684:()=>l5t,content_2321_5686:()=>m5t,content_2321_5688:()=>h5t,content_2321_5690:()=>y5t,content_2321_5692:()=>M5t,content_2321_5694:()=>w5t,content_2321_5696:()=>X5t,content_2321_5698:()=>T5t,content_2321_570:()=>xb,content_2321_5700:()=>C5t,content_2321_5702:()=>L5t,content_2321_5704:()=>b5t,content_2321_5706:()=>z5t,content_2321_5708:()=>W5t,content_2321_5710:()=>I5t,content_2321_5712:()=>P5t,content_2321_5714:()=>B5t,content_2321_5716:()=>O5t,content_2321_5718:()=>F5t,content_2321_572:()=>vb,content_2321_5720:()=>V5t,content_2321_5722:()=>H5t,content_2321_5724:()=>$5t,content_2321_5726:()=>K5t,content_2321_5728:()=>t7t,content_2321_5730:()=>e7t,content_2321_5732:()=>p7t,content_2321_5734:()=>s7t,content_2321_5736:()=>i7t,content_2321_5738:()=>l7t,content_2321_574:()=>Zb,content_2321_5740:()=>m7t,content_2321_5742:()=>h7t,content_2321_5744:()=>y7t,content_2321_5746:()=>M7t,content_2321_5748:()=>w7t,content_2321_5750:()=>X7t,content_2321_5752:()=>T7t,content_2321_5754:()=>C7t,content_2321_5756:()=>L7t,content_2321_5758:()=>b7t,content_2321_576:()=>Nb,content_2321_5760:()=>z7t,content_2321_5762:()=>W7t,content_2321_5764:()=>I7t,content_2321_5766:()=>P7t,content_2321_5768:()=>B7t,content_2321_5770:()=>O7t,content_2321_5772:()=>F7t,content_2321_5774:()=>V7t,content_2321_5776:()=>H7t,content_2321_5778:()=>$7t,content_2321_578:()=>Ab,content_2321_5780:()=>K7t,content_2321_5782:()=>t9t,content_2321_5784:()=>e9t,content_2321_5786:()=>p9t,content_2321_5788:()=>s9t,content_2321_5790:()=>i9t,content_2321_5792:()=>l9t,content_2321_5794:()=>m9t,content_2321_5796:()=>h9t,content_2321_5798:()=>y9t,content_2321_58:()=>Jw,content_2321_580:()=>Rb,content_2321_5800:()=>M9t,content_2321_5802:()=>w9t,content_2321_5804:()=>X9t,content_2321_5806:()=>T9t,content_2321_5808:()=>C9t,content_2321_5810:()=>L9t,content_2321_5812:()=>b9t,content_2321_5814:()=>z9t,content_2321_5816:()=>W9t,content_2321_5818:()=>I9t,content_2321_582:()=>Sb,content_2321_5820:()=>P9t,content_2321_5822:()=>B9t,content_2321_5824:()=>O9t,content_2321_5826:()=>F9t,content_2321_5828:()=>V9t,content_2321_5830:()=>H9t,content_2321_5832:()=>$9t,content_2321_5834:()=>K9t,content_2321_5836:()=>ttn,content_2321_5838:()=>etn,content_2321_584:()=>Eb,content_2321_5840:()=>ptn,content_2321_5842:()=>stn,content_2321_5844:()=>itn,content_2321_5846:()=>ltn,content_2321_5848:()=>mtn,content_2321_5850:()=>htn,content_2321_5852:()=>ytn,content_2321_5854:()=>Mtn,content_2321_5856:()=>wtn,content_2321_5858:()=>Xtn,content_2321_586:()=>Gb,content_2321_5860:()=>Ttn,content_2321_5862:()=>Ctn,content_2321_5864:()=>Ltn,content_2321_5866:()=>btn,content_2321_5868:()=>ztn,content_2321_5870:()=>Wtn,content_2321_5872:()=>Itn,content_2321_5874:()=>Ptn,content_2321_5876:()=>Btn,content_2321_5878:()=>Otn,content_2321_588:()=>Ub,content_2321_5880:()=>Ftn,content_2321_5882:()=>Vtn,content_2321_5884:()=>Htn,content_2321_5886:()=>$tn,content_2321_5888:()=>Ktn,content_2321_5890:()=>tnn,content_2321_5892:()=>enn,content_2321_5894:()=>pnn,content_2321_5896:()=>snn,content_2321_5898:()=>inn,content_2321_590:()=>qb,content_2321_5900:()=>lnn,content_2321_5902:()=>mnn,content_2321_5904:()=>hnn,content_2321_5906:()=>ynn,content_2321_5908:()=>Mnn,content_2321_5910:()=>wnn,content_2321_5912:()=>Xnn,content_2321_5914:()=>Tnn,content_2321_5916:()=>Cnn,content_2321_5918:()=>Lnn,content_2321_592:()=>jb,content_2321_5920:()=>bnn,content_2321_5922:()=>znn,content_2321_5924:()=>Wnn,content_2321_5926:()=>Inn,content_2321_5928:()=>Pnn,content_2321_5930:()=>Bnn,content_2321_5932:()=>Onn,content_2321_5934:()=>Fnn,content_2321_5936:()=>Vnn,content_2321_5938:()=>Hnn,content_2321_594:()=>Qb,content_2321_5940:()=>$nn,content_2321_5942:()=>Knn,content_2321_5944:()=>ten,content_2321_5946:()=>een,content_2321_5948:()=>pen,content_2321_5950:()=>sen,content_2321_5952:()=>ien,content_2321_5954:()=>len,content_2321_5956:()=>men,content_2321_5958:()=>hen,content_2321_596:()=>Yb,content_2321_5960:()=>yen,content_2321_5962:()=>Men,content_2321_5964:()=>wen,content_2321_5966:()=>Xen,content_2321_5968:()=>Ten,content_2321_5970:()=>Cen,content_2321_5972:()=>Len,content_2321_5974:()=>ben,content_2321_5976:()=>zen,content_2321_5978:()=>Wen,content_2321_598:()=>Jb,content_2321_5980:()=>Ien,content_2321_5982:()=>Pen,content_2321_5984:()=>Ben,content_2321_5986:()=>Oen,content_2321_5988:()=>Fen,content_2321_5990:()=>Ven,content_2321_5992:()=>Hen,content_2321_5994:()=>$en,content_2321_5996:()=>Ken,content_2321_5998:()=>ton,content_2321_6:()=>nw,content_2321_60:()=>n_,content_2321_600:()=>nN,content_2321_6000:()=>eon,content_2321_6002:()=>pon,content_2321_6004:()=>son,content_2321_6006:()=>ion,content_2321_6008:()=>lon,content_2321_6010:()=>mon,content_2321_6012:()=>hon,content_2321_6014:()=>yon,content_2321_6016:()=>Mon,content_2321_6018:()=>won,content_2321_602:()=>oN,content_2321_6020:()=>Xon,content_2321_6022:()=>Ton,content_2321_6024:()=>Con,content_2321_6026:()=>Lon,content_2321_6028:()=>bon,content_2321_6030:()=>zon,content_2321_6032:()=>Won,content_2321_6034:()=>Ion,content_2321_6036:()=>Pon,content_2321_6038:()=>Bon,content_2321_604:()=>rN,content_2321_6040:()=>Oon,content_2321_6042:()=>Fon,content_2321_6044:()=>Von,content_2321_6046:()=>Hon,content_2321_6048:()=>$on,content_2321_6050:()=>Kon,content_2321_6052:()=>tpn,content_2321_6054:()=>epn,content_2321_6056:()=>ppn,content_2321_6058:()=>spn,content_2321_606:()=>cN,content_2321_6060:()=>ipn,content_2321_6062:()=>lpn,content_2321_6064:()=>mpn,content_2321_6066:()=>hpn,content_2321_6068:()=>ypn,content_2321_6070:()=>Mpn,content_2321_6072:()=>wpn,content_2321_6074:()=>Xpn,content_2321_6076:()=>Tpn,content_2321_6078:()=>Cpn,content_2321_608:()=>aN,content_2321_6080:()=>Lpn,content_2321_6082:()=>bpn,content_2321_6084:()=>zpn,content_2321_6086:()=>Wpn,content_2321_6088:()=>Ipn,content_2321_6090:()=>Ppn,content_2321_6092:()=>Bpn,content_2321_6094:()=>Opn,content_2321_6096:()=>Fpn,content_2321_6098:()=>Vpn,content_2321_610:()=>uN,content_2321_6100:()=>Hpn,content_2321_6102:()=>$pn,content_2321_6104:()=>Kpn,content_2321_6106:()=>trn,content_2321_6108:()=>ern,content_2321_6110:()=>prn,content_2321_6112:()=>srn,content_2321_6114:()=>irn,content_2321_6116:()=>lrn,content_2321_6118:()=>mrn,content_2321_612:()=>dN,content_2321_6120:()=>hrn,content_2321_6122:()=>yrn,content_2321_6124:()=>Mrn,content_2321_6126:()=>wrn,content_2321_6128:()=>Xrn,content_2321_6130:()=>Trn,content_2321_6132:()=>Crn,content_2321_6134:()=>Lrn,content_2321_6136:()=>brn,content_2321_6138:()=>zrn,content_2321_614:()=>kN,content_2321_6140:()=>Wrn,content_2321_6142:()=>Irn,content_2321_6144:()=>Prn,content_2321_6146:()=>Brn,content_2321_6148:()=>Orn,content_2321_6150:()=>Frn,content_2321_6152:()=>Vrn,content_2321_6154:()=>Hrn,content_2321_6156:()=>$rn,content_2321_6158:()=>Krn,content_2321_616:()=>fN,content_2321_6160:()=>tsn,content_2321_6162:()=>esn,content_2321_6164:()=>psn,content_2321_6166:()=>ssn,content_2321_6168:()=>isn,content_2321_6170:()=>lsn,content_2321_6172:()=>msn,content_2321_6174:()=>hsn,content_2321_6176:()=>ysn,content_2321_6178:()=>Msn,content_2321_618:()=>DN,content_2321_6180:()=>wsn,content_2321_6182:()=>Xsn,content_2321_6184:()=>Tsn,content_2321_6186:()=>Csn,content_2321_6188:()=>Lsn,content_2321_6190:()=>bsn,content_2321_6192:()=>zsn,content_2321_6194:()=>Wsn,content_2321_6196:()=>Isn,content_2321_6198:()=>Psn,content_2321_62:()=>o_,content_2321_620:()=>_N,content_2321_6200:()=>Bsn,content_2321_6202:()=>Osn,content_2321_6204:()=>Fsn,content_2321_6206:()=>Vsn,content_2321_6208:()=>Hsn,content_2321_6210:()=>$sn,content_2321_6212:()=>Ksn,content_2321_6214:()=>tcn,content_2321_6216:()=>ecn,content_2321_6218:()=>pcn,content_2321_622:()=>gN,content_2321_6220:()=>scn,content_2321_6222:()=>icn,content_2321_6224:()=>lcn,content_2321_6226:()=>mcn,content_2321_6228:()=>hcn,content_2321_6230:()=>ycn,content_2321_6232:()=>Mcn,content_2321_6234:()=>wcn,content_2321_6236:()=>Xcn,content_2321_6238:()=>Tcn,content_2321_624:()=>xN,content_2321_6240:()=>Ccn,content_2321_6242:()=>Lcn,content_2321_6244:()=>bcn,content_2321_6246:()=>zcn,content_2321_6248:()=>Wcn,content_2321_6250:()=>Icn,content_2321_6252:()=>Pcn,content_2321_6254:()=>Bcn,content_2321_6256:()=>Ocn,content_2321_6258:()=>Fcn,content_2321_626:()=>vN,content_2321_6260:()=>Vcn,content_2321_6262:()=>Hcn,content_2321_6264:()=>$cn,content_2321_6266:()=>Kcn,content_2321_6268:()=>tin,content_2321_6270:()=>ein,content_2321_6272:()=>pin,content_2321_6274:()=>sin,content_2321_6276:()=>iin,content_2321_6278:()=>lin,content_2321_628:()=>ZN,content_2321_6280:()=>min,content_2321_6282:()=>hin,content_2321_6284:()=>yin,content_2321_6286:()=>Min,content_2321_6288:()=>win,content_2321_6290:()=>Xin,content_2321_6292:()=>Tin,content_2321_6294:()=>Cin,content_2321_6296:()=>Lin,content_2321_6298:()=>bin,content_2321_630:()=>NN,content_2321_6300:()=>zin,content_2321_6302:()=>Win,content_2321_6304:()=>Iin,content_2321_6306:()=>Pin,content_2321_6308:()=>Bin,content_2321_6310:()=>Oin,content_2321_6312:()=>Fin,content_2321_6314:()=>Vin,content_2321_6316:()=>Hin,content_2321_6318:()=>$in,content_2321_632:()=>AN,content_2321_6320:()=>Kin,content_2321_6322:()=>tan,content_2321_6324:()=>ean,content_2321_6326:()=>pan,content_2321_6328:()=>san,content_2321_6330:()=>ian,content_2321_6332:()=>lan,content_2321_6334:()=>man,content_2321_6336:()=>han,content_2321_6338:()=>yan,content_2321_634:()=>RN,content_2321_6340:()=>Man,content_2321_6342:()=>wan,content_2321_6344:()=>Xan,content_2321_6346:()=>Tan,content_2321_6348:()=>Can,content_2321_6350:()=>Lan,content_2321_6352:()=>ban,content_2321_6354:()=>zan,content_2321_6356:()=>Wan,content_2321_6358:()=>Ian,content_2321_636:()=>SN,content_2321_6360:()=>Pan,content_2321_6362:()=>Ban,content_2321_6364:()=>Oan,content_2321_6366:()=>Fan,content_2321_6368:()=>Van,content_2321_6370:()=>Han,content_2321_6372:()=>$an,content_2321_6374:()=>Kan,content_2321_6376:()=>tln,content_2321_6378:()=>eln,content_2321_638:()=>EN,content_2321_6380:()=>pln,content_2321_6382:()=>sln,content_2321_6384:()=>iln,content_2321_6386:()=>lln,content_2321_6388:()=>mln,content_2321_6390:()=>hln,content_2321_6392:()=>yln,content_2321_6394:()=>Mln,content_2321_6396:()=>wln,content_2321_6398:()=>Xln,content_2321_64:()=>r_,content_2321_640:()=>GN,content_2321_6400:()=>Tln,content_2321_6402:()=>Cln,content_2321_6404:()=>Lln,content_2321_6406:()=>bln,content_2321_6408:()=>zln,content_2321_6410:()=>Wln,content_2321_6412:()=>Iln,content_2321_6414:()=>Pln,content_2321_6416:()=>Bln,content_2321_6418:()=>Oln,content_2321_642:()=>UN,content_2321_6420:()=>Fln,content_2321_6422:()=>Vln,content_2321_6424:()=>Hln,content_2321_6426:()=>$ln,content_2321_6428:()=>Kln,content_2321_6430:()=>tun,content_2321_6432:()=>eun,content_2321_6434:()=>pun,content_2321_6436:()=>sun,content_2321_6438:()=>iun,content_2321_644:()=>qN,content_2321_6440:()=>lun,content_2321_6442:()=>mun,content_2321_6444:()=>hun,content_2321_6446:()=>yun,content_2321_6448:()=>Mun,content_2321_6450:()=>wun,content_2321_6452:()=>Xun,content_2321_6454:()=>Tun,content_2321_6456:()=>Cun,content_2321_6458:()=>Lun,content_2321_646:()=>jN,content_2321_6460:()=>bun,content_2321_6462:()=>zun,content_2321_6464:()=>Wun,content_2321_6466:()=>Iun,content_2321_6468:()=>Pun,content_2321_6470:()=>Bun,content_2321_6472:()=>Oun,content_2321_6474:()=>Fun,content_2321_6476:()=>Vun,content_2321_6478:()=>Hun,content_2321_648:()=>QN,content_2321_6480:()=>$un,content_2321_6482:()=>Kun,content_2321_6484:()=>tmn,content_2321_6486:()=>emn,content_2321_6488:()=>pmn,content_2321_6490:()=>smn,content_2321_6492:()=>imn,content_2321_6494:()=>lmn,content_2321_6496:()=>mmn,content_2321_6498:()=>hmn,content_2321_650:()=>YN,content_2321_6500:()=>ymn,content_2321_6502:()=>Mmn,content_2321_6504:()=>wmn,content_2321_6506:()=>Xmn,content_2321_6508:()=>Tmn,content_2321_6510:()=>Cmn,content_2321_6512:()=>Lmn,content_2321_6514:()=>bmn,content_2321_6516:()=>zmn,content_2321_6518:()=>Wmn,content_2321_652:()=>JN,content_2321_6520:()=>Imn,content_2321_6522:()=>Pmn,content_2321_6524:()=>Bmn,content_2321_6526:()=>Omn,content_2321_6528:()=>Fmn,content_2321_6530:()=>Vmn,content_2321_6532:()=>Hmn,content_2321_6534:()=>$mn,content_2321_6536:()=>Kmn,content_2321_6538:()=>tdn,content_2321_654:()=>nz,content_2321_6540:()=>edn,content_2321_6542:()=>pdn,content_2321_6544:()=>sdn,content_2321_6546:()=>idn,content_2321_6548:()=>ldn,content_2321_6550:()=>mdn,content_2321_6552:()=>hdn,content_2321_6554:()=>ydn,content_2321_6556:()=>Mdn,content_2321_6558:()=>wdn,content_2321_656:()=>oz,content_2321_6560:()=>Xdn,content_2321_6562:()=>Tdn,content_2321_6564:()=>Cdn,content_2321_6566:()=>Ldn,content_2321_6568:()=>bdn,content_2321_6570:()=>zdn,content_2321_6572:()=>Wdn,content_2321_6574:()=>Idn,content_2321_6576:()=>Pdn,content_2321_6578:()=>Bdn,content_2321_658:()=>rz,content_2321_6580:()=>Odn,content_2321_6582:()=>Fdn,content_2321_6584:()=>Vdn,content_2321_6586:()=>Hdn,content_2321_6588:()=>$dn,content_2321_6590:()=>Kdn,content_2321_6592:()=>thn,content_2321_6594:()=>ehn,content_2321_6596:()=>phn,content_2321_6598:()=>shn,content_2321_66:()=>c_,content_2321_660:()=>cz,content_2321_6600:()=>ihn,content_2321_6602:()=>lhn,content_2321_6604:()=>mhn,content_2321_6606:()=>hhn,content_2321_6608:()=>yhn,content_2321_6610:()=>Mhn,content_2321_6612:()=>whn,content_2321_6614:()=>Xhn,content_2321_6616:()=>Thn,content_2321_6618:()=>Chn,content_2321_662:()=>az,content_2321_6620:()=>Lhn,content_2321_6622:()=>bhn,content_2321_6624:()=>zhn,content_2321_6626:()=>Whn,content_2321_6628:()=>Ihn,content_2321_6630:()=>Phn,content_2321_6632:()=>Bhn,content_2321_6634:()=>Ohn,content_2321_6636:()=>Fhn,content_2321_6638:()=>Vhn,content_2321_664:()=>uz,content_2321_6640:()=>Hhn,content_2321_6642:()=>$hn,content_2321_6644:()=>Khn,content_2321_6646:()=>tkn,content_2321_6648:()=>ekn,content_2321_6650:()=>pkn,content_2321_6652:()=>skn,content_2321_6654:()=>ikn,content_2321_6656:()=>lkn,content_2321_6658:()=>mkn,content_2321_666:()=>dz,content_2321_6660:()=>hkn,content_2321_6662:()=>ykn,content_2321_6664:()=>Mkn,content_2321_6666:()=>wkn,content_2321_6668:()=>Xkn,content_2321_6670:()=>Tkn,content_2321_6672:()=>Ckn,content_2321_6674:()=>Lkn,content_2321_6676:()=>bkn,content_2321_6678:()=>zkn,content_2321_668:()=>kz,content_2321_6680:()=>Wkn,content_2321_6682:()=>Ikn,content_2321_6684:()=>Pkn,content_2321_6686:()=>Bkn,content_2321_6688:()=>Okn,content_2321_6690:()=>Fkn,content_2321_6692:()=>Vkn,content_2321_6694:()=>Hkn,content_2321_6696:()=>$kn,content_2321_6698:()=>Kkn,content_2321_670:()=>fz,content_2321_6700:()=>tyn,content_2321_6702:()=>eyn,content_2321_6704:()=>pyn,content_2321_6706:()=>syn,content_2321_6708:()=>iyn,content_2321_6710:()=>lyn,content_2321_6712:()=>myn,content_2321_6714:()=>hyn,content_2321_6716:()=>yyn,content_2321_6718:()=>Myn,content_2321_672:()=>Dz,content_2321_6720:()=>wyn,content_2321_6722:()=>Xyn,content_2321_6724:()=>Tyn,content_2321_6726:()=>Cyn,content_2321_6728:()=>Lyn,content_2321_6730:()=>byn,content_2321_6732:()=>zyn,content_2321_6734:()=>Wyn,content_2321_6736:()=>Iyn,content_2321_6738:()=>Pyn,content_2321_674:()=>_z,content_2321_6740:()=>Byn,content_2321_6742:()=>Oyn,content_2321_6744:()=>Fyn,content_2321_6746:()=>Vyn,content_2321_6748:()=>Hyn,content_2321_6750:()=>$yn,content_2321_6752:()=>Kyn,content_2321_6754:()=>tfn,content_2321_6756:()=>efn,content_2321_6758:()=>pfn,content_2321_676:()=>gz,content_2321_6760:()=>sfn,content_2321_6762:()=>ifn,content_2321_6764:()=>lfn,content_2321_6766:()=>mfn,content_2321_6768:()=>hfn,content_2321_6770:()=>yfn,content_2321_6772:()=>Mfn,content_2321_6774:()=>wfn,content_2321_6776:()=>Xfn,content_2321_6778:()=>Tfn,content_2321_678:()=>xz,content_2321_6780:()=>Cfn,content_2321_6782:()=>Lfn,content_2321_6784:()=>bfn,content_2321_6786:()=>zfn,content_2321_6788:()=>Wfn,content_2321_6790:()=>Ifn,content_2321_6792:()=>Pfn,content_2321_6794:()=>Bfn,content_2321_6796:()=>Ofn,content_2321_6798:()=>Ffn,content_2321_68:()=>a_,content_2321_680:()=>vz,content_2321_6800:()=>Vfn,content_2321_6802:()=>Hfn,content_2321_6804:()=>$fn,content_2321_6806:()=>Kfn,content_2321_6808:()=>tMn,content_2321_6810:()=>eMn,content_2321_6812:()=>pMn,content_2321_6814:()=>sMn,content_2321_6816:()=>iMn,content_2321_6818:()=>lMn,content_2321_682:()=>Zz,content_2321_6820:()=>mMn,content_2321_6822:()=>hMn,content_2321_6824:()=>yMn,content_2321_6826:()=>MMn,content_2321_6828:()=>wMn,content_2321_6830:()=>XMn,content_2321_6832:()=>TMn,content_2321_6834:()=>CMn,content_2321_6836:()=>LMn,content_2321_6838:()=>bMn,content_2321_684:()=>Nz,content_2321_6840:()=>zMn,content_2321_6842:()=>WMn,content_2321_6844:()=>IMn,content_2321_6846:()=>PMn,content_2321_6848:()=>BMn,content_2321_6850:()=>OMn,content_2321_6852:()=>FMn,content_2321_6854:()=>VMn,content_2321_6856:()=>HMn,content_2321_6858:()=>$Mn,content_2321_686:()=>Az,content_2321_6860:()=>KMn,content_2321_6862:()=>tDn,content_2321_6864:()=>eDn,content_2321_6866:()=>pDn,content_2321_6868:()=>sDn,content_2321_6870:()=>iDn,content_2321_6872:()=>lDn,content_2321_6874:()=>mDn,content_2321_6876:()=>hDn,content_2321_6878:()=>yDn,content_2321_688:()=>Rz,content_2321_6880:()=>MDn,content_2321_6882:()=>wDn,content_2321_6884:()=>XDn,content_2321_6886:()=>TDn,content_2321_6888:()=>CDn,content_2321_6890:()=>LDn,content_2321_6892:()=>bDn,content_2321_6894:()=>zDn,content_2321_6896:()=>WDn,content_2321_6898:()=>IDn,content_2321_690:()=>Sz,content_2321_6900:()=>PDn,content_2321_6902:()=>BDn,content_2321_6904:()=>ODn,content_2321_6906:()=>FDn,content_2321_6908:()=>VDn,content_2321_6910:()=>HDn,content_2321_6912:()=>$Dn,content_2321_6914:()=>KDn,content_2321_6916:()=>twn,content_2321_6918:()=>ewn,content_2321_692:()=>Ez,content_2321_6920:()=>pwn,content_2321_6922:()=>swn,content_2321_6924:()=>iwn,content_2321_6926:()=>lwn,content_2321_6928:()=>mwn,content_2321_6930:()=>hwn,content_2321_6932:()=>ywn,content_2321_6934:()=>Mwn,content_2321_6936:()=>wwn,content_2321_6938:()=>Xwn,content_2321_694:()=>Gz,content_2321_6940:()=>Twn,content_2321_6942:()=>Cwn,content_2321_6944:()=>Lwn,content_2321_6946:()=>bwn,content_2321_6948:()=>zwn,content_2321_6950:()=>Wwn,content_2321_6952:()=>Iwn,content_2321_6954:()=>Pwn,content_2321_6956:()=>Bwn,content_2321_6958:()=>Own,content_2321_696:()=>Uz,content_2321_6960:()=>Fwn,content_2321_6962:()=>Vwn,content_2321_6964:()=>Hwn,content_2321_6966:()=>$wn,content_2321_6968:()=>Kwn,content_2321_6970:()=>t_n,content_2321_6972:()=>e_n,content_2321_6974:()=>p_n,content_2321_6976:()=>s_n,content_2321_6978:()=>i_n,content_2321_698:()=>qz,content_2321_6980:()=>l_n,content_2321_6982:()=>m_n,content_2321_6984:()=>h_n,content_2321_6986:()=>y_n,content_2321_6988:()=>M_n,content_2321_6990:()=>w_n,content_2321_6992:()=>X_n,content_2321_6994:()=>T_n,content_2321_6996:()=>C_n,content_2321_6998:()=>L_n,content_2321_70:()=>u_,content_2321_700:()=>jz,content_2321_7000:()=>b_n,content_2321_7002:()=>z_n,content_2321_7004:()=>W_n,content_2321_7006:()=>I_n,content_2321_7008:()=>P_n,content_2321_7010:()=>B_n,content_2321_7012:()=>O_n,content_2321_7014:()=>F_n,content_2321_7016:()=>V_n,content_2321_7018:()=>H_n,content_2321_702:()=>Qz,content_2321_7020:()=>$_n,content_2321_7022:()=>K_n,content_2321_7024:()=>tXn,content_2321_7026:()=>eXn,content_2321_7028:()=>pXn,content_2321_7030:()=>sXn,content_2321_7032:()=>iXn,content_2321_7034:()=>lXn,content_2321_7036:()=>mXn,content_2321_7038:()=>hXn,content_2321_704:()=>Yz,content_2321_7040:()=>yXn,content_2321_7042:()=>MXn,content_2321_7044:()=>wXn,content_2321_7046:()=>XXn,content_2321_7048:()=>TXn,content_2321_7050:()=>CXn,content_2321_7052:()=>LXn,content_2321_7054:()=>bXn,content_2321_7056:()=>zXn,content_2321_7058:()=>WXn,content_2321_706:()=>Jz,content_2321_7060:()=>IXn,content_2321_7062:()=>PXn,content_2321_7064:()=>BXn,content_2321_7066:()=>OXn,content_2321_7068:()=>FXn,content_2321_7070:()=>VXn,content_2321_7072:()=>HXn,content_2321_7074:()=>$Xn,content_2321_7076:()=>KXn,content_2321_7078:()=>tgn,content_2321_708:()=>nA,content_2321_7080:()=>egn,content_2321_7082:()=>pgn,content_2321_7084:()=>sgn,content_2321_7086:()=>ign,content_2321_7088:()=>lgn,content_2321_7090:()=>mgn,content_2321_7092:()=>hgn,content_2321_7094:()=>ygn,content_2321_7096:()=>Mgn,content_2321_7098:()=>wgn,content_2321_710:()=>oA,content_2321_7100:()=>Xgn,content_2321_7102:()=>Tgn,content_2321_712:()=>rA,content_2321_714:()=>cA,content_2321_716:()=>aA,content_2321_718:()=>uA,content_2321_72:()=>d_,content_2321_720:()=>dA,content_2321_722:()=>kA,content_2321_724:()=>fA,content_2321_726:()=>DA,content_2321_728:()=>_A,content_2321_730:()=>gA,content_2321_732:()=>xA,content_2321_734:()=>vA,content_2321_736:()=>ZA,content_2321_738:()=>NA,content_2321_74:()=>k_,content_2321_740:()=>AA,content_2321_742:()=>RA,content_2321_744:()=>SA,content_2321_746:()=>EA,content_2321_748:()=>GA,content_2321_750:()=>UA,content_2321_752:()=>qA,content_2321_754:()=>jA,content_2321_756:()=>QA,content_2321_758:()=>YA,content_2321_76:()=>f_,content_2321_760:()=>JA,content_2321_762:()=>nW,content_2321_764:()=>oW,content_2321_766:()=>rW,content_2321_768:()=>cW,content_2321_770:()=>aW,content_2321_772:()=>uW,content_2321_774:()=>dW,content_2321_776:()=>kW,content_2321_778:()=>fW,content_2321_78:()=>D_,content_2321_780:()=>DW,content_2321_782:()=>_W,content_2321_784:()=>gW,content_2321_786:()=>xW,content_2321_788:()=>vW,content_2321_790:()=>ZW,content_2321_792:()=>NW,content_2321_794:()=>AW,content_2321_796:()=>RW,content_2321_798:()=>SW,content_2321_8:()=>ow,content_2321_80:()=>__,content_2321_800:()=>EW,content_2321_802:()=>GW,content_2321_804:()=>UW,content_2321_806:()=>qW,content_2321_808:()=>jW,content_2321_810:()=>QW,content_2321_812:()=>YW,content_2321_814:()=>JW,content_2321_816:()=>nR,content_2321_818:()=>oR,content_2321_82:()=>g_,content_2321_820:()=>rR,content_2321_822:()=>cR,content_2321_824:()=>aR,content_2321_826:()=>uR,content_2321_828:()=>dR,content_2321_830:()=>kR,content_2321_832:()=>fR,content_2321_834:()=>DR,content_2321_836:()=>_R,content_2321_838:()=>gR,content_2321_84:()=>x_,content_2321_840:()=>xR,content_2321_842:()=>vR,content_2321_844:()=>ZR,content_2321_846:()=>NR,content_2321_848:()=>AR,content_2321_850:()=>RR,content_2321_852:()=>SR,content_2321_854:()=>ER,content_2321_856:()=>GR,content_2321_858:()=>UR,content_2321_86:()=>v_,content_2321_860:()=>qR,content_2321_862:()=>jR,content_2321_864:()=>QR,content_2321_866:()=>YR,content_2321_868:()=>JR,content_2321_870:()=>nI,content_2321_872:()=>oI,content_2321_874:()=>rI,content_2321_876:()=>cI,content_2321_878:()=>aI,content_2321_88:()=>Z_,content_2321_880:()=>uI,content_2321_882:()=>dI,content_2321_884:()=>kI,content_2321_886:()=>fI,content_2321_888:()=>DI,content_2321_890:()=>_I,content_2321_892:()=>gI,content_2321_894:()=>xI,content_2321_896:()=>vI,content_2321_898:()=>ZI,content_2321_90:()=>N_,content_2321_900:()=>NI,content_2321_902:()=>AI,content_2321_904:()=>RI,content_2321_906:()=>SI,content_2321_908:()=>EI,content_2321_910:()=>GI,content_2321_912:()=>UI,content_2321_914:()=>qI,content_2321_916:()=>jI,content_2321_918:()=>QI,content_2321_92:()=>A_,content_2321_920:()=>YI,content_2321_922:()=>JI,content_2321_924:()=>nS,content_2321_926:()=>oS,content_2321_928:()=>rS,content_2321_930:()=>cS,content_2321_932:()=>aS,content_2321_934:()=>uS,content_2321_936:()=>dS,content_2321_938:()=>kS,content_2321_94:()=>R_,content_2321_940:()=>fS,content_2321_942:()=>DS,content_2321_944:()=>_S,content_2321_946:()=>gS,content_2321_948:()=>xS,content_2321_950:()=>vS,content_2321_952:()=>ZS,content_2321_954:()=>NS,content_2321_956:()=>AS,content_2321_958:()=>RS,content_2321_96:()=>S_,content_2321_960:()=>SS,content_2321_962:()=>ES,content_2321_964:()=>GS,content_2321_966:()=>US,content_2321_968:()=>qS,content_2321_970:()=>jS,content_2321_972:()=>QS,content_2321_974:()=>YS,content_2321_976:()=>JS,content_2321_978:()=>nP,content_2321_98:()=>E_,content_2321_980:()=>oP,content_2321_982:()=>rP,content_2321_984:()=>cP,content_2321_986:()=>aP,content_2321_988:()=>uP,content_2321_990:()=>dP,content_2321_992:()=>kP,content_2321_994:()=>fP,content_2321_996:()=>DP,content_2321_998:()=>_P});var p=e(2784),r=e(7896),s=e(30876);const c={toc:[]};function i(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Property decorators."))}i.isMDXComponent=!0;const a={toc:[]};function l(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,s.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a lazy decorator."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the value of this property."))}h.isMDXComponent=!0;const k={toc:[]};function y(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscriptions and triggering of events."))}y.isMDXComponent=!0;const f={toc:[]};function M(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,s.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}M.isMDXComponent=!0;const D={toc:[]};function w(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}w.isMDXComponent=!0;const _={toc:[]};function X(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches an asynchronous ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}X.isMDXComponent=!0;const g={toc:[]};function T(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}T.isMDXComponent=!0;const x={toc:[]};function C(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}C.isMDXComponent=!0;const v={toc:[]};function L(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}L.isMDXComponent=!0;const Z={toc:[]};function b(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}b.isMDXComponent=!0;const N={toc:[]};function z(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}z.isMDXComponent=!0;const A={toc:[]};function W(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}W.isMDXComponent=!0;const R={toc:[]};function I(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}I.isMDXComponent=!0;const S={toc:[]};function P(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}P.isMDXComponent=!0;const E={toc:[]};function B(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}B.isMDXComponent=!0;const G={toc:[]};function O(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}O.isMDXComponent=!0;const U={toc:[]};function F(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}F.isMDXComponent=!0;const q={toc:[]};function V(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}V.isMDXComponent=!0;const j={toc:[]};function H(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}H.isMDXComponent=!0;const Q={toc:[]};function $(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}$.isMDXComponent=!0;const Y={toc:[]};function K(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}K.isMDXComponent=!0;const J={toc:[]};function tt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value argument to subscribers."))}tt.isMDXComponent=!0;const nt={toc:[]};function et(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A base for dispatching ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,s.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}et.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}pt.isMDXComponent=!0;const rt={toc:[]};function st(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}st.isMDXComponent=!0;const ct={toc:[]};function it(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}it.isMDXComponent=!0;const at={toc:[]};function lt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},at,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}ht.isMDXComponent=!0;const kt={toc:[]};function yt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}yt.isMDXComponent=!0;const ft={toc:[]};function Mt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}Mt.isMDXComponent=!0;const Dt={toc:[]};function wt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,s.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,s.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}wt.isMDXComponent=!0;const _t={toc:[]};function Xt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}Xt.isMDXComponent=!0;const gt={toc:[]};function Tt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}Tt.isMDXComponent=!0;const xt={toc:[]};function Ct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Ct.isMDXComponent=!0;const vt={toc:[]};function Lt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Are subscribers being notified?"))}Lt.isMDXComponent=!0;const Zt={toc:[]};function bt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Notify all current and future subscribers."))}bt.isMDXComponent=!0;const Nt={toc:[]};function zt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Stop notifying future subscribers."))}zt.isMDXComponent=!0;const At={toc:[]};function Wt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},At,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Wt.isMDXComponent=!0;const Rt={toc:[]};function It(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}It.isMDXComponent=!0;const St={toc:[]};function Pt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},St,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Pt.isMDXComponent=!0;const Et={toc:[]};function Bt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Et,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Bt.isMDXComponent=!0;const Gt={toc:[]};function Ot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Ot.isMDXComponent=!0;const Ut={toc:[]};function Ft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Ft.isMDXComponent=!0;const qt={toc:[]};function Vt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Vt.isMDXComponent=!0;const jt={toc:[]};function Ht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Ht.isMDXComponent=!0;const Qt={toc:[]};function $t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}$t.isMDXComponent=!0;const Yt={toc:[]};function Kt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Kt.isMDXComponent=!0;const Jt={toc:[]};function tn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}tn.isMDXComponent=!0;const nn={toc:[]};function en(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}en.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},on,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}pn.isMDXComponent=!0;const rn={toc:[]};function sn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}sn.isMDXComponent=!0;const cn={toc:[]};function an(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}dn.isMDXComponent=!0;const hn={toc:[]};function kn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}kn.isMDXComponent=!0;const yn={toc:[]};function fn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}fn.isMDXComponent=!0;const Mn={toc:[]};function Dn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Dn.isMDXComponent=!0;const wn={toc:[]};function _n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}_n.isMDXComponent=!0;const Xn={toc:[]};function gn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}gn.isMDXComponent=!0;const Tn={toc:[]};function xn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}xn.isMDXComponent=!0;const Cn={toc:[]};function vn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}vn.isMDXComponent=!0;const Ln={toc:[]};function Zn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Zn.isMDXComponent=!0;const bn={toc:[]};function Nn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Nn.isMDXComponent=!0;const zn={toc:[]};function An(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}An.isMDXComponent=!0;const Wn={toc:[]};function Rn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Rn.isMDXComponent=!0;const In={toc:[]};function Sn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},In,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Sn.isMDXComponent=!0;const Pn={toc:[]};function En(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value."))}En.isMDXComponent=!0;const Bn={toc:[]};function Gn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}Gn.isMDXComponent=!0;const On={toc:[]};function Un(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},On,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Setting the value will immediately notify all subscribers."))}Un.isMDXComponent=!0;const Fn={toc:[]};function qn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value of this dispatcher."))}qn.isMDXComponent=!0;const Vn={toc:[]};function jn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}jn.isMDXComponent=!0;const Hn={toc:[]};function Qn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Qn.isMDXComponent=!0;const $n={toc:[]};function Yn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}Yn.isMDXComponent=!0;const Kn={toc:[]};function Jn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Jn.isMDXComponent=!0;const te={toc:[]};function ne(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},te,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}ne.isMDXComponent=!0;const ee={toc:[]};function oe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}oe.isMDXComponent=!0;const pe={toc:[]};function re(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}re.isMDXComponent=!0;const se={toc:[]};function ce(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},se,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}ce.isMDXComponent=!0;const ie={toc:[]};function ae(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}ae.isMDXComponent=!0;const le={toc:[]};function ue(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},le,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ue.isMDXComponent=!0;const me={toc:[]};function de(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},me,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}de.isMDXComponent=!0;const he={toc:[]};function ke(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},he,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}ke.isMDXComponent=!0;const ye={toc:[]};function fe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}fe.isMDXComponent=!0;const Me={toc:[]};function De(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Me,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}De.isMDXComponent=!0;const we={toc:[]};function _e(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},we,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}_e.isMDXComponent=!0;const Xe={toc:[]};function ge(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ge.isMDXComponent=!0;const Te={toc:[]};function xe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Te,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}xe.isMDXComponent=!0;const Ce={toc:[]};function ve(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}ve.isMDXComponent=!0;const Le={toc:[]};function Ze(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Le,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of times the timer has ticked."))}Ze.isMDXComponent=!0;const be={toc:[]};function Ne(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},be,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator responsible for running this timer."))}Ne.isMDXComponent=!0;const ze={toc:[]};function Ae(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the timer ticks."))}Ae.isMDXComponent=!0;const We={toc:[]};function Re(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},We,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current iteration index."))}Re.isMDXComponent=!0;const Ie={toc:[]};function Se(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Se.isMDXComponent=!0;const Pe={toc:[]};function Ee(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Ee.isMDXComponent=!0;const Be={toc:[]};function Ge(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Be,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Ge.isMDXComponent=!0;const Oe={toc:[]};function Ue(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Ue.isMDXComponent=!0;const Fe={toc:[]};function qe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}qe.isMDXComponent=!0;const Ve={toc:[]};function je(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}je.isMDXComponent=!0;const He={toc:[]};function Qe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},He,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}Qe.isMDXComponent=!0;const $e={toc:[]};function Ye(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run tasks one after another."))}Ye.isMDXComponent=!0;const Ke={toc:[]};function Je(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Je.isMDXComponent=!0;const to={toc:[]};function no(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},to,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}no.isMDXComponent=!0;const eo={toc:[]};function oo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}oo.isMDXComponent=!0;const po={toc:[]};function ro(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},po,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay in seconds"))}ro.isMDXComponent=!0;const so={toc:[]};function co(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},so,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task or callback to run after the delay."))}co.isMDXComponent=!0;const io={toc:[]};function ao(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},io,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}ao.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Call the given callback every N seconds."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interval between subsequent calls."))}ho.isMDXComponent=!0;const ko={toc:[]};function yo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to be called."))}yo.isMDXComponent=!0;const fo={toc:[]};function Mo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each iteration waits until the previous one is completed."))}Mo.isMDXComponent=!0;const Do={toc:[]};function wo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Do,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}wo.isMDXComponent=!0;const _o={toc:[]};function Xo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator N times."))}Xo.isMDXComponent=!0;const go={toc:[]};function To(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},go,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of iterations."))}To.isMDXComponent=!0;const xo={toc:[]};function Co(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Co.isMDXComponent=!0;const vo={toc:[]};function Lo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Lo.isMDXComponent=!0;const Zo={toc:[]};function bo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}bo.isMDXComponent=!0;const No={toc:[]};function zo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},No,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop for the given amount of time."))}zo.isMDXComponent=!0;const Ao={toc:[]};function Wo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration in seconds."))}Wo.isMDXComponent=!0;const Ro={toc:[]};function Io(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Io.isMDXComponent=!0;const So={toc:[]};function Po(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},So,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Po.isMDXComponent=!0;const Eo={toc:[]};function Bo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Bo.isMDXComponent=!0;const Go={toc:[]};function Oo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Go,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop until the given time event."))}Oo.isMDXComponent=!0;const Uo={toc:[]};function Fo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The event."))}Fo.isMDXComponent=!0;const qo={toc:[]};function Vo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Vo.isMDXComponent=!0;const jo={toc:[]};function Ho(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Do nothing."))}Ho.isMDXComponent=!0;const Qo={toc:[]};function $o(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}$o.isMDXComponent=!0;const Yo={toc:[]};function Ko(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Ko.isMDXComponent=!0;const Jo={toc:[]};function tp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}tp.isMDXComponent=!0;const np={toc:[]};function ep(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},np,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}ep.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},op,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}pp.isMDXComponent=!0;const rp={toc:[]};function sp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional name used when displaying this generator in the UI."))}sp.isMDXComponent=!0;const cp={toc:[]};function ip(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}ip.isMDXComponent=!0;const ap={toc:[]};function lp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},up,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Start all tasks one after another with a constant delay between."))}hp.isMDXComponent=!0;const kp={toc:[]};function yp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay between each of the tasks."))}yp.isMDXComponent=!0;const fp={toc:[]};function Mp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to be run in a sequence."))}Mp.isMDXComponent=!0;const Dp={toc:[]};function wp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}wp.isMDXComponent=!0;const _p={toc:[]};function Xp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the given amount of time."))}Xp.isMDXComponent=!0;const gp={toc:[]};function Tp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The relative time in seconds."))}Tp.isMDXComponent=!0;const xp={toc:[]};function Cp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}Cp.isMDXComponent=!0;const vp={toc:[]};function Lp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}Lp.isMDXComponent=!0;const Zp={toc:[]};function bp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}bp.isMDXComponent=!0;const Np={toc:[]};function zp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Np,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the given time event."))}zp.isMDXComponent=!0;const Ap={toc:[]};function Wp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the time event."))}Wp.isMDXComponent=!0;const Rp={toc:[]};function Ip(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}Ip.isMDXComponent=!0;const Sp={toc:[]};function Pp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multi-media management."))}Pp.isMDXComponent=!0;const Ep={toc:[]};function Bp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Bp.isMDXComponent=!0;const Gp={toc:[]};function Op(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause/resume the audio."))}Op.isMDXComponent=!0;const Up={toc:[]};function Fp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Up,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the audio should be paused or resumed."))}Fp.isMDXComponent=!0;const qp={toc:[]};function Vp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The absolute biggest value from the peaks array."))}Vp.isMDXComponent=!0;const jp={toc:[]};function Hp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of samples taken."))}Hp.isMDXComponent=!0;const Qp={toc:[]};function $p(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}$p.isMDXComponent=!0;const Yp={toc:[]};function Kp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Samples per seconds."))}Kp.isMDXComponent=!0;const Jp={toc:[]};function tr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abstract scene representations and related utilities."))}tr.isMDXComponent=!0;const nr={toc:[]};function er(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Signifies the various stages of a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}er.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},or,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs after a render ends."))}pr.isMDXComponent=!0;const rr={toc:[]};function sr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}sr.isMDXComponent=!0;const cr={toc:[]};function ir(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,s.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}ir.isMDXComponent=!0;const ar={toc:[]};function lr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ar,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,s.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ur,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes the state of a scene."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}hr.isMDXComponent=!0;const kr={toc:[]};function yr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished transitioning in."))}yr.isMDXComponent=!0;const fr={toc:[]};function Mr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}Mr.isMDXComponent=!0;const Dr={toc:[]};function wr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene is ready to transition out."))}wr.isMDXComponent=!0;const _r={toc:[]};function Xr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_r,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoking ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}Xr.isMDXComponent=!0;const gr={toc:[]};function Tr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished."))}Tr.isMDXComponent=!0;const xr={toc:[]};function Cr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has just been created/reset."))}Cr.isMDXComponent=!0;const vr={toc:[]};function Lr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The default implementation of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,s.kt)("p",null,"Uses generators to control the animation."))}Lr.isMDXComponent=!0;const Zr={toc:[]};function br(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}br.isMDXComponent=!0;const Nr={toc:[]};function zr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}zr.isMDXComponent=!0;const Ar={toc:[]};function Wr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ar,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}Wr.isMDXComponent=!0;const Rr={toc:[]};function Ir(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Ir.isMDXComponent=!0;const Sr={toc:[]};function Pr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Pr.isMDXComponent=!0;const Er={toc:[]};function Br(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Er,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}Br.isMDXComponent=!0;const Gr={toc:[]};function Or(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}Or.isMDXComponent=!0;const Ur={toc:[]};function Fr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ur,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}Fr.isMDXComponent=!0;const qr={toc:[]};function Vr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}Vr.isMDXComponent=!0;const jr={toc:[]};function Hr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}Hr.isMDXComponent=!0;const Qr={toc:[]};function $r(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}$r.isMDXComponent=!0;const Yr={toc:[]};function Kr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}Kr.isMDXComponent=!0;const Jr={toc:[]};function ts(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}ts.isMDXComponent=!0;const ns={toc:[]};function es(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ns,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}es.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},os,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}ps.isMDXComponent=!0;const rs={toc:[]};function ss(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}ss.isMDXComponent=!0;const cs={toc:[]};function is(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}is.isMDXComponent=!0;const as={toc:[]};function ls(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},as,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},us,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ds,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}hs.isMDXComponent=!0;const ks={toc:[]};function ys(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ks,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}ys.isMDXComponent=!0;const fs={toc:[]};function Ms(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}Ms.isMDXComponent=!0;const Ds={toc:[]};function ws(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ds,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}ws.isMDXComponent=!0;const _s={toc:[]};function Xs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_s,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Xs.isMDXComponent=!0;const gs={toc:[]};function Ts(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}Ts.isMDXComponent=!0;const xs={toc:[]};function Cs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}Cs.isMDXComponent=!0;const vs={toc:[]};function Ls(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Ls.isMDXComponent=!0;const Zs={toc:[]};function bs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}bs.isMDXComponent=!0;const Ns={toc:[]};function zs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ns,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}zs.isMDXComponent=!0;const As={toc:[]};function Ws(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},As,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}Ws.isMDXComponent=!0;const Rs={toc:[]};function Is(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}Is.isMDXComponent=!0;const Ss={toc:[]};function Ps(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ss,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}Ps.isMDXComponent=!0;const Es={toc:[]};function Bs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Es,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}Bs.isMDXComponent=!0;const Gs={toc:[]};function Os(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}Os.isMDXComponent=!0;const Us={toc:[]};function Fs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Us,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}Fs.isMDXComponent=!0;const qs={toc:[]};function Vs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}Vs.isMDXComponent=!0;const js={toc:[]};function Hs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},js,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Lifecycle events for ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Hs.isMDXComponent=!0;const Qs={toc:[]};function $s(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A random number generator based on\n",(0,s.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,s.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}$s.isMDXComponent=!0;const Ys={toc:[]};function Ks(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ys,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random floats in the given range."))}Ks.isMDXComponent=!0;const Js={toc:[]};function tc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Js,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."))}tc.isMDXComponent=!0;const nc={toc:[]};function ec(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}ec.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}pc.isMDXComponent=!0;const rc={toc:[]};function sc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random integers in the given range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"}),(0,s.kt)("li",{parentName:"ul"})))}sc.isMDXComponent=!0;const cc={toc:[]};function ic(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}ic.isMDXComponent=!0;const ac={toc:[]};function lc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ac,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random float in the given range."))}hc.isMDXComponent=!0;const kc={toc:[]};function yc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}yc.isMDXComponent=!0;const fc={toc:[]};function Mc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}Mc.isMDXComponent=!0;const Dc={toc:[]};function wc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random integer in the given range."))}wc.isMDXComponent=!0;const _c={toc:[]};function Xc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_c,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}Xc.isMDXComponent=!0;const gc={toc:[]};function Tc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}Tc.isMDXComponent=!0;const xc={toc:[]};function Cc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a new independent generator."))}Cc.isMDXComponent=!0;const vc={toc:[]};function Lc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}Lc.isMDXComponent=!0;const Zc={toc:[]};function bc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the variable."))}bc.isMDXComponent=!0;const Nc={toc:[]};function zc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}zc.isMDXComponent=!0;const Ac={toc:[]};function Wc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ac,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}Wc.isMDXComponent=!0;const Rc={toc:[]};function Ic(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset all stored signals."))}Ic.isMDXComponent=!0;const Sc={toc:[]};function Pc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update all signals with new project variable values."))}Pc.isMDXComponent=!0;const Ec={toc:[]};function Bc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ec,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes cached information about the timing of a scene."))}Bc.isMDXComponent=!0;const Gc={toc:[]};function Oc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a complete scene together with the meta file."))}Oc.isMDXComponent=!0;const Uc={toc:[]};function Fc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}Fc.isMDXComponent=!0;const qc={toc:[]};function Vc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}Vc.isMDXComponent=!0;const jc={toc:[]};function Hc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}Hc.isMDXComponent=!0;const Qc={toc:[]};function $c(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}$c.isMDXComponent=!0;const Yc={toc:[]};function Kc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Kc.isMDXComponent=!0;const Jc={toc:[]};function ti(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}ti.isMDXComponent=!0;const ni={toc:[]};function ei(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ni,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for the inspected element."))}ei.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element for which to draw an overlay."))}pi.isMDXComponent=!0;const ri={toc:[]};function si(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ri,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}si.isMDXComponent=!0;const ci={toc:[]};function ii(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ci,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ii.isMDXComponent=!0;const ai={toc:[]};function li(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ai,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ui,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the attributes of the inspected element."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},di,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to inspect."))}hi.isMDXComponent=!0;const ki={toc:[]};function yi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ki,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a possible element to inspect at a given position."))}yi.isMDXComponent=!0;const fi={toc:[]};function Mi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}Mi.isMDXComponent=!0;const Di={toc:[]};function wi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Di,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}wi.isMDXComponent=!0;const _i={toc:[]};function Xi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_i,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}Xi.isMDXComponent=!0;const gi={toc:[]};function Ti(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the inspected element is still valid."))}Ti.isMDXComponent=!0;const xi={toc:[]};function Ci(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to validate."))}Ci.isMDXComponent=!0;const vi={toc:[]};function Li(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}Li.isMDXComponent=!0;const Zi={toc:[]};function bi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for scenes."))}bi.isMDXComponent=!0;const Ni={toc:[]};function zi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ni,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}zi.isMDXComponent=!0;const Ai={toc:[]};function Wi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ai,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}Wi.isMDXComponent=!0;const Ri={toc:[]};function Ii(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ri,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}Ii.isMDXComponent=!0;const Si={toc:[]};function Pi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Si,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Pi.isMDXComponent=!0;const Ei={toc:[]};function Bi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ei,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Bi.isMDXComponent=!0;const Gi={toc:[]};function Oi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}Oi.isMDXComponent=!0;const Ui={toc:[]};function Fi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ui,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}Fi.isMDXComponent=!0;const qi={toc:[]};function Vi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Vi.isMDXComponent=!0;const ji={toc:[]};function Hi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ji,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}Hi.isMDXComponent=!0;const Qi={toc:[]};function $i(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}$i.isMDXComponent=!0;const Yi={toc:[]};function Ki(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}Ki.isMDXComponent=!0;const Ji={toc:[]};function ta(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ji,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}ta.isMDXComponent=!0;const na={toc:[]};function ea(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},na,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}ea.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}pa.isMDXComponent=!0;const ra={toc:[]};function sa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ra,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}sa.isMDXComponent=!0;const ca={toc:[]};function ia(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ca,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}ia.isMDXComponent=!0;const aa={toc:[]};function la(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ua,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},da,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}ha.isMDXComponent=!0;const ka={toc:[]};function ya(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ka,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}ya.isMDXComponent=!0;const fa={toc:[]};function Ma(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Ma.isMDXComponent=!0;const Da={toc:[]};function wa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Da,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}wa.isMDXComponent=!0;const _a={toc:[]};function Xa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_a,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}Xa.isMDXComponent=!0;const ga={toc:[]};function Ta(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ga,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Ta.isMDXComponent=!0;const xa={toc:[]};function Ca(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}Ca.isMDXComponent=!0;const va={toc:[]};function La(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},va,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}La.isMDXComponent=!0;const Za={toc:[]};function ba(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Za,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}ba.isMDXComponent=!0;const Na={toc:[]};function za(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Na,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}za.isMDXComponent=!0;const Aa={toc:[]};function Wa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}Wa.isMDXComponent=!0;const Ra={toc:[]};function Ia(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ra,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}Ia.isMDXComponent=!0;const Sa={toc:[]};function Pa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}Pa.isMDXComponent=!0;const Ea={toc:[]};function Ba(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ea,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}Ba.isMDXComponent=!0;const Ga={toc:[]};function Oa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ga,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}Oa.isMDXComponent=!0;const Ua={toc:[]};function Fa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ua,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each class implementing the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}Fa.isMDXComponent=!0;const qa={toc:[]};function Va(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constructor used when creating new scenes."))}Va.isMDXComponent=!0;const ja={toc:[]};function Ha(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ja,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,s.kt)("inlineCode",{parentName:"a"},"config")),"."))}Ha.isMDXComponent=!0;const Qa={toc:[]};function $a(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a scene exposed by scene files."))}$a.isMDXComponent=!0;const Ya={toc:[]};function Ka(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ya,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}Ka.isMDXComponent=!0;const Ja={toc:[]};function tl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ja,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}tl.isMDXComponent=!0;const nl={toc:[]};function el(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}el.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ol,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}pl.isMDXComponent=!0;const rl={toc:[]};function sl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A part of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}sl.isMDXComponent=!0;const cl={toc:[]};function il(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}il.isMDXComponent=!0;const al={toc:[]};function ll(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},al,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ul,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}hl.isMDXComponent=!0;const kl={toc:[]};function yl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents attributes of an inspected element."))}yl.isMDXComponent=!0;const fl={toc:[]};function Ml(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}Ml.isMDXComponent=!0;const Dl={toc:[]};function wl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an element to inspect."))}wl.isMDXComponent=!0;const _l={toc:[]};function Xl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_l,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the scene metadata."))}Xl.isMDXComponent=!0;const gl={toc:[]};function Tl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the scene metadata."))}Tl.isMDXComponent=!0;const xl={toc:[]};function Cl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}Cl.isMDXComponent=!0;const vl={toc:[]};function Ll(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}Ll.isMDXComponent=!0;const Zl={toc:[]};function bl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}bl.isMDXComponent=!0;const Nl={toc:[]};function zl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}zl.isMDXComponent=!0;const Al={toc:[]};function Wl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Al,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Wl.isMDXComponent=!0;const Rl={toc:[]};function Il(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}Il.isMDXComponent=!0;const Sl={toc:[]};function Pl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Pl.isMDXComponent=!0;const El={toc:[]};function Bl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},El,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Bl.isMDXComponent=!0;const Gl={toc:[]};function Ol(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Ol.isMDXComponent=!0;const Ul={toc:[]};function Fl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ul,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Fl.isMDXComponent=!0;const ql={toc:[]};function Vl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ql,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Vl.isMDXComponent=!0;const jl={toc:[]};function Hl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}Hl.isMDXComponent=!0;const Ql={toc:[]};function $l(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ql,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}$l.isMDXComponent=!0;const Yl={toc:[]};function Kl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}Kl.isMDXComponent=!0;const Jl={toc:[]};function tu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}tu.isMDXComponent=!0;const nu={toc:[]};function eu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}eu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ou,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}pu.isMDXComponent=!0;const ru={toc:[]};function su(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ru,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}su.isMDXComponent=!0;const cu={toc:[]};function iu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}iu.isMDXComponent=!0;const au={toc:[]};function lu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},au,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},du,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}hu.isMDXComponent=!0;const ku={toc:[]};function yu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ku,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}yu.isMDXComponent=!0;const fu={toc:[]};function Mu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Mu.isMDXComponent=!0;const Du={toc:[]};function wu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Du,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}wu.isMDXComponent=!0;const _u={toc:[]};function Xu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_u,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween back to the original value."))}Xu.isMDXComponent=!0;const gu={toc:[]};function Tu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}Tu.isMDXComponent=!0;const xu={toc:[]};function Cu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function of the tween."))}Cu.isMDXComponent=!0;const vu={toc:[]};function Lu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function of the tween."))}Lu.isMDXComponent=!0;const Zu={toc:[]};function bu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback."))}bu.isMDXComponent=!0;const Nu={toc:[]};function zu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}zu.isMDXComponent=!0;const Au={toc:[]};function Wu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Au,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given task."))}Wu.isMDXComponent=!0;const Ru={toc:[]};function Iu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ru,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator to run."))}Iu.isMDXComponent=!0;const Su={toc:[]};function Pu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Su,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween to the specified value."))}Pu.isMDXComponent=!0;const Eu={toc:[]};function Bu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the specified duration."))}Bu.isMDXComponent=!0;const Gu={toc:[]};function Ou(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration to wait."))}Ou.isMDXComponent=!0;const Uu={toc:[]};function Fu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread management."))}Fu.isMDXComponent=!0;const qu={toc:[]};function Vu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,s.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}Vu.isMDXComponent=!0;const ju={toc:[]};function Hu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ju,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A class representing an individual thread."))}Hu.isMDXComponent=!0;const Qu={toc:[]};function $u(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}$u.isMDXComponent=!0;const Yu={toc:[]};function Ku(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}Ku.isMDXComponent=!0;const Ju={toc:[]};function tm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ju,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}tm.isMDXComponent=!0;const nm={toc:[]};function em(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current time of this thread."))}em.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},om,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The next value to be passed to the wrapped generator."))}pm.isMDXComponent=!0;const rm={toc:[]};function sm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}sm.isMDXComponent=!0;const cm={toc:[]};function im(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,s.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}im.isMDXComponent=!0;const am={toc:[]};function lm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},am,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The fixed time of this thread."))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},um,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress the wrapped generator once."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the thread for the next update cycle."))}hm.isMDXComponent=!0;const km={toc:[]};function ym(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},km,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delta time of the next cycle."))}ym.isMDXComponent=!0;const fm={toc:[]};function Mm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a normal function that returns a generator."))}Mm.isMDXComponent=!0;const Dm={toc:[]};function wm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,s.kt)("p",null,"Progress to the next frame:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,s.kt)("p",null,"Run another generator synchronously:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,s.kt)("p",null,"Run another generator concurrently:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,s.kt)("p",null,"Await a Promise:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}wm.isMDXComponent=!0;const _m={toc:[]};function Xm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_m,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}Xm.isMDXComponent=!0;const gm={toc:[]};function Tm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Cancel all listed tasks."),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Tm.isMDXComponent=!0;const xm={toc:[]};function Cm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to cancel."))}Cm.isMDXComponent=!0;const vm={toc:[]};function Lm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}Lm.isMDXComponent=!0;const Zm={toc:[]};function bm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}bm.isMDXComponent=!0;const Nm={toc:[]};function zm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}zm.isMDXComponent=!0;const Am={toc:[]};function Wm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Am,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible thread ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Wm.isMDXComponent=!0;const Rm={toc:[]};function Im(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}Im.isMDXComponent=!0;const Sm={toc:[]};function Pm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}Pm.isMDXComponent=!0;const Em={toc:[]};function Bm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Em,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Bm.isMDXComponent=!0;const Gm={toc:[]};function Om(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}Om.isMDXComponent=!0;const Um={toc:[]};function Fm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Um,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until listed tasks are finished."))}Fm.isMDXComponent=!0;const qm={toc:[]};function Vm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}Vm.isMDXComponent=!0;const jm={toc:[]};function Hm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Hm.isMDXComponent=!0;const Qm={toc:[]};function $m(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"From the perspective of the external generator, ",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}$m.isMDXComponent=!0;const Ym={toc:[]};function Km(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ym,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}Km.isMDXComponent=!0;const Jm={toc:[]};function td(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a context in which generators can be run concurrently."))}td.isMDXComponent=!0;const nd={toc:[]};function ed(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the generator to run."))}ed.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},od,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}pd.isMDXComponent=!0;const rd={toc:[]};function sd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transitions between scenes."))}sd.isMDXComponent=!0;const cd={toc:[]};function id(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that fades between the scenes."))}id.isMDXComponent=!0;const ad={toc:[]};function ld(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ad,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ud,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The direction in which to slide."))}hd.isMDXComponent=!0;const kd={toc:[]};function yd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}yd.isMDXComponent=!0;const fd={toc:[]};function Md(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}Md.isMDXComponent=!0;const Dd={toc:[]};function wd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the current scene is rendered."))}wd.isMDXComponent=!0;const _d={toc:[]};function Xd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_d,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the previous scene is rendered."))}Xd.isMDXComponent=!0;const gd={toc:[]};function Td(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}Td.isMDXComponent=!0;const xd={toc:[]};function Cd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area on which to zoom in."))}Cd.isMDXComponent=!0;const vd={toc:[]};function Ld(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Ld.isMDXComponent=!0;const Zd={toc:[]};function bd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}bd.isMDXComponent=!0;const Nd={toc:[]};function zd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area from which to zoom out."))}zd.isMDXComponent=!0;const Ad={toc:[]};function Wd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ad,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Wd.isMDXComponent=!0;const Rd={toc:[]};function Id(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolation and timing of tweens."))}Id.isMDXComponent=!0;const Sd={toc:[]};function Pd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any old key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"})))}Pd.isMDXComponent=!0;const Ed={toc:[]};function Bd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ed,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}Bd.isMDXComponent=!0;const Gd={toc:[]};function Od(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}Od.isMDXComponent=!0;const Ud={toc:[]};function Fd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ud,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}Fd.isMDXComponent=!0;const qd={toc:[]};function Vd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}Vd.isMDXComponent=!0;const jd={toc:[]};function Hd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}Hd.isMDXComponent=!0;const Qd={toc:[]};function $d(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}$d.isMDXComponent=!0;const Yd={toc:[]};function Kd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}Kd.isMDXComponent=!0;const Jd={toc:[]};function th(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}th.isMDXComponent=!0;const nh={toc:[]};function eh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}eh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}ph.isMDXComponent=!0;const rh={toc:[]};function sh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Complex types used in animations."))}sh.isMDXComponent=!0;const ch={toc:[]};function ih(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ch,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,s.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,s.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,s.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,s.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}ih.isMDXComponent=!0;const ah={toc:[]};function lh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ah,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the determinant of the matrix."))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}hh.isMDXComponent=!0;const kh={toc:[]};function yh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the inverse of the matrix."))}yh.isMDXComponent=!0;const fh={toc:[]};function Mh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Mh.isMDXComponent=!0;const Dh={toc:[]};function wh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}wh.isMDXComponent=!0;const _h={toc:[]};function Xh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_h,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the provided matrix to this matrix."))}Xh.isMDXComponent=!0;const gh={toc:[]};function Th(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to add"))}Th.isMDXComponent=!0;const xh={toc:[]};function Ch(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}Ch.isMDXComponent=!0;const vh={toc:[]};function Lh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}Lh.isMDXComponent=!0;const Zh={toc:[]};function bh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the component vector to retrieve."))}bh.isMDXComponent=!0;const Nh={toc:[]};function zh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}zh.isMDXComponent=!0;const Ah={toc:[]};function Wh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ah,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}Wh.isMDXComponent=!0;const Rh={toc:[]};function Ih(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}Ih.isMDXComponent=!0;const Sh={toc:[]};function Ph(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to multiply with"))}Ph.isMDXComponent=!0;const Eh={toc:[]};function Bh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}Bh.isMDXComponent=!0;const Gh={toc:[]};function Oh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}Oh.isMDXComponent=!0;const Uh={toc:[]};function Fh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to scale each term"))}Fh.isMDXComponent=!0;const qh={toc:[]};function Vh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Vh.isMDXComponent=!0;const jh={toc:[]};function Hh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}Hh.isMDXComponent=!0;const Qh={toc:[]};function $h(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}$h.isMDXComponent=!0;const Yh={toc:[]};function Kh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate the matrix."))}Kh.isMDXComponent=!0;const Jh={toc:[]};function tk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the angle is provided in degrees."))}tk.isMDXComponent=!0;const nk={toc:[]};function ek(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}ek.isMDXComponent=!0;const ok={toc:[]};function pk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ok,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}pk.isMDXComponent=!0;const rk={toc:[]};function sk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the row to retrieve."))}sk.isMDXComponent=!0;const ck={toc:[]};function ik(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ck,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}ik.isMDXComponent=!0;const ak={toc:[]};function lk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ak,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}lk.isMDXComponent=!0;const uk={toc:[]};function mk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scale the x and y component vectors of the matrix."))}mk.isMDXComponent=!0;const dk={toc:[]};function hk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The factor by which to scale the matrix"))}hk.isMDXComponent=!0;const kk={toc:[]};function yk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}yk.isMDXComponent=!0;const fk={toc:[]};function Mk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}Mk.isMDXComponent=!0;const Dk={toc:[]};function wk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subtract the provided matrix from this matrix."))}wk.isMDXComponent=!0;const _k={toc:[]};function Xk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_k,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to subract"))}Xk.isMDXComponent=!0;const gk={toc:[]};function Tk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Tk.isMDXComponent=!0;const xk={toc:[]};function Ck(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}Ck.isMDXComponent=!0;const vk={toc:[]};function Lk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}Lk.isMDXComponent=!0;const Zk={toc:[]};function bk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector by which to translate the matrix"))}bk.isMDXComponent=!0;const Nk={toc:[]};function zk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector."))}zk.isMDXComponent=!0;const Ak={toc:[]};function Wk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ak,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}Wk.isMDXComponent=!0;const Rk={toc:[]};function Ik(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}Ik.isMDXComponent=!0;const Sk={toc:[]};function Pk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}Pk.isMDXComponent=!0;const Ek={toc:[]};function Bk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ek,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,s.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}Bk.isMDXComponent=!0;const Gk={toc:[]};function Ok(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are equal to each other."))}Ok.isMDXComponent=!0;const Uk={toc:[]};function Fk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}Fk.isMDXComponent=!0;const qk={toc:[]};function Vk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The allowed error threshold when comparing the vectors."))}Vk.isMDXComponent=!0;const jk={toc:[]};function Hk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,s.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}Hk.isMDXComponent=!0;const Qk={toc:[]};function $k(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are exactly equal to each other."))}$k.isMDXComponent=!0;const Yk={toc:[]};function Kk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}Kk.isMDXComponent=!0;const Jk={toc:[]};function ty(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}ty.isMDXComponent=!0;const ny={toc:[]};function ey(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ny,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}ey.isMDXComponent=!0;const oy={toc:[]};function py(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}py.isMDXComponent=!0;const ry={toc:[]};function sy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ry,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}sy.isMDXComponent=!0;const cy={toc:[]};function iy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}iy.isMDXComponent=!0;const ay={toc:[]};function ly(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ay,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}ly.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}hy.isMDXComponent=!0;const ky={toc:[]};function yy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ky,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The unclipped RGB components."))}yy.isMDXComponent=!0;const fy={toc:[]};function My(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}My.isMDXComponent=!0;const Dy={toc:[]};function wy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}wy.isMDXComponent=!0;const _y={toc:[]};function Xy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_y,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Xy.isMDXComponent=!0;const gy={toc:[]};function Ty(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}Ty.isMDXComponent=!0;const xy={toc:[]};function Cy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}Cy.isMDXComponent=!0;const vy={toc:[]};function Ly(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}Ly.isMDXComponent=!0;const Zy={toc:[]};function by(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}by.isMDXComponent=!0;const Ny={toc:[]};function zy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ny,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Alias of ",(0,s.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}zy.isMDXComponent=!0;const Ay={toc:[]};function Wy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ay,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}Wy.isMDXComponent=!0;const Ry={toc:[]};function Iy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ry,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns an array with the ",(0,s.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}Iy.isMDXComponent=!0;const Sy={toc:[]};function Py(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}Py.isMDXComponent=!0;const Ey={toc:[]};function By(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ey,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns an array with the ",(0,s.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,s.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,s.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}By.isMDXComponent=!0;const Gy={toc:[]};function Oy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}Oy.isMDXComponent=!0;const Uy={toc:[]};function Fy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns an array with the ",(0,s.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,s.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,s.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}Fy.isMDXComponent=!0;const qy={toc:[]};function Vy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}Vy.isMDXComponent=!0;const jy={toc:[]};function Hy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns an array with the ",(0,s.kt)("strong",{parentName:"p"},"L"),", ",(0,s.kt)("strong",{parentName:"p"},"a"),", and ",(0,s.kt)("strong",{parentName:"p"},"b")," components."))}Hy.isMDXComponent=!0;const Qy={toc:[]};function $y(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}$y.isMDXComponent=!0;const Yy={toc:[]};function Ky(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns an array with the ",(0,s.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,s.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,s.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}Ky.isMDXComponent=!0;const Jy={toc:[]};function tf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}tf.isMDXComponent=!0;const nf={toc:[]};function ef(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}ef.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},of,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}pf.isMDXComponent=!0;const rf={toc:[]};function sf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}sf.isMDXComponent=!0;const cf={toc:[]};function af(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get and set the color opacity."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,s.kt)("code",null,"'rgb'")))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Similar to saturate, but the opposite direction."))}df.isMDXComponent=!0;const hf={toc:[]};function kf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"set"))}kf.isMDXComponent=!0;const yf={toc:[]};function ff(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns a single channel value.\nAlso"))}ff.isMDXComponent=!0;const Mf={toc:[]};function Df(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}Df.isMDXComponent=!0;const wf={toc:[]};function _f(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color as hexadecimal string."))}_f.isMDXComponent=!0;const Xf={toc:[]};function gf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,s.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,s.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}gf.isMDXComponent=!0;const Tf={toc:[]};function xf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,s.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}xf.isMDXComponent=!0;const Cf={toc:[]};function vf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}vf.isMDXComponent=!0;const Lf={toc:[]};function Zf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}Zf.isMDXComponent=!0;const bf={toc:[]};function Nf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}Nf.isMDXComponent=!0;const zf={toc:[]};function Af(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}Af.isMDXComponent=!0;const Wf={toc:[]};function Rf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}Rf.isMDXComponent=!0;const If={toc:[]};function Sf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},If,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}Sf.isMDXComponent=!0;const Pf={toc:[]};function Ef(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}Ef.isMDXComponent=!0;const Bf={toc:[]};function Gf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}Gf.isMDXComponent=!0;const Of={toc:[]};function Uf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Of,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}Uf.isMDXComponent=!0;const Ff={toc:[]};function qf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ff,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}qf.isMDXComponent=!0;const Vf={toc:[]};function jf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given origin to a vector representing its offset."))}jf.isMDXComponent=!0;const Hf={toc:[]};function Qf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin to convert."))}Qf.isMDXComponent=!0;const $f={toc:[]};function Yf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$f,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"General utilities and helper functions."))}Yf.isMDXComponent=!0;const Kf={toc:[]};function Jf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}Jf.isMDXComponent=!0;const tM={toc:[]};function nM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Optional override for formatting stack traces"))}nM.isMDXComponent=!0;const eM={toc:[]};function oM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create .stack property on a target object"))}oM.isMDXComponent=!0;const pM={toc:[]};function rM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}rM.isMDXComponent=!0;const sM={toc:[]};function cM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting degrees to radians"))}cM.isMDXComponent=!0;const iM={toc:[]};function aM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}aM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting radians to degrees"))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is a shortcut for calling ",(0,s.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}dM.isMDXComponent=!0;const hM={toc:[]};function kM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}kM.isMDXComponent=!0;const yM={toc:[]};function fM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Logs a debug message with an arbitrary payload."))}fM.isMDXComponent=!0;const MM={toc:[]};function DM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The payload to log"))}DM.isMDXComponent=!0;const wM={toc:[]};function _M(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the given function as deprecated."))}_M.isMDXComponent=!0;const XM={toc:[]};function gM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to deprecate."))}gM.isMDXComponent=!0;const TM={toc:[]};function xM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The log message."))}xM.isMDXComponent=!0;const CM={toc:[]};function vM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The optional log remarks."))}vM.isMDXComponent=!0;const LM={toc:[]};function ZM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}ZM.isMDXComponent=!0;const bM={toc:[]};function NM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the current scene as ready to transition out."))}NM.isMDXComponent=!0;const zM={toc:[]};function AM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}AM.isMDXComponent=!0;const WM={toc:[]};function RM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,s.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}RM.isMDXComponent=!0;const IM={toc:[]};function SM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}SM.isMDXComponent=!0;const PM={toc:[]};function EM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}EM.isMDXComponent=!0;const BM={toc:[]};function GM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The length of the array."))}GM.isMDXComponent=!0;const OM={toc:[]};function UM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}UM.isMDXComponent=!0;const FM={toc:[]};function qM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}qM.isMDXComponent=!0;const VM={toc:[]};function jM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}jM.isMDXComponent=!0;const HM={toc:[]};function QM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}QM.isMDXComponent=!0;const $M={toc:[]};function YM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$M,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}YM.isMDXComponent=!0;const KM={toc:[]};function JM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}JM.isMDXComponent=!0;const tD={toc:[]};function nD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}nD.isMDXComponent=!0;const eD={toc:[]};function oD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}oD.isMDXComponent=!0;const pD={toc:[]};function rD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to increment or decrement."))}rD.isMDXComponent=!0;const sD={toc:[]};function cD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}cD.isMDXComponent=!0;const iD={toc:[]};function aD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context before render."))}aD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context after render."))}dD.isMDXComponent=!0;const hD={toc:[]};function kD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}kD.isMDXComponent=!0;const yD={toc:[]};function fD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}fD.isMDXComponent=!0;const MD={toc:[]};function DD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the event in seconds."))}DD.isMDXComponent=!0;const wD={toc:[]};function _D(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Register a time event and get its duration in seconds."))}_D.isMDXComponent=!0;const XD={toc:[]};function gD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the event."))}gD.isMDXComponent=!0;const TD={toc:[]};function xD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the playback status."))}xD.isMDXComponent=!0;const CD={toc:[]};function vD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the current scene."))}vD.isMDXComponent=!0;const LD={toc:[]};function ZD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the given seed."))}ZD.isMDXComponent=!0;const bD={toc:[]};function ND(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seed for the generator."))}ND.isMDXComponent=!0;const zD={toc:[]};function AD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}AD.isMDXComponent=!0;const WD={toc:[]};function RD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current scene."))}RD.isMDXComponent=!0;const ID={toc:[]};function SD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ID,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current thread."))}SD.isMDXComponent=!0;const PD={toc:[]};function ED(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}ED.isMDXComponent=!0;const BD={toc:[]};function GD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}GD.isMDXComponent=!0;const OD={toc:[]};function UD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real time since the start of the animation."))}UD.isMDXComponent=!0;const FD={toc:[]};function qD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This rewrites a remote url like ",(0,s.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,s.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}qD.isMDXComponent=!0;const VD={toc:[]};function jD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Route the given url through a local proxy."))}jD.isMDXComponent=!0;const HD={toc:[]};function QD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}QD.isMDXComponent=!0;const $D={toc:[]};function YD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$D,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n")))}YD.isMDXComponent=!0;const KD={toc:[]};function JD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing circular shapes."))}JD.isMDXComponent=!0;const tw={toc:[]};function nw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}nw.isMDXComponent=!0;const ew={toc:[]};function ow(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ew,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}ow.isMDXComponent=!0;const pw={toc:[]};function rw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}rw.isMDXComponent=!0;const sw={toc:[]};function cw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}cw.isMDXComponent=!0;const iw={toc:[]};function aw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}aw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}dw.isMDXComponent=!0;const hw={toc:[]};function kw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}kw.isMDXComponent=!0;const yw={toc:[]};function fw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}fw.isMDXComponent=!0;const Mw={toc:[]};function Dw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Dw.isMDXComponent=!0;const ww={toc:[]};function _w(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ww,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}_w.isMDXComponent=!0;const Xw={toc:[]};function gw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}gw.isMDXComponent=!0;const Tw={toc:[]};function xw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}xw.isMDXComponent=!0;const Cw={toc:[]};function vw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A closed circle will look like a pie chart:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,s.kt)("p",null,"An open one will look like an arc:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}vw.isMDXComponent=!0;const Lw={toc:[]};function Zw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"false"))}Zw.isMDXComponent=!0;const bw={toc:[]};function Nw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}Nw.isMDXComponent=!0;const zw={toc:[]};function Aw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Aw.isMDXComponent=!0;const Ww={toc:[]};function Rw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ww,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"360"))}Rw.isMDXComponent=!0;const Iw={toc:[]};function Sw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}Sw.isMDXComponent=!0;const Pw={toc:[]};function Ew(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Ew.isMDXComponent=!0;const Bw={toc:[]};function Gw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Gw.isMDXComponent=!0;const Ow={toc:[]};function Uw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ow,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Uw.isMDXComponent=!0;const Fw={toc:[]};function qw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}qw.isMDXComponent=!0;const Vw={toc:[]};function jw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}jw.isMDXComponent=!0;const Hw={toc:[]};function Qw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Qw.isMDXComponent=!0;const $w={toc:[]};function Yw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$w,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Yw.isMDXComponent=!0;const Kw={toc:[]};function Jw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Jw.isMDXComponent=!0;const t_={toc:[]};function n_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}n_.isMDXComponent=!0;const e_={toc:[]};function o_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}o_.isMDXComponent=!0;const p_={toc:[]};function r_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}r_.isMDXComponent=!0;const s_={toc:[]};function c_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}c_.isMDXComponent=!0;const i_={toc:[]};function a_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}a_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}d_.isMDXComponent=!0;const h_={toc:[]};function k_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}k_.isMDXComponent=!0;const y_={toc:[]};function f_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}f_.isMDXComponent=!0;const M_={toc:[]};function D_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}D_.isMDXComponent=!0;const w_={toc:[]};function __(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}__.isMDXComponent=!0;const X_={toc:[]};function g_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}g_.isMDXComponent=!0;const T_={toc:[]};function x_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}x_.isMDXComponent=!0;const C_={toc:[]};function v_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}v_.isMDXComponent=!0;const L_={toc:[]};function Z_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Z_.isMDXComponent=!0;const b_={toc:[]};function N_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}N_.isMDXComponent=!0;const z_={toc:[]};function A_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}A_.isMDXComponent=!0;const W_={toc:[]};function R_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}R_.isMDXComponent=!0;const I_={toc:[]};function S_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}S_.isMDXComponent=!0;const P_={toc:[]};function E_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}E_.isMDXComponent=!0;const B_={toc:[]};function G_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}G_.isMDXComponent=!0;const O_={toc:[]};function U_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}U_.isMDXComponent=!0;const F_={toc:[]};function q_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}q_.isMDXComponent=!0;const V_={toc:[]};function j_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}j_.isMDXComponent=!0;const H_={toc:[]};function Q_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Q_.isMDXComponent=!0;const $_={toc:[]};function Y_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Y_.isMDXComponent=!0;const K_={toc:[]};function J_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}J_.isMDXComponent=!0;const tX={toc:[]};function nX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}nX.isMDXComponent=!0;const eX={toc:[]};function oX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}oX.isMDXComponent=!0;const pX={toc:[]};function rX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}rX.isMDXComponent=!0;const sX={toc:[]};function cX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}cX.isMDXComponent=!0;const iX={toc:[]};function aX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}aX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}dX.isMDXComponent=!0;const hX={toc:[]};function kX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kX.isMDXComponent=!0;const yX={toc:[]};function fX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}fX.isMDXComponent=!0;const MX={toc:[]};function DX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}DX.isMDXComponent=!0;const wX={toc:[]};function _X(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}_X.isMDXComponent=!0;const XX={toc:[]};function gX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}gX.isMDXComponent=!0;const TX={toc:[]};function xX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}xX.isMDXComponent=!0;const CX={toc:[]};function vX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}vX.isMDXComponent=!0;const LX={toc:[]};function ZX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}ZX.isMDXComponent=!0;const bX={toc:[]};function NX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}NX.isMDXComponent=!0;const zX={toc:[]};function AX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}AX.isMDXComponent=!0;const WX={toc:[]};function RX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}RX.isMDXComponent=!0;const IX={toc:[]};function SX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}SX.isMDXComponent=!0;const PX={toc:[]};function EX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}EX.isMDXComponent=!0;const BX={toc:[]};function GX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}GX.isMDXComponent=!0;const OX={toc:[]};function UX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}UX.isMDXComponent=!0;const FX={toc:[]};function qX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}qX.isMDXComponent=!0;const VX={toc:[]};function jX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}jX.isMDXComponent=!0;const HX={toc:[]};function QX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}QX.isMDXComponent=!0;const $X={toc:[]};function YX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$X,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}YX.isMDXComponent=!0;const KX={toc:[]};function JX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}JX.isMDXComponent=!0;const tg={toc:[]};function ng(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}ng.isMDXComponent=!0;const eg={toc:[]};function og(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}og.isMDXComponent=!0;const pg={toc:[]};function rg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}rg.isMDXComponent=!0;const sg={toc:[]};function cg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}cg.isMDXComponent=!0;const ig={toc:[]};function ag(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ig,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}ag.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dg.isMDXComponent=!0;const hg={toc:[]};function kg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}kg.isMDXComponent=!0;const yg={toc:[]};function fg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}fg.isMDXComponent=!0;const Mg={toc:[]};function Dg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Dg.isMDXComponent=!0;const wg={toc:[]};function _g(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}_g.isMDXComponent=!0;const Xg={toc:[]};function gg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}gg.isMDXComponent=!0;const Tg={toc:[]};function xg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}xg.isMDXComponent=!0;const Cg={toc:[]};function vg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}vg.isMDXComponent=!0;const Lg={toc:[]};function Zg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Zg.isMDXComponent=!0;const bg={toc:[]};function Ng(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Ng.isMDXComponent=!0;const zg={toc:[]};function Ag(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Ag.isMDXComponent=!0;const Wg={toc:[]};function Rg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Rg.isMDXComponent=!0;const Ig={toc:[]};function Sg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ig,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Sg.isMDXComponent=!0;const Pg={toc:[]};function Eg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Eg.isMDXComponent=!0;const Bg={toc:[]};function Gg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Gg.isMDXComponent=!0;const Og={toc:[]};function Ug(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Og,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Ug.isMDXComponent=!0;const Fg={toc:[]};function qg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}qg.isMDXComponent=!0;const Vg={toc:[]};function jg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}jg.isMDXComponent=!0;const Hg={toc:[]};function Qg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Qg.isMDXComponent=!0;const $g={toc:[]};function Yg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$g,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Yg.isMDXComponent=!0;const Kg={toc:[]};function Jg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Jg.isMDXComponent=!0;const tT={toc:[]};function nT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}nT.isMDXComponent=!0;const eT={toc:[]};function oT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}oT.isMDXComponent=!0;const pT={toc:[]};function rT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}rT.isMDXComponent=!0;const sT={toc:[]};function cT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}cT.isMDXComponent=!0;const iT={toc:[]};function aT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}aT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}dT.isMDXComponent=!0;const hT={toc:[]};function kT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}kT.isMDXComponent=!0;const yT={toc:[]};function fT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}fT.isMDXComponent=!0;const MT={toc:[]};function DT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}DT.isMDXComponent=!0;const wT={toc:[]};function _T(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_T.isMDXComponent=!0;const XT={toc:[]};function gT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}gT.isMDXComponent=!0;const TT={toc:[]};function xT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}xT.isMDXComponent=!0;const CT={toc:[]};function vT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}vT.isMDXComponent=!0;const LT={toc:[]};function ZT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}ZT.isMDXComponent=!0;const bT={toc:[]};function NT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}NT.isMDXComponent=!0;const zT={toc:[]};function AT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}AT.isMDXComponent=!0;const WT={toc:[]};function RT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}RT.isMDXComponent=!0;const IT={toc:[]};function ST(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}ST.isMDXComponent=!0;const PT={toc:[]};function ET(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}ET.isMDXComponent=!0;const BT={toc:[]};function GT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}GT.isMDXComponent=!0;const OT={toc:[]};function UT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}UT.isMDXComponent=!0;const FT={toc:[]};function qT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}qT.isMDXComponent=!0;const VT={toc:[]};function jT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}jT.isMDXComponent=!0;const HT={toc:[]};function QT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}QT.isMDXComponent=!0;const $T={toc:[]};function YT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$T,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}YT.isMDXComponent=!0;const KT={toc:[]};function JT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}JT.isMDXComponent=!0;const tx={toc:[]};function nx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}nx.isMDXComponent=!0;const ex={toc:[]};function ox(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ex,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ox.isMDXComponent=!0;const px={toc:[]};function rx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},px,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}rx.isMDXComponent=!0;const sx={toc:[]};function cx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}cx.isMDXComponent=!0;const ix={toc:[]};function ax(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ix,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}ax.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}dx.isMDXComponent=!0;const hx={toc:[]};function kx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}kx.isMDXComponent=!0;const yx={toc:[]};function fx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}fx.isMDXComponent=!0;const Mx={toc:[]};function Dx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Dx.isMDXComponent=!0;const wx={toc:[]};function _x(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}_x.isMDXComponent=!0;const Xx={toc:[]};function gx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}gx.isMDXComponent=!0;const Tx={toc:[]};function xx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defining a cubic B\xe9zier curve using ",(0,s.kt)("inlineCode",{parentName:"p"},"points")," property."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  <CubicBezier\n    lineWidth={4}\n    stroke={'lightseagreen'}\n    p0={[-200, -200]}\n    p1={[100, -200]}\n    p2={[-100, 200]}\n    p3={[200, 200]}\n    end={0}\n  />\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}xx.isMDXComponent=!0;const Cx={toc:[]};function vx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a cubic B\xe9zier curve."))}vx.isMDXComponent=!0;const Lx={toc:[]};function Zx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Zx.isMDXComponent=!0;const bx={toc:[]};function Nx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Nx.isMDXComponent=!0;const zx={toc:[]};function Ax(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Ax.isMDXComponent=!0;const Wx={toc:[]};function Rx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Rx.isMDXComponent=!0;const Ix={toc:[]};function Sx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ix,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Sx.isMDXComponent=!0;const Px={toc:[]};function Ex(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Px,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Ex.isMDXComponent=!0;const Bx={toc:[]};function Gx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Gx.isMDXComponent=!0;const Ox={toc:[]};function Ux(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ox,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Ux.isMDXComponent=!0;const Fx={toc:[]};function qx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qx.isMDXComponent=!0;const Vx={toc:[]};function jx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}jx.isMDXComponent=!0;const Hx={toc:[]};function Qx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Qx.isMDXComponent=!0;const $x={toc:[]};function Yx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$x,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Yx.isMDXComponent=!0;const Kx={toc:[]};function Jx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Jx.isMDXComponent=!0;const tC={toc:[]};function nC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}nC.isMDXComponent=!0;const eC={toc:[]};function oC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}oC.isMDXComponent=!0;const pC={toc:[]};function rC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}rC.isMDXComponent=!0;const sC={toc:[]};function cC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}cC.isMDXComponent=!0;const iC={toc:[]};function aC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}aC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}dC.isMDXComponent=!0;const hC={toc:[]};function kC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}kC.isMDXComponent=!0;const yC={toc:[]};function fC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}fC.isMDXComponent=!0;const MC={toc:[]};function DC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}DC.isMDXComponent=!0;const wC={toc:[]};function _C(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}_C.isMDXComponent=!0;const XC={toc:[]};function gC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}gC.isMDXComponent=!0;const TC={toc:[]};function xC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}xC.isMDXComponent=!0;const CC={toc:[]};function vC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}vC.isMDXComponent=!0;const LC={toc:[]};function ZC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The first control point of the B\xe9zier curve."))}ZC.isMDXComponent=!0;const bC={toc:[]};function NC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The second control point of the B\xe9zier curve."))}NC.isMDXComponent=!0;const zC={toc:[]};function AC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}AC.isMDXComponent=!0;const WC={toc:[]};function RC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}RC.isMDXComponent=!0;const IC={toc:[]};function SC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}SC.isMDXComponent=!0;const PC={toc:[]};function EC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}EC.isMDXComponent=!0;const BC={toc:[]};function GC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}GC.isMDXComponent=!0;const OC={toc:[]};function UC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}UC.isMDXComponent=!0;const FC={toc:[]};function qC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}qC.isMDXComponent=!0;const VC={toc:[]};function jC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}jC.isMDXComponent=!0;const HC={toc:[]};function QC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}QC.isMDXComponent=!0;const $C={toc:[]};function YC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$C,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}YC.isMDXComponent=!0;const KC={toc:[]};function JC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}JC.isMDXComponent=!0;const tv={toc:[]};function nv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}nv.isMDXComponent=!0;const ev={toc:[]};function ov(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ev,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}ov.isMDXComponent=!0;const pv={toc:[]};function rv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}rv.isMDXComponent=!0;const sv={toc:[]};function cv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}cv.isMDXComponent=!0;const iv={toc:[]};function av(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}av.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}dv.isMDXComponent=!0;const hv={toc:[]};function kv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}kv.isMDXComponent=!0;const yv={toc:[]};function fv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}fv.isMDXComponent=!0;const Mv={toc:[]};function Dv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Dv.isMDXComponent=!0;const wv={toc:[]};function _v(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}_v.isMDXComponent=!0;const Xv={toc:[]};function gv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}gv.isMDXComponent=!0;const Tv={toc:[]};function xv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}xv.isMDXComponent=!0;const Cv={toc:[]};function vv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}vv.isMDXComponent=!0;const Lv={toc:[]};function Zv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Zv.isMDXComponent=!0;const bv={toc:[]};function Nv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Nv.isMDXComponent=!0;const zv={toc:[]};function Av(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Av.isMDXComponent=!0;const Wv={toc:[]};function Rv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Rv.isMDXComponent=!0;const Iv={toc:[]};function Sv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Sv.isMDXComponent=!0;const Pv={toc:[]};function Ev(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Ev.isMDXComponent=!0;const Bv={toc:[]};function Gv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Gv.isMDXComponent=!0;const Ov={toc:[]};function Uv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ov,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Uv.isMDXComponent=!0;const Fv={toc:[]};function qv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}qv.isMDXComponent=!0;const Vv={toc:[]};function jv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}jv.isMDXComponent=!0;const Hv={toc:[]};function Qv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Qv.isMDXComponent=!0;const $v={toc:[]};function Yv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$v,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Yv.isMDXComponent=!0;const Kv={toc:[]};function Jv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Jv.isMDXComponent=!0;const tL={toc:[]};function nL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}nL.isMDXComponent=!0;const eL={toc:[]};function oL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}oL.isMDXComponent=!0;const pL={toc:[]};function rL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}rL.isMDXComponent=!0;const sL={toc:[]};function cL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}cL.isMDXComponent=!0;const iL={toc:[]};function aL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}aL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}dL.isMDXComponent=!0;const hL={toc:[]};function kL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}kL.isMDXComponent=!0;const yL={toc:[]};function fL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}fL.isMDXComponent=!0;const ML={toc:[]};function DL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ML,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}DL.isMDXComponent=!0;const wL={toc:[]};function _L(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}_L.isMDXComponent=!0;const XL={toc:[]};function gL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}gL.isMDXComponent=!0;const TL={toc:[]};function xL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}xL.isMDXComponent=!0;const CL={toc:[]};function vL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}vL.isMDXComponent=!0;const LL={toc:[]};function ZL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}ZL.isMDXComponent=!0;const bL={toc:[]};function NL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}NL.isMDXComponent=!0;const zL={toc:[]};function AL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}AL.isMDXComponent=!0;const WL={toc:[]};function RL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}RL.isMDXComponent=!0;const IL={toc:[]};function SL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}SL.isMDXComponent=!0;const PL={toc:[]};function EL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}EL.isMDXComponent=!0;const BL={toc:[]};function GL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}GL.isMDXComponent=!0;const OL={toc:[]};function UL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}UL.isMDXComponent=!0;const FL={toc:[]};function qL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}qL.isMDXComponent=!0;const VL={toc:[]};function jL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}jL.isMDXComponent=!0;const HL={toc:[]};function QL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}QL.isMDXComponent=!0;const $L={toc:[]};function YL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$L,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}YL.isMDXComponent=!0;const KL={toc:[]};function JL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}JL.isMDXComponent=!0;const tZ={toc:[]};function nZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}nZ.isMDXComponent=!0;const eZ={toc:[]};function oZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}oZ.isMDXComponent=!0;const pZ={toc:[]};function rZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}rZ.isMDXComponent=!0;const sZ={toc:[]};function cZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}cZ.isMDXComponent=!0;const iZ={toc:[]};function aZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}aZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function kZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}kZ.isMDXComponent=!0;const yZ={toc:[]};function fZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}fZ.isMDXComponent=!0;const MZ={toc:[]};function DZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}DZ.isMDXComponent=!0;const wZ={toc:[]};function _Z(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}_Z.isMDXComponent=!0;const XZ={toc:[]};function gZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}gZ.isMDXComponent=!0;const TZ={toc:[]};function xZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}xZ.isMDXComponent=!0;const CZ={toc:[]};function vZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}vZ.isMDXComponent=!0;const LZ={toc:[]};function ZZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}ZZ.isMDXComponent=!0;const bZ={toc:[]};function NZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}NZ.isMDXComponent=!0;const zZ={toc:[]};function AZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}AZ.isMDXComponent=!0;const WZ={toc:[]};function RZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}RZ.isMDXComponent=!0;const IZ={toc:[]};function SZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}SZ.isMDXComponent=!0;const PZ={toc:[]};function EZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}EZ.isMDXComponent=!0;const BZ={toc:[]};function GZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}GZ.isMDXComponent=!0;const OZ={toc:[]};function UZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}UZ.isMDXComponent=!0;const FZ={toc:[]};function qZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}qZ.isMDXComponent=!0;const VZ={toc:[]};function jZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}jZ.isMDXComponent=!0;const HZ={toc:[]};function QZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}QZ.isMDXComponent=!0;const $Z={toc:[]};function YZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Z,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}YZ.isMDXComponent=!0;const KZ={toc:[]};function JZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}JZ.isMDXComponent=!0;const tb={toc:[]};function nb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}nb.isMDXComponent=!0;const eb={toc:[]};function ob(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}ob.isMDXComponent=!0;const pb={toc:[]};function rb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}rb.isMDXComponent=!0;const sb={toc:[]};function cb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cb.isMDXComponent=!0;const ib={toc:[]};function ab(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ib,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}ab.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}db.isMDXComponent=!0;const hb={toc:[]};function kb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}kb.isMDXComponent=!0;const yb={toc:[]};function fb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}fb.isMDXComponent=!0;const Mb={toc:[]};function Db(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Db.isMDXComponent=!0;const wb={toc:[]};function _b(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}_b.isMDXComponent=!0;const Xb={toc:[]};function gb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}gb.isMDXComponent=!0;const Tb={toc:[]};function xb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}xb.isMDXComponent=!0;const Cb={toc:[]};function vb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}vb.isMDXComponent=!0;const Lb={toc:[]};function Zb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}Zb.isMDXComponent=!0;const bb={toc:[]};function Nb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Nb.isMDXComponent=!0;const zb={toc:[]};function Ab(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Ab.isMDXComponent=!0;const Wb={toc:[]};function Rb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Rb.isMDXComponent=!0;const Ib={toc:[]};function Sb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ib,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Sb.isMDXComponent=!0;const Pb={toc:[]};function Eb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Eb.isMDXComponent=!0;const Bb={toc:[]};function Gb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Gb.isMDXComponent=!0;const Ob={toc:[]};function Ub(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ob,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Ub.isMDXComponent=!0;const Fb={toc:[]};function qb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qb.isMDXComponent=!0;const Vb={toc:[]};function jb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}jb.isMDXComponent=!0;const Hb={toc:[]};function Qb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Qb.isMDXComponent=!0;const $b={toc:[]};function Yb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$b,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Yb.isMDXComponent=!0;const Kb={toc:[]};function Jb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Jb.isMDXComponent=!0;const tN={toc:[]};function nN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}nN.isMDXComponent=!0;const eN={toc:[]};function oN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}oN.isMDXComponent=!0;const pN={toc:[]};function rN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}rN.isMDXComponent=!0;const sN={toc:[]};function cN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}cN.isMDXComponent=!0;const iN={toc:[]};function aN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}aN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}dN.isMDXComponent=!0;const hN={toc:[]};function kN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}kN.isMDXComponent=!0;const yN={toc:[]};function fN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}fN.isMDXComponent=!0;const MN={toc:[]};function DN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}DN.isMDXComponent=!0;const wN={toc:[]};function _N(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}_N.isMDXComponent=!0;const XN={toc:[]};function gN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}gN.isMDXComponent=!0;const TN={toc:[]};function xN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}xN.isMDXComponent=!0;const CN={toc:[]};function vN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}vN.isMDXComponent=!0;const LN={toc:[]};function ZN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}ZN.isMDXComponent=!0;const bN={toc:[]};function NN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}NN.isMDXComponent=!0;const zN={toc:[]};function AN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}AN.isMDXComponent=!0;const WN={toc:[]};function RN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}RN.isMDXComponent=!0;const IN={toc:[]};function SN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}SN.isMDXComponent=!0;const PN={toc:[]};function EN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}EN.isMDXComponent=!0;const BN={toc:[]};function GN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}GN.isMDXComponent=!0;const ON={toc:[]};function UN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ON,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}UN.isMDXComponent=!0;const FN={toc:[]};function qN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qN.isMDXComponent=!0;const VN={toc:[]};function jN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}jN.isMDXComponent=!0;const HN={toc:[]};function QN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}QN.isMDXComponent=!0;const $N={toc:[]};function YN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$N,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}YN.isMDXComponent=!0;const KN={toc:[]};function JN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}JN.isMDXComponent=!0;const tz={toc:[]};function nz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}nz.isMDXComponent=!0;const ez={toc:[]};function oz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ez,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}oz.isMDXComponent=!0;const pz={toc:[]};function rz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}rz.isMDXComponent=!0;const sz={toc:[]};function cz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}cz.isMDXComponent=!0;const iz={toc:[]};function az(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}az.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}dz.isMDXComponent=!0;const hz={toc:[]};function kz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}kz.isMDXComponent=!0;const yz={toc:[]};function fz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}fz.isMDXComponent=!0;const Mz={toc:[]};function Dz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Dz.isMDXComponent=!0;const wz={toc:[]};function _z(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}_z.isMDXComponent=!0;const Xz={toc:[]};function gz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}gz.isMDXComponent=!0;const Tz={toc:[]};function xz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}xz.isMDXComponent=!0;const Cz={toc:[]};function vz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}vz.isMDXComponent=!0;const Lz={toc:[]};function Zz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Zz.isMDXComponent=!0;const bz={toc:[]};function Nz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Nz.isMDXComponent=!0;const zz={toc:[]};function Az(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Az.isMDXComponent=!0;const Wz={toc:[]};function Rz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Rz.isMDXComponent=!0;const Iz={toc:[]};function Sz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Sz.isMDXComponent=!0;const Pz={toc:[]};function Ez(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Ez.isMDXComponent=!0;const Bz={toc:[]};function Gz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Gz.isMDXComponent=!0;const Oz={toc:[]};function Uz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Uz.isMDXComponent=!0;const Fz={toc:[]};function qz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}qz.isMDXComponent=!0;const Vz={toc:[]};function jz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}jz.isMDXComponent=!0;const Hz={toc:[]};function Qz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Qz.isMDXComponent=!0;const $z={toc:[]};function Yz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$z,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Yz.isMDXComponent=!0;const Kz={toc:[]};function Jz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Jz.isMDXComponent=!0;const tA={toc:[]};function nA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}nA.isMDXComponent=!0;const eA={toc:[]};function oA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}oA.isMDXComponent=!0;const pA={toc:[]};function rA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}rA.isMDXComponent=!0;const sA={toc:[]};function cA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}cA.isMDXComponent=!0;const iA={toc:[]};function aA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}aA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}dA.isMDXComponent=!0;const hA={toc:[]};function kA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}kA.isMDXComponent=!0;const yA={toc:[]};function fA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}fA.isMDXComponent=!0;const MA={toc:[]};function DA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}DA.isMDXComponent=!0;const wA={toc:[]};function _A(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}_A.isMDXComponent=!0;const XA={toc:[]};function gA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}gA.isMDXComponent=!0;const TA={toc:[]};function xA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}xA.isMDXComponent=!0;const CA={toc:[]};function vA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}vA.isMDXComponent=!0;const LA={toc:[]};function ZA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}ZA.isMDXComponent=!0;const bA={toc:[]};function NA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}NA.isMDXComponent=!0;const zA={toc:[]};function AA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}AA.isMDXComponent=!0;const WA={toc:[]};function RA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}RA.isMDXComponent=!0;const IA={toc:[]};function SA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}SA.isMDXComponent=!0;const PA={toc:[]};function EA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}EA.isMDXComponent=!0;const BA={toc:[]};function GA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}GA.isMDXComponent=!0;const OA={toc:[]};function UA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}UA.isMDXComponent=!0;const FA={toc:[]};function qA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}qA.isMDXComponent=!0;const VA={toc:[]};function jA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}jA.isMDXComponent=!0;const HA={toc:[]};function QA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}QA.isMDXComponent=!0;const $A={toc:[]};function YA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$A,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}YA.isMDXComponent=!0;const KA={toc:[]};function JA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}JA.isMDXComponent=!0;const tW={toc:[]};function nW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}nW.isMDXComponent=!0;const eW={toc:[]};function oW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}oW.isMDXComponent=!0;const pW={toc:[]};function rW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}rW.isMDXComponent=!0;const sW={toc:[]};function cW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}cW.isMDXComponent=!0;const iW={toc:[]};function aW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}aW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}dW.isMDXComponent=!0;const hW={toc:[]};function kW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kW.isMDXComponent=!0;const yW={toc:[]};function fW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}fW.isMDXComponent=!0;const MW={toc:[]};function DW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}DW.isMDXComponent=!0;const wW={toc:[]};function _W(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}_W.isMDXComponent=!0;const XW={toc:[]};function gW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}gW.isMDXComponent=!0;const TW={toc:[]};function xW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}xW.isMDXComponent=!0;const CW={toc:[]};function vW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}vW.isMDXComponent=!0;const LW={toc:[]};function ZW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}ZW.isMDXComponent=!0;const bW={toc:[]};function NW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}NW.isMDXComponent=!0;const zW={toc:[]};function AW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}AW.isMDXComponent=!0;const WW={toc:[]};function RW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}RW.isMDXComponent=!0;const IW={toc:[]};function SW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}SW.isMDXComponent=!0;const PW={toc:[]};function EW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}EW.isMDXComponent=!0;const BW={toc:[]};function GW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}GW.isMDXComponent=!0;const OW={toc:[]};function UW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}UW.isMDXComponent=!0;const FW={toc:[]};function qW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}qW.isMDXComponent=!0;const VW={toc:[]};function jW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}jW.isMDXComponent=!0;const HW={toc:[]};function QW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}QW.isMDXComponent=!0;const $W={toc:[]};function YW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$W,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}YW.isMDXComponent=!0;const KW={toc:[]};function JW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}JW.isMDXComponent=!0;const tR={toc:[]};function nR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}nR.isMDXComponent=!0;const eR={toc:[]};function oR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}oR.isMDXComponent=!0;const pR={toc:[]};function rR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}rR.isMDXComponent=!0;const sR={toc:[]};function cR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}cR.isMDXComponent=!0;const iR={toc:[]};function aR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}aR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}dR.isMDXComponent=!0;const hR={toc:[]};function kR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}kR.isMDXComponent=!0;const yR={toc:[]};function fR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}fR.isMDXComponent=!0;const MR={toc:[]};function DR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}DR.isMDXComponent=!0;const wR={toc:[]};function _R(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}_R.isMDXComponent=!0;const XR={toc:[]};function gR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}gR.isMDXComponent=!0;const TR={toc:[]};function xR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}xR.isMDXComponent=!0;const CR={toc:[]};function vR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}vR.isMDXComponent=!0;const LR={toc:[]};function ZR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}ZR.isMDXComponent=!0;const bR={toc:[]};function NR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}NR.isMDXComponent=!0;const zR={toc:[]};function AR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}AR.isMDXComponent=!0;const WR={toc:[]};function RR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}RR.isMDXComponent=!0;const IR={toc:[]};function SR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}SR.isMDXComponent=!0;const PR={toc:[]};function ER(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}ER.isMDXComponent=!0;const BR={toc:[]};function GR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}GR.isMDXComponent=!0;const OR={toc:[]};function UR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}UR.isMDXComponent=!0;const FR={toc:[]};function qR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}qR.isMDXComponent=!0;const VR={toc:[]};function jR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}jR.isMDXComponent=!0;const HR={toc:[]};function QR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}QR.isMDXComponent=!0;const $R={toc:[]};function YR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$R,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}YR.isMDXComponent=!0;const KR={toc:[]};function JR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}JR.isMDXComponent=!0;const tI={toc:[]};function nI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}nI.isMDXComponent=!0;const eI={toc:[]};function oI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}oI.isMDXComponent=!0;const pI={toc:[]};function rI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}rI.isMDXComponent=!0;const sI={toc:[]};function cI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}cI.isMDXComponent=!0;const iI={toc:[]};function aI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}aI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}dI.isMDXComponent=!0;const hI={toc:[]};function kI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}kI.isMDXComponent=!0;const yI={toc:[]};function fI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}fI.isMDXComponent=!0;const MI={toc:[]};function DI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}DI.isMDXComponent=!0;const wI={toc:[]};function _I(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}_I.isMDXComponent=!0;const XI={toc:[]};function gI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}gI.isMDXComponent=!0;const TI={toc:[]};function xI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}xI.isMDXComponent=!0;const CI={toc:[]};function vI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}vI.isMDXComponent=!0;const LI={toc:[]};function ZI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}ZI.isMDXComponent=!0;const bI={toc:[]};function NI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}NI.isMDXComponent=!0;const zI={toc:[]};function AI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}AI.isMDXComponent=!0;const WI={toc:[]};function RI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}RI.isMDXComponent=!0;const II={toc:[]};function SI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},II,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}SI.isMDXComponent=!0;const PI={toc:[]};function EI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}EI.isMDXComponent=!0;const BI={toc:[]};function GI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}GI.isMDXComponent=!0;const OI={toc:[]};function UI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}UI.isMDXComponent=!0;const FI={toc:[]};function qI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}qI.isMDXComponent=!0;const VI={toc:[]};function jI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}jI.isMDXComponent=!0;const HI={toc:[]};function QI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}QI.isMDXComponent=!0;const $I={toc:[]};function YI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$I,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}YI.isMDXComponent=!0;const KI={toc:[]};function JI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}JI.isMDXComponent=!0;const tS={toc:[]};function nS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}nS.isMDXComponent=!0;const eS={toc:[]};function oS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}oS.isMDXComponent=!0;const pS={toc:[]};function rS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}rS.isMDXComponent=!0;const sS={toc:[]};function cS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}cS.isMDXComponent=!0;const iS={toc:[]};function aS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}aS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}dS.isMDXComponent=!0;const hS={toc:[]};function kS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}kS.isMDXComponent=!0;const yS={toc:[]};function fS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}fS.isMDXComponent=!0;const MS={toc:[]};function DS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}DS.isMDXComponent=!0;const wS={toc:[]};function _S(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}_S.isMDXComponent=!0;const XS={toc:[]};function gS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}gS.isMDXComponent=!0;const TS={toc:[]};function xS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}xS.isMDXComponent=!0;const CS={toc:[]};function vS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}vS.isMDXComponent=!0;const LS={toc:[]};function ZS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}ZS.isMDXComponent=!0;const bS={toc:[]};function NS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}NS.isMDXComponent=!0;const zS={toc:[]};function AS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}AS.isMDXComponent=!0;const WS={toc:[]};function RS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}RS.isMDXComponent=!0;const IS={toc:[]};function SS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}SS.isMDXComponent=!0;const PS={toc:[]};function ES(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}ES.isMDXComponent=!0;const BS={toc:[]};function GS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}GS.isMDXComponent=!0;const OS={toc:[]};function US(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}US.isMDXComponent=!0;const FS={toc:[]};function qS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}qS.isMDXComponent=!0;const VS={toc:[]};function jS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}jS.isMDXComponent=!0;const HS={toc:[]};function QS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}QS.isMDXComponent=!0;const $S={toc:[]};function YS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$S,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}YS.isMDXComponent=!0;const KS={toc:[]};function JS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}JS.isMDXComponent=!0;const tP={toc:[]};function nP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}nP.isMDXComponent=!0;const eP={toc:[]};function oP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}oP.isMDXComponent=!0;const pP={toc:[]};function rP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}rP.isMDXComponent=!0;const sP={toc:[]};function cP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}cP.isMDXComponent=!0;const iP={toc:[]};function aP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}aP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}dP.isMDXComponent=!0;const hP={toc:[]};function kP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}kP.isMDXComponent=!0;const yP={toc:[]};function fP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}fP.isMDXComponent=!0;const MP={toc:[]};function DP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}DP.isMDXComponent=!0;const wP={toc:[]};function _P(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}_P.isMDXComponent=!0;const XP={toc:[]};function gP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}gP.isMDXComponent=!0;const TP={toc:[]};function xP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}xP.isMDXComponent=!0;const CP={toc:[]};function vP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}vP.isMDXComponent=!0;const LP={toc:[]};function ZP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}ZP.isMDXComponent=!0;const bP={toc:[]};function NP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}NP.isMDXComponent=!0;const zP={toc:[]};function AP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}AP.isMDXComponent=!0;const WP={toc:[]};function RP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}RP.isMDXComponent=!0;const IP={toc:[]};function SP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}SP.isMDXComponent=!0;const PP={toc:[]};function EP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}EP.isMDXComponent=!0;const BP={toc:[]};function GP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}GP.isMDXComponent=!0;const OP={toc:[]};function UP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}UP.isMDXComponent=!0;const FP={toc:[]};function qP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}qP.isMDXComponent=!0;const VP={toc:[]};function jP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}jP.isMDXComponent=!0;const HP={toc:[]};function QP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}QP.isMDXComponent=!0;const $P={toc:[]};function YP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$P,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}YP.isMDXComponent=!0;const KP={toc:[]};function JP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}JP.isMDXComponent=!0;const tE={toc:[]};function nE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}nE.isMDXComponent=!0;const eE={toc:[]};function oE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}oE.isMDXComponent=!0;const pE={toc:[]};function rE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}rE.isMDXComponent=!0;const sE={toc:[]};function cE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}cE.isMDXComponent=!0;const iE={toc:[]};function aE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}aE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}dE.isMDXComponent=!0;const hE={toc:[]};function kE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}kE.isMDXComponent=!0;const yE={toc:[]};function fE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}fE.isMDXComponent=!0;const ME={toc:[]};function DE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ME,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}DE.isMDXComponent=!0;const wE={toc:[]};function _E(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}_E.isMDXComponent=!0;const XE={toc:[]};function gE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}gE.isMDXComponent=!0;const TE={toc:[]};function xE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}xE.isMDXComponent=!0;const CE={toc:[]};function vE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}vE.isMDXComponent=!0;const LE={toc:[]};function ZE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}ZE.isMDXComponent=!0;const bE={toc:[]};function NE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}NE.isMDXComponent=!0;const zE={toc:[]};function AE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}AE.isMDXComponent=!0;const WE={toc:[]};function RE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}RE.isMDXComponent=!0;const IE={toc:[]};function SE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}SE.isMDXComponent=!0;const PE={toc:[]};function EE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}EE.isMDXComponent=!0;const BE={toc:[]};function GE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}GE.isMDXComponent=!0;const OE={toc:[]};function UE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}UE.isMDXComponent=!0;const FE={toc:[]};function qE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}qE.isMDXComponent=!0;const VE={toc:[]};function jE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}jE.isMDXComponent=!0;const HE={toc:[]};function QE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}QE.isMDXComponent=!0;const $E={toc:[]};function YE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$E,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}YE.isMDXComponent=!0;const KE={toc:[]};function JE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}JE.isMDXComponent=!0;const tB={toc:[]};function nB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}nB.isMDXComponent=!0;const eB={toc:[]};function oB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}oB.isMDXComponent=!0;const pB={toc:[]};function rB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}rB.isMDXComponent=!0;const sB={toc:[]};function cB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}cB.isMDXComponent=!0;const iB={toc:[]};function aB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}aB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}dB.isMDXComponent=!0;const hB={toc:[]};function kB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}kB.isMDXComponent=!0;const yB={toc:[]};function fB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}fB.isMDXComponent=!0;const MB={toc:[]};function DB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}DB.isMDXComponent=!0;const wB={toc:[]};function _B(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}_B.isMDXComponent=!0;const XB={toc:[]};function gB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}gB.isMDXComponent=!0;const TB={toc:[]};function xB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}xB.isMDXComponent=!0;const CB={toc:[]};function vB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}vB.isMDXComponent=!0;const LB={toc:[]};function ZB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}ZB.isMDXComponent=!0;const bB={toc:[]};function NB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}NB.isMDXComponent=!0;const zB={toc:[]};function AB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}AB.isMDXComponent=!0;const WB={toc:[]};function RB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}RB.isMDXComponent=!0;const IB={toc:[]};function SB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}SB.isMDXComponent=!0;const PB={toc:[]};function EB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}EB.isMDXComponent=!0;const BB={toc:[]};function GB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}GB.isMDXComponent=!0;const OB={toc:[]};function UB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}UB.isMDXComponent=!0;const FB={toc:[]};function qB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}qB.isMDXComponent=!0;const VB={toc:[]};function jB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}jB.isMDXComponent=!0;const HB={toc:[]};function QB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}QB.isMDXComponent=!0;const $B={toc:[]};function YB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$B,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}YB.isMDXComponent=!0;const KB={toc:[]};function JB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}JB.isMDXComponent=!0;const tG={toc:[]};function nG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}nG.isMDXComponent=!0;const eG={toc:[]};function oG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}oG.isMDXComponent=!0;const pG={toc:[]};function rG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}rG.isMDXComponent=!0;const sG={toc:[]};function cG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}cG.isMDXComponent=!0;const iG={toc:[]};function aG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}aG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}dG.isMDXComponent=!0;const hG={toc:[]};function kG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}kG.isMDXComponent=!0;const yG={toc:[]};function fG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}fG.isMDXComponent=!0;const MG={toc:[]};function DG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}DG.isMDXComponent=!0;const wG={toc:[]};function _G(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}_G.isMDXComponent=!0;const XG={toc:[]};function gG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}gG.isMDXComponent=!0;const TG={toc:[]};function xG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}xG.isMDXComponent=!0;const CG={toc:[]};function vG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}vG.isMDXComponent=!0;const LG={toc:[]};function ZG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}ZG.isMDXComponent=!0;const bG={toc:[]};function NG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}NG.isMDXComponent=!0;const zG={toc:[]};function AG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}AG.isMDXComponent=!0;const WG={toc:[]};function RG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}RG.isMDXComponent=!0;const IG={toc:[]};function SG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}SG.isMDXComponent=!0;const PG={toc:[]};function EG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}EG.isMDXComponent=!0;const BG={toc:[]};function GG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}GG.isMDXComponent=!0;const OG={toc:[]};function UG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}UG.isMDXComponent=!0;const FG={toc:[]};function qG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}qG.isMDXComponent=!0;const VG={toc:[]};function jG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}jG.isMDXComponent=!0;const HG={toc:[]};function QG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}QG.isMDXComponent=!0;const $G={toc:[]};function YG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$G,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}YG.isMDXComponent=!0;const KG={toc:[]};function JG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}JG.isMDXComponent=!0;const tO={toc:[]};function nO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}nO.isMDXComponent=!0;const eO={toc:[]};function oO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}oO.isMDXComponent=!0;const pO={toc:[]};function rO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}rO.isMDXComponent=!0;const sO={toc:[]};function cO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}cO.isMDXComponent=!0;const iO={toc:[]};function aO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}aO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}dO.isMDXComponent=!0;const hO={toc:[]};function kO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}kO.isMDXComponent=!0;const yO={toc:[]};function fO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}fO.isMDXComponent=!0;const MO={toc:[]};function DO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}DO.isMDXComponent=!0;const wO={toc:[]};function _O(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}_O.isMDXComponent=!0;const XO={toc:[]};function gO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}gO.isMDXComponent=!0;const TO={toc:[]};function xO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}xO.isMDXComponent=!0;const CO={toc:[]};function vO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An Icon Component that provides an easy access to over 150k icons.\nSee ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}vO.isMDXComponent=!0;const LO={toc:[]};function ZO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}ZO.isMDXComponent=!0;const bO={toc:[]};function NO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}NO.isMDXComponent=!0;const zO={toc:[]};function AO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}AO.isMDXComponent=!0;const WO={toc:[]};function RO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}RO.isMDXComponent=!0;const IO={toc:[]};function SO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}SO.isMDXComponent=!0;const PO={toc:[]};function EO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}EO.isMDXComponent=!0;const BO={toc:[]};function GO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}GO.isMDXComponent=!0;const OO={toc:[]};function UO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}UO.isMDXComponent=!0;const FO={toc:[]};function qO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qO.isMDXComponent=!0;const VO={toc:[]};function jO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}jO.isMDXComponent=!0;const HO={toc:[]};function QO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}QO.isMDXComponent=!0;const $O={toc:[]};function YO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$O,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}YO.isMDXComponent=!0;const KO={toc:[]};function JO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}JO.isMDXComponent=!0;const tU={toc:[]};function nU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}nU.isMDXComponent=!0;const eU={toc:[]};function oU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}oU.isMDXComponent=!0;const pU={toc:[]};function rU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"'white'"))}rU.isMDXComponent=!0;const sU={toc:[]};function cU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}cU.isMDXComponent=!0;const iU={toc:[]};function aU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}aU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}dU.isMDXComponent=!0;const hU={toc:[]};function kU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}kU.isMDXComponent=!0;const yU={toc:[]};function fU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}fU.isMDXComponent=!0;const MU={toc:[]};function DU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}DU.isMDXComponent=!0;const wU={toc:[]};function _U(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}_U.isMDXComponent=!0;const XU={toc:[]};function gU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}gU.isMDXComponent=!0;const TU={toc:[]};function xU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}xU.isMDXComponent=!0;const CU={toc:[]};function vU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}vU.isMDXComponent=!0;const LU={toc:[]};function ZU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}ZU.isMDXComponent=!0;const bU={toc:[]};function NU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}NU.isMDXComponent=!0;const zU={toc:[]};function AU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}AU.isMDXComponent=!0;const WU={toc:[]};function RU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}RU.isMDXComponent=!0;const IU={toc:[]};function SU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}SU.isMDXComponent=!0;const PU={toc:[]};function EU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}EU.isMDXComponent=!0;const BU={toc:[]};function GU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}GU.isMDXComponent=!0;const OU={toc:[]};function UU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}UU.isMDXComponent=!0;const FU={toc:[]};function qU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}qU.isMDXComponent=!0;const VU={toc:[]};function jU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}jU.isMDXComponent=!0;const HU={toc:[]};function QU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}QU.isMDXComponent=!0;const $U={toc:[]};function YU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$U,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}YU.isMDXComponent=!0;const KU={toc:[]};function JU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}JU.isMDXComponent=!0;const tF={toc:[]};function nF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}nF.isMDXComponent=!0;const eF={toc:[]};function oF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}oF.isMDXComponent=!0;const pF={toc:[]};function rF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}rF.isMDXComponent=!0;const sF={toc:[]};function cF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}cF.isMDXComponent=!0;const iF={toc:[]};function aF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}aF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}dF.isMDXComponent=!0;const hF={toc:[]};function kF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}kF.isMDXComponent=!0;const yF={toc:[]};function fF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}fF.isMDXComponent=!0;const MF={toc:[]};function DF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}DF.isMDXComponent=!0;const wF={toc:[]};function _F(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}_F.isMDXComponent=!0;const XF={toc:[]};function gF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}gF.isMDXComponent=!0;const TF={toc:[]};function xF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}xF.isMDXComponent=!0;const CF={toc:[]};function vF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}vF.isMDXComponent=!0;const LF={toc:[]};function ZF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}ZF.isMDXComponent=!0;const bF={toc:[]};function NF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}NF.isMDXComponent=!0;const zF={toc:[]};function AF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}AF.isMDXComponent=!0;const WF={toc:[]};function RF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}RF.isMDXComponent=!0;const IF={toc:[]};function SF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}SF.isMDXComponent=!0;const PF={toc:[]};function EF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}EF.isMDXComponent=!0;const BF={toc:[]};function GF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}GF.isMDXComponent=!0;const OF={toc:[]};function UF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}UF.isMDXComponent=!0;const FF={toc:[]};function qF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}qF.isMDXComponent=!0;const VF={toc:[]};function jF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}jF.isMDXComponent=!0;const HF={toc:[]};function QF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}QF.isMDXComponent=!0;const $F={toc:[]};function YF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$F,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}YF.isMDXComponent=!0;const KF={toc:[]};function JF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}JF.isMDXComponent=!0;const tq={toc:[]};function nq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}nq.isMDXComponent=!0;const eq={toc:[]};function oq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}oq.isMDXComponent=!0;const pq={toc:[]};function rq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}rq.isMDXComponent=!0;const sq={toc:[]};function cq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}cq.isMDXComponent=!0;const iq={toc:[]};function aq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}aq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}dq.isMDXComponent=!0;const hq={toc:[]};function kq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}kq.isMDXComponent=!0;const yq={toc:[]};function fq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}fq.isMDXComponent=!0;const Mq={toc:[]};function Dq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Dq.isMDXComponent=!0;const wq={toc:[]};function _q(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}_q.isMDXComponent=!0;const Xq={toc:[]};function gq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}gq.isMDXComponent=!0;const Tq={toc:[]};function xq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}xq.isMDXComponent=!0;const Cq={toc:[]};function vq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}vq.isMDXComponent=!0;const Lq={toc:[]};function Zq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}Zq.isMDXComponent=!0;const bq={toc:[]};function Nq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}Nq.isMDXComponent=!0;const zq={toc:[]};function Aq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Aq.isMDXComponent=!0;const Wq={toc:[]};function Rq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Rq.isMDXComponent=!0;const Iq={toc:[]};function Sq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Sq.isMDXComponent=!0;const Pq={toc:[]};function Eq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Eq.isMDXComponent=!0;const Bq={toc:[]};function Gq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Gq.isMDXComponent=!0;const Oq={toc:[]};function Uq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Uq.isMDXComponent=!0;const Fq={toc:[]};function qq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}qq.isMDXComponent=!0;const Vq={toc:[]};function jq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}jq.isMDXComponent=!0;const Hq={toc:[]};function Qq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Qq.isMDXComponent=!0;const $q={toc:[]};function Yq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$q,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Yq.isMDXComponent=!0;const Kq={toc:[]};function Jq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Jq.isMDXComponent=!0;const tV={toc:[]};function nV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}nV.isMDXComponent=!0;const eV={toc:[]};function oV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}oV.isMDXComponent=!0;const pV={toc:[]};function rV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}rV.isMDXComponent=!0;const sV={toc:[]};function cV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}cV.isMDXComponent=!0;const iV={toc:[]};function aV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}aV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dV.isMDXComponent=!0;const hV={toc:[]};function kV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}kV.isMDXComponent=!0;const yV={toc:[]};function fV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}fV.isMDXComponent=!0;const MV={toc:[]};function DV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}DV.isMDXComponent=!0;const wV={toc:[]};function _V(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}_V.isMDXComponent=!0;const XV={toc:[]};function gV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}gV.isMDXComponent=!0;const TV={toc:[]};function xV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}xV.isMDXComponent=!0;const CV={toc:[]};function vV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}vV.isMDXComponent=!0;const LV={toc:[]};function ZV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}ZV.isMDXComponent=!0;const bV={toc:[]};function NV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}NV.isMDXComponent=!0;const zV={toc:[]};function AV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}AV.isMDXComponent=!0;const WV={toc:[]};function RV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}RV.isMDXComponent=!0;const IV={toc:[]};function SV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}SV.isMDXComponent=!0;const PV={toc:[]};function EV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}EV.isMDXComponent=!0;const BV={toc:[]};function GV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}GV.isMDXComponent=!0;const OV={toc:[]};function UV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}UV.isMDXComponent=!0;const FV={toc:[]};function qV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}qV.isMDXComponent=!0;const VV={toc:[]};function jV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}jV.isMDXComponent=!0;const HV={toc:[]};function QV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}QV.isMDXComponent=!0;const $V={toc:[]};function YV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$V,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}YV.isMDXComponent=!0;const KV={toc:[]};function JV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}JV.isMDXComponent=!0;const tj={toc:[]};function nj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}nj.isMDXComponent=!0;const ej={toc:[]};function oj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ej,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}oj.isMDXComponent=!0;const pj={toc:[]};function rj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}rj.isMDXComponent=!0;const sj={toc:[]};function cj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}cj.isMDXComponent=!0;const ij={toc:[]};function aj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ij,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}aj.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}dj.isMDXComponent=!0;const hj={toc:[]};function kj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}kj.isMDXComponent=!0;const yj={toc:[]};function fj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}fj.isMDXComponent=!0;const Mj={toc:[]};function Dj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Dj.isMDXComponent=!0;const wj={toc:[]};function _j(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}_j.isMDXComponent=!0;const Xj={toc:[]};function gj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}gj.isMDXComponent=!0;const Tj={toc:[]};function xj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}xj.isMDXComponent=!0;const Cj={toc:[]};function vj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}vj.isMDXComponent=!0;const Lj={toc:[]};function Zj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Zj.isMDXComponent=!0;const bj={toc:[]};function Nj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Nj.isMDXComponent=!0;const zj={toc:[]};function Aj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Aj.isMDXComponent=!0;const Wj={toc:[]};function Rj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Rj.isMDXComponent=!0;const Ij={toc:[]};function Sj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ij,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Sj.isMDXComponent=!0;const Pj={toc:[]};function Ej(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Ej.isMDXComponent=!0;const Bj={toc:[]};function Gj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Gj.isMDXComponent=!0;const Oj={toc:[]};function Uj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}Uj.isMDXComponent=!0;const Fj={toc:[]};function qj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}qj.isMDXComponent=!0;const Vj={toc:[]};function jj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}jj.isMDXComponent=!0;const Hj={toc:[]};function Qj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Qj.isMDXComponent=!0;const $j={toc:[]};function Yj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$j,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}Yj.isMDXComponent=!0;const Kj={toc:[]};function Jj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Jj.isMDXComponent=!0;const tH={toc:[]};function nH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}nH.isMDXComponent=!0;const eH={toc:[]};function oH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}oH.isMDXComponent=!0;const pH={toc:[]};function rH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}rH.isMDXComponent=!0;const sH={toc:[]};function cH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}cH.isMDXComponent=!0;const iH={toc:[]};function aH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}aH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Address to Iconify API for the requested Icon."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create the URL that will be used as the Image source"))}dH.isMDXComponent=!0;const hH={toc:[]};function kH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}kH.isMDXComponent=!0;const yH={toc:[]};function fH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}fH.isMDXComponent=!0;const MH={toc:[]};function DH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}DH.isMDXComponent=!0;const wH={toc:[]};function _H(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}_H.isMDXComponent=!0;const XH={toc:[]};function gH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}gH.isMDXComponent=!0;const TH={toc:[]};function xH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}xH.isMDXComponent=!0;const CH={toc:[]};function vH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}vH.isMDXComponent=!0;const LH={toc:[]};function ZH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}ZH.isMDXComponent=!0;const bH={toc:[]};function NH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}NH.isMDXComponent=!0;const zH={toc:[]};function AH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}AH.isMDXComponent=!0;const WH={toc:[]};function RH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}RH.isMDXComponent=!0;const IH={toc:[]};function SH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}SH.isMDXComponent=!0;const PH={toc:[]};function EH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}EH.isMDXComponent=!0;const BH={toc:[]};function GH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}GH.isMDXComponent=!0;const OH={toc:[]};function UH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}UH.isMDXComponent=!0;const FH={toc:[]};function qH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}qH.isMDXComponent=!0;const VH={toc:[]};function jH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}jH.isMDXComponent=!0;const HH={toc:[]};function QH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}QH.isMDXComponent=!0;const $H={toc:[]};function YH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$H,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}YH.isMDXComponent=!0;const KH={toc:[]};function JH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}JH.isMDXComponent=!0;const tQ={toc:[]};function nQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}nQ.isMDXComponent=!0;const eQ={toc:[]};function oQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}oQ.isMDXComponent=!0;const pQ={toc:[]};function rQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}rQ.isMDXComponent=!0;const sQ={toc:[]};function cQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}cQ.isMDXComponent=!0;const iQ={toc:[]};function aQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}aQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function kQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}kQ.isMDXComponent=!0;const yQ={toc:[]};function fQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}fQ.isMDXComponent=!0;const MQ={toc:[]};function DQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}DQ.isMDXComponent=!0;const wQ={toc:[]};function _Q(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}_Q.isMDXComponent=!0;const XQ={toc:[]};function gQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}gQ.isMDXComponent=!0;const TQ={toc:[]};function xQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}xQ.isMDXComponent=!0;const CQ={toc:[]};function vQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}vQ.isMDXComponent=!0;const LQ={toc:[]};function ZQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}ZQ.isMDXComponent=!0;const bQ={toc:[]};function NQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}NQ.isMDXComponent=!0;const zQ={toc:[]};function AQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}AQ.isMDXComponent=!0;const WQ={toc:[]};function RQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}RQ.isMDXComponent=!0;const IQ={toc:[]};function SQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}SQ.isMDXComponent=!0;const PQ={toc:[]};function EQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}EQ.isMDXComponent=!0;const BQ={toc:[]};function GQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}GQ.isMDXComponent=!0;const OQ={toc:[]};function UQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}UQ.isMDXComponent=!0;const FQ={toc:[]};function qQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}qQ.isMDXComponent=!0;const VQ={toc:[]};function jQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}jQ.isMDXComponent=!0;const HQ={toc:[]};function QQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}QQ.isMDXComponent=!0;const $Q={toc:[]};function YQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Q,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}YQ.isMDXComponent=!0;const KQ={toc:[]};function JQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}JQ.isMDXComponent=!0;const t$={toc:[]};function n$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}n$.isMDXComponent=!0;const e$={toc:[]};function o$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}o$.isMDXComponent=!0;const p$={toc:[]};function r$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}r$.isMDXComponent=!0;const s$={toc:[]};function c$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}c$.isMDXComponent=!0;const i$={toc:[]};function a$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}a$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}d$.isMDXComponent=!0;const h$={toc:[]};function k$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}k$.isMDXComponent=!0;const y$={toc:[]};function f$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}f$.isMDXComponent=!0;const M$={toc:[]};function D$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}D$.isMDXComponent=!0;const w$={toc:[]};function _$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}_$.isMDXComponent=!0;const X$={toc:[]};function g$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}g$.isMDXComponent=!0;const T$={toc:[]};function x$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}x$.isMDXComponent=!0;const C$={toc:[]};function v$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}v$.isMDXComponent=!0;const L$={toc:[]};function Z$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Z$.isMDXComponent=!0;const b$={toc:[]};function N$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}N$.isMDXComponent=!0;const z$={toc:[]};function A$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}A$.isMDXComponent=!0;const W$={toc:[]};function R$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}R$.isMDXComponent=!0;const I$={toc:[]};function S$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}S$.isMDXComponent=!0;const P$={toc:[]};function E$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}E$.isMDXComponent=!0;const B$={toc:[]};function G$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}G$.isMDXComponent=!0;const O$={toc:[]};function U$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}U$.isMDXComponent=!0;const F$={toc:[]};function q$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}q$.isMDXComponent=!0;const V$={toc:[]};function j$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}j$.isMDXComponent=!0;const H$={toc:[]};function Q$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Q$.isMDXComponent=!0;const $$={toc:[]};function Y$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Y$.isMDXComponent=!0;const K$={toc:[]};function J$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}J$.isMDXComponent=!0;const tY={toc:[]};function nY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}nY.isMDXComponent=!0;const eY={toc:[]};function oY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}oY.isMDXComponent=!0;const pY={toc:[]};function rY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}rY.isMDXComponent=!0;const sY={toc:[]};function cY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}cY.isMDXComponent=!0;const iY={toc:[]};function aY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}aY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}dY.isMDXComponent=!0;const hY={toc:[]};function kY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}kY.isMDXComponent=!0;const yY={toc:[]};function fY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}fY.isMDXComponent=!0;const MY={toc:[]};function DY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}DY.isMDXComponent=!0;const wY={toc:[]};function _Y(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}_Y.isMDXComponent=!0;const XY={toc:[]};function gY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}gY.isMDXComponent=!0;const TY={toc:[]};function xY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}xY.isMDXComponent=!0;const CY={toc:[]};function vY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}vY.isMDXComponent=!0;const LY={toc:[]};function ZY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}ZY.isMDXComponent=!0;const bY={toc:[]};function NY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}NY.isMDXComponent=!0;const zY={toc:[]};function AY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}AY.isMDXComponent=!0;const WY={toc:[]};function RY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}RY.isMDXComponent=!0;const IY={toc:[]};function SY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}SY.isMDXComponent=!0;const PY={toc:[]};function EY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}EY.isMDXComponent=!0;const BY={toc:[]};function GY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}GY.isMDXComponent=!0;const OY={toc:[]};function UY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}UY.isMDXComponent=!0;const FY={toc:[]};function qY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}qY.isMDXComponent=!0;const VY={toc:[]};function jY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}jY.isMDXComponent=!0;const HY={toc:[]};function QY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}QY.isMDXComponent=!0;const $Y={toc:[]};function YY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Y,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}YY.isMDXComponent=!0;const KY={toc:[]};function JY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}JY.isMDXComponent=!0;const tK={toc:[]};function nK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}nK.isMDXComponent=!0;const eK={toc:[]};function oK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}oK.isMDXComponent=!0;const pK={toc:[]};function rK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}rK.isMDXComponent=!0;const sK={toc:[]};function cK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}cK.isMDXComponent=!0;const iK={toc:[]};function aK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}aK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}dK.isMDXComponent=!0;const hK={toc:[]};function kK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}kK.isMDXComponent=!0;const yK={toc:[]};function fK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}fK.isMDXComponent=!0;const MK={toc:[]};function DK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}DK.isMDXComponent=!0;const wK={toc:[]};function _K(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}_K.isMDXComponent=!0;const XK={toc:[]};function gK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}gK.isMDXComponent=!0;const TK={toc:[]};function xK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}xK.isMDXComponent=!0;const CK={toc:[]};function vK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}vK.isMDXComponent=!0;const LK={toc:[]};function ZK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}ZK.isMDXComponent=!0;const bK={toc:[]};function NK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}NK.isMDXComponent=!0;const zK={toc:[]};function AK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}AK.isMDXComponent=!0;const WK={toc:[]};function RK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}RK.isMDXComponent=!0;const IK={toc:[]};function SK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}SK.isMDXComponent=!0;const PK={toc:[]};function EK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}EK.isMDXComponent=!0;const BK={toc:[]};function GK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}GK.isMDXComponent=!0;const OK={toc:[]};function UK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}UK.isMDXComponent=!0;const FK={toc:[]};function qK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}qK.isMDXComponent=!0;const VK={toc:[]};function jK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}jK.isMDXComponent=!0;const HK={toc:[]};function QK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}QK.isMDXComponent=!0;const $K={toc:[]};function YK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$K,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}YK.isMDXComponent=!0;const KK={toc:[]};function JK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}JK.isMDXComponent=!0;const tJ={toc:[]};function nJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}nJ.isMDXComponent=!0;const eJ={toc:[]};function oJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}oJ.isMDXComponent=!0;const pJ={toc:[]};function rJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}rJ.isMDXComponent=!0;const sJ={toc:[]};function cJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}cJ.isMDXComponent=!0;const iJ={toc:[]};function aJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}aJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function kJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}kJ.isMDXComponent=!0;const yJ={toc:[]};function fJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}fJ.isMDXComponent=!0;const MJ={toc:[]};function DJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}DJ.isMDXComponent=!0;const wJ={toc:[]};function _J(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}_J.isMDXComponent=!0;const XJ={toc:[]};function gJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}gJ.isMDXComponent=!0;const TJ={toc:[]};function xJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}xJ.isMDXComponent=!0;const CJ={toc:[]};function vJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}vJ.isMDXComponent=!0;const LJ={toc:[]};function ZJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}ZJ.isMDXComponent=!0;const bJ={toc:[]};function NJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}NJ.isMDXComponent=!0;const zJ={toc:[]};function AJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}AJ.isMDXComponent=!0;const WJ={toc:[]};function RJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}RJ.isMDXComponent=!0;const IJ={toc:[]};function SJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}SJ.isMDXComponent=!0;const PJ={toc:[]};function EJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}EJ.isMDXComponent=!0;const BJ={toc:[]};function GJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}GJ.isMDXComponent=!0;const OJ={toc:[]};function UJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}UJ.isMDXComponent=!0;const FJ={toc:[]};function qJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}qJ.isMDXComponent=!0;const VJ={toc:[]};function jJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}jJ.isMDXComponent=!0;const HJ={toc:[]};function QJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}QJ.isMDXComponent=!0;const $J={toc:[]};function YJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$J,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}YJ.isMDXComponent=!0;const KJ={toc:[]};function JJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}JJ.isMDXComponent=!0;const t0={toc:[]};function n0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}n0.isMDXComponent=!0;const e0={toc:[]};function o0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}o0.isMDXComponent=!0;const p0={toc:[]};function r0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}r0.isMDXComponent=!0;const s0={toc:[]};function c0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}c0.isMDXComponent=!0;const i0={toc:[]};function a0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}a0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}d0.isMDXComponent=!0;const h0={toc:[]};function k0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}k0.isMDXComponent=!0;const y0={toc:[]};function f0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}f0.isMDXComponent=!0;const M0={toc:[]};function D0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}D0.isMDXComponent=!0;const w0={toc:[]};function _0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}_0.isMDXComponent=!0;const X0={toc:[]};function g0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}g0.isMDXComponent=!0;const T0={toc:[]};function x0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}x0.isMDXComponent=!0;const C0={toc:[]};function v0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node representing a knot of a ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,s.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}v0.isMDXComponent=!0;const L0={toc:[]};function Z0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Z0.isMDXComponent=!0;const b0={toc:[]};function N0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}N0.isMDXComponent=!0;const z0={toc:[]};function A0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}A0.isMDXComponent=!0;const W0={toc:[]};function R0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}R0.isMDXComponent=!0;const I0={toc:[]};function S0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}S0.isMDXComponent=!0;const P0={toc:[]};function E0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}E0.isMDXComponent=!0;const B0={toc:[]};function G0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}G0.isMDXComponent=!0;const O0={toc:[]};function U0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}U0.isMDXComponent=!0;const F0={toc:[]};function q0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}q0.isMDXComponent=!0;const V0={toc:[]};function j0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}j0.isMDXComponent=!0;const H0={toc:[]};function Q0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the startHandle."))}Q0.isMDXComponent=!0;const $0={toc:[]};function Y0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}Y0.isMDXComponent=!0;const K0={toc:[]};function J0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}J0.isMDXComponent=!0;const t2={toc:[]};function n2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}n2.isMDXComponent=!0;const e2={toc:[]};function o2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}o2.isMDXComponent=!0;const p2={toc:[]};function r2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}r2.isMDXComponent=!0;const s2={toc:[]};function c2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}c2.isMDXComponent=!0;const i2={toc:[]};function a2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}a2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the endHandle."))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}d2.isMDXComponent=!0;const h2={toc:[]};function k2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}k2.isMDXComponent=!0;const y2={toc:[]};function f2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}f2.isMDXComponent=!0;const M2={toc:[]};function D2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}D2.isMDXComponent=!0;const w2={toc:[]};function _2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}_2.isMDXComponent=!0;const X2={toc:[]};function g2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}g2.isMDXComponent=!0;const T2={toc:[]};function x2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}x2.isMDXComponent=!0;const C2={toc:[]};function v2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}v2.isMDXComponent=!0;const L2={toc:[]};function Z2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Z2.isMDXComponent=!0;const b2={toc:[]};function N2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}N2.isMDXComponent=!0;const z2={toc:[]};function A2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}A2.isMDXComponent=!0;const W2={toc:[]};function R2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}R2.isMDXComponent=!0;const I2={toc:[]};function S2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}S2.isMDXComponent=!0;const P2={toc:[]};function E2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}E2.isMDXComponent=!0;const B2={toc:[]};function G2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}G2.isMDXComponent=!0;const O2={toc:[]};function U2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}U2.isMDXComponent=!0;const F2={toc:[]};function q2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}q2.isMDXComponent=!0;const V2={toc:[]};function j2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}j2.isMDXComponent=!0;const H2={toc:[]};function Q2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Q2.isMDXComponent=!0;const $2={toc:[]};function Y2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Y2.isMDXComponent=!0;const K2={toc:[]};function J2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}J2.isMDXComponent=!0;const t1={toc:[]};function n1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}n1.isMDXComponent=!0;const e1={toc:[]};function o1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}o1.isMDXComponent=!0;const p1={toc:[]};function r1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}r1.isMDXComponent=!0;const s1={toc:[]};function c1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}c1.isMDXComponent=!0;const i1={toc:[]};function a1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}a1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}d1.isMDXComponent=!0;const h1={toc:[]};function k1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}k1.isMDXComponent=!0;const y1={toc:[]};function f1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}f1.isMDXComponent=!0;const M1={toc:[]};function D1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}D1.isMDXComponent=!0;const w1={toc:[]};function _1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}_1.isMDXComponent=!0;const X1={toc:[]};function g1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}g1.isMDXComponent=!0;const T1={toc:[]};function x1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}x1.isMDXComponent=!0;const C1={toc:[]};function v1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}v1.isMDXComponent=!0;const L1={toc:[]};function Z1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Z1.isMDXComponent=!0;const b1={toc:[]};function N1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}N1.isMDXComponent=!0;const z1={toc:[]};function A1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}A1.isMDXComponent=!0;const W1={toc:[]};function R1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}R1.isMDXComponent=!0;const I1={toc:[]};function S1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}S1.isMDXComponent=!0;const P1={toc:[]};function E1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}E1.isMDXComponent=!0;const B1={toc:[]};function G1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}G1.isMDXComponent=!0;const O1={toc:[]};function U1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}U1.isMDXComponent=!0;const F1={toc:[]};function q1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}q1.isMDXComponent=!0;const V1={toc:[]};function j1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}j1.isMDXComponent=!0;const H1={toc:[]};function Q1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Q1.isMDXComponent=!0;const $1={toc:[]};function Y1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Y1.isMDXComponent=!0;const K1={toc:[]};function J1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}J1.isMDXComponent=!0;const t3={toc:[]};function n3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}n3.isMDXComponent=!0;const e3={toc:[]};function o3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}o3.isMDXComponent=!0;const p3={toc:[]};function r3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}r3.isMDXComponent=!0;const s3={toc:[]};function c3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}c3.isMDXComponent=!0;const i3={toc:[]};function a3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}a3.isMDXComponent=!0;const l3={toc:[]};function u3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}d3.isMDXComponent=!0;const h3={toc:[]};function k3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}k3.isMDXComponent=!0;const y3={toc:[]};function f3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}f3.isMDXComponent=!0;const M3={toc:[]};function D3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}D3.isMDXComponent=!0;const w3={toc:[]};function _3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}_3.isMDXComponent=!0;const X3={toc:[]};function g3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}g3.isMDXComponent=!0;const T3={toc:[]};function x3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}x3.isMDXComponent=!0;const C3={toc:[]};function v3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}v3.isMDXComponent=!0;const L3={toc:[]};function Z3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Z3.isMDXComponent=!0;const b3={toc:[]};function N3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}N3.isMDXComponent=!0;const z3={toc:[]};function A3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}A3.isMDXComponent=!0;const W3={toc:[]};function R3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}R3.isMDXComponent=!0;const I3={toc:[]};function S3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}S3.isMDXComponent=!0;const P3={toc:[]};function E3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}E3.isMDXComponent=!0;const B3={toc:[]};function G3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}G3.isMDXComponent=!0;const O3={toc:[]};function U3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}U3.isMDXComponent=!0;const F3={toc:[]};function q3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}q3.isMDXComponent=!0;const V3={toc:[]};function j3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}j3.isMDXComponent=!0;const H3={toc:[]};function Q3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Q3.isMDXComponent=!0;const $3={toc:[]};function Y3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Y3.isMDXComponent=!0;const K3={toc:[]};function J3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}J3.isMDXComponent=!0;const t6={toc:[]};function n6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}n6.isMDXComponent=!0;const e6={toc:[]};function o6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}o6.isMDXComponent=!0;const p6={toc:[]};function r6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}r6.isMDXComponent=!0;const s6={toc:[]};function c6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}c6.isMDXComponent=!0;const i6={toc:[]};function a6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}a6.isMDXComponent=!0;const l6={toc:[]};function u6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}u6.isMDXComponent=!0;const m6={toc:[]};function d6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}d6.isMDXComponent=!0;const h6={toc:[]};function k6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}k6.isMDXComponent=!0;const y6={toc:[]};function f6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}f6.isMDXComponent=!0;const M6={toc:[]};function D6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}D6.isMDXComponent=!0;const w6={toc:[]};function _6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}_6.isMDXComponent=!0;const X6={toc:[]};function g6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}g6.isMDXComponent=!0;const T6={toc:[]};function x6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}x6.isMDXComponent=!0;const C6={toc:[]};function v6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}v6.isMDXComponent=!0;const L6={toc:[]};function Z6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Z6.isMDXComponent=!0;const b6={toc:[]};function N6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}N6.isMDXComponent=!0;const z6={toc:[]};function A6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}A6.isMDXComponent=!0;const W6={toc:[]};function R6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}R6.isMDXComponent=!0;const I6={toc:[]};function S6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}S6.isMDXComponent=!0;const P6={toc:[]};function E6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}E6.isMDXComponent=!0;const B6={toc:[]};function G6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}G6.isMDXComponent=!0;const O6={toc:[]};function U6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}U6.isMDXComponent=!0;const F6={toc:[]};function q6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}q6.isMDXComponent=!0;const V6={toc:[]};function j6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}j6.isMDXComponent=!0;const H6={toc:[]};function Q6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Q6.isMDXComponent=!0;const $6={toc:[]};function Y6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Y6.isMDXComponent=!0;const K6={toc:[]};function J6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}J6.isMDXComponent=!0;const t4={toc:[]};function n4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}n4.isMDXComponent=!0;const e4={toc:[]};function o4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}o4.isMDXComponent=!0;const p4={toc:[]};function r4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}r4.isMDXComponent=!0;const s4={toc:[]};function c4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}c4.isMDXComponent=!0;const i4={toc:[]};function a4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}a4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}d4.isMDXComponent=!0;const h4={toc:[]};function k4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}k4.isMDXComponent=!0;const y4={toc:[]};function f4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}f4.isMDXComponent=!0;const M4={toc:[]};function D4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}D4.isMDXComponent=!0;const w4={toc:[]};function _4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}_4.isMDXComponent=!0;const X4={toc:[]};function g4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}g4.isMDXComponent=!0;const T4={toc:[]};function x4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}x4.isMDXComponent=!0;const C4={toc:[]};function v4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}v4.isMDXComponent=!0;const L4={toc:[]};function Z4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Z4.isMDXComponent=!0;const b4={toc:[]};function N4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}N4.isMDXComponent=!0;const z4={toc:[]};function A4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}A4.isMDXComponent=!0;const W4={toc:[]};function R4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}R4.isMDXComponent=!0;const I4={toc:[]};function S4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}S4.isMDXComponent=!0;const P4={toc:[]};function E4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}E4.isMDXComponent=!0;const B4={toc:[]};function G4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}G4.isMDXComponent=!0;const O4={toc:[]};function U4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}U4.isMDXComponent=!0;const F4={toc:[]};function q4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}q4.isMDXComponent=!0;const V4={toc:[]};function j4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}j4.isMDXComponent=!0;const H4={toc:[]};function Q4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Q4.isMDXComponent=!0;const $4={toc:[]};function Y4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Y4.isMDXComponent=!0;const K4={toc:[]};function J4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}J4.isMDXComponent=!0;const t8={toc:[]};function n8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}n8.isMDXComponent=!0;const e8={toc:[]};function o8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}o8.isMDXComponent=!0;const p8={toc:[]};function r8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}r8.isMDXComponent=!0;const s8={toc:[]};function c8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}c8.isMDXComponent=!0;const i8={toc:[]};function a8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}a8.isMDXComponent=!0;const l8={toc:[]};function u8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}u8.isMDXComponent=!0;const m8={toc:[]};function d8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}d8.isMDXComponent=!0;const h8={toc:[]};function k8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}k8.isMDXComponent=!0;const y8={toc:[]};function f8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}f8.isMDXComponent=!0;const M8={toc:[]};function D8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}D8.isMDXComponent=!0;const w8={toc:[]};function _8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}_8.isMDXComponent=!0;const X8={toc:[]};function g8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}g8.isMDXComponent=!0;const T8={toc:[]};function x8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}x8.isMDXComponent=!0;const C8={toc:[]};function v8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}v8.isMDXComponent=!0;const L8={toc:[]};function Z8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Z8.isMDXComponent=!0;const b8={toc:[]};function N8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}N8.isMDXComponent=!0;const z8={toc:[]};function A8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}A8.isMDXComponent=!0;const W8={toc:[]};function R8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}R8.isMDXComponent=!0;const I8={toc:[]};function S8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}S8.isMDXComponent=!0;const P8={toc:[]};function E8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}E8.isMDXComponent=!0;const B8={toc:[]};function G8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}G8.isMDXComponent=!0;const O8={toc:[]};function U8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}U8.isMDXComponent=!0;const F8={toc:[]};function q8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}q8.isMDXComponent=!0;const V8={toc:[]};function j8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}j8.isMDXComponent=!0;const H8={toc:[]};function Q8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Q8.isMDXComponent=!0;const $8={toc:[]};function Y8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Y8.isMDXComponent=!0;const K8={toc:[]};function J8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}J8.isMDXComponent=!0;const t5={toc:[]};function n5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}n5.isMDXComponent=!0;const e5={toc:[]};function o5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}o5.isMDXComponent=!0;const p5={toc:[]};function r5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}r5.isMDXComponent=!0;const s5={toc:[]};function c5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}c5.isMDXComponent=!0;const i5={toc:[]};function a5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}a5.isMDXComponent=!0;const l5={toc:[]};function u5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}u5.isMDXComponent=!0;const m5={toc:[]};function d5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}d5.isMDXComponent=!0;const h5={toc:[]};function k5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}k5.isMDXComponent=!0;const y5={toc:[]};function f5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}f5.isMDXComponent=!0;const M5={toc:[]};function D5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}D5.isMDXComponent=!0;const w5={toc:[]};function _5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}_5.isMDXComponent=!0;const X5={toc:[]};function g5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}g5.isMDXComponent=!0;const T5={toc:[]};function x5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}x5.isMDXComponent=!0;const C5={toc:[]};function v5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}v5.isMDXComponent=!0;const L5={toc:[]};function Z5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Z5.isMDXComponent=!0;const b5={toc:[]};function N5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}N5.isMDXComponent=!0;const z5={toc:[]};function A5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}A5.isMDXComponent=!0;const W5={toc:[]};function R5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}R5.isMDXComponent=!0;const I5={toc:[]};function S5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}S5.isMDXComponent=!0;const P5={toc:[]};function E5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}E5.isMDXComponent=!0;const B5={toc:[]};function G5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}G5.isMDXComponent=!0;const O5={toc:[]};function U5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}U5.isMDXComponent=!0;const F5={toc:[]};function q5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}q5.isMDXComponent=!0;const V5={toc:[]};function j5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}j5.isMDXComponent=!0;const H5={toc:[]};function Q5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Q5.isMDXComponent=!0;const $5={toc:[]};function Y5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Y5.isMDXComponent=!0;const K5={toc:[]};function J5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}J5.isMDXComponent=!0;const t7={toc:[]};function n7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}n7.isMDXComponent=!0;const e7={toc:[]};function o7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}o7.isMDXComponent=!0;const p7={toc:[]};function r7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}r7.isMDXComponent=!0;const s7={toc:[]};function c7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}c7.isMDXComponent=!0;const i7={toc:[]};function a7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}a7.isMDXComponent=!0;const l7={toc:[]};function u7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}u7.isMDXComponent=!0;const m7={toc:[]};function d7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}d7.isMDXComponent=!0;const h7={toc:[]};function k7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}k7.isMDXComponent=!0;const y7={toc:[]};function f7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}f7.isMDXComponent=!0;const M7={toc:[]};function D7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}D7.isMDXComponent=!0;const w7={toc:[]};function _7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}_7.isMDXComponent=!0;const X7={toc:[]};function g7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}g7.isMDXComponent=!0;const T7={toc:[]};function x7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}x7.isMDXComponent=!0;const C7={toc:[]};function v7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}v7.isMDXComponent=!0;const L7={toc:[]};function Z7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Z7.isMDXComponent=!0;const b7={toc:[]};function N7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}N7.isMDXComponent=!0;const z7={toc:[]};function A7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}A7.isMDXComponent=!0;const W7={toc:[]};function R7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}R7.isMDXComponent=!0;const I7={toc:[]};function S7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}S7.isMDXComponent=!0;const P7={toc:[]};function E7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}E7.isMDXComponent=!0;const B7={toc:[]};function G7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}G7.isMDXComponent=!0;const O7={toc:[]};function U7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}U7.isMDXComponent=!0;const F7={toc:[]};function q7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}q7.isMDXComponent=!0;const V7={toc:[]};function j7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}j7.isMDXComponent=!0;const H7={toc:[]};function Q7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Q7.isMDXComponent=!0;const $7={toc:[]};function Y7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Y7.isMDXComponent=!0;const K7={toc:[]};function J7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}J7.isMDXComponent=!0;const t9={toc:[]};function n9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}n9.isMDXComponent=!0;const e9={toc:[]};function o9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}o9.isMDXComponent=!0;const p9={toc:[]};function r9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}r9.isMDXComponent=!0;const s9={toc:[]};function c9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}c9.isMDXComponent=!0;const i9={toc:[]};function a9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}a9.isMDXComponent=!0;const l9={toc:[]};function u9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}u9.isMDXComponent=!0;const m9={toc:[]};function d9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}d9.isMDXComponent=!0;const h9={toc:[]};function k9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}k9.isMDXComponent=!0;const y9={toc:[]};function f9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}f9.isMDXComponent=!0;const M9={toc:[]};function D9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}D9.isMDXComponent=!0;const w9={toc:[]};function _9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}_9.isMDXComponent=!0;const X9={toc:[]};function g9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}g9.isMDXComponent=!0;const T9={toc:[]};function x9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}x9.isMDXComponent=!0;const C9={toc:[]};function v9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}v9.isMDXComponent=!0;const L9={toc:[]};function Z9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Z9.isMDXComponent=!0;const b9={toc:[]};function N9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}N9.isMDXComponent=!0;const z9={toc:[]};function A9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}A9.isMDXComponent=!0;const W9={toc:[]};function R9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}R9.isMDXComponent=!0;const I9={toc:[]};function S9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}S9.isMDXComponent=!0;const P9={toc:[]};function E9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}E9.isMDXComponent=!0;const B9={toc:[]};function G9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}G9.isMDXComponent=!0;const O9={toc:[]};function U9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}U9.isMDXComponent=!0;const F9={toc:[]};function q9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}q9.isMDXComponent=!0;const V9={toc:[]};function j9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}j9.isMDXComponent=!0;const H9={toc:[]};function Q9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Q9.isMDXComponent=!0;const $9={toc:[]};function Y9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}Y9.isMDXComponent=!0;const K9={toc:[]};function J9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}J9.isMDXComponent=!0;const ttt={toc:[]};function ntt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ttt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}ntt.isMDXComponent=!0;const ett={toc:[]};function ott(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ett,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}ott.isMDXComponent=!0;const ptt={toc:[]};function rtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ptt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}rtt.isMDXComponent=!0;const stt={toc:[]};function ctt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},stt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}ctt.isMDXComponent=!0;const itt={toc:[]};function att(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},itt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}att.isMDXComponent=!0;const ltt={toc:[]};function utt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ltt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}utt.isMDXComponent=!0;const mtt={toc:[]};function dtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}dtt.isMDXComponent=!0;const htt={toc:[]};function ktt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},htt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ktt.isMDXComponent=!0;const ytt={toc:[]};function ftt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ytt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ftt.isMDXComponent=!0;const Mtt={toc:[]};function Dtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Dtt.isMDXComponent=!0;const wtt={toc:[]};function _tt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}_tt.isMDXComponent=!0;const Xtt={toc:[]};function gtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}gtt.isMDXComponent=!0;const Ttt={toc:[]};function xtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ttt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}xtt.isMDXComponent=!0;const Ctt={toc:[]};function vtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ctt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}vtt.isMDXComponent=!0;const Ltt={toc:[]};function Ztt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ltt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Ztt.isMDXComponent=!0;const btt={toc:[]};function Ntt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},btt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Ntt.isMDXComponent=!0;const ztt={toc:[]};function Att(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ztt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Att.isMDXComponent=!0;const Wtt={toc:[]};function Rtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Rtt.isMDXComponent=!0;const Itt={toc:[]};function Stt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Itt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Stt.isMDXComponent=!0;const Ptt={toc:[]};function Ett(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ptt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Ett.isMDXComponent=!0;const Btt={toc:[]};function Gtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Btt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Gtt.isMDXComponent=!0;const Ott={toc:[]};function Utt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ott,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Utt.isMDXComponent=!0;const Ftt={toc:[]};function qtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ftt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}qtt.isMDXComponent=!0;const Vtt={toc:[]};function jtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}jtt.isMDXComponent=!0;const Htt={toc:[]};function Qtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Htt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Qtt.isMDXComponent=!0;const $tt={toc:[]};function Ytt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$tt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ytt.isMDXComponent=!0;const Ktt={toc:[]};function Jtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ktt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Jtt.isMDXComponent=!0;const tnt={toc:[]};function nnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}nnt.isMDXComponent=!0;const ent={toc:[]};function ont(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ent,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}ont.isMDXComponent=!0;const pnt={toc:[]};function rnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}rnt.isMDXComponent=!0;const snt={toc:[]};function cnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},snt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}cnt.isMDXComponent=!0;const int={toc:[]};function ant(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},int,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}ant.isMDXComponent=!0;const lnt={toc:[]};function unt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}unt.isMDXComponent=!0;const mnt={toc:[]};function dnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}dnt.isMDXComponent=!0;const hnt={toc:[]};function knt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}knt.isMDXComponent=!0;const ynt={toc:[]};function fnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ynt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}fnt.isMDXComponent=!0;const Mnt={toc:[]};function Dnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Dnt.isMDXComponent=!0;const wnt={toc:[]};function _nt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}_nt.isMDXComponent=!0;const Xnt={toc:[]};function gnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}gnt.isMDXComponent=!0;const Tnt={toc:[]};function xnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}xnt.isMDXComponent=!0;const Cnt={toc:[]};function vnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}vnt.isMDXComponent=!0;const Lnt={toc:[]};function Znt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Znt.isMDXComponent=!0;const bnt={toc:[]};function Nnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Nnt.isMDXComponent=!0;const znt={toc:[]};function Ant(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},znt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Ant.isMDXComponent=!0;const Wnt={toc:[]};function Rnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Rnt.isMDXComponent=!0;const Int={toc:[]};function Snt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Int,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Snt.isMDXComponent=!0;const Pnt={toc:[]};function Ent(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Ent.isMDXComponent=!0;const Bnt={toc:[]};function Gnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Gnt.isMDXComponent=!0;const Ont={toc:[]};function Unt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ont,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Unt.isMDXComponent=!0;const Fnt={toc:[]};function qnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}qnt.isMDXComponent=!0;const Vnt={toc:[]};function jnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}jnt.isMDXComponent=!0;const Hnt={toc:[]};function Qnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Qnt.isMDXComponent=!0;const $nt={toc:[]};function Ynt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Ynt.isMDXComponent=!0;const Knt={toc:[]};function Jnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Knt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Jnt.isMDXComponent=!0;const tet={toc:[]};function net(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}net.isMDXComponent=!0;const eet={toc:[]};function oet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}oet.isMDXComponent=!0;const pet={toc:[]};function ret(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}ret.isMDXComponent=!0;const set={toc:[]};function cet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},set,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}cet.isMDXComponent=!0;const iet={toc:[]};function aet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}aet.isMDXComponent=!0;const uet={toc:[]};function met(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}met.isMDXComponent=!0;const det={toc:[]};function het(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},det,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}het.isMDXComponent=!0;const ket={toc:[]};function yet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ket,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}yet.isMDXComponent=!0;const fet={toc:[]};function Met(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Met.isMDXComponent=!0;const Det={toc:[]};function wet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Det,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}wet.isMDXComponent=!0;const _et={toc:[]};function Xet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_et,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Xet.isMDXComponent=!0;const get={toc:[]};function Tet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},get,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Tet.isMDXComponent=!0;const xet={toc:[]};function Cet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Cet.isMDXComponent=!0;const vet={toc:[]};function Let(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Let.isMDXComponent=!0;const Zet={toc:[]};function bet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}bet.isMDXComponent=!0;const Net={toc:[]};function zet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Net,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}zet.isMDXComponent=!0;const Aet={toc:[]};function Wet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Wet.isMDXComponent=!0;const Ret={toc:[]};function Iet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ret,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Iet.isMDXComponent=!0;const Set={toc:[]};function Pet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Set,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Pet.isMDXComponent=!0;const Eet={toc:[]};function Bet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Bet.isMDXComponent=!0;const Get={toc:[]};function Oet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Get,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Oet.isMDXComponent=!0;const Uet={toc:[]};function Fet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Fet.isMDXComponent=!0;const qet={toc:[]};function Vet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Vet.isMDXComponent=!0;const jet={toc:[]};function Het(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Het.isMDXComponent=!0;const Qet={toc:[]};function $et(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}$et.isMDXComponent=!0;const Yet={toc:[]};function Ket(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Ket.isMDXComponent=!0;const Jet={toc:[]};function tot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}tot.isMDXComponent=!0;const not={toc:[]};function eot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},not,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}eot.isMDXComponent=!0;const oot={toc:[]};function pot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}pot.isMDXComponent=!0;const rot={toc:[]};function sot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}sot.isMDXComponent=!0;const cot={toc:[]};function iot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}iot.isMDXComponent=!0;const aot={toc:[]};function lot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}lot.isMDXComponent=!0;const uot={toc:[]};function mot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}mot.isMDXComponent=!0;const dot={toc:[]};function hot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}hot.isMDXComponent=!0;const kot={toc:[]};function yot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}yot.isMDXComponent=!0;const fot={toc:[]};function Mot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Mot.isMDXComponent=!0;const Dot={toc:[]};function wot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}wot.isMDXComponent=!0;const _ot={toc:[]};function Xot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Xot.isMDXComponent=!0;const got={toc:[]};function Tot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},got,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Tot.isMDXComponent=!0;const xot={toc:[]};function Cot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Cot.isMDXComponent=!0;const vot={toc:[]};function Lot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Lot.isMDXComponent=!0;const Zot={toc:[]};function bot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}bot.isMDXComponent=!0;const Not={toc:[]};function zot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Not,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}zot.isMDXComponent=!0;const Aot={toc:[]};function Wot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Wot.isMDXComponent=!0;const Rot={toc:[]};function Iot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Iot.isMDXComponent=!0;const Sot={toc:[]};function Pot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Pot.isMDXComponent=!0;const Eot={toc:[]};function Bot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Bot.isMDXComponent=!0;const Got={toc:[]};function Oot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Got,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Oot.isMDXComponent=!0;const Uot={toc:[]};function Fot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Fot.isMDXComponent=!0;const qot={toc:[]};function Vot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Vot.isMDXComponent=!0;const jot={toc:[]};function Hot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Hot.isMDXComponent=!0;const Qot={toc:[]};function $ot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}$ot.isMDXComponent=!0;const Yot={toc:[]};function Kot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Kot.isMDXComponent=!0;const Jot={toc:[]};function tpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}tpt.isMDXComponent=!0;const npt={toc:[]};function ept(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},npt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ept.isMDXComponent=!0;const opt={toc:[]};function ppt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},opt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}ppt.isMDXComponent=!0;const rpt={toc:[]};function spt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}spt.isMDXComponent=!0;const cpt={toc:[]};function ipt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}ipt.isMDXComponent=!0;const apt={toc:[]};function lpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},apt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}lpt.isMDXComponent=!0;const upt={toc:[]};function mpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}mpt.isMDXComponent=!0;const dpt={toc:[]};function hpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}hpt.isMDXComponent=!0;const kpt={toc:[]};function ypt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}ypt.isMDXComponent=!0;const fpt={toc:[]};function Mpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Mpt.isMDXComponent=!0;const Dpt={toc:[]};function wpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}wpt.isMDXComponent=!0;const _pt={toc:[]};function Xpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_pt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Xpt.isMDXComponent=!0;const gpt={toc:[]};function Tpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Tpt.isMDXComponent=!0;const xpt={toc:[]};function Cpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Cpt.isMDXComponent=!0;const vpt={toc:[]};function Lpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Lpt.isMDXComponent=!0;const Zpt={toc:[]};function bpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}bpt.isMDXComponent=!0;const Npt={toc:[]};function zpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}zpt.isMDXComponent=!0;const Apt={toc:[]};function Wpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Apt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Wpt.isMDXComponent=!0;const Rpt={toc:[]};function Ipt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Ipt.isMDXComponent=!0;const Spt={toc:[]};function Ppt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Spt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Ppt.isMDXComponent=!0;const Ept={toc:[]};function Bpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ept,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Bpt.isMDXComponent=!0;const Gpt={toc:[]};function Opt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Opt.isMDXComponent=!0;const Upt={toc:[]};function Fpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Upt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Fpt.isMDXComponent=!0;const qpt={toc:[]};function Vpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Vpt.isMDXComponent=!0;const jpt={toc:[]};function Hpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Hpt.isMDXComponent=!0;const Qpt={toc:[]};function $pt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}$pt.isMDXComponent=!0;const Ypt={toc:[]};function Kpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ypt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Kpt.isMDXComponent=!0;const Jpt={toc:[]};function trt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}trt.isMDXComponent=!0;const nrt={toc:[]};function ert(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}ert.isMDXComponent=!0;const ort={toc:[]};function prt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ort,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}prt.isMDXComponent=!0;const rrt={toc:[]};function srt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}srt.isMDXComponent=!0;const crt={toc:[]};function irt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},crt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}irt.isMDXComponent=!0;const art={toc:[]};function lrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},art,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}lrt.isMDXComponent=!0;const urt={toc:[]};function mrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},urt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}mrt.isMDXComponent=!0;const drt={toc:[]};function hrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},drt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}hrt.isMDXComponent=!0;const krt={toc:[]};function yrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},krt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}yrt.isMDXComponent=!0;const frt={toc:[]};function Mrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},frt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Mrt.isMDXComponent=!0;const Drt={toc:[]};function wrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Drt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wrt.isMDXComponent=!0;const _rt={toc:[]};function Xrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_rt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Xrt.isMDXComponent=!0;const grt={toc:[]};function Trt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},grt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Trt.isMDXComponent=!0;const xrt={toc:[]};function Crt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Crt.isMDXComponent=!0;const vrt={toc:[]};function Lrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Lrt.isMDXComponent=!0;const Zrt={toc:[]};function brt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}brt.isMDXComponent=!0;const Nrt={toc:[]};function zrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}zrt.isMDXComponent=!0;const Art={toc:[]};function Wrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Art,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Wrt.isMDXComponent=!0;const Rrt={toc:[]};function Irt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Irt.isMDXComponent=!0;const Srt={toc:[]};function Prt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Srt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Prt.isMDXComponent=!0;const Ert={toc:[]};function Brt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ert,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Brt.isMDXComponent=!0;const Grt={toc:[]};function Ort(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Grt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Ort.isMDXComponent=!0;const Urt={toc:[]};function Frt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Urt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Frt.isMDXComponent=!0;const qrt={toc:[]};function Vrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Vrt.isMDXComponent=!0;const jrt={toc:[]};function Hrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Hrt.isMDXComponent=!0;const Qrt={toc:[]};function $rt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}$rt.isMDXComponent=!0;const Yrt={toc:[]};function Krt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Krt.isMDXComponent=!0;const Jrt={toc:[]};function tst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}tst.isMDXComponent=!0;const nst={toc:[]};function est(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}est.isMDXComponent=!0;const ost={toc:[]};function pst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ost,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}pst.isMDXComponent=!0;const rst={toc:[]};function sst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}sst.isMDXComponent=!0;const cst={toc:[]};function ist(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}ist.isMDXComponent=!0;const ast={toc:[]};function lst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ast,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}lst.isMDXComponent=!0;const ust={toc:[]};function mst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ust,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}mst.isMDXComponent=!0;const dst={toc:[]};function hst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}hst.isMDXComponent=!0;const kst={toc:[]};function yst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}yst.isMDXComponent=!0;const fst={toc:[]};function Mst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Mst.isMDXComponent=!0;const Dst={toc:[]};function wst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wst.isMDXComponent=!0;const _st={toc:[]};function Xst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_st,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Xst.isMDXComponent=!0;const gst={toc:[]};function Tst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Tst.isMDXComponent=!0;const xst={toc:[]};function Cst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Cst.isMDXComponent=!0;const vst={toc:[]};function Lst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Lst.isMDXComponent=!0;const Zst={toc:[]};function bst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}bst.isMDXComponent=!0;const Nst={toc:[]};function zst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}zst.isMDXComponent=!0;const Ast={toc:[]};function Wst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ast,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Wst.isMDXComponent=!0;const Rst={toc:[]};function Ist(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Ist.isMDXComponent=!0;const Sst={toc:[]};function Pst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Pst.isMDXComponent=!0;const Est={toc:[]};function Bst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Est,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Bst.isMDXComponent=!0;const Gst={toc:[]};function Ost(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Ost.isMDXComponent=!0;const Ust={toc:[]};function Fst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ust,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Fst.isMDXComponent=!0;const qst={toc:[]};function Vst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Vst.isMDXComponent=!0;const jst={toc:[]};function Hst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Hst.isMDXComponent=!0;const Qst={toc:[]};function $st(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}$st.isMDXComponent=!0;const Yst={toc:[]};function Kst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Kst.isMDXComponent=!0;const Jst={toc:[]};function tct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}tct.isMDXComponent=!0;const nct={toc:[]};function ect(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ect.isMDXComponent=!0;const oct={toc:[]};function pct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}pct.isMDXComponent=!0;const rct={toc:[]};function sct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}sct.isMDXComponent=!0;const cct={toc:[]};function ict(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}ict.isMDXComponent=!0;const act={toc:[]};function lct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},act,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lct.isMDXComponent=!0;const uct={toc:[]};function mct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}mct.isMDXComponent=!0;const dct={toc:[]};function hct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}hct.isMDXComponent=!0;const kct={toc:[]};function yct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}yct.isMDXComponent=!0;const fct={toc:[]};function Mct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Mct.isMDXComponent=!0;const Dct={toc:[]};function wct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}wct.isMDXComponent=!0;const _ct={toc:[]};function Xct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Xct.isMDXComponent=!0;const gct={toc:[]};function Tct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Tct.isMDXComponent=!0;const xct={toc:[]};function Cct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Cct.isMDXComponent=!0;const vct={toc:[]};function Lct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Lct.isMDXComponent=!0;const Zct={toc:[]};function bct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}bct.isMDXComponent=!0;const Nct={toc:[]};function zct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}zct.isMDXComponent=!0;const Act={toc:[]};function Wct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Act,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Wct.isMDXComponent=!0;const Rct={toc:[]};function Ict(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Ict.isMDXComponent=!0;const Sct={toc:[]};function Pct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Pct.isMDXComponent=!0;const Ect={toc:[]};function Bct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ect,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Bct.isMDXComponent=!0;const Gct={toc:[]};function Oct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Oct.isMDXComponent=!0;const Uct={toc:[]};function Fct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Fct.isMDXComponent=!0;const qct={toc:[]};function Vct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Vct.isMDXComponent=!0;const jct={toc:[]};function Hct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Hct.isMDXComponent=!0;const Qct={toc:[]};function $ct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}$ct.isMDXComponent=!0;const Yct={toc:[]};function Kct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Kct.isMDXComponent=!0;const Jct={toc:[]};function tit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}tit.isMDXComponent=!0;const nit={toc:[]};function eit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}eit.isMDXComponent=!0;const oit={toc:[]};function pit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}pit.isMDXComponent=!0;const rit={toc:[]};function sit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}sit.isMDXComponent=!0;const cit={toc:[]};function iit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}iit.isMDXComponent=!0;const ait={toc:[]};function lit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ait,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}lit.isMDXComponent=!0;const uit={toc:[]};function mit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}mit.isMDXComponent=!0;const dit={toc:[]};function hit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}hit.isMDXComponent=!0;const kit={toc:[]};function yit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}yit.isMDXComponent=!0;const fit={toc:[]};function Mit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Mit.isMDXComponent=!0;const Dit={toc:[]};function wit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}wit.isMDXComponent=!0;const _it={toc:[]};function Xit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_it,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Xit.isMDXComponent=!0;const git={toc:[]};function Tit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},git,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Tit.isMDXComponent=!0;const xit={toc:[]};function Cit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Cit.isMDXComponent=!0;const vit={toc:[]};function Lit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Lit.isMDXComponent=!0;const Zit={toc:[]};function bit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}bit.isMDXComponent=!0;const Nit={toc:[]};function zit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}zit.isMDXComponent=!0;const Ait={toc:[]};function Wit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ait,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Wit.isMDXComponent=!0;const Rit={toc:[]};function Iit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Iit.isMDXComponent=!0;const Sit={toc:[]};function Pit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Pit.isMDXComponent=!0;const Eit={toc:[]};function Bit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Bit.isMDXComponent=!0;const Git={toc:[]};function Oit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Git,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Oit.isMDXComponent=!0;const Uit={toc:[]};function Fit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Fit.isMDXComponent=!0;const qit={toc:[]};function Vit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Vit.isMDXComponent=!0;const jit={toc:[]};function Hit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Hit.isMDXComponent=!0;const Qit={toc:[]};function $it(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}$it.isMDXComponent=!0;const Yit={toc:[]};function Kit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Kit.isMDXComponent=!0;const Jit={toc:[]};function tat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}tat.isMDXComponent=!0;const nat={toc:[]};function eat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}eat.isMDXComponent=!0;const oat={toc:[]};function pat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}pat.isMDXComponent=!0;const rat={toc:[]};function sat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}sat.isMDXComponent=!0;const cat={toc:[]};function iat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}iat.isMDXComponent=!0;const aat={toc:[]};function lat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}lat.isMDXComponent=!0;const uat={toc:[]};function mat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}mat.isMDXComponent=!0;const dat={toc:[]};function hat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}hat.isMDXComponent=!0;const kat={toc:[]};function yat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}yat.isMDXComponent=!0;const fat={toc:[]};function Mat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Mat.isMDXComponent=!0;const Dat={toc:[]};function wat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}wat.isMDXComponent=!0;const _at={toc:[]};function Xat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_at,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Xat.isMDXComponent=!0;const gat={toc:[]};function Tat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Tat.isMDXComponent=!0;const xat={toc:[]};function Cat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Cat.isMDXComponent=!0;const vat={toc:[]};function Lat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Lat.isMDXComponent=!0;const Zat={toc:[]};function bat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}bat.isMDXComponent=!0;const Nat={toc:[]};function zat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}zat.isMDXComponent=!0;const Aat={toc:[]};function Wat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Wat.isMDXComponent=!0;const Rat={toc:[]};function Iat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Iat.isMDXComponent=!0;const Sat={toc:[]};function Pat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Pat.isMDXComponent=!0;const Eat={toc:[]};function Bat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Bat.isMDXComponent=!0;const Gat={toc:[]};function Oat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Oat.isMDXComponent=!0;const Uat={toc:[]};function Fat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Fat.isMDXComponent=!0;const qat={toc:[]};function Vat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Vat.isMDXComponent=!0;const jat={toc:[]};function Hat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Hat.isMDXComponent=!0;const Qat={toc:[]};function $at(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}$at.isMDXComponent=!0;const Yat={toc:[]};function Kat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Kat.isMDXComponent=!0;const Jat={toc:[]};function tlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}tlt.isMDXComponent=!0;const nlt={toc:[]};function elt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}elt.isMDXComponent=!0;const olt={toc:[]};function plt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},olt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}plt.isMDXComponent=!0;const rlt={toc:[]};function slt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}slt.isMDXComponent=!0;const clt={toc:[]};function ilt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},clt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}ilt.isMDXComponent=!0;const alt={toc:[]};function llt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},alt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}llt.isMDXComponent=!0;const ult={toc:[]};function mlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ult,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}mlt.isMDXComponent=!0;const dlt={toc:[]};function hlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}hlt.isMDXComponent=!0;const klt={toc:[]};function ylt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},klt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}ylt.isMDXComponent=!0;const flt={toc:[]};function Mlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},flt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Mlt.isMDXComponent=!0;const Dlt={toc:[]};function wlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}wlt.isMDXComponent=!0;const _lt={toc:[]};function Xlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_lt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Xlt.isMDXComponent=!0;const glt={toc:[]};function Tlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},glt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Tlt.isMDXComponent=!0;const xlt={toc:[]};function Clt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Clt.isMDXComponent=!0;const vlt={toc:[]};function Llt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Llt.isMDXComponent=!0;const Zlt={toc:[]};function blt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}blt.isMDXComponent=!0;const Nlt={toc:[]};function zlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}zlt.isMDXComponent=!0;const Alt={toc:[]};function Wlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Alt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Wlt.isMDXComponent=!0;const Rlt={toc:[]};function Ilt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Ilt.isMDXComponent=!0;const Slt={toc:[]};function Plt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Slt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Plt.isMDXComponent=!0;const Elt={toc:[]};function Blt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Elt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Blt.isMDXComponent=!0;const Glt={toc:[]};function Olt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Glt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Olt.isMDXComponent=!0;const Ult={toc:[]};function Flt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ult,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Flt.isMDXComponent=!0;const qlt={toc:[]};function Vlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Vlt.isMDXComponent=!0;const jlt={toc:[]};function Hlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Hlt.isMDXComponent=!0;const Qlt={toc:[]};function $lt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}$lt.isMDXComponent=!0;const Ylt={toc:[]};function Klt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ylt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Klt.isMDXComponent=!0;const Jlt={toc:[]};function tut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}tut.isMDXComponent=!0;const nut={toc:[]};function eut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}eut.isMDXComponent=!0;const out={toc:[]};function put(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},out,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}put.isMDXComponent=!0;const rut={toc:[]};function sut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}sut.isMDXComponent=!0;const cut={toc:[]};function iut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}iut.isMDXComponent=!0;const aut={toc:[]};function lut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}lut.isMDXComponent=!0;const uut={toc:[]};function mut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}mut.isMDXComponent=!0;const dut={toc:[]};function hut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}hut.isMDXComponent=!0;const kut={toc:[]};function yut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}yut.isMDXComponent=!0;const fut={toc:[]};function Mut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Mut.isMDXComponent=!0;const Dut={toc:[]};function wut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wut.isMDXComponent=!0;const _ut={toc:[]};function Xut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Xut.isMDXComponent=!0;const gut={toc:[]};function Tut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Tut.isMDXComponent=!0;const xut={toc:[]};function Cut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Cut.isMDXComponent=!0;const vut={toc:[]};function Lut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Lut.isMDXComponent=!0;const Zut={toc:[]};function but(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}but.isMDXComponent=!0;const Nut={toc:[]};function zut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}zut.isMDXComponent=!0;const Aut={toc:[]};function Wut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Wut.isMDXComponent=!0;const Rut={toc:[]};function Iut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Iut.isMDXComponent=!0;const Sut={toc:[]};function Put(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Put.isMDXComponent=!0;const Eut={toc:[]};function But(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}But.isMDXComponent=!0;const Gut={toc:[]};function Out(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Out.isMDXComponent=!0;const Uut={toc:[]};function Fut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Fut.isMDXComponent=!0;const qut={toc:[]};function Vut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Vut.isMDXComponent=!0;const jut={toc:[]};function Hut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Hut.isMDXComponent=!0;const Qut={toc:[]};function $ut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}$ut.isMDXComponent=!0;const Yut={toc:[]};function Kut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Kut.isMDXComponent=!0;const Jut={toc:[]};function tmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}tmt.isMDXComponent=!0;const nmt={toc:[]};function emt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}emt.isMDXComponent=!0;const omt={toc:[]};function pmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},omt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}pmt.isMDXComponent=!0;const rmt={toc:[]};function smt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}smt.isMDXComponent=!0;const cmt={toc:[]};function imt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}imt.isMDXComponent=!0;const amt={toc:[]};function lmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},amt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lmt.isMDXComponent=!0;const umt={toc:[]};function mmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},umt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}mmt.isMDXComponent=!0;const dmt={toc:[]};function hmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}hmt.isMDXComponent=!0;const kmt={toc:[]};function ymt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}ymt.isMDXComponent=!0;const fmt={toc:[]};function Mmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Mmt.isMDXComponent=!0;const Dmt={toc:[]};function wmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}wmt.isMDXComponent=!0;const _mt={toc:[]};function Xmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_mt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Xmt.isMDXComponent=!0;const gmt={toc:[]};function Tmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Tmt.isMDXComponent=!0;const xmt={toc:[]};function Cmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Cmt.isMDXComponent=!0;const vmt={toc:[]};function Lmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Lmt.isMDXComponent=!0;const Zmt={toc:[]};function bmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}bmt.isMDXComponent=!0;const Nmt={toc:[]};function zmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}zmt.isMDXComponent=!0;const Amt={toc:[]};function Wmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Amt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Wmt.isMDXComponent=!0;const Rmt={toc:[]};function Imt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Imt.isMDXComponent=!0;const Smt={toc:[]};function Pmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Smt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Pmt.isMDXComponent=!0;const Emt={toc:[]};function Bmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Emt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Bmt.isMDXComponent=!0;const Gmt={toc:[]};function Omt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Omt.isMDXComponent=!0;const Umt={toc:[]};function Fmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Umt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Fmt.isMDXComponent=!0;const qmt={toc:[]};function Vmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Vmt.isMDXComponent=!0;const jmt={toc:[]};function Hmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Hmt.isMDXComponent=!0;const Qmt={toc:[]};function $mt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}$mt.isMDXComponent=!0;const Ymt={toc:[]};function Kmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ymt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Kmt.isMDXComponent=!0;const Jmt={toc:[]};function tdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}tdt.isMDXComponent=!0;const ndt={toc:[]};function edt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ndt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}edt.isMDXComponent=!0;const odt={toc:[]};function pdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},odt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}pdt.isMDXComponent=!0;const rdt={toc:[]};function sdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}sdt.isMDXComponent=!0;const cdt={toc:[]};function idt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}idt.isMDXComponent=!0;const adt={toc:[]};function ldt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},adt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}ldt.isMDXComponent=!0;const udt={toc:[]};function mdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},udt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}mdt.isMDXComponent=!0;const ddt={toc:[]};function hdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ddt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}hdt.isMDXComponent=!0;const kdt={toc:[]};function ydt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}ydt.isMDXComponent=!0;const fdt={toc:[]};function Mdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Mdt.isMDXComponent=!0;const Ddt={toc:[]};function wdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ddt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}wdt.isMDXComponent=!0;const _dt={toc:[]};function Xdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Xdt.isMDXComponent=!0;const gdt={toc:[]};function Tdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Tdt.isMDXComponent=!0;const xdt={toc:[]};function Cdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Cdt.isMDXComponent=!0;const vdt={toc:[]};function Ldt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Ldt.isMDXComponent=!0;const Zdt={toc:[]};function bdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}bdt.isMDXComponent=!0;const Ndt={toc:[]};function zdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ndt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}zdt.isMDXComponent=!0;const Adt={toc:[]};function Wdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Adt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Wdt.isMDXComponent=!0;const Rdt={toc:[]};function Idt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Idt.isMDXComponent=!0;const Sdt={toc:[]};function Pdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Pdt.isMDXComponent=!0;const Edt={toc:[]};function Bdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Edt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Bdt.isMDXComponent=!0;const Gdt={toc:[]};function Odt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Odt.isMDXComponent=!0;const Udt={toc:[]};function Fdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Udt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Fdt.isMDXComponent=!0;const qdt={toc:[]};function Vdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Vdt.isMDXComponent=!0;const jdt={toc:[]};function Hdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Hdt.isMDXComponent=!0;const Qdt={toc:[]};function $dt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}$dt.isMDXComponent=!0;const Ydt={toc:[]};function Kdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ydt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Kdt.isMDXComponent=!0;const Jdt={toc:[]};function tht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}tht.isMDXComponent=!0;const nht={toc:[]};function eht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}eht.isMDXComponent=!0;const oht={toc:[]};function pht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}pht.isMDXComponent=!0;const rht={toc:[]};function sht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}sht.isMDXComponent=!0;const cht={toc:[]};function iht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}iht.isMDXComponent=!0;const aht={toc:[]};function lht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}lht.isMDXComponent=!0;const uht={toc:[]};function mht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}mht.isMDXComponent=!0;const dht={toc:[]};function hht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}hht.isMDXComponent=!0;const kht={toc:[]};function yht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}yht.isMDXComponent=!0;const fht={toc:[]};function Mht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Mht.isMDXComponent=!0;const Dht={toc:[]};function wht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}wht.isMDXComponent=!0;const _ht={toc:[]};function Xht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Xht.isMDXComponent=!0;const ght={toc:[]};function Tht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ght,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Tht.isMDXComponent=!0;const xht={toc:[]};function Cht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Cht.isMDXComponent=!0;const vht={toc:[]};function Lht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Lht.isMDXComponent=!0;const Zht={toc:[]};function bht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}bht.isMDXComponent=!0;const Nht={toc:[]};function zht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}zht.isMDXComponent=!0;const Aht={toc:[]};function Wht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Wht.isMDXComponent=!0;const Rht={toc:[]};function Iht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Iht.isMDXComponent=!0;const Sht={toc:[]};function Pht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Pht.isMDXComponent=!0;const Eht={toc:[]};function Bht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Bht.isMDXComponent=!0;const Ght={toc:[]};function Oht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ght,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Oht.isMDXComponent=!0;const Uht={toc:[]};function Fht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Fht.isMDXComponent=!0;const qht={toc:[]};function Vht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Vht.isMDXComponent=!0;const jht={toc:[]};function Hht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Hht.isMDXComponent=!0;const Qht={toc:[]};function $ht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$ht.isMDXComponent=!0;const Yht={toc:[]};function Kht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Kht.isMDXComponent=!0;const Jht={toc:[]};function tkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}tkt.isMDXComponent=!0;const nkt={toc:[]};function ekt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}ekt.isMDXComponent=!0;const okt={toc:[]};function pkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},okt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}pkt.isMDXComponent=!0;const rkt={toc:[]};function skt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}skt.isMDXComponent=!0;const ckt={toc:[]};function ikt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ckt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}ikt.isMDXComponent=!0;const akt={toc:[]};function lkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},akt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}lkt.isMDXComponent=!0;const ukt={toc:[]};function mkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ukt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}mkt.isMDXComponent=!0;const dkt={toc:[]};function hkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}hkt.isMDXComponent=!0;const kkt={toc:[]};function ykt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}ykt.isMDXComponent=!0;const fkt={toc:[]};function Mkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Mkt.isMDXComponent=!0;const Dkt={toc:[]};function wkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wkt.isMDXComponent=!0;const _kt={toc:[]};function Xkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_kt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Xkt.isMDXComponent=!0;const gkt={toc:[]};function Tkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Tkt.isMDXComponent=!0;const xkt={toc:[]};function Ckt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Ckt.isMDXComponent=!0;const vkt={toc:[]};function Lkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Lkt.isMDXComponent=!0;const Zkt={toc:[]};function bkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bkt.isMDXComponent=!0;const Nkt={toc:[]};function zkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}zkt.isMDXComponent=!0;const Akt={toc:[]};function Wkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Akt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Wkt.isMDXComponent=!0;const Rkt={toc:[]};function Ikt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Ikt.isMDXComponent=!0;const Skt={toc:[]};function Pkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Skt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Pkt.isMDXComponent=!0;const Ekt={toc:[]};function Bkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ekt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Bkt.isMDXComponent=!0;const Gkt={toc:[]};function Okt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Okt.isMDXComponent=!0;const Ukt={toc:[]};function Fkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ukt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Fkt.isMDXComponent=!0;const qkt={toc:[]};function Vkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Vkt.isMDXComponent=!0;const jkt={toc:[]};function Hkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Hkt.isMDXComponent=!0;const Qkt={toc:[]};function $kt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,s.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,s.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticable if the number of sides is low, e.g. for a\ntriangle."))}$kt.isMDXComponent=!0;const Ykt={toc:[]};function Kkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ykt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}Kkt.isMDXComponent=!0;const Jkt={toc:[]};function tyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing regular polygons."))}tyt.isMDXComponent=!0;const nyt={toc:[]};function eyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}eyt.isMDXComponent=!0;const oyt={toc:[]};function pyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}pyt.isMDXComponent=!0;const ryt={toc:[]};function syt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ryt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}syt.isMDXComponent=!0;const cyt={toc:[]};function iyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}iyt.isMDXComponent=!0;const ayt={toc:[]};function lyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ayt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}lyt.isMDXComponent=!0;const uyt={toc:[]};function myt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}myt.isMDXComponent=!0;const dyt={toc:[]};function hyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}hyt.isMDXComponent=!0;const kyt={toc:[]};function yyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}yyt.isMDXComponent=!0;const fyt={toc:[]};function Myt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Myt.isMDXComponent=!0;const Dyt={toc:[]};function wyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}wyt.isMDXComponent=!0;const _yt={toc:[]};function Xyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_yt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Xyt.isMDXComponent=!0;const gyt={toc:[]};function Tyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Tyt.isMDXComponent=!0;const xyt={toc:[]};function Cyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Cyt.isMDXComponent=!0;const vyt={toc:[]};function Lyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Lyt.isMDXComponent=!0;const Zyt={toc:[]};function byt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}byt.isMDXComponent=!0;const Nyt={toc:[]};function zyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}zyt.isMDXComponent=!0;const Ayt={toc:[]};function Wyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ayt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Wyt.isMDXComponent=!0;const Ryt={toc:[]};function Iyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ryt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Iyt.isMDXComponent=!0;const Syt={toc:[]};function Pyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Syt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Pyt.isMDXComponent=!0;const Eyt={toc:[]};function Byt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Byt.isMDXComponent=!0;const Gyt={toc:[]};function Oyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Oyt.isMDXComponent=!0;const Uyt={toc:[]};function Fyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Fyt.isMDXComponent=!0;const qyt={toc:[]};function Vyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Vyt.isMDXComponent=!0;const jyt={toc:[]};function Hyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}Hyt.isMDXComponent=!0;const Qyt={toc:[]};function $yt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}$yt.isMDXComponent=!0;const Yyt={toc:[]};function Kyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}Kyt.isMDXComponent=!0;const Jyt={toc:[]};function tft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}tft.isMDXComponent=!0;const nft={toc:[]};function eft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}eft.isMDXComponent=!0;const oft={toc:[]};function pft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}pft.isMDXComponent=!0;const rft={toc:[]};function sft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}sft.isMDXComponent=!0;const cft={toc:[]};function ift(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}ift.isMDXComponent=!0;const aft={toc:[]};function lft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}lft.isMDXComponent=!0;const uft={toc:[]};function mft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}mft.isMDXComponent=!0;const dft={toc:[]};function hft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}hft.isMDXComponent=!0;const kft={toc:[]};function yft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}yft.isMDXComponent=!0;const fft={toc:[]};function Mft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Mft.isMDXComponent=!0;const Dft={toc:[]};function wft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}wft.isMDXComponent=!0;const _ft={toc:[]};function Xft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Xft.isMDXComponent=!0;const gft={toc:[]};function Tft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Tft.isMDXComponent=!0;const xft={toc:[]};function Cft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Cft.isMDXComponent=!0;const vft={toc:[]};function Lft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Lft.isMDXComponent=!0;const Zft={toc:[]};function bft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}bft.isMDXComponent=!0;const Nft={toc:[]};function zft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}zft.isMDXComponent=!0;const Aft={toc:[]};function Wft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Wft.isMDXComponent=!0;const Rft={toc:[]};function Ift(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Ift.isMDXComponent=!0;const Sft={toc:[]};function Pft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Pft.isMDXComponent=!0;const Eft={toc:[]};function Bft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Bft.isMDXComponent=!0;const Gft={toc:[]};function Oft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Oft.isMDXComponent=!0;const Uft={toc:[]};function Fft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Fft.isMDXComponent=!0;const qft={toc:[]};function Vft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Vft.isMDXComponent=!0;const jft={toc:[]};function Hft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Hft.isMDXComponent=!0;const Qft={toc:[]};function $ft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}$ft.isMDXComponent=!0;const Yft={toc:[]};function Kft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Kft.isMDXComponent=!0;const Jft={toc:[]};function tMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}tMt.isMDXComponent=!0;const nMt={toc:[]};function eMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}eMt.isMDXComponent=!0;const oMt={toc:[]};function pMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}pMt.isMDXComponent=!0;const rMt={toc:[]};function sMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}sMt.isMDXComponent=!0;const cMt={toc:[]};function iMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}iMt.isMDXComponent=!0;const aMt={toc:[]};function lMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}lMt.isMDXComponent=!0;const uMt={toc:[]};function mMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}mMt.isMDXComponent=!0;const dMt={toc:[]};function hMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}hMt.isMDXComponent=!0;const kMt={toc:[]};function yMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}yMt.isMDXComponent=!0;const fMt={toc:[]};function MMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}MMt.isMDXComponent=!0;const DMt={toc:[]};function wMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}wMt.isMDXComponent=!0;const _Mt={toc:[]};function XMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Mt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}XMt.isMDXComponent=!0;const gMt={toc:[]};function TMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}TMt.isMDXComponent=!0;const xMt={toc:[]};function CMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}CMt.isMDXComponent=!0;const vMt={toc:[]};function LMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}LMt.isMDXComponent=!0;const ZMt={toc:[]};function bMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}bMt.isMDXComponent=!0;const NMt={toc:[]};function zMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}zMt.isMDXComponent=!0;const AMt={toc:[]};function WMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}WMt.isMDXComponent=!0;const RMt={toc:[]};function IMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}IMt.isMDXComponent=!0;const SMt={toc:[]};function PMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}PMt.isMDXComponent=!0;const EMt={toc:[]};function BMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}BMt.isMDXComponent=!0;const GMt={toc:[]};function OMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}OMt.isMDXComponent=!0;const UMt={toc:[]};function FMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}FMt.isMDXComponent=!0;const qMt={toc:[]};function VMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}VMt.isMDXComponent=!0;const jMt={toc:[]};function HMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}HMt.isMDXComponent=!0;const QMt={toc:[]};function $Mt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}$Mt.isMDXComponent=!0;const YMt={toc:[]};function KMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}KMt.isMDXComponent=!0;const JMt={toc:[]};function tDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}tDt.isMDXComponent=!0;const nDt={toc:[]};function eDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}eDt.isMDXComponent=!0;const oDt={toc:[]};function pDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}pDt.isMDXComponent=!0;const rDt={toc:[]};function sDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}sDt.isMDXComponent=!0;const cDt={toc:[]};function iDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}iDt.isMDXComponent=!0;const aDt={toc:[]};function lDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}lDt.isMDXComponent=!0;const uDt={toc:[]};function mDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}mDt.isMDXComponent=!0;const dDt={toc:[]};function hDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}hDt.isMDXComponent=!0;const kDt={toc:[]};function yDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}yDt.isMDXComponent=!0;const fDt={toc:[]};function MDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}MDt.isMDXComponent=!0;const DDt={toc:[]};function wDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}wDt.isMDXComponent=!0;const _Dt={toc:[]};function XDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}XDt.isMDXComponent=!0;const gDt={toc:[]};function TDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}TDt.isMDXComponent=!0;const xDt={toc:[]};function CDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}CDt.isMDXComponent=!0;const vDt={toc:[]};function LDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}LDt.isMDXComponent=!0;const ZDt={toc:[]};function bDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}bDt.isMDXComponent=!0;const NDt={toc:[]};function zDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}zDt.isMDXComponent=!0;const ADt={toc:[]};function WDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}WDt.isMDXComponent=!0;const RDt={toc:[]};function IDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}IDt.isMDXComponent=!0;const SDt={toc:[]};function PDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}PDt.isMDXComponent=!0;const EDt={toc:[]};function BDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}BDt.isMDXComponent=!0;const GDt={toc:[]};function ODt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}ODt.isMDXComponent=!0;const UDt={toc:[]};function FDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}FDt.isMDXComponent=!0;const qDt={toc:[]};function VDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}VDt.isMDXComponent=!0;const jDt={toc:[]};function HDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}HDt.isMDXComponent=!0;const QDt={toc:[]};function $Dt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}$Dt.isMDXComponent=!0;const YDt={toc:[]};function KDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}KDt.isMDXComponent=!0;const JDt={toc:[]};function twt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}twt.isMDXComponent=!0;const nwt={toc:[]};function ewt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}ewt.isMDXComponent=!0;const owt={toc:[]};function pwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},owt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}pwt.isMDXComponent=!0;const rwt={toc:[]};function swt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}swt.isMDXComponent=!0;const cwt={toc:[]};function iwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}iwt.isMDXComponent=!0;const awt={toc:[]};function lwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}lwt.isMDXComponent=!0;const uwt={toc:[]};function mwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}mwt.isMDXComponent=!0;const dwt={toc:[]};function hwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}hwt.isMDXComponent=!0;const kwt={toc:[]};function ywt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}ywt.isMDXComponent=!0;const fwt={toc:[]};function Mwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Mwt.isMDXComponent=!0;const Dwt={toc:[]};function wwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}wwt.isMDXComponent=!0;const _wt={toc:[]};function Xwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_wt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Xwt.isMDXComponent=!0;const gwt={toc:[]};function Twt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Twt.isMDXComponent=!0;const xwt={toc:[]};function Cwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}Cwt.isMDXComponent=!0;const vwt={toc:[]};function Lwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}Lwt.isMDXComponent=!0;const Zwt={toc:[]};function bwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}bwt.isMDXComponent=!0;const Nwt={toc:[]};function zwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}zwt.isMDXComponent=!0;const Awt={toc:[]};function Wwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Wwt.isMDXComponent=!0;const Rwt={toc:[]};function Iwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Iwt.isMDXComponent=!0;const Swt={toc:[]};function Pwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Swt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Pwt.isMDXComponent=!0;const Ewt={toc:[]};function Bwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ewt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Bwt.isMDXComponent=!0;const Gwt={toc:[]};function Owt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Owt.isMDXComponent=!0;const Uwt={toc:[]};function Fwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Fwt.isMDXComponent=!0;const qwt={toc:[]};function Vwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Vwt.isMDXComponent=!0;const jwt={toc:[]};function Hwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Hwt.isMDXComponent=!0;const Qwt={toc:[]};function $wt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}$wt.isMDXComponent=!0;const Ywt={toc:[]};function Kwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ywt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Kwt.isMDXComponent=!0;const Jwt={toc:[]};function t_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}t_t.isMDXComponent=!0;const n_t={toc:[]};function e_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}e_t.isMDXComponent=!0;const o_t={toc:[]};function p_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}p_t.isMDXComponent=!0;const r_t={toc:[]};function s_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}s_t.isMDXComponent=!0;const c_t={toc:[]};function i_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}i_t.isMDXComponent=!0;const a_t={toc:[]};function l_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}l_t.isMDXComponent=!0;const u_t={toc:[]};function m_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}m_t.isMDXComponent=!0;const d_t={toc:[]};function h_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}h_t.isMDXComponent=!0;const k_t={toc:[]};function y_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}y_t.isMDXComponent=!0;const f_t={toc:[]};function M_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}M_t.isMDXComponent=!0;const D_t={toc:[]};function w_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}w_t.isMDXComponent=!0;const __t={toc:[]};function X_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},__t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}X_t.isMDXComponent=!0;const g_t={toc:[]};function T_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}T_t.isMDXComponent=!0;const x_t={toc:[]};function C_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}C_t.isMDXComponent=!0;const v_t={toc:[]};function L_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}L_t.isMDXComponent=!0;const Z_t={toc:[]};function b_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}b_t.isMDXComponent=!0;const N_t={toc:[]};function z_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}z_t.isMDXComponent=!0;const A_t={toc:[]};function W_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}W_t.isMDXComponent=!0;const R_t={toc:[]};function I_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}I_t.isMDXComponent=!0;const S_t={toc:[]};function P_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}P_t.isMDXComponent=!0;const E_t={toc:[]};function B_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}B_t.isMDXComponent=!0;const G_t={toc:[]};function O_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}O_t.isMDXComponent=!0;const U_t={toc:[]};function F_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}F_t.isMDXComponent=!0;const q_t={toc:[]};function V_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}V_t.isMDXComponent=!0;const j_t={toc:[]};function H_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}H_t.isMDXComponent=!0;const Q_t={toc:[]};function $_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}$_t.isMDXComponent=!0;const Y_t={toc:[]};function K_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}K_t.isMDXComponent=!0;const J_t={toc:[]};function tXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}tXt.isMDXComponent=!0;const nXt={toc:[]};function eXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}eXt.isMDXComponent=!0;const oXt={toc:[]};function pXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}pXt.isMDXComponent=!0;const rXt={toc:[]};function sXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}sXt.isMDXComponent=!0;const cXt={toc:[]};function iXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}iXt.isMDXComponent=!0;const aXt={toc:[]};function lXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}lXt.isMDXComponent=!0;const uXt={toc:[]};function mXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}mXt.isMDXComponent=!0;const dXt={toc:[]};function hXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}hXt.isMDXComponent=!0;const kXt={toc:[]};function yXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The control point of the B\xe9zier curve."))}yXt.isMDXComponent=!0;const fXt={toc:[]};function MXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}MXt.isMDXComponent=!0;const DXt={toc:[]};function wXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}wXt.isMDXComponent=!0;const _Xt={toc:[]};function XXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Xt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}XXt.isMDXComponent=!0;const gXt={toc:[]};function TXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}TXt.isMDXComponent=!0;const xXt={toc:[]};function CXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}CXt.isMDXComponent=!0;const vXt={toc:[]};function LXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}LXt.isMDXComponent=!0;const ZXt={toc:[]};function bXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}bXt.isMDXComponent=!0;const NXt={toc:[]};function zXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}zXt.isMDXComponent=!0;const AXt={toc:[]};function WXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}WXt.isMDXComponent=!0;const RXt={toc:[]};function IXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}IXt.isMDXComponent=!0;const SXt={toc:[]};function PXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}PXt.isMDXComponent=!0;const EXt={toc:[]};function BXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}BXt.isMDXComponent=!0;const GXt={toc:[]};function OXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}OXt.isMDXComponent=!0;const UXt={toc:[]};function FXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}FXt.isMDXComponent=!0;const qXt={toc:[]};function VXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}VXt.isMDXComponent=!0;const jXt={toc:[]};function HXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}HXt.isMDXComponent=!0;const QXt={toc:[]};function $Xt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}$Xt.isMDXComponent=!0;const YXt={toc:[]};function KXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}KXt.isMDXComponent=!0;const JXt={toc:[]};function tgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}tgt.isMDXComponent=!0;const ngt={toc:[]};function egt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ngt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}egt.isMDXComponent=!0;const ogt={toc:[]};function pgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ogt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pgt.isMDXComponent=!0;const rgt={toc:[]};function sgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}sgt.isMDXComponent=!0;const cgt={toc:[]};function igt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}igt.isMDXComponent=!0;const agt={toc:[]};function lgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},agt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}lgt.isMDXComponent=!0;const ugt={toc:[]};function mgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ugt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}mgt.isMDXComponent=!0;const dgt={toc:[]};function hgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}hgt.isMDXComponent=!0;const kgt={toc:[]};function ygt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}ygt.isMDXComponent=!0;const fgt={toc:[]};function Mgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Mgt.isMDXComponent=!0;const Dgt={toc:[]};function wgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}wgt.isMDXComponent=!0;const _gt={toc:[]};function Xgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Xgt.isMDXComponent=!0;const ggt={toc:[]};function Tgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ggt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Tgt.isMDXComponent=!0;const xgt={toc:[]};function Cgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Cgt.isMDXComponent=!0;const vgt={toc:[]};function Lgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Lgt.isMDXComponent=!0;const Zgt={toc:[]};function bgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}bgt.isMDXComponent=!0;const Ngt={toc:[]};function zgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ngt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}zgt.isMDXComponent=!0;const Agt={toc:[]};function Wgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Agt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Wgt.isMDXComponent=!0;const Rgt={toc:[]};function Igt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Igt.isMDXComponent=!0;const Sgt={toc:[]};function Pgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Pgt.isMDXComponent=!0;const Egt={toc:[]};function Bgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Egt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Bgt.isMDXComponent=!0;const Ggt={toc:[]};function Ogt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ggt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Ogt.isMDXComponent=!0;const Ugt={toc:[]};function Fgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ugt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Fgt.isMDXComponent=!0;const qgt={toc:[]};function Vgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Vgt.isMDXComponent=!0;const jgt={toc:[]};function Hgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Hgt.isMDXComponent=!0;const Qgt={toc:[]};function $gt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}$gt.isMDXComponent=!0;const Ygt={toc:[]};function Kgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ygt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Kgt.isMDXComponent=!0;const Jgt={toc:[]};function tTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}tTt.isMDXComponent=!0;const nTt={toc:[]};function eTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}eTt.isMDXComponent=!0;const oTt={toc:[]};function pTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}pTt.isMDXComponent=!0;const rTt={toc:[]};function sTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}sTt.isMDXComponent=!0;const cTt={toc:[]};function iTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}iTt.isMDXComponent=!0;const aTt={toc:[]};function lTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}lTt.isMDXComponent=!0;const uTt={toc:[]};function mTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}mTt.isMDXComponent=!0;const dTt={toc:[]};function hTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}hTt.isMDXComponent=!0;const kTt={toc:[]};function yTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}yTt.isMDXComponent=!0;const fTt={toc:[]};function MTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}MTt.isMDXComponent=!0;const DTt={toc:[]};function wTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}wTt.isMDXComponent=!0;const _Tt={toc:[]};function XTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Tt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}XTt.isMDXComponent=!0;const gTt={toc:[]};function TTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}TTt.isMDXComponent=!0;const xTt={toc:[]};function CTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}CTt.isMDXComponent=!0;const vTt={toc:[]};function LTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}LTt.isMDXComponent=!0;const ZTt={toc:[]};function bTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}bTt.isMDXComponent=!0;const NTt={toc:[]};function zTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}zTt.isMDXComponent=!0;const ATt={toc:[]};function WTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ATt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}WTt.isMDXComponent=!0;const RTt={toc:[]};function ITt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}ITt.isMDXComponent=!0;const STt={toc:[]};function PTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},STt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}PTt.isMDXComponent=!0;const ETt={toc:[]};function BTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ETt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}BTt.isMDXComponent=!0;const GTt={toc:[]};function OTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}OTt.isMDXComponent=!0;const UTt={toc:[]};function FTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}FTt.isMDXComponent=!0;const qTt={toc:[]};function VTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}VTt.isMDXComponent=!0;const jTt={toc:[]};function HTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}HTt.isMDXComponent=!0;const QTt={toc:[]};function $Tt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}$Tt.isMDXComponent=!0;const YTt={toc:[]};function KTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}KTt.isMDXComponent=!0;const JTt={toc:[]};function txt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}txt.isMDXComponent=!0;const nxt={toc:[]};function ext(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ext.isMDXComponent=!0;const oxt={toc:[]};function pxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}pxt.isMDXComponent=!0;const rxt={toc:[]};function sxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}sxt.isMDXComponent=!0;const cxt={toc:[]};function ixt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}ixt.isMDXComponent=!0;const axt={toc:[]};function lxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},axt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}lxt.isMDXComponent=!0;const uxt={toc:[]};function mxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}mxt.isMDXComponent=!0;const dxt={toc:[]};function hxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}hxt.isMDXComponent=!0;const kxt={toc:[]};function yxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}yxt.isMDXComponent=!0;const fxt={toc:[]};function Mxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Mxt.isMDXComponent=!0;const Dxt={toc:[]};function wxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}wxt.isMDXComponent=!0;const _xt={toc:[]};function Xxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_xt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Xxt.isMDXComponent=!0;const gxt={toc:[]};function Txt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Txt.isMDXComponent=!0;const xxt={toc:[]};function Cxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Cxt.isMDXComponent=!0;const vxt={toc:[]};function Lxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Lxt.isMDXComponent=!0;const Zxt={toc:[]};function bxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}bxt.isMDXComponent=!0;const Nxt={toc:[]};function zxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}zxt.isMDXComponent=!0;const Axt={toc:[]};function Wxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Axt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Wxt.isMDXComponent=!0;const Rxt={toc:[]};function Ixt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Ixt.isMDXComponent=!0;const Sxt={toc:[]};function Pxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Pxt.isMDXComponent=!0;const Ext={toc:[]};function Bxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ext,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Bxt.isMDXComponent=!0;const Gxt={toc:[]};function Oxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Oxt.isMDXComponent=!0;const Uxt={toc:[]};function Fxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Fxt.isMDXComponent=!0;const qxt={toc:[]};function Vxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Vxt.isMDXComponent=!0;const jxt={toc:[]};function Hxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Hxt.isMDXComponent=!0;const Qxt={toc:[]};function $xt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}$xt.isMDXComponent=!0;const Yxt={toc:[]};function Kxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Kxt.isMDXComponent=!0;const Jxt={toc:[]};function tCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}tCt.isMDXComponent=!0;const nCt={toc:[]};function eCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}eCt.isMDXComponent=!0;const oCt={toc:[]};function pCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}pCt.isMDXComponent=!0;const rCt={toc:[]};function sCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}sCt.isMDXComponent=!0;const cCt={toc:[]};function iCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}iCt.isMDXComponent=!0;const aCt={toc:[]};function lCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}lCt.isMDXComponent=!0;const uCt={toc:[]};function mCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}mCt.isMDXComponent=!0;const dCt={toc:[]};function hCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}hCt.isMDXComponent=!0;const kCt={toc:[]};function yCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}yCt.isMDXComponent=!0;const fCt={toc:[]};function MCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}MCt.isMDXComponent=!0;const DCt={toc:[]};function wCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wCt.isMDXComponent=!0;const _Ct={toc:[]};function XCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}XCt.isMDXComponent=!0;const gCt={toc:[]};function TCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}TCt.isMDXComponent=!0;const xCt={toc:[]};function CCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}CCt.isMDXComponent=!0;const vCt={toc:[]};function LCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}LCt.isMDXComponent=!0;const ZCt={toc:[]};function bCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bCt.isMDXComponent=!0;const NCt={toc:[]};function zCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}zCt.isMDXComponent=!0;const ACt={toc:[]};function WCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ACt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}WCt.isMDXComponent=!0;const RCt={toc:[]};function ICt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}ICt.isMDXComponent=!0;const SCt={toc:[]};function PCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}PCt.isMDXComponent=!0;const ECt={toc:[]};function BCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ECt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}BCt.isMDXComponent=!0;const GCt={toc:[]};function OCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}OCt.isMDXComponent=!0;const UCt={toc:[]};function FCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}FCt.isMDXComponent=!0;const qCt={toc:[]};function VCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}VCt.isMDXComponent=!0;const jCt={toc:[]};function HCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}HCt.isMDXComponent=!0;const QCt={toc:[]};function $Ct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}$Ct.isMDXComponent=!0;const YCt={toc:[]};function KCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@motion-canvas/2d';\nimport {Ray} from '@motion-canvas/2d/lib/components';\nimport {createRef} from '@motion-canvas/core/lib/utils';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}KCt.isMDXComponent=!0;const JCt={toc:[]};function tvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing an individual line segment."))}tvt.isMDXComponent=!0;const nvt={toc:[]};function evt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}evt.isMDXComponent=!0;const ovt={toc:[]};function pvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ovt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}pvt.isMDXComponent=!0;const rvt={toc:[]};function svt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}svt.isMDXComponent=!0;const cvt={toc:[]};function ivt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}ivt.isMDXComponent=!0;const avt={toc:[]};function lvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},avt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}lvt.isMDXComponent=!0;const uvt={toc:[]};function mvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}mvt.isMDXComponent=!0;const dvt={toc:[]};function hvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}hvt.isMDXComponent=!0;const kvt={toc:[]};function yvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}yvt.isMDXComponent=!0;const fvt={toc:[]};function Mvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Mvt.isMDXComponent=!0;const Dvt={toc:[]};function wvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}wvt.isMDXComponent=!0;const _vt={toc:[]};function Xvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_vt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Xvt.isMDXComponent=!0;const gvt={toc:[]};function Tvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Tvt.isMDXComponent=!0;const xvt={toc:[]};function Cvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Cvt.isMDXComponent=!0;const vvt={toc:[]};function Lvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Lvt.isMDXComponent=!0;const Zvt={toc:[]};function bvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}bvt.isMDXComponent=!0;const Nvt={toc:[]};function zvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}zvt.isMDXComponent=!0;const Avt={toc:[]};function Wvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Avt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Wvt.isMDXComponent=!0;const Rvt={toc:[]};function Ivt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Ivt.isMDXComponent=!0;const Svt={toc:[]};function Pvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Svt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Pvt.isMDXComponent=!0;const Evt={toc:[]};function Bvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Evt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Bvt.isMDXComponent=!0;const Gvt={toc:[]};function Ovt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Ovt.isMDXComponent=!0;const Uvt={toc:[]};function Fvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Fvt.isMDXComponent=!0;const qvt={toc:[]};function Vvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}Vvt.isMDXComponent=!0;const jvt={toc:[]};function Hvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Hvt.isMDXComponent=!0;const Qvt={toc:[]};function $vt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}$vt.isMDXComponent=!0;const Yvt={toc:[]};function Kvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Kvt.isMDXComponent=!0;const Jvt={toc:[]};function tLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}tLt.isMDXComponent=!0;const nLt={toc:[]};function eLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}eLt.isMDXComponent=!0;const oLt={toc:[]};function pLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}pLt.isMDXComponent=!0;const rLt={toc:[]};function sLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}sLt.isMDXComponent=!0;const cLt={toc:[]};function iLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}iLt.isMDXComponent=!0;const aLt={toc:[]};function lLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}lLt.isMDXComponent=!0;const uLt={toc:[]};function mLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}mLt.isMDXComponent=!0;const dLt={toc:[]};function hLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}hLt.isMDXComponent=!0;const kLt={toc:[]};function yLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}yLt.isMDXComponent=!0;const fLt={toc:[]};function MLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}MLt.isMDXComponent=!0;const DLt={toc:[]};function wLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}wLt.isMDXComponent=!0;const _Lt={toc:[]};function XLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Lt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}XLt.isMDXComponent=!0;const gLt={toc:[]};function TLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}TLt.isMDXComponent=!0;const xLt={toc:[]};function CLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}CLt.isMDXComponent=!0;const vLt={toc:[]};function LLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}LLt.isMDXComponent=!0;const ZLt={toc:[]};function bLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}bLt.isMDXComponent=!0;const NLt={toc:[]};function zLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}zLt.isMDXComponent=!0;const ALt={toc:[]};function WLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ALt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}WLt.isMDXComponent=!0;const RLt={toc:[]};function ILt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}ILt.isMDXComponent=!0;const SLt={toc:[]};function PLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}PLt.isMDXComponent=!0;const ELt={toc:[]};function BLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ELt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}BLt.isMDXComponent=!0;const GLt={toc:[]};function OLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}OLt.isMDXComponent=!0;const ULt={toc:[]};function FLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ULt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}FLt.isMDXComponent=!0;const qLt={toc:[]};function VLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}VLt.isMDXComponent=!0;const jLt={toc:[]};function HLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}HLt.isMDXComponent=!0;const QLt={toc:[]};function $Lt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}$Lt.isMDXComponent=!0;const YLt={toc:[]};function KLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}KLt.isMDXComponent=!0;const JLt={toc:[]};function tZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}tZt.isMDXComponent=!0;const nZt={toc:[]};function eZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}eZt.isMDXComponent=!0;const oZt={toc:[]};function pZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}pZt.isMDXComponent=!0;const rZt={toc:[]};function sZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}sZt.isMDXComponent=!0;const cZt={toc:[]};function iZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}iZt.isMDXComponent=!0;const aZt={toc:[]};function lZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}lZt.isMDXComponent=!0;const uZt={toc:[]};function mZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}mZt.isMDXComponent=!0;const dZt={toc:[]};function hZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}hZt.isMDXComponent=!0;const kZt={toc:[]};function yZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}yZt.isMDXComponent=!0;const fZt={toc:[]};function MZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}MZt.isMDXComponent=!0;const DZt={toc:[]};function wZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wZt.isMDXComponent=!0;const _Zt={toc:[]};function XZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Zt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}XZt.isMDXComponent=!0;const gZt={toc:[]};function TZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}TZt.isMDXComponent=!0;const xZt={toc:[]};function CZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}CZt.isMDXComponent=!0;const vZt={toc:[]};function LZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}LZt.isMDXComponent=!0;const ZZt={toc:[]};function bZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}bZt.isMDXComponent=!0;const NZt={toc:[]};function zZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}zZt.isMDXComponent=!0;const AZt={toc:[]};function WZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}WZt.isMDXComponent=!0;const RZt={toc:[]};function IZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}IZt.isMDXComponent=!0;const SZt={toc:[]};function PZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}PZt.isMDXComponent=!0;const EZt={toc:[]};function BZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}BZt.isMDXComponent=!0;const GZt={toc:[]};function OZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}OZt.isMDXComponent=!0;const UZt={toc:[]};function FZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}FZt.isMDXComponent=!0;const qZt={toc:[]};function VZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}VZt.isMDXComponent=!0;const jZt={toc:[]};function HZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}HZt.isMDXComponent=!0;const QZt={toc:[]};function $Zt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$Zt.isMDXComponent=!0;const YZt={toc:[]};function KZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}KZt.isMDXComponent=!0;const JZt={toc:[]};function tbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}tbt.isMDXComponent=!0;const nbt={toc:[]};function ebt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ebt.isMDXComponent=!0;const obt={toc:[]};function pbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},obt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}pbt.isMDXComponent=!0;const rbt={toc:[]};function sbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}sbt.isMDXComponent=!0;const cbt={toc:[]};function ibt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}ibt.isMDXComponent=!0;const abt={toc:[]};function lbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},abt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}lbt.isMDXComponent=!0;const ubt={toc:[]};function mbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ubt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}mbt.isMDXComponent=!0;const dbt={toc:[]};function hbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}hbt.isMDXComponent=!0;const kbt={toc:[]};function ybt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}ybt.isMDXComponent=!0;const fbt={toc:[]};function Mbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Mbt.isMDXComponent=!0;const Dbt={toc:[]};function wbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}wbt.isMDXComponent=!0;const _bt={toc:[]};function Xbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_bt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Xbt.isMDXComponent=!0;const gbt={toc:[]};function Tbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Tbt.isMDXComponent=!0;const xbt={toc:[]};function Cbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Cbt.isMDXComponent=!0;const vbt={toc:[]};function Lbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Lbt.isMDXComponent=!0;const Zbt={toc:[]};function bbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}bbt.isMDXComponent=!0;const Nbt={toc:[]};function zbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}zbt.isMDXComponent=!0;const Abt={toc:[]};function Wbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Abt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Wbt.isMDXComponent=!0;const Rbt={toc:[]};function Ibt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Ibt.isMDXComponent=!0;const Sbt={toc:[]};function Pbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Pbt.isMDXComponent=!0;const Ebt={toc:[]};function Bbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ebt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Bbt.isMDXComponent=!0;const Gbt={toc:[]};function Obt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Obt.isMDXComponent=!0;const Ubt={toc:[]};function Fbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ubt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Fbt.isMDXComponent=!0;const qbt={toc:[]};function Vbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Vbt.isMDXComponent=!0;const jbt={toc:[]};function Hbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Hbt.isMDXComponent=!0;const Qbt={toc:[]};function $bt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}$bt.isMDXComponent=!0;const Ybt={toc:[]};function Kbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ybt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Kbt.isMDXComponent=!0;const Jbt={toc:[]};function tNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}tNt.isMDXComponent=!0;const nNt={toc:[]};function eNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}eNt.isMDXComponent=!0;const oNt={toc:[]};function pNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}pNt.isMDXComponent=!0;const rNt={toc:[]};function sNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}sNt.isMDXComponent=!0;const cNt={toc:[]};function iNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}iNt.isMDXComponent=!0;const aNt={toc:[]};function lNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}lNt.isMDXComponent=!0;const uNt={toc:[]};function mNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}mNt.isMDXComponent=!0;const dNt={toc:[]};function hNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}hNt.isMDXComponent=!0;const kNt={toc:[]};function yNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}yNt.isMDXComponent=!0;const fNt={toc:[]};function MNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}MNt.isMDXComponent=!0;const DNt={toc:[]};function wNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}wNt.isMDXComponent=!0;const _Nt={toc:[]};function XNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}XNt.isMDXComponent=!0;const gNt={toc:[]};function TNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}TNt.isMDXComponent=!0;const xNt={toc:[]};function CNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}CNt.isMDXComponent=!0;const vNt={toc:[]};function LNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}LNt.isMDXComponent=!0;const ZNt={toc:[]};function bNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}bNt.isMDXComponent=!0;const NNt={toc:[]};function zNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}zNt.isMDXComponent=!0;const ANt={toc:[]};function WNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ANt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}WNt.isMDXComponent=!0;const RNt={toc:[]};function INt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}INt.isMDXComponent=!0;const SNt={toc:[]};function PNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}PNt.isMDXComponent=!0;const ENt={toc:[]};function BNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ENt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}BNt.isMDXComponent=!0;const GNt={toc:[]};function ONt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}ONt.isMDXComponent=!0;const UNt={toc:[]};function FNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}FNt.isMDXComponent=!0;const qNt={toc:[]};function VNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}VNt.isMDXComponent=!0;const jNt={toc:[]};function HNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}HNt.isMDXComponent=!0;const QNt={toc:[]};function $Nt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}$Nt.isMDXComponent=!0;const YNt={toc:[]};function KNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}KNt.isMDXComponent=!0;const JNt={toc:[]};function tzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}tzt.isMDXComponent=!0;const nzt={toc:[]};function ezt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ezt.isMDXComponent=!0;const ozt={toc:[]};function pzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ozt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}pzt.isMDXComponent=!0;const rzt={toc:[]};function szt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}szt.isMDXComponent=!0;const czt={toc:[]};function izt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},czt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}izt.isMDXComponent=!0;const azt={toc:[]};function lzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},azt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lzt.isMDXComponent=!0;const uzt={toc:[]};function mzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}mzt.isMDXComponent=!0;const dzt={toc:[]};function hzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}hzt.isMDXComponent=!0;const kzt={toc:[]};function yzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}yzt.isMDXComponent=!0;const fzt={toc:[]};function Mzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Mzt.isMDXComponent=!0;const Dzt={toc:[]};function wzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}wzt.isMDXComponent=!0;const _zt={toc:[]};function Xzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_zt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Xzt.isMDXComponent=!0;const gzt={toc:[]};function Tzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Tzt.isMDXComponent=!0;const xzt={toc:[]};function Czt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Czt.isMDXComponent=!0;const vzt={toc:[]};function Lzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Lzt.isMDXComponent=!0;const Zzt={toc:[]};function bzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}bzt.isMDXComponent=!0;const Nzt={toc:[]};function zzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}zzt.isMDXComponent=!0;const Azt={toc:[]};function Wzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Azt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Wzt.isMDXComponent=!0;const Rzt={toc:[]};function Izt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Izt.isMDXComponent=!0;const Szt={toc:[]};function Pzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Szt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Pzt.isMDXComponent=!0;const Ezt={toc:[]};function Bzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ezt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Bzt.isMDXComponent=!0;const Gzt={toc:[]};function Ozt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Ozt.isMDXComponent=!0;const Uzt={toc:[]};function Fzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Fzt.isMDXComponent=!0;const qzt={toc:[]};function Vzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Vzt.isMDXComponent=!0;const jzt={toc:[]};function Hzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Hzt.isMDXComponent=!0;const Qzt={toc:[]};function $zt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}$zt.isMDXComponent=!0;const Yzt={toc:[]};function Kzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Kzt.isMDXComponent=!0;const Jzt={toc:[]};function tAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}tAt.isMDXComponent=!0;const nAt={toc:[]};function eAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}eAt.isMDXComponent=!0;const oAt={toc:[]};function pAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}pAt.isMDXComponent=!0;const rAt={toc:[]};function sAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}sAt.isMDXComponent=!0;const cAt={toc:[]};function iAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}iAt.isMDXComponent=!0;const aAt={toc:[]};function lAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}lAt.isMDXComponent=!0;const uAt={toc:[]};function mAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}mAt.isMDXComponent=!0;const dAt={toc:[]};function hAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}hAt.isMDXComponent=!0;const kAt={toc:[]};function yAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}yAt.isMDXComponent=!0;const fAt={toc:[]};function MAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}MAt.isMDXComponent=!0;const DAt={toc:[]};function wAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}wAt.isMDXComponent=!0;const _At={toc:[]};function XAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_At,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}XAt.isMDXComponent=!0;const gAt={toc:[]};function TAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}TAt.isMDXComponent=!0;const xAt={toc:[]};function CAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}CAt.isMDXComponent=!0;const vAt={toc:[]};function LAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}LAt.isMDXComponent=!0;const ZAt={toc:[]};function bAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}bAt.isMDXComponent=!0;const NAt={toc:[]};function zAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}zAt.isMDXComponent=!0;const AAt={toc:[]};function WAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}WAt.isMDXComponent=!0;const RAt={toc:[]};function IAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}IAt.isMDXComponent=!0;const SAt={toc:[]};function PAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}PAt.isMDXComponent=!0;const EAt={toc:[]};function BAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}BAt.isMDXComponent=!0;const GAt={toc:[]};function OAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}OAt.isMDXComponent=!0;const UAt={toc:[]};function FAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}FAt.isMDXComponent=!0;const qAt={toc:[]};function VAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}VAt.isMDXComponent=!0;const jAt={toc:[]};function HAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}HAt.isMDXComponent=!0;const QAt={toc:[]};function $At(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}$At.isMDXComponent=!0;const YAt={toc:[]};function KAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}KAt.isMDXComponent=!0;const JAt={toc:[]};function tWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}tWt.isMDXComponent=!0;const nWt={toc:[]};function eWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}eWt.isMDXComponent=!0;const oWt={toc:[]};function pWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}pWt.isMDXComponent=!0;const rWt={toc:[]};function sWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}sWt.isMDXComponent=!0;const cWt={toc:[]};function iWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}iWt.isMDXComponent=!0;const aWt={toc:[]};function lWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}lWt.isMDXComponent=!0;const uWt={toc:[]};function mWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}mWt.isMDXComponent=!0;const dWt={toc:[]};function hWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}hWt.isMDXComponent=!0;const kWt={toc:[]};function yWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}yWt.isMDXComponent=!0;const fWt={toc:[]};function MWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}MWt.isMDXComponent=!0;const DWt={toc:[]};function wWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}wWt.isMDXComponent=!0;const _Wt={toc:[]};function XWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Wt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}XWt.isMDXComponent=!0;const gWt={toc:[]};function TWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}TWt.isMDXComponent=!0;const xWt={toc:[]};function CWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}CWt.isMDXComponent=!0;const vWt={toc:[]};function LWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}LWt.isMDXComponent=!0;const ZWt={toc:[]};function bWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}bWt.isMDXComponent=!0;const NWt={toc:[]};function zWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}zWt.isMDXComponent=!0;const AWt={toc:[]};function WWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}WWt.isMDXComponent=!0;const RWt={toc:[]};function IWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}IWt.isMDXComponent=!0;const SWt={toc:[]};function PWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}PWt.isMDXComponent=!0;const EWt={toc:[]};function BWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}BWt.isMDXComponent=!0;const GWt={toc:[]};function OWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}OWt.isMDXComponent=!0;const UWt={toc:[]};function FWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}FWt.isMDXComponent=!0;const qWt={toc:[]};function VWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}VWt.isMDXComponent=!0;const jWt={toc:[]};function HWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}HWt.isMDXComponent=!0;const QWt={toc:[]};function $Wt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}$Wt.isMDXComponent=!0;const YWt={toc:[]};function KWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}KWt.isMDXComponent=!0;const JWt={toc:[]};function tRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}tRt.isMDXComponent=!0;const nRt={toc:[]};function eRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}eRt.isMDXComponent=!0;const oRt={toc:[]};function pRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}pRt.isMDXComponent=!0;const rRt={toc:[]};function sRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}sRt.isMDXComponent=!0;const cRt={toc:[]};function iRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}iRt.isMDXComponent=!0;const aRt={toc:[]};function lRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}lRt.isMDXComponent=!0;const uRt={toc:[]};function mRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}mRt.isMDXComponent=!0;const dRt={toc:[]};function hRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}hRt.isMDXComponent=!0;const kRt={toc:[]};function yRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}yRt.isMDXComponent=!0;const fRt={toc:[]};function MRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}MRt.isMDXComponent=!0;const DRt={toc:[]};function wRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}wRt.isMDXComponent=!0;const _Rt={toc:[]};function XRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Rt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}XRt.isMDXComponent=!0;const gRt={toc:[]};function TRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}TRt.isMDXComponent=!0;const xRt={toc:[]};function CRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}CRt.isMDXComponent=!0;const vRt={toc:[]};function LRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}LRt.isMDXComponent=!0;const ZRt={toc:[]};function bRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}bRt.isMDXComponent=!0;const NRt={toc:[]};function zRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}zRt.isMDXComponent=!0;const ARt={toc:[]};function WRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ARt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}WRt.isMDXComponent=!0;const RRt={toc:[]};function IRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}IRt.isMDXComponent=!0;const SRt={toc:[]};function PRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}PRt.isMDXComponent=!0;const ERt={toc:[]};function BRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ERt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}BRt.isMDXComponent=!0;const GRt={toc:[]};function ORt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}ORt.isMDXComponent=!0;const URt={toc:[]};function FRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},URt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}FRt.isMDXComponent=!0;const qRt={toc:[]};function VRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}VRt.isMDXComponent=!0;const jRt={toc:[]};function HRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}HRt.isMDXComponent=!0;const QRt={toc:[]};function $Rt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}$Rt.isMDXComponent=!0;const YRt={toc:[]};function KRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}KRt.isMDXComponent=!0;const JRt={toc:[]};function tIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}tIt.isMDXComponent=!0;const nIt={toc:[]};function eIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}eIt.isMDXComponent=!0;const oIt={toc:[]};function pIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}pIt.isMDXComponent=!0;const rIt={toc:[]};function sIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}sIt.isMDXComponent=!0;const cIt={toc:[]};function iIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}iIt.isMDXComponent=!0;const aIt={toc:[]};function lIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}lIt.isMDXComponent=!0;const uIt={toc:[]};function mIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}mIt.isMDXComponent=!0;const dIt={toc:[]};function hIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}hIt.isMDXComponent=!0;const kIt={toc:[]};function yIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}yIt.isMDXComponent=!0;const fIt={toc:[]};function MIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}MIt.isMDXComponent=!0;const DIt={toc:[]};function wIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}wIt.isMDXComponent=!0;const _It={toc:[]};function XIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_It,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}XIt.isMDXComponent=!0;const gIt={toc:[]};function TIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}TIt.isMDXComponent=!0;const xIt={toc:[]};function CIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}CIt.isMDXComponent=!0;const vIt={toc:[]};function LIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}LIt.isMDXComponent=!0;const ZIt={toc:[]};function bIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}bIt.isMDXComponent=!0;const NIt={toc:[]};function zIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}zIt.isMDXComponent=!0;const AIt={toc:[]};function WIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}WIt.isMDXComponent=!0;const RIt={toc:[]};function IIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}IIt.isMDXComponent=!0;const SIt={toc:[]};function PIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}PIt.isMDXComponent=!0;const EIt={toc:[]};function BIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}BIt.isMDXComponent=!0;const GIt={toc:[]};function OIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}OIt.isMDXComponent=!0;const UIt={toc:[]};function FIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}FIt.isMDXComponent=!0;const qIt={toc:[]};function VIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}VIt.isMDXComponent=!0;const jIt={toc:[]};function HIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}HIt.isMDXComponent=!0;const QIt={toc:[]};function $It(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}$It.isMDXComponent=!0;const YIt={toc:[]};function KIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}KIt.isMDXComponent=!0;const JIt={toc:[]};function tSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}tSt.isMDXComponent=!0;const nSt={toc:[]};function eSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}eSt.isMDXComponent=!0;const oSt={toc:[]};function pSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}pSt.isMDXComponent=!0;const rSt={toc:[]};function sSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}sSt.isMDXComponent=!0;const cSt={toc:[]};function iSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}iSt.isMDXComponent=!0;const aSt={toc:[]};function lSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}lSt.isMDXComponent=!0;const uSt={toc:[]};function mSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}mSt.isMDXComponent=!0;const dSt={toc:[]};function hSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}hSt.isMDXComponent=!0;const kSt={toc:[]};function ySt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}ySt.isMDXComponent=!0;const fSt={toc:[]};function MSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}MSt.isMDXComponent=!0;const DSt={toc:[]};function wSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}wSt.isMDXComponent=!0;const _St={toc:[]};function XSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_St,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}XSt.isMDXComponent=!0;const gSt={toc:[]};function TSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}TSt.isMDXComponent=!0;const xSt={toc:[]};function CSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}CSt.isMDXComponent=!0;const vSt={toc:[]};function LSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}LSt.isMDXComponent=!0;const ZSt={toc:[]};function bSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}bSt.isMDXComponent=!0;const NSt={toc:[]};function zSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}zSt.isMDXComponent=!0;const ASt={toc:[]};function WSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ASt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}WSt.isMDXComponent=!0;const RSt={toc:[]};function ISt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}ISt.isMDXComponent=!0;const SSt={toc:[]};function PSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}PSt.isMDXComponent=!0;const ESt={toc:[]};function BSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ESt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}BSt.isMDXComponent=!0;const GSt={toc:[]};function OSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}OSt.isMDXComponent=!0;const USt={toc:[]};function FSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},USt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}FSt.isMDXComponent=!0;const qSt={toc:[]};function VSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}VSt.isMDXComponent=!0;const jSt={toc:[]};function HSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}HSt.isMDXComponent=!0;const QSt={toc:[]};function $St(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}$St.isMDXComponent=!0;const YSt={toc:[]};function KSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}KSt.isMDXComponent=!0;const JSt={toc:[]};function tPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}tPt.isMDXComponent=!0;const nPt={toc:[]};function ePt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}ePt.isMDXComponent=!0;const oPt={toc:[]};function pPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}pPt.isMDXComponent=!0;const rPt={toc:[]};function sPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}sPt.isMDXComponent=!0;const cPt={toc:[]};function iPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}iPt.isMDXComponent=!0;const aPt={toc:[]};function lPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lPt.isMDXComponent=!0;const uPt={toc:[]};function mPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}mPt.isMDXComponent=!0;const dPt={toc:[]};function hPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}hPt.isMDXComponent=!0;const kPt={toc:[]};function yPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}yPt.isMDXComponent=!0;const fPt={toc:[]};function MPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}MPt.isMDXComponent=!0;const DPt={toc:[]};function wPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}wPt.isMDXComponent=!0;const _Pt={toc:[]};function XPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Pt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}XPt.isMDXComponent=!0;const gPt={toc:[]};function TPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}TPt.isMDXComponent=!0;const xPt={toc:[]};function CPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}CPt.isMDXComponent=!0;const vPt={toc:[]};function LPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}LPt.isMDXComponent=!0;const ZPt={toc:[]};function bPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}bPt.isMDXComponent=!0;const NPt={toc:[]};function zPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}zPt.isMDXComponent=!0;const APt={toc:[]};function WPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},APt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}WPt.isMDXComponent=!0;const RPt={toc:[]};function IPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}IPt.isMDXComponent=!0;const SPt={toc:[]};function PPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}PPt.isMDXComponent=!0;const EPt={toc:[]};function BPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}BPt.isMDXComponent=!0;const GPt={toc:[]};function OPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}OPt.isMDXComponent=!0;const UPt={toc:[]};function FPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}FPt.isMDXComponent=!0;const qPt={toc:[]};function VPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}VPt.isMDXComponent=!0;const jPt={toc:[]};function HPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}HPt.isMDXComponent=!0;const QPt={toc:[]};function $Pt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}$Pt.isMDXComponent=!0;const YPt={toc:[]};function KPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}KPt.isMDXComponent=!0;const JPt={toc:[]};function tEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}tEt.isMDXComponent=!0;const nEt={toc:[]};function eEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}eEt.isMDXComponent=!0;const oEt={toc:[]};function pEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pEt.isMDXComponent=!0;const rEt={toc:[]};function sEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}sEt.isMDXComponent=!0;const cEt={toc:[]};function iEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}iEt.isMDXComponent=!0;const aEt={toc:[]};function lEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lEt.isMDXComponent=!0;const uEt={toc:[]};function mEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}mEt.isMDXComponent=!0;const dEt={toc:[]};function hEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}hEt.isMDXComponent=!0;const kEt={toc:[]};function yEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}yEt.isMDXComponent=!0;const fEt={toc:[]};function MEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}MEt.isMDXComponent=!0;const DEt={toc:[]};function wEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}wEt.isMDXComponent=!0;const _Et={toc:[]};function XEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Et,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}XEt.isMDXComponent=!0;const gEt={toc:[]};function TEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}TEt.isMDXComponent=!0;const xEt={toc:[]};function CEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}CEt.isMDXComponent=!0;const vEt={toc:[]};function LEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}LEt.isMDXComponent=!0;const ZEt={toc:[]};function bEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}bEt.isMDXComponent=!0;const NEt={toc:[]};function zEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}zEt.isMDXComponent=!0;const AEt={toc:[]};function WEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}WEt.isMDXComponent=!0;const REt={toc:[]};function IEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},REt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}IEt.isMDXComponent=!0;const SEt={toc:[]};function PEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}PEt.isMDXComponent=!0;const EEt={toc:[]};function BEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}BEt.isMDXComponent=!0;const GEt={toc:[]};function OEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}OEt.isMDXComponent=!0;const UEt={toc:[]};function FEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}FEt.isMDXComponent=!0;const qEt={toc:[]};function VEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}VEt.isMDXComponent=!0;const jEt={toc:[]};function HEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}HEt.isMDXComponent=!0;const QEt={toc:[]};function $Et(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}$Et.isMDXComponent=!0;const YEt={toc:[]};function KEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}KEt.isMDXComponent=!0;const JEt={toc:[]};function tBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}tBt.isMDXComponent=!0;const nBt={toc:[]};function eBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}eBt.isMDXComponent=!0;const oBt={toc:[]};function pBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}pBt.isMDXComponent=!0;const rBt={toc:[]};function sBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}sBt.isMDXComponent=!0;const cBt={toc:[]};function iBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}iBt.isMDXComponent=!0;const aBt={toc:[]};function lBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}lBt.isMDXComponent=!0;const uBt={toc:[]};function mBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}mBt.isMDXComponent=!0;const dBt={toc:[]};function hBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}hBt.isMDXComponent=!0;const kBt={toc:[]};function yBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}yBt.isMDXComponent=!0;const fBt={toc:[]};function MBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}MBt.isMDXComponent=!0;const DBt={toc:[]};function wBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}wBt.isMDXComponent=!0;const _Bt={toc:[]};function XBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Bt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}XBt.isMDXComponent=!0;const gBt={toc:[]};function TBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}TBt.isMDXComponent=!0;const xBt={toc:[]};function CBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}CBt.isMDXComponent=!0;const vBt={toc:[]};function LBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}LBt.isMDXComponent=!0;const ZBt={toc:[]};function bBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}bBt.isMDXComponent=!0;const NBt={toc:[]};function zBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}zBt.isMDXComponent=!0;const ABt={toc:[]};function WBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ABt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}WBt.isMDXComponent=!0;const RBt={toc:[]};function IBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}IBt.isMDXComponent=!0;const SBt={toc:[]};function PBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}PBt.isMDXComponent=!0;const EBt={toc:[]};function BBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}BBt.isMDXComponent=!0;const GBt={toc:[]};function OBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}OBt.isMDXComponent=!0;const UBt={toc:[]};function FBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}FBt.isMDXComponent=!0;const qBt={toc:[]};function VBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}VBt.isMDXComponent=!0;const jBt={toc:[]};function HBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}HBt.isMDXComponent=!0;const QBt={toc:[]};function $Bt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}$Bt.isMDXComponent=!0;const YBt={toc:[]};function KBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}KBt.isMDXComponent=!0;const JBt={toc:[]};function tGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}tGt.isMDXComponent=!0;const nGt={toc:[]};function eGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}eGt.isMDXComponent=!0;const oGt={toc:[]};function pGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}pGt.isMDXComponent=!0;const rGt={toc:[]};function sGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}sGt.isMDXComponent=!0;const cGt={toc:[]};function iGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}iGt.isMDXComponent=!0;const aGt={toc:[]};function lGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}lGt.isMDXComponent=!0;const uGt={toc:[]};function mGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}mGt.isMDXComponent=!0;const dGt={toc:[]};function hGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}hGt.isMDXComponent=!0;const kGt={toc:[]};function yGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}yGt.isMDXComponent=!0;const fGt={toc:[]};function MGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}MGt.isMDXComponent=!0;const DGt={toc:[]};function wGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}wGt.isMDXComponent=!0;const _Gt={toc:[]};function XGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}XGt.isMDXComponent=!0;const gGt={toc:[]};function TGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}TGt.isMDXComponent=!0;const xGt={toc:[]};function CGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}CGt.isMDXComponent=!0;const vGt={toc:[]};function LGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}LGt.isMDXComponent=!0;const ZGt={toc:[]};function bGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}bGt.isMDXComponent=!0;const NGt={toc:[]};function zGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}zGt.isMDXComponent=!0;const AGt={toc:[]};function WGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}WGt.isMDXComponent=!0;const RGt={toc:[]};function IGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}IGt.isMDXComponent=!0;const SGt={toc:[]};function PGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}PGt.isMDXComponent=!0;const EGt={toc:[]};function BGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}BGt.isMDXComponent=!0;const GGt={toc:[]};function OGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}OGt.isMDXComponent=!0;const UGt={toc:[]};function FGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}FGt.isMDXComponent=!0;const qGt={toc:[]};function VGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}VGt.isMDXComponent=!0;const jGt={toc:[]};function HGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}HGt.isMDXComponent=!0;const QGt={toc:[]};function $Gt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}$Gt.isMDXComponent=!0;const YGt={toc:[]};function KGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}KGt.isMDXComponent=!0;const JGt={toc:[]};function tOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}tOt.isMDXComponent=!0;const nOt={toc:[]};function eOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}eOt.isMDXComponent=!0;const oOt={toc:[]};function pOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}pOt.isMDXComponent=!0;const rOt={toc:[]};function sOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}sOt.isMDXComponent=!0;const cOt={toc:[]};function iOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}iOt.isMDXComponent=!0;const aOt={toc:[]};function lOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}lOt.isMDXComponent=!0;const uOt={toc:[]};function mOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}mOt.isMDXComponent=!0;const dOt={toc:[]};function hOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}hOt.isMDXComponent=!0;const kOt={toc:[]};function yOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}yOt.isMDXComponent=!0;const fOt={toc:[]};function MOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}MOt.isMDXComponent=!0;const DOt={toc:[]};function wOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}wOt.isMDXComponent=!0;const _Ot={toc:[]};function XOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}XOt.isMDXComponent=!0;const gOt={toc:[]};function TOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}TOt.isMDXComponent=!0;const xOt={toc:[]};function COt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}COt.isMDXComponent=!0;const vOt={toc:[]};function LOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}LOt.isMDXComponent=!0;const ZOt={toc:[]};function bOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}bOt.isMDXComponent=!0;const NOt={toc:[]};function zOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}zOt.isMDXComponent=!0;const AOt={toc:[]};function WOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}WOt.isMDXComponent=!0;const ROt={toc:[]};function IOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ROt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}IOt.isMDXComponent=!0;const SOt={toc:[]};function POt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}POt.isMDXComponent=!0;const EOt={toc:[]};function BOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}BOt.isMDXComponent=!0;const GOt={toc:[]};function OOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}OOt.isMDXComponent=!0;const UOt={toc:[]};function FOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}FOt.isMDXComponent=!0;const qOt={toc:[]};function VOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}VOt.isMDXComponent=!0;const jOt={toc:[]};function HOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}HOt.isMDXComponent=!0;const QOt={toc:[]};function $Ot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}$Ot.isMDXComponent=!0;const YOt={toc:[]};function KOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}KOt.isMDXComponent=!0;const JOt={toc:[]};function tUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}tUt.isMDXComponent=!0;const nUt={toc:[]};function eUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}eUt.isMDXComponent=!0;const oUt={toc:[]};function pUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}pUt.isMDXComponent=!0;const rUt={toc:[]};function sUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}sUt.isMDXComponent=!0;const cUt={toc:[]};function iUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}iUt.isMDXComponent=!0;const aUt={toc:[]};function lUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lUt.isMDXComponent=!0;const uUt={toc:[]};function mUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}mUt.isMDXComponent=!0;const dUt={toc:[]};function hUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hUt.isMDXComponent=!0;const kUt={toc:[]};function yUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}yUt.isMDXComponent=!0;const fUt={toc:[]};function MUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}MUt.isMDXComponent=!0;const DUt={toc:[]};function wUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}wUt.isMDXComponent=!0;const _Ut={toc:[]};function XUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}XUt.isMDXComponent=!0;const gUt={toc:[]};function TUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}TUt.isMDXComponent=!0;const xUt={toc:[]};function CUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}CUt.isMDXComponent=!0;const vUt={toc:[]};function LUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}LUt.isMDXComponent=!0;const ZUt={toc:[]};function bUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}bUt.isMDXComponent=!0;const NUt={toc:[]};function zUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}zUt.isMDXComponent=!0;const AUt={toc:[]};function WUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}WUt.isMDXComponent=!0;const RUt={toc:[]};function IUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}IUt.isMDXComponent=!0;const SUt={toc:[]};function PUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defining knots using the ",(0,s.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,s.kt)("p",null,"Defining knots with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,s.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}PUt.isMDXComponent=!0;const EUt={toc:[]};function BUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a smooth line through a number of points."))}BUt.isMDXComponent=!0;const GUt={toc:[]};function OUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}OUt.isMDXComponent=!0;const UUt={toc:[]};function FUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}FUt.isMDXComponent=!0;const qUt={toc:[]};function VUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}VUt.isMDXComponent=!0;const jUt={toc:[]};function HUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}HUt.isMDXComponent=!0;const QUt={toc:[]};function $Ut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}$Ut.isMDXComponent=!0;const YUt={toc:[]};function KUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}KUt.isMDXComponent=!0;const JUt={toc:[]};function tFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}tFt.isMDXComponent=!0;const nFt={toc:[]};function eFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}eFt.isMDXComponent=!0;const oFt={toc:[]};function pFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}pFt.isMDXComponent=!0;const rFt={toc:[]};function sFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}sFt.isMDXComponent=!0;const cFt={toc:[]};function iFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}iFt.isMDXComponent=!0;const aFt={toc:[]};function lFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}lFt.isMDXComponent=!0;const uFt={toc:[]};function mFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}mFt.isMDXComponent=!0;const dFt={toc:[]};function hFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}hFt.isMDXComponent=!0;const kFt={toc:[]};function yFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}yFt.isMDXComponent=!0;const fFt={toc:[]};function MFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}MFt.isMDXComponent=!0;const DFt={toc:[]};function wFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wFt.isMDXComponent=!0;const _Ft={toc:[]};function XFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}XFt.isMDXComponent=!0;const gFt={toc:[]};function TFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}TFt.isMDXComponent=!0;const xFt={toc:[]};function CFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}CFt.isMDXComponent=!0;const vFt={toc:[]};function LFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}LFt.isMDXComponent=!0;const ZFt={toc:[]};function bFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}bFt.isMDXComponent=!0;const NFt={toc:[]};function zFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}zFt.isMDXComponent=!0;const AFt={toc:[]};function WFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}WFt.isMDXComponent=!0;const RFt={toc:[]};function IFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}IFt.isMDXComponent=!0;const SFt={toc:[]};function PFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}PFt.isMDXComponent=!0;const EFt={toc:[]};function BFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}BFt.isMDXComponent=!0;const GFt={toc:[]};function OFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}OFt.isMDXComponent=!0;const UFt={toc:[]};function FFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}FFt.isMDXComponent=!0;const qFt={toc:[]};function VFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}VFt.isMDXComponent=!0;const jFt={toc:[]};function HFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}HFt.isMDXComponent=!0;const QFt={toc:[]};function $Ft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}$Ft.isMDXComponent=!0;const YFt={toc:[]};function KFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}KFt.isMDXComponent=!0;const JFt={toc:[]};function tqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}tqt.isMDXComponent=!0;const nqt={toc:[]};function eqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}eqt.isMDXComponent=!0;const oqt={toc:[]};function pqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}pqt.isMDXComponent=!0;const rqt={toc:[]};function sqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}sqt.isMDXComponent=!0;const cqt={toc:[]};function iqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0.4"))}iqt.isMDXComponent=!0;const aqt={toc:[]};function lqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}lqt.isMDXComponent=!0;const uqt={toc:[]};function mqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}mqt.isMDXComponent=!0;const dqt={toc:[]};function hqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}hqt.isMDXComponent=!0;const kqt={toc:[]};function yqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}yqt.isMDXComponent=!0;const fqt={toc:[]};function Mqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Mqt.isMDXComponent=!0;const Dqt={toc:[]};function wqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}wqt.isMDXComponent=!0;const _qt={toc:[]};function Xqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_qt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Xqt.isMDXComponent=!0;const gqt={toc:[]};function Tqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Tqt.isMDXComponent=!0;const xqt={toc:[]};function Cqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Cqt.isMDXComponent=!0;const vqt={toc:[]};function Lqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Lqt.isMDXComponent=!0;const Zqt={toc:[]};function bqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}bqt.isMDXComponent=!0;const Nqt={toc:[]};function zqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}zqt.isMDXComponent=!0;const Aqt={toc:[]};function Wqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Wqt.isMDXComponent=!0;const Rqt={toc:[]};function Iqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Iqt.isMDXComponent=!0;const Sqt={toc:[]};function Pqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Pqt.isMDXComponent=!0;const Eqt={toc:[]};function Bqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Bqt.isMDXComponent=!0;const Gqt={toc:[]};function Oqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Oqt.isMDXComponent=!0;const Uqt={toc:[]};function Fqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Fqt.isMDXComponent=!0;const qqt={toc:[]};function Vqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Vqt.isMDXComponent=!0;const jqt={toc:[]};function Hqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Hqt.isMDXComponent=!0;const Qqt={toc:[]};function $qt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}$qt.isMDXComponent=!0;const Yqt={toc:[]};function Kqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Kqt.isMDXComponent=!0;const Jqt={toc:[]};function tVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}tVt.isMDXComponent=!0;const nVt={toc:[]};function eVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}eVt.isMDXComponent=!0;const oVt={toc:[]};function pVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}pVt.isMDXComponent=!0;const rVt={toc:[]};function sVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}sVt.isMDXComponent=!0;const cVt={toc:[]};function iVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}iVt.isMDXComponent=!0;const aVt={toc:[]};function lVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}lVt.isMDXComponent=!0;const uVt={toc:[]};function mVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}mVt.isMDXComponent=!0;const dVt={toc:[]};function hVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}hVt.isMDXComponent=!0;const kVt={toc:[]};function yVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}yVt.isMDXComponent=!0;const fVt={toc:[]};function MVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}MVt.isMDXComponent=!0;const DVt={toc:[]};function wVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}wVt.isMDXComponent=!0;const _Vt={toc:[]};function XVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Vt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}XVt.isMDXComponent=!0;const gVt={toc:[]};function TVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}TVt.isMDXComponent=!0;const xVt={toc:[]};function CVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}CVt.isMDXComponent=!0;const vVt={toc:[]};function LVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}LVt.isMDXComponent=!0;const ZVt={toc:[]};function bVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}bVt.isMDXComponent=!0;const NVt={toc:[]};function zVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}zVt.isMDXComponent=!0;const AVt={toc:[]};function WVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}WVt.isMDXComponent=!0;const RVt={toc:[]};function IVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}IVt.isMDXComponent=!0;const SVt={toc:[]};function PVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}PVt.isMDXComponent=!0;const EVt={toc:[]};function BVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}BVt.isMDXComponent=!0;const GVt={toc:[]};function OVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}OVt.isMDXComponent=!0;const UVt={toc:[]};function FVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}FVt.isMDXComponent=!0;const qVt={toc:[]};function VVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}VVt.isMDXComponent=!0;const jVt={toc:[]};function HVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}HVt.isMDXComponent=!0;const QVt={toc:[]};function $Vt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}$Vt.isMDXComponent=!0;const YVt={toc:[]};function KVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}KVt.isMDXComponent=!0;const JVt={toc:[]};function tjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}tjt.isMDXComponent=!0;const njt={toc:[]};function ejt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},njt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}ejt.isMDXComponent=!0;const ojt={toc:[]};function pjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ojt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}pjt.isMDXComponent=!0;const rjt={toc:[]};function sjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}sjt.isMDXComponent=!0;const cjt={toc:[]};function ijt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}ijt.isMDXComponent=!0;const ajt={toc:[]};function ljt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ajt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}ljt.isMDXComponent=!0;const ujt={toc:[]};function mjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ujt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}mjt.isMDXComponent=!0;const djt={toc:[]};function hjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},djt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}hjt.isMDXComponent=!0;const kjt={toc:[]};function yjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}yjt.isMDXComponent=!0;const fjt={toc:[]};function Mjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Mjt.isMDXComponent=!0;const Djt={toc:[]};function wjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Djt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}wjt.isMDXComponent=!0;const _jt={toc:[]};function Xjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_jt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Xjt.isMDXComponent=!0;const gjt={toc:[]};function Tjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Tjt.isMDXComponent=!0;const xjt={toc:[]};function Cjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Cjt.isMDXComponent=!0;const vjt={toc:[]};function Ljt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Ljt.isMDXComponent=!0;const Zjt={toc:[]};function bjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}bjt.isMDXComponent=!0;const Njt={toc:[]};function zjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Njt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}zjt.isMDXComponent=!0;const Ajt={toc:[]};function Wjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ajt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Wjt.isMDXComponent=!0;const Rjt={toc:[]};function Ijt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Ijt.isMDXComponent=!0;const Sjt={toc:[]};function Pjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Pjt.isMDXComponent=!0;const Ejt={toc:[]};function Bjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ejt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Bjt.isMDXComponent=!0;const Gjt={toc:[]};function Ojt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Ojt.isMDXComponent=!0;const Ujt={toc:[]};function Fjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ujt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Fjt.isMDXComponent=!0;const qjt={toc:[]};function Vjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Vjt.isMDXComponent=!0;const jjt={toc:[]};function Hjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Hjt.isMDXComponent=!0;const Qjt={toc:[]};function $jt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}$jt.isMDXComponent=!0;const Yjt={toc:[]};function Kjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Kjt.isMDXComponent=!0;const Jjt={toc:[]};function tHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}tHt.isMDXComponent=!0;const nHt={toc:[]};function eHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}eHt.isMDXComponent=!0;const oHt={toc:[]};function pHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}pHt.isMDXComponent=!0;const rHt={toc:[]};function sHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}sHt.isMDXComponent=!0;const cHt={toc:[]};function iHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}iHt.isMDXComponent=!0;const aHt={toc:[]};function lHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}lHt.isMDXComponent=!0;const uHt={toc:[]};function mHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}mHt.isMDXComponent=!0;const dHt={toc:[]};function hHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}hHt.isMDXComponent=!0;const kHt={toc:[]};function yHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}yHt.isMDXComponent=!0;const fHt={toc:[]};function MHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}MHt.isMDXComponent=!0;const DHt={toc:[]};function wHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}wHt.isMDXComponent=!0;const _Ht={toc:[]};function XHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}XHt.isMDXComponent=!0;const gHt={toc:[]};function THt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}THt.isMDXComponent=!0;const xHt={toc:[]};function CHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}CHt.isMDXComponent=!0;const vHt={toc:[]};function LHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}LHt.isMDXComponent=!0;const ZHt={toc:[]};function bHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}bHt.isMDXComponent=!0;const NHt={toc:[]};function zHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}zHt.isMDXComponent=!0;const AHt={toc:[]};function WHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}WHt.isMDXComponent=!0;const RHt={toc:[]};function IHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}IHt.isMDXComponent=!0;const SHt={toc:[]};function PHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}PHt.isMDXComponent=!0;const EHt={toc:[]};function BHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}BHt.isMDXComponent=!0;const GHt={toc:[]};function OHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}OHt.isMDXComponent=!0;const UHt={toc:[]};function FHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}FHt.isMDXComponent=!0;const qHt={toc:[]};function VHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}VHt.isMDXComponent=!0;const jHt={toc:[]};function HHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}HHt.isMDXComponent=!0;const QHt={toc:[]};function $Ht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}$Ht.isMDXComponent=!0;const YHt={toc:[]};function KHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}KHt.isMDXComponent=!0;const JHt={toc:[]};function tQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}tQt.isMDXComponent=!0;const nQt={toc:[]};function eQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}eQt.isMDXComponent=!0;const oQt={toc:[]};function pQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}pQt.isMDXComponent=!0;const rQt={toc:[]};function sQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}sQt.isMDXComponent=!0;const cQt={toc:[]};function iQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}iQt.isMDXComponent=!0;const aQt={toc:[]};function lQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}lQt.isMDXComponent=!0;const uQt={toc:[]};function mQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}mQt.isMDXComponent=!0;const dQt={toc:[]};function hQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}hQt.isMDXComponent=!0;const kQt={toc:[]};function yQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}yQt.isMDXComponent=!0;const fQt={toc:[]};function MQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}MQt.isMDXComponent=!0;const DQt={toc:[]};function wQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}wQt.isMDXComponent=!0;const _Qt={toc:[]};function XQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Qt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}XQt.isMDXComponent=!0;const gQt={toc:[]};function TQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}TQt.isMDXComponent=!0;const xQt={toc:[]};function CQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}CQt.isMDXComponent=!0;const vQt={toc:[]};function LQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}LQt.isMDXComponent=!0;const ZQt={toc:[]};function bQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}bQt.isMDXComponent=!0;const NQt={toc:[]};function zQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}zQt.isMDXComponent=!0;const AQt={toc:[]};function WQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}WQt.isMDXComponent=!0;const RQt={toc:[]};function IQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}IQt.isMDXComponent=!0;const SQt={toc:[]};function PQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}PQt.isMDXComponent=!0;const EQt={toc:[]};function BQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}BQt.isMDXComponent=!0;const GQt={toc:[]};function OQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}OQt.isMDXComponent=!0;const UQt={toc:[]};function FQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}FQt.isMDXComponent=!0;const qQt={toc:[]};function VQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}VQt.isMDXComponent=!0;const jQt={toc:[]};function HQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}HQt.isMDXComponent=!0;const QQt={toc:[]};function $Qt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}$Qt.isMDXComponent=!0;const YQt={toc:[]};function KQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}KQt.isMDXComponent=!0;const JQt={toc:[]};function t$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}t$t.isMDXComponent=!0;const n$t={toc:[]};function e$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}e$t.isMDXComponent=!0;const o$t={toc:[]};function p$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}p$t.isMDXComponent=!0;const r$t={toc:[]};function s$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}s$t.isMDXComponent=!0;const c$t={toc:[]};function i$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}i$t.isMDXComponent=!0;const a$t={toc:[]};function l$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}l$t.isMDXComponent=!0;const u$t={toc:[]};function m$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}m$t.isMDXComponent=!0;const d$t={toc:[]};function h$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}h$t.isMDXComponent=!0;const k$t={toc:[]};function y$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}y$t.isMDXComponent=!0;const f$t={toc:[]};function M$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}M$t.isMDXComponent=!0;const D$t={toc:[]};function w$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}w$t.isMDXComponent=!0;const _$t={toc:[]};function X$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}X$t.isMDXComponent=!0;const g$t={toc:[]};function T$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}T$t.isMDXComponent=!0;const x$t={toc:[]};function C$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}C$t.isMDXComponent=!0;const v$t={toc:[]};function L$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}L$t.isMDXComponent=!0;const Z$t={toc:[]};function b$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}b$t.isMDXComponent=!0;const N$t={toc:[]};function z$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}z$t.isMDXComponent=!0;const A$t={toc:[]};function W$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}W$t.isMDXComponent=!0;const R$t={toc:[]};function I$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}I$t.isMDXComponent=!0;const S$t={toc:[]};function P$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}P$t.isMDXComponent=!0;const E$t={toc:[]};function B$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}B$t.isMDXComponent=!0;const G$t={toc:[]};function O$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}O$t.isMDXComponent=!0;const U$t={toc:[]};function F$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}F$t.isMDXComponent=!0;const q$t={toc:[]};function V$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}V$t.isMDXComponent=!0;const j$t={toc:[]};function H$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}H$t.isMDXComponent=!0;const Q$t={toc:[]};function $$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}$$t.isMDXComponent=!0;const Y$t={toc:[]};function K$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}K$t.isMDXComponent=!0;const J$t={toc:[]};function tYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}tYt.isMDXComponent=!0;const nYt={toc:[]};function eYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}eYt.isMDXComponent=!0;const oYt={toc:[]};function pYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pYt.isMDXComponent=!0;const rYt={toc:[]};function sYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}sYt.isMDXComponent=!0;const cYt={toc:[]};function iYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}iYt.isMDXComponent=!0;const aYt={toc:[]};function lYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}lYt.isMDXComponent=!0;const uYt={toc:[]};function mYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}mYt.isMDXComponent=!0;const dYt={toc:[]};function hYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}hYt.isMDXComponent=!0;const kYt={toc:[]};function yYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}yYt.isMDXComponent=!0;const fYt={toc:[]};function MYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}MYt.isMDXComponent=!0;const DYt={toc:[]};function wYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}wYt.isMDXComponent=!0;const _Yt={toc:[]};function XYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Yt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}XYt.isMDXComponent=!0;const gYt={toc:[]};function TYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}TYt.isMDXComponent=!0;const xYt={toc:[]};function CYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}CYt.isMDXComponent=!0;const vYt={toc:[]};function LYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}LYt.isMDXComponent=!0;const ZYt={toc:[]};function bYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}bYt.isMDXComponent=!0;const NYt={toc:[]};function zYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}zYt.isMDXComponent=!0;const AYt={toc:[]};function WYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}WYt.isMDXComponent=!0;const RYt={toc:[]};function IYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}IYt.isMDXComponent=!0;const SYt={toc:[]};function PYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}PYt.isMDXComponent=!0;const EYt={toc:[]};function BYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}BYt.isMDXComponent=!0;const GYt={toc:[]};function OYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}OYt.isMDXComponent=!0;const UYt={toc:[]};function FYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}FYt.isMDXComponent=!0;const qYt={toc:[]};function VYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}VYt.isMDXComponent=!0;const jYt={toc:[]};function HYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}HYt.isMDXComponent=!0;const QYt={toc:[]};function $Yt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}$Yt.isMDXComponent=!0;const YYt={toc:[]};function KYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}KYt.isMDXComponent=!0;const JYt={toc:[]};function tKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}tKt.isMDXComponent=!0;const nKt={toc:[]};function eKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}eKt.isMDXComponent=!0;const oKt={toc:[]};function pKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pKt.isMDXComponent=!0;const rKt={toc:[]};function sKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}sKt.isMDXComponent=!0;const cKt={toc:[]};function iKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}iKt.isMDXComponent=!0;const aKt={toc:[]};function lKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}lKt.isMDXComponent=!0;const uKt={toc:[]};function mKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}mKt.isMDXComponent=!0;const dKt={toc:[]};function hKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}hKt.isMDXComponent=!0;const kKt={toc:[]};function yKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}yKt.isMDXComponent=!0;const fKt={toc:[]};function MKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}MKt.isMDXComponent=!0;const DKt={toc:[]};function wKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}wKt.isMDXComponent=!0;const _Kt={toc:[]};function XKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Kt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}XKt.isMDXComponent=!0;const gKt={toc:[]};function TKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}TKt.isMDXComponent=!0;const xKt={toc:[]};function CKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}CKt.isMDXComponent=!0;const vKt={toc:[]};function LKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}LKt.isMDXComponent=!0;const ZKt={toc:[]};function bKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}bKt.isMDXComponent=!0;const NKt={toc:[]};function zKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}zKt.isMDXComponent=!0;const AKt={toc:[]};function WKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}WKt.isMDXComponent=!0;const RKt={toc:[]};function IKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}IKt.isMDXComponent=!0;const SKt={toc:[]};function PKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}PKt.isMDXComponent=!0;const EKt={toc:[]};function BKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}BKt.isMDXComponent=!0;const GKt={toc:[]};function OKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}OKt.isMDXComponent=!0;const UKt={toc:[]};function FKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}FKt.isMDXComponent=!0;const qKt={toc:[]};function VKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}VKt.isMDXComponent=!0;const jKt={toc:[]};function HKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}HKt.isMDXComponent=!0;const QKt={toc:[]};function $Kt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}$Kt.isMDXComponent=!0;const YKt={toc:[]};function KKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}KKt.isMDXComponent=!0;const JKt={toc:[]};function tJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}tJt.isMDXComponent=!0;const nJt={toc:[]};function eJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}eJt.isMDXComponent=!0;const oJt={toc:[]};function pJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}pJt.isMDXComponent=!0;const rJt={toc:[]};function sJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}sJt.isMDXComponent=!0;const cJt={toc:[]};function iJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}iJt.isMDXComponent=!0;const aJt={toc:[]};function lJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}lJt.isMDXComponent=!0;const uJt={toc:[]};function mJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}mJt.isMDXComponent=!0;const dJt={toc:[]};function hJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}hJt.isMDXComponent=!0;const kJt={toc:[]};function yJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}yJt.isMDXComponent=!0;const fJt={toc:[]};function MJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}MJt.isMDXComponent=!0;const DJt={toc:[]};function wJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}wJt.isMDXComponent=!0;const _Jt={toc:[]};function XJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Jt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}XJt.isMDXComponent=!0;const gJt={toc:[]};function TJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}TJt.isMDXComponent=!0;const xJt={toc:[]};function CJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}CJt.isMDXComponent=!0;const vJt={toc:[]};function LJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}LJt.isMDXComponent=!0;const ZJt={toc:[]};function bJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}bJt.isMDXComponent=!0;const NJt={toc:[]};function zJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}zJt.isMDXComponent=!0;const AJt={toc:[]};function WJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}WJt.isMDXComponent=!0;const RJt={toc:[]};function IJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}IJt.isMDXComponent=!0;const SJt={toc:[]};function PJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}PJt.isMDXComponent=!0;const EJt={toc:[]};function BJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}BJt.isMDXComponent=!0;const GJt={toc:[]};function OJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}OJt.isMDXComponent=!0;const UJt={toc:[]};function FJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}FJt.isMDXComponent=!0;const qJt={toc:[]};function VJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}VJt.isMDXComponent=!0;const jJt={toc:[]};function HJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}HJt.isMDXComponent=!0;const QJt={toc:[]};function $Jt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}$Jt.isMDXComponent=!0;const YJt={toc:[]};function KJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}KJt.isMDXComponent=!0;const JJt={toc:[]};function t0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}t0t.isMDXComponent=!0;const n0t={toc:[]};function e0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}e0t.isMDXComponent=!0;const o0t={toc:[]};function p0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}p0t.isMDXComponent=!0;const r0t={toc:[]};function s0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}s0t.isMDXComponent=!0;const c0t={toc:[]};function i0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}i0t.isMDXComponent=!0;const a0t={toc:[]};function l0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}l0t.isMDXComponent=!0;const u0t={toc:[]};function m0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}m0t.isMDXComponent=!0;const d0t={toc:[]};function h0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}h0t.isMDXComponent=!0;const k0t={toc:[]};function y0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}y0t.isMDXComponent=!0;const f0t={toc:[]};function M0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}M0t.isMDXComponent=!0;const D0t={toc:[]};function w0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}w0t.isMDXComponent=!0;const _0t={toc:[]};function X0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}X0t.isMDXComponent=!0;const g0t={toc:[]};function T0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}T0t.isMDXComponent=!0;const x0t={toc:[]};function C0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}C0t.isMDXComponent=!0;const v0t={toc:[]};function L0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}L0t.isMDXComponent=!0;const Z0t={toc:[]};function b0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}b0t.isMDXComponent=!0;const N0t={toc:[]};function z0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}z0t.isMDXComponent=!0;const A0t={toc:[]};function W0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}W0t.isMDXComponent=!0;const R0t={toc:[]};function I0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}I0t.isMDXComponent=!0;const S0t={toc:[]};function P0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}P0t.isMDXComponent=!0;const E0t={toc:[]};function B0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}B0t.isMDXComponent=!0;const G0t={toc:[]};function O0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}O0t.isMDXComponent=!0;const U0t={toc:[]};function F0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}F0t.isMDXComponent=!0;const q0t={toc:[]};function V0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}V0t.isMDXComponent=!0;const j0t={toc:[]};function H0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}H0t.isMDXComponent=!0;const Q0t={toc:[]};function $0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}$0t.isMDXComponent=!0;const Y0t={toc:[]};function K0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}K0t.isMDXComponent=!0;const J0t={toc:[]};function t2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}t2t.isMDXComponent=!0;const n2t={toc:[]};function e2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}e2t.isMDXComponent=!0;const o2t={toc:[]};function p2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}p2t.isMDXComponent=!0;const r2t={toc:[]};function s2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}s2t.isMDXComponent=!0;const c2t={toc:[]};function i2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}i2t.isMDXComponent=!0;const a2t={toc:[]};function l2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}l2t.isMDXComponent=!0;const u2t={toc:[]};function m2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}m2t.isMDXComponent=!0;const d2t={toc:[]};function h2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}h2t.isMDXComponent=!0;const k2t={toc:[]};function y2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}y2t.isMDXComponent=!0;const f2t={toc:[]};function M2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}M2t.isMDXComponent=!0;const D2t={toc:[]};function w2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}w2t.isMDXComponent=!0;const _2t={toc:[]};function X2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}X2t.isMDXComponent=!0;const g2t={toc:[]};function T2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}T2t.isMDXComponent=!0;const x2t={toc:[]};function C2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}C2t.isMDXComponent=!0;const v2t={toc:[]};function L2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}L2t.isMDXComponent=!0;const Z2t={toc:[]};function b2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}b2t.isMDXComponent=!0;const N2t={toc:[]};function z2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}z2t.isMDXComponent=!0;const A2t={toc:[]};function W2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}W2t.isMDXComponent=!0;const R2t={toc:[]};function I2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}I2t.isMDXComponent=!0;const S2t={toc:[]};function P2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}P2t.isMDXComponent=!0;const E2t={toc:[]};function B2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}B2t.isMDXComponent=!0;const G2t={toc:[]};function O2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}O2t.isMDXComponent=!0;const U2t={toc:[]};function F2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}F2t.isMDXComponent=!0;const q2t={toc:[]};function V2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}V2t.isMDXComponent=!0;const j2t={toc:[]};function H2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}H2t.isMDXComponent=!0;const Q2t={toc:[]};function $2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}$2t.isMDXComponent=!0;const Y2t={toc:[]};function K2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}K2t.isMDXComponent=!0;const J2t={toc:[]};function t1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}t1t.isMDXComponent=!0;const n1t={toc:[]};function e1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}e1t.isMDXComponent=!0;const o1t={toc:[]};function p1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}p1t.isMDXComponent=!0;const r1t={toc:[]};function s1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}s1t.isMDXComponent=!0;const c1t={toc:[]};function i1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}i1t.isMDXComponent=!0;const a1t={toc:[]};function l1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}l1t.isMDXComponent=!0;const u1t={toc:[]};function m1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}m1t.isMDXComponent=!0;const d1t={toc:[]};function h1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}h1t.isMDXComponent=!0;const k1t={toc:[]};function y1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}y1t.isMDXComponent=!0;const f1t={toc:[]};function M1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}M1t.isMDXComponent=!0;const D1t={toc:[]};function w1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}w1t.isMDXComponent=!0;const _1t={toc:[]};function X1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}X1t.isMDXComponent=!0;const g1t={toc:[]};function T1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}T1t.isMDXComponent=!0;const x1t={toc:[]};function C1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}C1t.isMDXComponent=!0;const v1t={toc:[]};function L1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}L1t.isMDXComponent=!0;const Z1t={toc:[]};function b1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local video:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import video from './example.mp4';\n// ...\nview.add(<Video src={video} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Video src="https://example.com/video.mp4" />)\n')))}b1t.isMDXComponent=!0;const N1t={toc:[]};function z1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}z1t.isMDXComponent=!0;const A1t={toc:[]};function W1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}W1t.isMDXComponent=!0;const R1t={toc:[]};function I1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}I1t.isMDXComponent=!0;const S1t={toc:[]};function P1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}P1t.isMDXComponent=!0;const E1t={toc:[]};function B1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}B1t.isMDXComponent=!0;const G1t={toc:[]};function O1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}O1t.isMDXComponent=!0;const U1t={toc:[]};function F1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}F1t.isMDXComponent=!0;const q1t={toc:[]};function V1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}V1t.isMDXComponent=!0;const j1t={toc:[]};function H1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}H1t.isMDXComponent=!0;const Q1t={toc:[]};function $1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}$1t.isMDXComponent=!0;const Y1t={toc:[]};function K1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}K1t.isMDXComponent=!0;const J1t={toc:[]};function t3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}t3t.isMDXComponent=!0;const n3t={toc:[]};function e3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}e3t.isMDXComponent=!0;const o3t={toc:[]};function p3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}p3t.isMDXComponent=!0;const r3t={toc:[]};function s3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}s3t.isMDXComponent=!0;const c3t={toc:[]};function i3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}i3t.isMDXComponent=!0;const a3t={toc:[]};function l3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}l3t.isMDXComponent=!0;const u3t={toc:[]};function m3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}m3t.isMDXComponent=!0;const d3t={toc:[]};function h3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}h3t.isMDXComponent=!0;const k3t={toc:[]};function y3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}y3t.isMDXComponent=!0;const f3t={toc:[]};function M3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}M3t.isMDXComponent=!0;const D3t={toc:[]};function w3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}w3t.isMDXComponent=!0;const _3t={toc:[]};function X3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}X3t.isMDXComponent=!0;const g3t={toc:[]};function T3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}T3t.isMDXComponent=!0;const x3t={toc:[]};function C3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}C3t.isMDXComponent=!0;const v3t={toc:[]};function L3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}L3t.isMDXComponent=!0;const Z3t={toc:[]};function b3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}b3t.isMDXComponent=!0;const N3t={toc:[]};function z3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}z3t.isMDXComponent=!0;const A3t={toc:[]};function W3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}W3t.isMDXComponent=!0;const R3t={toc:[]};function I3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}I3t.isMDXComponent=!0;const S3t={toc:[]};function P3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}P3t.isMDXComponent=!0;const E3t={toc:[]};function B3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}B3t.isMDXComponent=!0;const G3t={toc:[]};function O3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}O3t.isMDXComponent=!0;const U3t={toc:[]};function F3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}F3t.isMDXComponent=!0;const q3t={toc:[]};function V3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}V3t.isMDXComponent=!0;const j3t={toc:[]};function H3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}H3t.isMDXComponent=!0;const Q3t={toc:[]};function $3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}$3t.isMDXComponent=!0;const Y3t={toc:[]};function K3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}K3t.isMDXComponent=!0;const J3t={toc:[]};function t6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}t6t.isMDXComponent=!0;const n6t={toc:[]};function e6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}e6t.isMDXComponent=!0;const o6t={toc:[]};function p6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}p6t.isMDXComponent=!0;const r6t={toc:[]};function s6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}s6t.isMDXComponent=!0;const c6t={toc:[]};function i6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}i6t.isMDXComponent=!0;const a6t={toc:[]};function l6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}l6t.isMDXComponent=!0;const u6t={toc:[]};function m6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}m6t.isMDXComponent=!0;const d6t={toc:[]};function h6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}h6t.isMDXComponent=!0;const k6t={toc:[]};function y6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}y6t.isMDXComponent=!0;const f6t={toc:[]};function M6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}M6t.isMDXComponent=!0;const D6t={toc:[]};function w6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}w6t.isMDXComponent=!0;const _6t={toc:[]};function X6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}X6t.isMDXComponent=!0;const g6t={toc:[]};function T6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}T6t.isMDXComponent=!0;const x6t={toc:[]};function C6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}C6t.isMDXComponent=!0;const v6t={toc:[]};function L6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}L6t.isMDXComponent=!0;const Z6t={toc:[]};function b6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}b6t.isMDXComponent=!0;const N6t={toc:[]};function z6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}z6t.isMDXComponent=!0;const A6t={toc:[]};function W6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}W6t.isMDXComponent=!0;const R6t={toc:[]};function I6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}I6t.isMDXComponent=!0;const S6t={toc:[]};function P6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}P6t.isMDXComponent=!0;const E6t={toc:[]};function B6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}B6t.isMDXComponent=!0;const G6t={toc:[]};function O6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}O6t.isMDXComponent=!0;const U6t={toc:[]};function F6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}F6t.isMDXComponent=!0;const q6t={toc:[]};function V6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}V6t.isMDXComponent=!0;const j6t={toc:[]};function H6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}H6t.isMDXComponent=!0;const Q6t={toc:[]};function $6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}$6t.isMDXComponent=!0;const Y6t={toc:[]};function K6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}K6t.isMDXComponent=!0;const J6t={toc:[]};function t4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}t4t.isMDXComponent=!0;const n4t={toc:[]};function e4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}e4t.isMDXComponent=!0;const o4t={toc:[]};function p4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}p4t.isMDXComponent=!0;const r4t={toc:[]};function s4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}s4t.isMDXComponent=!0;const c4t={toc:[]};function i4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}i4t.isMDXComponent=!0;const a4t={toc:[]};function l4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}l4t.isMDXComponent=!0;const u4t={toc:[]};function m4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}m4t.isMDXComponent=!0;const d4t={toc:[]};function h4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}h4t.isMDXComponent=!0;const k4t={toc:[]};function y4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}y4t.isMDXComponent=!0;const f4t={toc:[]};function M4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}M4t.isMDXComponent=!0;const D4t={toc:[]};function w4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}w4t.isMDXComponent=!0;const _4t={toc:[]};function X4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}X4t.isMDXComponent=!0;const g4t={toc:[]};function T4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}T4t.isMDXComponent=!0;const x4t={toc:[]};function C4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}C4t.isMDXComponent=!0;const v4t={toc:[]};function L4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}L4t.isMDXComponent=!0;const Z4t={toc:[]};function b4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}b4t.isMDXComponent=!0;const N4t={toc:[]};function z4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}z4t.isMDXComponent=!0;const A4t={toc:[]};function W4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}W4t.isMDXComponent=!0;const R4t={toc:[]};function I4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}I4t.isMDXComponent=!0;const S4t={toc:[]};function P4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}P4t.isMDXComponent=!0;const E4t={toc:[]};function B4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}B4t.isMDXComponent=!0;const G4t={toc:[]};function O4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}O4t.isMDXComponent=!0;const U4t={toc:[]};function F4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}F4t.isMDXComponent=!0;const q4t={toc:[]};function V4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}V4t.isMDXComponent=!0;const j4t={toc:[]};function H4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}H4t.isMDXComponent=!0;const Q4t={toc:[]};function $4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}$4t.isMDXComponent=!0;const Y4t={toc:[]};function K4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}K4t.isMDXComponent=!0;const J4t={toc:[]};function t8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}t8t.isMDXComponent=!0;const n8t={toc:[]};function e8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}e8t.isMDXComponent=!0;const o8t={toc:[]};function p8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}p8t.isMDXComponent=!0;const r8t={toc:[]};function s8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}s8t.isMDXComponent=!0;const c8t={toc:[]};function i8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}i8t.isMDXComponent=!0;const a8t={toc:[]};function l8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}l8t.isMDXComponent=!0;const u8t={toc:[]};function m8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}m8t.isMDXComponent=!0;const d8t={toc:[]};function h8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}h8t.isMDXComponent=!0;const k8t={toc:[]};function y8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}y8t.isMDXComponent=!0;const f8t={toc:[]};function M8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}M8t.isMDXComponent=!0;const D8t={toc:[]};function w8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}w8t.isMDXComponent=!0;const _8t={toc:[]};function X8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}X8t.isMDXComponent=!0;const g8t={toc:[]};function T8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}T8t.isMDXComponent=!0;const x8t={toc:[]};function C8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}C8t.isMDXComponent=!0;const v8t={toc:[]};function L8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}L8t.isMDXComponent=!0;const Z8t={toc:[]};function b8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}b8t.isMDXComponent=!0;const N8t={toc:[]};function z8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}z8t.isMDXComponent=!0;const A8t={toc:[]};function W8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}W8t.isMDXComponent=!0;const R8t={toc:[]};function I8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}I8t.isMDXComponent=!0;const S8t={toc:[]};function P8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}P8t.isMDXComponent=!0;const E8t={toc:[]};function B8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}B8t.isMDXComponent=!0;const G8t={toc:[]};function O8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}O8t.isMDXComponent=!0;const U8t={toc:[]};function F8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}F8t.isMDXComponent=!0;const q8t={toc:[]};function V8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}V8t.isMDXComponent=!0;const j8t={toc:[]};function H8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}H8t.isMDXComponent=!0;const Q8t={toc:[]};function $8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}$8t.isMDXComponent=!0;const Y8t={toc:[]};function K8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}K8t.isMDXComponent=!0;const J8t={toc:[]};function t5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}t5t.isMDXComponent=!0;const n5t={toc:[]};function e5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}e5t.isMDXComponent=!0;const o5t={toc:[]};function p5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}p5t.isMDXComponent=!0;const r5t={toc:[]};function s5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}s5t.isMDXComponent=!0;const c5t={toc:[]};function i5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}i5t.isMDXComponent=!0;const a5t={toc:[]};function l5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}l5t.isMDXComponent=!0;const u5t={toc:[]};function m5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}m5t.isMDXComponent=!0;const d5t={toc:[]};function h5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}h5t.isMDXComponent=!0;const k5t={toc:[]};function y5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}y5t.isMDXComponent=!0;const f5t={toc:[]};function M5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}M5t.isMDXComponent=!0;const D5t={toc:[]};function w5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}w5t.isMDXComponent=!0;const _5t={toc:[]};function X5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}X5t.isMDXComponent=!0;const g5t={toc:[]};function T5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}T5t.isMDXComponent=!0;const x5t={toc:[]};function C5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}C5t.isMDXComponent=!0;const v5t={toc:[]};function L5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}L5t.isMDXComponent=!0;const Z5t={toc:[]};function b5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}b5t.isMDXComponent=!0;const N5t={toc:[]};function z5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}z5t.isMDXComponent=!0;const A5t={toc:[]};function W5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}W5t.isMDXComponent=!0;const R5t={toc:[]};function I5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}I5t.isMDXComponent=!0;const S5t={toc:[]};function P5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}P5t.isMDXComponent=!0;const E5t={toc:[]};function B5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}B5t.isMDXComponent=!0;const G5t={toc:[]};function O5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}O5t.isMDXComponent=!0;const U5t={toc:[]};function F5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}F5t.isMDXComponent=!0;const q5t={toc:[]};function V5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}V5t.isMDXComponent=!0;const j5t={toc:[]};function H5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}H5t.isMDXComponent=!0;const Q5t={toc:[]};function $5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}$5t.isMDXComponent=!0;const Y5t={toc:[]};function K5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}K5t.isMDXComponent=!0;const J5t={toc:[]};function t7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}t7t.isMDXComponent=!0;const n7t={toc:[]};function e7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}e7t.isMDXComponent=!0;const o7t={toc:[]};function p7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}p7t.isMDXComponent=!0;const r7t={toc:[]};function s7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}s7t.isMDXComponent=!0;const c7t={toc:[]};function i7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}i7t.isMDXComponent=!0;const a7t={toc:[]};function l7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}l7t.isMDXComponent=!0;const u7t={toc:[]};function m7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}m7t.isMDXComponent=!0;const d7t={toc:[]};function h7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}h7t.isMDXComponent=!0;const k7t={toc:[]};function y7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}y7t.isMDXComponent=!0;const f7t={toc:[]};function M7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}M7t.isMDXComponent=!0;const D7t={toc:[]};function w7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}w7t.isMDXComponent=!0;const _7t={toc:[]};function X7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}X7t.isMDXComponent=!0;const g7t={toc:[]};function T7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}T7t.isMDXComponent=!0;const x7t={toc:[]};function C7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}C7t.isMDXComponent=!0;const v7t={toc:[]};function L7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}L7t.isMDXComponent=!0;const Z7t={toc:[]};function b7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}b7t.isMDXComponent=!0;const N7t={toc:[]};function z7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}z7t.isMDXComponent=!0;const A7t={toc:[]};function W7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}W7t.isMDXComponent=!0;const R7t={toc:[]};function I7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}I7t.isMDXComponent=!0;const S7t={toc:[]};function P7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}P7t.isMDXComponent=!0;const E7t={toc:[]};function B7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}B7t.isMDXComponent=!0;const G7t={toc:[]};function O7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}O7t.isMDXComponent=!0;const U7t={toc:[]};function F7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}F7t.isMDXComponent=!0;const q7t={toc:[]};function V7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}V7t.isMDXComponent=!0;const j7t={toc:[]};function H7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}H7t.isMDXComponent=!0;const Q7t={toc:[]};function $7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}$7t.isMDXComponent=!0;const Y7t={toc:[]};function K7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}K7t.isMDXComponent=!0;const J7t={toc:[]};function t9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}t9t.isMDXComponent=!0;const n9t={toc:[]};function e9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}e9t.isMDXComponent=!0;const o9t={toc:[]};function p9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}p9t.isMDXComponent=!0;const r9t={toc:[]};function s9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}s9t.isMDXComponent=!0;const c9t={toc:[]};function i9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}i9t.isMDXComponent=!0;const a9t={toc:[]};function l9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}l9t.isMDXComponent=!0;const u9t={toc:[]};function m9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}m9t.isMDXComponent=!0;const d9t={toc:[]};function h9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}h9t.isMDXComponent=!0;const k9t={toc:[]};function y9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}y9t.isMDXComponent=!0;const f9t={toc:[]};function M9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}M9t.isMDXComponent=!0;const D9t={toc:[]};function w9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}w9t.isMDXComponent=!0;const _9t={toc:[]};function X9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}X9t.isMDXComponent=!0;const g9t={toc:[]};function T9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}T9t.isMDXComponent=!0;const x9t={toc:[]};function C9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}C9t.isMDXComponent=!0;const v9t={toc:[]};function L9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}L9t.isMDXComponent=!0;const Z9t={toc:[]};function b9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}b9t.isMDXComponent=!0;const N9t={toc:[]};function z9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}z9t.isMDXComponent=!0;const A9t={toc:[]};function W9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}W9t.isMDXComponent=!0;const R9t={toc:[]};function I9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}I9t.isMDXComponent=!0;const S9t={toc:[]};function P9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}P9t.isMDXComponent=!0;const E9t={toc:[]};function B9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}B9t.isMDXComponent=!0;const G9t={toc:[]};function O9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}O9t.isMDXComponent=!0;const U9t={toc:[]};function F9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}F9t.isMDXComponent=!0;const q9t={toc:[]};function V9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}V9t.isMDXComponent=!0;const j9t={toc:[]};function H9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}H9t.isMDXComponent=!0;const Q9t={toc:[]};function $9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}$9t.isMDXComponent=!0;const Y9t={toc:[]};function K9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}K9t.isMDXComponent=!0;const J9t={toc:[]};function ttn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}ttn.isMDXComponent=!0;const ntn={toc:[]};function etn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ntn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}etn.isMDXComponent=!0;const otn={toc:[]};function ptn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},otn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}ptn.isMDXComponent=!0;const rtn={toc:[]};function stn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}stn.isMDXComponent=!0;const ctn={toc:[]};function itn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ctn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}itn.isMDXComponent=!0;const atn={toc:[]};function ltn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},atn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}ltn.isMDXComponent=!0;const utn={toc:[]};function mtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},utn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}mtn.isMDXComponent=!0;const dtn={toc:[]};function htn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}htn.isMDXComponent=!0;const ktn={toc:[]};function ytn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ktn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ytn.isMDXComponent=!0;const ftn={toc:[]};function Mtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ftn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Mtn.isMDXComponent=!0;const Dtn={toc:[]};function wtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}wtn.isMDXComponent=!0;const _tn={toc:[]};function Xtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_tn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Xtn.isMDXComponent=!0;const gtn={toc:[]};function Ttn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Ttn.isMDXComponent=!0;const xtn={toc:[]};function Ctn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Ctn.isMDXComponent=!0;const vtn={toc:[]};function Ltn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Ltn.isMDXComponent=!0;const Ztn={toc:[]};function btn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ztn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}btn.isMDXComponent=!0;const Ntn={toc:[]};function ztn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ntn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}ztn.isMDXComponent=!0;const Atn={toc:[]};function Wtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Atn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Wtn.isMDXComponent=!0;const Rtn={toc:[]};function Itn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Itn.isMDXComponent=!0;const Stn={toc:[]};function Ptn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Stn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Ptn.isMDXComponent=!0;const Etn={toc:[]};function Btn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Etn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Btn.isMDXComponent=!0;const Gtn={toc:[]};function Otn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Otn.isMDXComponent=!0;const Utn={toc:[]};function Ftn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Utn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Ftn.isMDXComponent=!0;const qtn={toc:[]};function Vtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Vtn.isMDXComponent=!0;const jtn={toc:[]};function Htn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Htn.isMDXComponent=!0;const Qtn={toc:[]};function $tn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$tn.isMDXComponent=!0;const Ytn={toc:[]};function Ktn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ytn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Ktn.isMDXComponent=!0;const Jtn={toc:[]};function tnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}tnn.isMDXComponent=!0;const nnn={toc:[]};function enn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}enn.isMDXComponent=!0;const onn={toc:[]};function pnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},onn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}pnn.isMDXComponent=!0;const rnn={toc:[]};function snn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}snn.isMDXComponent=!0;const cnn={toc:[]};function inn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}inn.isMDXComponent=!0;const ann={toc:[]};function lnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ann,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}lnn.isMDXComponent=!0;const unn={toc:[]};function mnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},unn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}mnn.isMDXComponent=!0;const dnn={toc:[]};function hnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}hnn.isMDXComponent=!0;const knn={toc:[]};function ynn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},knn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}ynn.isMDXComponent=!0;const fnn={toc:[]};function Mnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}Mnn.isMDXComponent=!0;const Dnn={toc:[]};function wnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}wnn.isMDXComponent=!0;const _nn={toc:[]};function Xnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_nn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Xnn.isMDXComponent=!0;const gnn={toc:[]};function Tnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Tnn.isMDXComponent=!0;const xnn={toc:[]};function Cnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Cnn.isMDXComponent=!0;const vnn={toc:[]};function Lnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Lnn.isMDXComponent=!0;const Znn={toc:[]};function bnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Znn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}bnn.isMDXComponent=!0;const Nnn={toc:[]};function znn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}znn.isMDXComponent=!0;const Ann={toc:[]};function Wnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ann,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Wnn.isMDXComponent=!0;const Rnn={toc:[]};function Inn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Inn.isMDXComponent=!0;const Snn={toc:[]};function Pnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Snn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Pnn.isMDXComponent=!0;const Enn={toc:[]};function Bnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Enn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Bnn.isMDXComponent=!0;const Gnn={toc:[]};function Onn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Onn.isMDXComponent=!0;const Unn={toc:[]};function Fnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Unn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Fnn.isMDXComponent=!0;const qnn={toc:[]};function Vnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Vnn.isMDXComponent=!0;const jnn={toc:[]};function Hnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Hnn.isMDXComponent=!0;const Qnn={toc:[]};function $nn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}$nn.isMDXComponent=!0;const Ynn={toc:[]};function Knn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ynn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Knn.isMDXComponent=!0;const Jnn={toc:[]};function ten(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}ten.isMDXComponent=!0;const nen={toc:[]};function een(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}een.isMDXComponent=!0;const oen={toc:[]};function pen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}pen.isMDXComponent=!0;const ren={toc:[]};function sen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ren,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sen.isMDXComponent=!0;const cen={toc:[]};function ien(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}ien.isMDXComponent=!0;const aen={toc:[]};function len(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}len.isMDXComponent=!0;const uen={toc:[]};function men(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}men.isMDXComponent=!0;const den={toc:[]};function hen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},den,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}hen.isMDXComponent=!0;const ken={toc:[]};function yen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ken,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}yen.isMDXComponent=!0;const fen={toc:[]};function Men(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Men.isMDXComponent=!0;const Den={toc:[]};function wen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Den,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}wen.isMDXComponent=!0;const _en={toc:[]};function Xen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_en,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xen.isMDXComponent=!0;const gen={toc:[]};function Ten(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Ten.isMDXComponent=!0;const xen={toc:[]};function Cen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cen.isMDXComponent=!0;const ven={toc:[]};function Len(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ven,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Len.isMDXComponent=!0;const Zen={toc:[]};function ben(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}ben.isMDXComponent=!0;const Nen={toc:[]};function zen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}zen.isMDXComponent=!0;const Aen={toc:[]};function Wen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wen.isMDXComponent=!0;const Ren={toc:[]};function Ien(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ren,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Ien.isMDXComponent=!0;const Sen={toc:[]};function Pen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pen.isMDXComponent=!0;const Een={toc:[]};function Ben(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Een,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Ben.isMDXComponent=!0;const Gen={toc:[]};function Oen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Oen.isMDXComponent=!0;const Uen={toc:[]};function Fen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Fen.isMDXComponent=!0;const qen={toc:[]};function Ven(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Ven.isMDXComponent=!0;const jen={toc:[]};function Hen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Hen.isMDXComponent=!0;const Qen={toc:[]};function $en(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$en.isMDXComponent=!0;const Yen={toc:[]};function Ken(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Ken.isMDXComponent=!0;const Jen={toc:[]};function ton(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ton.isMDXComponent=!0;const non={toc:[]};function eon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},non,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}eon.isMDXComponent=!0;const oon={toc:[]};function pon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pon.isMDXComponent=!0;const ron={toc:[]};function son(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ron,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}son.isMDXComponent=!0;const con={toc:[]};function ion(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},con,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}ion.isMDXComponent=!0;const aon={toc:[]};function lon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}lon.isMDXComponent=!0;const uon={toc:[]};function mon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}mon.isMDXComponent=!0;const don={toc:[]};function hon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},don,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}hon.isMDXComponent=!0;const kon={toc:[]};function yon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}yon.isMDXComponent=!0;const fon={toc:[]};function Mon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Mon.isMDXComponent=!0;const Don={toc:[]};function won(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Don,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}won.isMDXComponent=!0;const _on={toc:[]};function Xon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_on,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Xon.isMDXComponent=!0;const gon={toc:[]};function Ton(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ton.isMDXComponent=!0;const xon={toc:[]};function Con(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Con.isMDXComponent=!0;const von={toc:[]};function Lon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},von,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lon.isMDXComponent=!0;const Zon={toc:[]};function bon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}bon.isMDXComponent=!0;const Non={toc:[]};function zon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Non,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}zon.isMDXComponent=!0;const Aon={toc:[]};function Won(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Won.isMDXComponent=!0;const Ron={toc:[]};function Ion(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ron,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ion.isMDXComponent=!0;const Son={toc:[]};function Pon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Son,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Pon.isMDXComponent=!0;const Eon={toc:[]};function Bon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Bon.isMDXComponent=!0;const Gon={toc:[]};function Oon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Oon.isMDXComponent=!0;const Uon={toc:[]};function Fon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Fon.isMDXComponent=!0;const qon={toc:[]};function Von(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Von.isMDXComponent=!0;const jon={toc:[]};function Hon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hon.isMDXComponent=!0;const Qon={toc:[]};function $on(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}$on.isMDXComponent=!0;const Yon={toc:[]};function Kon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kon.isMDXComponent=!0;const Jon={toc:[]};function tpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}tpn.isMDXComponent=!0;const npn={toc:[]};function epn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},npn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}epn.isMDXComponent=!0;const opn={toc:[]};function ppn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},opn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}ppn.isMDXComponent=!0;const rpn={toc:[]};function spn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}spn.isMDXComponent=!0;const cpn={toc:[]};function ipn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}ipn.isMDXComponent=!0;const apn={toc:[]};function lpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},apn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lpn.isMDXComponent=!0;const upn={toc:[]};function mpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}mpn.isMDXComponent=!0;const dpn={toc:[]};function hpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hpn.isMDXComponent=!0;const kpn={toc:[]};function ypn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}ypn.isMDXComponent=!0;const fpn={toc:[]};function Mpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Mpn.isMDXComponent=!0;const Dpn={toc:[]};function wpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}wpn.isMDXComponent=!0;const _pn={toc:[]};function Xpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_pn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Xpn.isMDXComponent=!0;const gpn={toc:[]};function Tpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Tpn.isMDXComponent=!0;const xpn={toc:[]};function Cpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Cpn.isMDXComponent=!0;const vpn={toc:[]};function Lpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Lpn.isMDXComponent=!0;const Zpn={toc:[]};function bpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}bpn.isMDXComponent=!0;const Npn={toc:[]};function zpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}zpn.isMDXComponent=!0;const Apn={toc:[]};function Wpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Apn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wpn.isMDXComponent=!0;const Rpn={toc:[]};function Ipn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Ipn.isMDXComponent=!0;const Spn={toc:[]};function Ppn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Spn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ppn.isMDXComponent=!0;const Epn={toc:[]};function Bpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Epn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Bpn.isMDXComponent=!0;const Gpn={toc:[]};function Opn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Opn.isMDXComponent=!0;const Upn={toc:[]};function Fpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Upn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Fpn.isMDXComponent=!0;const qpn={toc:[]};function Vpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Vpn.isMDXComponent=!0;const jpn={toc:[]};function Hpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Hpn.isMDXComponent=!0;const Qpn={toc:[]};function $pn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}$pn.isMDXComponent=!0;const Ypn={toc:[]};function Kpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ypn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Kpn.isMDXComponent=!0;const Jpn={toc:[]};function trn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}trn.isMDXComponent=!0;const nrn={toc:[]};function ern(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}ern.isMDXComponent=!0;const orn={toc:[]};function prn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},orn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}prn.isMDXComponent=!0;const rrn={toc:[]};function srn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}srn.isMDXComponent=!0;const crn={toc:[]};function irn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},crn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}irn.isMDXComponent=!0;const arn={toc:[]};function lrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},arn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}lrn.isMDXComponent=!0;const urn={toc:[]};function mrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},urn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mrn.isMDXComponent=!0;const drn={toc:[]};function hrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},drn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}hrn.isMDXComponent=!0;const krn={toc:[]};function yrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},krn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}yrn.isMDXComponent=!0;const frn={toc:[]};function Mrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},frn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Mrn.isMDXComponent=!0;const Drn={toc:[]};function wrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Drn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wrn.isMDXComponent=!0;const _rn={toc:[]};function Xrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_rn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Xrn.isMDXComponent=!0;const grn={toc:[]};function Trn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},grn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Trn.isMDXComponent=!0;const xrn={toc:[]};function Crn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Crn.isMDXComponent=!0;const vrn={toc:[]};function Lrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lrn.isMDXComponent=!0;const Zrn={toc:[]};function brn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}brn.isMDXComponent=!0;const Nrn={toc:[]};function zrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zrn.isMDXComponent=!0;const Arn={toc:[]};function Wrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Arn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Wrn.isMDXComponent=!0;const Rrn={toc:[]};function Irn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Irn.isMDXComponent=!0;const Srn={toc:[]};function Prn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Srn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Prn.isMDXComponent=!0;const Ern={toc:[]};function Brn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ern,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Brn.isMDXComponent=!0;const Grn={toc:[]};function Orn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Grn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Orn.isMDXComponent=!0;const Urn={toc:[]};function Frn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Urn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Frn.isMDXComponent=!0;const qrn={toc:[]};function Vrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Vrn.isMDXComponent=!0;const jrn={toc:[]};function Hrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hrn.isMDXComponent=!0;const Qrn={toc:[]};function $rn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}$rn.isMDXComponent=!0;const Yrn={toc:[]};function Krn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Krn.isMDXComponent=!0;const Jrn={toc:[]};function tsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}tsn.isMDXComponent=!0;const nsn={toc:[]};function esn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}esn.isMDXComponent=!0;const osn={toc:[]};function psn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},osn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}psn.isMDXComponent=!0;const rsn={toc:[]};function ssn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}ssn.isMDXComponent=!0;const csn={toc:[]};function isn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},csn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}isn.isMDXComponent=!0;const asn={toc:[]};function lsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},asn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}lsn.isMDXComponent=!0;const usn={toc:[]};function msn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},usn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}msn.isMDXComponent=!0;const dsn={toc:[]};function hsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}hsn.isMDXComponent=!0;const ksn={toc:[]};function ysn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ksn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}ysn.isMDXComponent=!0;const fsn={toc:[]};function Msn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Msn.isMDXComponent=!0;const Dsn={toc:[]};function wsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}wsn.isMDXComponent=!0;const _sn={toc:[]};function Xsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_sn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xsn.isMDXComponent=!0;const gsn={toc:[]};function Tsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Tsn.isMDXComponent=!0;const xsn={toc:[]};function Csn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Csn.isMDXComponent=!0;const vsn={toc:[]};function Lsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Lsn.isMDXComponent=!0;const Zsn={toc:[]};function bsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}bsn.isMDXComponent=!0;const Nsn={toc:[]};function zsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}zsn.isMDXComponent=!0;const Asn={toc:[]};function Wsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Asn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Wsn.isMDXComponent=!0;const Rsn={toc:[]};function Isn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Isn.isMDXComponent=!0;const Ssn={toc:[]};function Psn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ssn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Psn.isMDXComponent=!0;const Esn={toc:[]};function Bsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Esn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bsn.isMDXComponent=!0;const Gsn={toc:[]};function Osn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Osn.isMDXComponent=!0;const Usn={toc:[]};function Fsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Usn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Fsn.isMDXComponent=!0;const qsn={toc:[]};function Vsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Vsn.isMDXComponent=!0;const jsn={toc:[]};function Hsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Hsn.isMDXComponent=!0;const Qsn={toc:[]};function $sn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}$sn.isMDXComponent=!0;const Ysn={toc:[]};function Ksn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ysn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ksn.isMDXComponent=!0;const Jsn={toc:[]};function tcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}tcn.isMDXComponent=!0;const ncn={toc:[]};function ecn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ncn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ecn.isMDXComponent=!0;const ocn={toc:[]};function pcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ocn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}pcn.isMDXComponent=!0;const rcn={toc:[]};function scn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}scn.isMDXComponent=!0;const ccn={toc:[]};function icn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ccn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}icn.isMDXComponent=!0;const acn={toc:[]};function lcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},acn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}lcn.isMDXComponent=!0;const ucn={toc:[]};function mcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ucn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}mcn.isMDXComponent=!0;const dcn={toc:[]};function hcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hcn.isMDXComponent=!0;const kcn={toc:[]};function ycn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}ycn.isMDXComponent=!0;const fcn={toc:[]};function Mcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mcn.isMDXComponent=!0;const Dcn={toc:[]};function wcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}wcn.isMDXComponent=!0;const _cn={toc:[]};function Xcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_cn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Xcn.isMDXComponent=!0;const gcn={toc:[]};function Tcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Tcn.isMDXComponent=!0;const xcn={toc:[]};function Ccn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Ccn.isMDXComponent=!0;const vcn={toc:[]};function Lcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Lcn.isMDXComponent=!0;const Zcn={toc:[]};function bcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}bcn.isMDXComponent=!0;const Ncn={toc:[]};function zcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ncn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zcn.isMDXComponent=!0;const Acn={toc:[]};function Wcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Acn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Wcn.isMDXComponent=!0;const Rcn={toc:[]};function Icn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Icn.isMDXComponent=!0;const Scn={toc:[]};function Pcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Scn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Pcn.isMDXComponent=!0;const Ecn={toc:[]};function Bcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ecn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bcn.isMDXComponent=!0;const Gcn={toc:[]};function Ocn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Ocn.isMDXComponent=!0;const Ucn={toc:[]};function Fcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ucn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}Fcn.isMDXComponent=!0;const qcn={toc:[]};function Vcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}Vcn.isMDXComponent=!0;const jcn={toc:[]};function Hcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Hcn.isMDXComponent=!0;const Qcn={toc:[]};function $cn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}$cn.isMDXComponent=!0;const Ycn={toc:[]};function Kcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ycn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Kcn.isMDXComponent=!0;const Jcn={toc:[]};function tin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}tin.isMDXComponent=!0;const nin={toc:[]};function ein(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}ein.isMDXComponent=!0;const oin={toc:[]};function pin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}pin.isMDXComponent=!0;const rin={toc:[]};function sin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sin.isMDXComponent=!0;const cin={toc:[]};function iin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}iin.isMDXComponent=!0;const ain={toc:[]};function lin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ain,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lin.isMDXComponent=!0;const uin={toc:[]};function min(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}min.isMDXComponent=!0;const din={toc:[]};function hin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},din,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hin.isMDXComponent=!0;const kin={toc:[]};function yin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}yin.isMDXComponent=!0;const fin={toc:[]};function Min(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Min.isMDXComponent=!0;const Din={toc:[]};function win(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Din,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}win.isMDXComponent=!0;const _in={toc:[]};function Xin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_in,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xin.isMDXComponent=!0;const gin={toc:[]};function Tin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Tin.isMDXComponent=!0;const xin={toc:[]};function Cin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cin.isMDXComponent=!0;const vin={toc:[]};function Lin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Lin.isMDXComponent=!0;const Zin={toc:[]};function bin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}bin.isMDXComponent=!0;const Nin={toc:[]};function zin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}zin.isMDXComponent=!0;const Ain={toc:[]};function Win(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ain,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Win.isMDXComponent=!0;const Rin={toc:[]};function Iin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Iin.isMDXComponent=!0;const Sin={toc:[]};function Pin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Pin.isMDXComponent=!0;const Ein={toc:[]};function Bin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ein,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bin.isMDXComponent=!0;const Gin={toc:[]};function Oin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Oin.isMDXComponent=!0;const Uin={toc:[]};function Fin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Fin.isMDXComponent=!0;const qin={toc:[]};function Vin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Vin.isMDXComponent=!0;const jin={toc:[]};function Hin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hin.isMDXComponent=!0;const Qin={toc:[]};function $in(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}$in.isMDXComponent=!0;const Yin={toc:[]};function Kin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kin.isMDXComponent=!0;const Jin={toc:[]};function tan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}tan.isMDXComponent=!0;const nan={toc:[]};function ean(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ean.isMDXComponent=!0;const oan={toc:[]};function pan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}pan.isMDXComponent=!0;const ran={toc:[]};function san(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ran,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}san.isMDXComponent=!0;const can={toc:[]};function ian(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},can,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}ian.isMDXComponent=!0;const aan={toc:[]};function lan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lan.isMDXComponent=!0;const uan={toc:[]};function man(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}man.isMDXComponent=!0;const dan={toc:[]};function han(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}han.isMDXComponent=!0;const kan={toc:[]};function yan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}yan.isMDXComponent=!0;const fan={toc:[]};function Man(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Man.isMDXComponent=!0;const Dan={toc:[]};function wan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}wan.isMDXComponent=!0;const _an={toc:[]};function Xan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_an,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xan.isMDXComponent=!0;const gan={toc:[]};function Tan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Tan.isMDXComponent=!0;const xan={toc:[]};function Can(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Can.isMDXComponent=!0;const van={toc:[]};function Lan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},van,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Lan.isMDXComponent=!0;const Zan={toc:[]};function ban(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}ban.isMDXComponent=!0;const Nan={toc:[]};function zan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}zan.isMDXComponent=!0;const Aan={toc:[]};function Wan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wan.isMDXComponent=!0;const Ran={toc:[]};function Ian(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ran,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Ian.isMDXComponent=!0;const San={toc:[]};function Pan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},San,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pan.isMDXComponent=!0;const Ean={toc:[]};function Ban(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ean,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Ban.isMDXComponent=!0;const Gan={toc:[]};function Oan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Oan.isMDXComponent=!0;const Uan={toc:[]};function Fan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Fan.isMDXComponent=!0;const qan={toc:[]};function Van(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Van.isMDXComponent=!0;const jan={toc:[]};function Han(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Han.isMDXComponent=!0;const Qan={toc:[]};function $an(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}$an.isMDXComponent=!0;const Yan={toc:[]};function Kan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Kan.isMDXComponent=!0;const Jan={toc:[]};function tln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}tln.isMDXComponent=!0;const nln={toc:[]};function eln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}eln.isMDXComponent=!0;const oln={toc:[]};function pln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}pln.isMDXComponent=!0;const rln={toc:[]};function sln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}sln.isMDXComponent=!0;const cln={toc:[]};function iln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iln.isMDXComponent=!0;const aln={toc:[]};function lln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}lln.isMDXComponent=!0;const uln={toc:[]};function mln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mln.isMDXComponent=!0;const dln={toc:[]};function hln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}hln.isMDXComponent=!0;const kln={toc:[]};function yln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}yln.isMDXComponent=!0;const fln={toc:[]};function Mln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Mln.isMDXComponent=!0;const Dln={toc:[]};function wln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wln.isMDXComponent=!0;const _ln={toc:[]};function Xln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Xln.isMDXComponent=!0;const gln={toc:[]};function Tln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Tln.isMDXComponent=!0;const xln={toc:[]};function Cln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Cln.isMDXComponent=!0;const vln={toc:[]};function Lln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lln.isMDXComponent=!0;const Zln={toc:[]};function bln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}bln.isMDXComponent=!0;const Nln={toc:[]};function zln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zln.isMDXComponent=!0;const Aln={toc:[]};function Wln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Wln.isMDXComponent=!0;const Rln={toc:[]};function Iln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Iln.isMDXComponent=!0;const Sln={toc:[]};function Pln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Pln.isMDXComponent=!0;const Eln={toc:[]};function Bln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bln.isMDXComponent=!0;const Gln={toc:[]};function Oln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Oln.isMDXComponent=!0;const Uln={toc:[]};function Fln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Fln.isMDXComponent=!0;const qln={toc:[]};function Vln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Vln.isMDXComponent=!0;const jln={toc:[]};function Hln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hln.isMDXComponent=!0;const Qln={toc:[]};function $ln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}$ln.isMDXComponent=!0;const Yln={toc:[]};function Kln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kln.isMDXComponent=!0;const Jln={toc:[]};function tun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}tun.isMDXComponent=!0;const nun={toc:[]};function eun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eun.isMDXComponent=!0;const oun={toc:[]};function pun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pun.isMDXComponent=!0;const run={toc:[]};function sun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},run,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}sun.isMDXComponent=!0;const cun={toc:[]};function iun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}iun.isMDXComponent=!0;const aun={toc:[]};function lun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lun.isMDXComponent=!0;const uun={toc:[]};function mun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}mun.isMDXComponent=!0;const dun={toc:[]};function hun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hun.isMDXComponent=!0;const kun={toc:[]};function yun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}yun.isMDXComponent=!0;const fun={toc:[]};function Mun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mun.isMDXComponent=!0;const Dun={toc:[]};function wun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}wun.isMDXComponent=!0;const _un={toc:[]};function Xun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_un,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Xun.isMDXComponent=!0;const gun={toc:[]};function Tun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Tun.isMDXComponent=!0;const xun={toc:[]};function Cun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cun.isMDXComponent=!0;const vun={toc:[]};function Lun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Lun.isMDXComponent=!0;const Zun={toc:[]};function bun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bun.isMDXComponent=!0;const Nun={toc:[]};function zun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}zun.isMDXComponent=!0;const Aun={toc:[]};function Wun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wun.isMDXComponent=!0;const Run={toc:[]};function Iun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Run,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Iun.isMDXComponent=!0;const Sun={toc:[]};function Pun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Pun.isMDXComponent=!0;const Eun={toc:[]};function Bun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Bun.isMDXComponent=!0;const Gun={toc:[]};function Oun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Oun.isMDXComponent=!0;const Uun={toc:[]};function Fun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Fun.isMDXComponent=!0;const qun={toc:[]};function Vun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Vun.isMDXComponent=!0;const jun={toc:[]};function Hun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Hun.isMDXComponent=!0;const Qun={toc:[]};function $un(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}$un.isMDXComponent=!0;const Yun={toc:[]};function Kun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Kun.isMDXComponent=!0;const Jun={toc:[]};function tmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tmn.isMDXComponent=!0;const nmn={toc:[]};function emn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}emn.isMDXComponent=!0;const omn={toc:[]};function pmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},omn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pmn.isMDXComponent=!0;const rmn={toc:[]};function smn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}smn.isMDXComponent=!0;const cmn={toc:[]};function imn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}imn.isMDXComponent=!0;const amn={toc:[]};function lmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},amn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}lmn.isMDXComponent=!0;const umn={toc:[]};function mmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},umn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}mmn.isMDXComponent=!0;const dmn={toc:[]};function hmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}hmn.isMDXComponent=!0;const kmn={toc:[]};function ymn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}ymn.isMDXComponent=!0;const fmn={toc:[]};function Mmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Mmn.isMDXComponent=!0;const Dmn={toc:[]};function wmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wmn.isMDXComponent=!0;const _mn={toc:[]};function Xmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_mn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Xmn.isMDXComponent=!0;const gmn={toc:[]};function Tmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tmn.isMDXComponent=!0;const xmn={toc:[]};function Cmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Cmn.isMDXComponent=!0;const vmn={toc:[]};function Lmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lmn.isMDXComponent=!0;const Zmn={toc:[]};function bmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}bmn.isMDXComponent=!0;const Nmn={toc:[]};function zmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}zmn.isMDXComponent=!0;const Amn={toc:[]};function Wmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Amn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Wmn.isMDXComponent=!0;const Rmn={toc:[]};function Imn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Imn.isMDXComponent=!0;const Smn={toc:[]};function Pmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Smn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Pmn.isMDXComponent=!0;const Emn={toc:[]};function Bmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Emn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bmn.isMDXComponent=!0;const Gmn={toc:[]};function Omn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Omn.isMDXComponent=!0;const Umn={toc:[]};function Fmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Umn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Fmn.isMDXComponent=!0;const qmn={toc:[]};function Vmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Vmn.isMDXComponent=!0;const jmn={toc:[]};function Hmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Hmn.isMDXComponent=!0;const Qmn={toc:[]};function $mn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}$mn.isMDXComponent=!0;const Ymn={toc:[]};function Kmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ymn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Kmn.isMDXComponent=!0;const Jmn={toc:[]};function tdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}tdn.isMDXComponent=!0;const ndn={toc:[]};function edn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ndn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}edn.isMDXComponent=!0;const odn={toc:[]};function pdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},odn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}pdn.isMDXComponent=!0;const rdn={toc:[]};function sdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}sdn.isMDXComponent=!0;const cdn={toc:[]};function idn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}idn.isMDXComponent=!0;const adn={toc:[]};function ldn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},adn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}ldn.isMDXComponent=!0;const udn={toc:[]};function mdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},udn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mdn.isMDXComponent=!0;const ddn={toc:[]};function hdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ddn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}hdn.isMDXComponent=!0;const kdn={toc:[]};function ydn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ydn.isMDXComponent=!0;const fdn={toc:[]};function Mdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Mdn.isMDXComponent=!0;const Ddn={toc:[]};function wdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ddn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wdn.isMDXComponent=!0;const _dn={toc:[]};function Xdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_dn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Xdn.isMDXComponent=!0;const gdn={toc:[]};function Tdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Tdn.isMDXComponent=!0;const xdn={toc:[]};function Cdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Cdn.isMDXComponent=!0;const vdn={toc:[]};function Ldn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Ldn.isMDXComponent=!0;const Zdn={toc:[]};function bdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}bdn.isMDXComponent=!0;const Ndn={toc:[]};function zdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ndn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}zdn.isMDXComponent=!0;const Adn={toc:[]};function Wdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Adn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wdn.isMDXComponent=!0;const Rdn={toc:[]};function Idn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Idn.isMDXComponent=!0;const Sdn={toc:[]};function Pdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pdn.isMDXComponent=!0;const Edn={toc:[]};function Bdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Edn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Bdn.isMDXComponent=!0;const Gdn={toc:[]};function Odn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Odn.isMDXComponent=!0;const Udn={toc:[]};function Fdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Udn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Fdn.isMDXComponent=!0;const qdn={toc:[]};function Vdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vdn.isMDXComponent=!0;const jdn={toc:[]};function Hdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Hdn.isMDXComponent=!0;const Qdn={toc:[]};function $dn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$dn.isMDXComponent=!0;const Ydn={toc:[]};function Kdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ydn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Kdn.isMDXComponent=!0;const Jdn={toc:[]};function thn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}thn.isMDXComponent=!0;const nhn={toc:[]};function ehn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}ehn.isMDXComponent=!0;const ohn={toc:[]};function phn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ohn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}phn.isMDXComponent=!0;const rhn={toc:[]};function shn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}shn.isMDXComponent=!0;const chn={toc:[]};function ihn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},chn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ihn.isMDXComponent=!0;const ahn={toc:[]};function lhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ahn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}lhn.isMDXComponent=!0;const uhn={toc:[]};function mhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mhn.isMDXComponent=!0;const dhn={toc:[]};function hhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}hhn.isMDXComponent=!0;const khn={toc:[]};function yhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},khn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}yhn.isMDXComponent=!0;const fhn={toc:[]};function Mhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Mhn.isMDXComponent=!0;const Dhn={toc:[]};function whn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}whn.isMDXComponent=!0;const _hn={toc:[]};function Xhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_hn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Xhn.isMDXComponent=!0;const ghn={toc:[]};function Thn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ghn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Thn.isMDXComponent=!0;const xhn={toc:[]};function Chn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Chn.isMDXComponent=!0;const vhn={toc:[]};function Lhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lhn.isMDXComponent=!0;const Zhn={toc:[]};function bhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}bhn.isMDXComponent=!0;const Nhn={toc:[]};function zhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zhn.isMDXComponent=!0;const Ahn={toc:[]};function Whn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ahn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Whn.isMDXComponent=!0;const Rhn={toc:[]};function Ihn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ihn.isMDXComponent=!0;const Shn={toc:[]};function Phn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Shn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Phn.isMDXComponent=!0;const Ehn={toc:[]};function Bhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ehn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bhn.isMDXComponent=!0;const Ghn={toc:[]};function Ohn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ghn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ohn.isMDXComponent=!0;const Uhn={toc:[]};function Fhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Fhn.isMDXComponent=!0;const qhn={toc:[]};function Vhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Vhn.isMDXComponent=!0;const jhn={toc:[]};function Hhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hhn.isMDXComponent=!0;const Qhn={toc:[]};function $hn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}$hn.isMDXComponent=!0;const Yhn={toc:[]};function Khn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Khn.isMDXComponent=!0;const Jhn={toc:[]};function tkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}tkn.isMDXComponent=!0;const nkn={toc:[]};function ekn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ekn.isMDXComponent=!0;const okn={toc:[]};function pkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},okn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}pkn.isMDXComponent=!0;const rkn={toc:[]};function skn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}skn.isMDXComponent=!0;const ckn={toc:[]};function ikn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ckn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}ikn.isMDXComponent=!0;const akn={toc:[]};function lkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},akn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}lkn.isMDXComponent=!0;const ukn={toc:[]};function mkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ukn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}mkn.isMDXComponent=!0;const dkn={toc:[]};function hkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hkn.isMDXComponent=!0;const kkn={toc:[]};function ykn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}ykn.isMDXComponent=!0;const fkn={toc:[]};function Mkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mkn.isMDXComponent=!0;const Dkn={toc:[]};function wkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}wkn.isMDXComponent=!0;const _kn={toc:[]};function Xkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_kn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xkn.isMDXComponent=!0;const gkn={toc:[]};function Tkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Tkn.isMDXComponent=!0;const xkn={toc:[]};function Ckn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Ckn.isMDXComponent=!0;const vkn={toc:[]};function Lkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Lkn.isMDXComponent=!0;const Zkn={toc:[]};function bkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}bkn.isMDXComponent=!0;const Nkn={toc:[]};function zkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}zkn.isMDXComponent=!0;const Akn={toc:[]};function Wkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Akn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Wkn.isMDXComponent=!0;const Rkn={toc:[]};function Ikn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Ikn.isMDXComponent=!0;const Skn={toc:[]};function Pkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Skn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Pkn.isMDXComponent=!0;const Ekn={toc:[]};function Bkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ekn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Bkn.isMDXComponent=!0;const Gkn={toc:[]};function Okn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Okn.isMDXComponent=!0;const Ukn={toc:[]};function Fkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ukn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Fkn.isMDXComponent=!0;const qkn={toc:[]};function Vkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Spline.points"))}Vkn.isMDXComponent=!0;const jkn={toc:[]};function Hkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hkn.isMDXComponent=!0;const Qkn={toc:[]};function $kn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}$kn.isMDXComponent=!0;const Ykn={toc:[]};function Kkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ykn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}Kkn.isMDXComponent=!0;const Jkn={toc:[]};function tyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}tyn.isMDXComponent=!0;const nyn={toc:[]};function eyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}eyn.isMDXComponent=!0;const oyn={toc:[]};function pyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}pyn.isMDXComponent=!0;const ryn={toc:[]};function syn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ryn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}syn.isMDXComponent=!0;const cyn={toc:[]};function iyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}iyn.isMDXComponent=!0;const ayn={toc:[]};function lyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ayn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lyn.isMDXComponent=!0;const uyn={toc:[]};function myn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}myn.isMDXComponent=!0;const dyn={toc:[]};function hyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hyn.isMDXComponent=!0;const kyn={toc:[]};function yyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}yyn.isMDXComponent=!0;const fyn={toc:[]};function Myn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Myn.isMDXComponent=!0;const Dyn={toc:[]};function wyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wyn.isMDXComponent=!0;const _yn={toc:[]};function Xyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_yn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xyn.isMDXComponent=!0;const gyn={toc:[]};function Tyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Tyn.isMDXComponent=!0;const xyn={toc:[]};function Cyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cyn.isMDXComponent=!0;const vyn={toc:[]};function Lyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Lyn.isMDXComponent=!0;const Zyn={toc:[]};function byn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}byn.isMDXComponent=!0;const Nyn={toc:[]};function zyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}zyn.isMDXComponent=!0;const Ayn={toc:[]};function Wyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ayn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wyn.isMDXComponent=!0;const Ryn={toc:[]};function Iyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ryn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Iyn.isMDXComponent=!0;const Syn={toc:[]};function Pyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Syn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pyn.isMDXComponent=!0;const Eyn={toc:[]};function Byn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Byn.isMDXComponent=!0;const Gyn={toc:[]};function Oyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Oyn.isMDXComponent=!0;const Uyn={toc:[]};function Fyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Fyn.isMDXComponent=!0;const qyn={toc:[]};function Vyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vyn.isMDXComponent=!0;const jyn={toc:[]};function Hyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Hyn.isMDXComponent=!0;const Qyn={toc:[]};function $yn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$yn.isMDXComponent=!0;const Yyn={toc:[]};function Kyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Kyn.isMDXComponent=!0;const Jyn={toc:[]};function tfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tfn.isMDXComponent=!0;const nfn={toc:[]};function efn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}efn.isMDXComponent=!0;const ofn={toc:[]};function pfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ofn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}pfn.isMDXComponent=!0;const rfn={toc:[]};function sfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}sfn.isMDXComponent=!0;const cfn={toc:[]};function ifn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ifn.isMDXComponent=!0;const afn={toc:[]};function lfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},afn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}lfn.isMDXComponent=!0;const ufn={toc:[]};function mfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ufn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mfn.isMDXComponent=!0;const dfn={toc:[]};function hfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}hfn.isMDXComponent=!0;const kfn={toc:[]};function yfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}yfn.isMDXComponent=!0;const ffn={toc:[]};function Mfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ffn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Mfn.isMDXComponent=!0;const Dfn={toc:[]};function wfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}wfn.isMDXComponent=!0;const _fn={toc:[]};function Xfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_fn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Xfn.isMDXComponent=!0;const gfn={toc:[]};function Tfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tfn.isMDXComponent=!0;const xfn={toc:[]};function Cfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Cfn.isMDXComponent=!0;const vfn={toc:[]};function Lfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}Lfn.isMDXComponent=!0;const Zfn={toc:[]};function bfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bfn.isMDXComponent=!0;const Nfn={toc:[]};function zfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}zfn.isMDXComponent=!0;const Afn={toc:[]};function Wfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Afn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Wfn.isMDXComponent=!0;const Rfn={toc:[]};function Ifn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Ifn.isMDXComponent=!0;const Sfn={toc:[]};function Pfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}Pfn.isMDXComponent=!0;const Efn={toc:[]};function Bfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Efn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}Bfn.isMDXComponent=!0;const Gfn={toc:[]};function Ofn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}Ofn.isMDXComponent=!0;const Ufn={toc:[]};function Ffn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ufn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting time for this video in seconds."))}Ffn.isMDXComponent=!0;const qfn={toc:[]};function Vfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vfn.isMDXComponent=!0;const jfn={toc:[]};function Hfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Hfn.isMDXComponent=!0;const Qfn={toc:[]};function $fn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$fn.isMDXComponent=!0;const Yfn={toc:[]};function Kfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Kfn.isMDXComponent=!0;const Jfn={toc:[]};function tMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tMn.isMDXComponent=!0;const nMn={toc:[]};function eMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}eMn.isMDXComponent=!0;const oMn={toc:[]};function pMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pMn.isMDXComponent=!0;const rMn={toc:[]};function sMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}sMn.isMDXComponent=!0;const cMn={toc:[]};function iMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iMn.isMDXComponent=!0;const aMn={toc:[]};function lMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}lMn.isMDXComponent=!0;const uMn={toc:[]};function mMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mMn.isMDXComponent=!0;const dMn={toc:[]};function hMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}hMn.isMDXComponent=!0;const kMn={toc:[]};function yMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}yMn.isMDXComponent=!0;const fMn={toc:[]};function MMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}MMn.isMDXComponent=!0;const DMn={toc:[]};function wMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wMn.isMDXComponent=!0;const _Mn={toc:[]};function XMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Mn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}XMn.isMDXComponent=!0;const gMn={toc:[]};function TMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TMn.isMDXComponent=!0;const xMn={toc:[]};function CMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}CMn.isMDXComponent=!0;const vMn={toc:[]};function LMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}LMn.isMDXComponent=!0;const ZMn={toc:[]};function bMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}bMn.isMDXComponent=!0;const NMn={toc:[]};function zMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zMn.isMDXComponent=!0;const AMn={toc:[]};function WMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}WMn.isMDXComponent=!0;const RMn={toc:[]};function IMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}IMn.isMDXComponent=!0;const SMn={toc:[]};function PMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}PMn.isMDXComponent=!0;const EMn={toc:[]};function BMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BMn.isMDXComponent=!0;const GMn={toc:[]};function OMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}OMn.isMDXComponent=!0;const UMn={toc:[]};function FMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}FMn.isMDXComponent=!0;const qMn={toc:[]};function VMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}VMn.isMDXComponent=!0;const jMn={toc:[]};function HMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}HMn.isMDXComponent=!0;const QMn={toc:[]};function $Mn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}$Mn.isMDXComponent=!0;const YMn={toc:[]};function KMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}KMn.isMDXComponent=!0;const JMn={toc:[]};function tDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,s.kt)("p",null,"Source code liberally taken from:\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}tDn.isMDXComponent=!0;const nDn={toc:[]};function eDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}eDn.isMDXComponent=!0;const oDn={toc:[]};function pDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}pDn.isMDXComponent=!0;const rDn={toc:[]};function sDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}sDn.isMDXComponent=!0;const cDn={toc:[]};function iDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}iDn.isMDXComponent=!0;const aDn={toc:[]};function lDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}lDn.isMDXComponent=!0;const uDn={toc:[]};function mDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}mDn.isMDXComponent=!0;const dDn={toc:[]};function hDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}hDn.isMDXComponent=!0;const kDn={toc:[]};function yDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}yDn.isMDXComponent=!0;const fDn={toc:[]};function MDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}MDn.isMDXComponent=!0;const DDn={toc:[]};function wDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}wDn.isMDXComponent=!0;const _Dn={toc:[]};function XDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Dn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The degree of the polynomial"))}XDn.isMDXComponent=!0;const gDn={toc:[]};function TDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the nth derivative of the polynomial."))}TDn.isMDXComponent=!0;const xDn={toc:[]};function CDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of times to differentiate the polynomial."))}CDn.isMDXComponent=!0;const vDn={toc:[]};function LDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given value t."))}LDn.isMDXComponent=!0;const ZDn={toc:[]};function bDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}bDn.isMDXComponent=!0;const NDn={toc:[]};function zDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}zDn.isMDXComponent=!0;const ADn={toc:[]};function WDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}WDn.isMDXComponent=!0;const RDn={toc:[]};function IDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The derivative of the polynomial to sample from"))}IDn.isMDXComponent=!0;const SDn={toc:[]};function PDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial."))}PDn.isMDXComponent=!0;const EDn={toc:[]};function BDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}BDn.isMDXComponent=!0;const GDn={toc:[]};function ODn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the output value range within the unit interval."))}ODn.isMDXComponent=!0;const UDn={toc:[]};function FDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}FDn.isMDXComponent=!0;const qDn={toc:[]};function VDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}VDn.isMDXComponent=!0;const jDn={toc:[]};function HDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}HDn.isMDXComponent=!0;const QDn={toc:[]};function $Dn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The point at which to split the polynomial."))}$Dn.isMDXComponent=!0;const YDn={toc:[]};function KDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a constant polynomial"))}KDn.isMDXComponent=!0;const JDn={toc:[]};function twn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}twn.isMDXComponent=!0;const nwn={toc:[]};function ewn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a cubic polynomial"))}ewn.isMDXComponent=!0;const own={toc:[]};function pwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},own,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}pwn.isMDXComponent=!0;const rwn={toc:[]};function swn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}swn.isMDXComponent=!0;const cwn={toc:[]};function iwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}iwn.isMDXComponent=!0;const awn={toc:[]};function lwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}lwn.isMDXComponent=!0;const uwn={toc:[]};function mwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a linear polynomial"))}mwn.isMDXComponent=!0;const dwn={toc:[]};function hwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}hwn.isMDXComponent=!0;const kwn={toc:[]};function ywn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}ywn.isMDXComponent=!0;const fwn={toc:[]};function Mwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a quadratic polynomial"))}Mwn.isMDXComponent=!0;const Dwn={toc:[]};function wwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}wwn.isMDXComponent=!0;const _wn={toc:[]};function Xwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_wn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}Xwn.isMDXComponent=!0;const gwn={toc:[]};function Twn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}Twn.isMDXComponent=!0;const xwn={toc:[]};function Cwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}Cwn.isMDXComponent=!0;const vwn={toc:[]};function Lwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}Lwn.isMDXComponent=!0;const Zwn={toc:[]};function bwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}bwn.isMDXComponent=!0;const Nwn={toc:[]};function zwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}zwn.isMDXComponent=!0;const Awn={toc:[]};function Wwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}Wwn.isMDXComponent=!0;const Rwn={toc:[]};function Iwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}Iwn.isMDXComponent=!0;const Swn={toc:[]};function Pwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Swn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,s.kt)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}Pwn.isMDXComponent=!0;const Ewn={toc:[]};function Bwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ewn,e,{components:n,mdxType:"MDXLayout"}))}Bwn.isMDXComponent=!0;const Gwn={toc:[]};function Own(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}Own.isMDXComponent=!0;const Uwn={toc:[]};function Fwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The knots defining the spline"))}Fwn.isMDXComponent=!0;const qwn={toc:[]};function Vwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the spline should be closed or not"))}Vwn.isMDXComponent=!0;const jwn={toc:[]};function Hwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}Hwn.isMDXComponent=!0;const Qwn={toc:[]};function $wn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}$wn.isMDXComponent=!0;const Ywn={toc:[]};function Kwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ywn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}Kwn.isMDXComponent=!0;const Jwn={toc:[]};function t_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}t_n.isMDXComponent=!0;const n_n={toc:[]};function e_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}e_n.isMDXComponent=!0;const o_n={toc:[]};function p_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}p_n.isMDXComponent=!0;const r_n={toc:[]};function s_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}s_n.isMDXComponent=!0;const c_n={toc:[]};function i_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}i_n.isMDXComponent=!0;const a_n={toc:[]};function l_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}l_n.isMDXComponent=!0;const u_n={toc:[]};function m_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}m_n.isMDXComponent=!0;const d_n={toc:[]};function h_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}h_n.isMDXComponent=!0;const k_n={toc:[]};function y_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,s.kt)("p",null,"By default, any property is cloneable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}y_n.isMDXComponent=!0;const f_n={toc:[]};function M_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}M_n.isMDXComponent=!0;const D_n={toc:[]};function w_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a cloneable property decorator."))}w_n.isMDXComponent=!0;const __n={toc:[]};function X_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},__n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be cloneable."))}X_n.isMDXComponent=!0;const g_n={toc:[]};function T_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}T_n.isMDXComponent=!0;const x_n={toc:[]};function C_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}C_n.isMDXComponent=!0;const v_n={toc:[]};function L_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a compound property decorator."))}L_n.isMDXComponent=!0;const Z_n={toc:[]};function b_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}b_n.isMDXComponent=!0;const N_n={toc:[]};function z_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,s.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,s.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}z_n.isMDXComponent=!0;const A_n={toc:[]};function W_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a computed method decorator."))}W_n.isMDXComponent=!0;const R_n={toc:[]};function I_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the initial value of a property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}I_n.isMDXComponent=!0;const S_n={toc:[]};function P_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}P_n.isMDXComponent=!0;const E_n={toc:[]};function B_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an initial signal value decorator."))}B_n.isMDXComponent=!0;const G_n={toc:[]};function O_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the property."))}O_n.isMDXComponent=!0;const U_n={toc:[]};function F_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,s.kt)("p",null,"By default, any property is inspectable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}F_n.isMDXComponent=!0;const q_n={toc:[]};function V_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}V_n.isMDXComponent=!0;const j_n={toc:[]};function H_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an inspectable property decorator."))}H_n.isMDXComponent=!0;const Q_n={toc:[]};function $_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be inspectable."))}$_n.isMDXComponent=!0;const Y_n={toc:[]};function K_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}K_n.isMDXComponent=!0;const J_n={toc:[]};function tXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}tXn.isMDXComponent=!0;const nXn={toc:[]};function eXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal interpolation function decorator."))}eXn.isMDXComponent=!0;const oXn={toc:[]};function pXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function for the property."))}pXn.isMDXComponent=!0;const rXn={toc:[]};function sXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,s.kt)("p",null,"If the wrapper class has a method called ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}sXn.isMDXComponent=!0;const cXn={toc:[]};function iXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}iXn.isMDXComponent=!0;const aXn={toc:[]};function lXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal parser decorator."))}lXn.isMDXComponent=!0;const uXn={toc:[]};function mXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}mXn.isMDXComponent=!0;const dXn={toc:[]};function hXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given property into a signal."),(0,s.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}hXn.isMDXComponent=!0;const kXn={toc:[]};function yXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}yXn.isMDXComponent=!0;const fXn={toc:[]};function MXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal decorator."))}MXn.isMDXComponent=!0;const DXn={toc:[]};function wXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,s.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,s.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,s.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}wXn.isMDXComponent=!0;const _Xn={toc:[]};function XXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Xn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}XXn.isMDXComponent=!0;const gXn={toc:[]};function TXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal wrapper decorator."))}TXn.isMDXComponent=!0;const xXn={toc:[]};function CXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}CXn.isMDXComponent=!0;const vXn={toc:[]};function LXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A unified abstraction for all CSS filters."))}LXn.isMDXComponent=!0;const ZXn={toc:[]};function bXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the desired length is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}bXn.isMDXComponent=!0;const NXn={toc:[]};function zXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}zXn.isMDXComponent=!0;const AXn={toc:[]};function WXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can be either:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'"))))}WXn.isMDXComponent=!0;const RXn={toc:[]};function IXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length used by most layout properties."))}IXn.isMDXComponent=!0;const SXn={toc:[]};function PXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,s.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}PXn.isMDXComponent=!0;const EXn={toc:[]};function BXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,s.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}BXn.isMDXComponent=!0;const GXn={toc:[]};function OXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in pixels."))}OXn.isMDXComponent=!0;const UXn={toc:[]};function FXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,s.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}FXn.isMDXComponent=!0;const qXn={toc:[]};function VXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}VXn.isMDXComponent=!0;const jXn={toc:[]};function HXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,s.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}HXn.isMDXComponent=!0;const QXn={toc:[]};function $Xn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}$Xn.isMDXComponent=!0;const YXn={toc:[]};function KXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,s.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}KXn.isMDXComponent=!0;const JXn={toc:[]};function tgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}tgn.isMDXComponent=!0;const ngn={toc:[]};function egn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ngn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}egn.isMDXComponent=!0;const ogn={toc:[]};function pgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ogn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in degrees."))}pgn.isMDXComponent=!0;const rgn={toc:[]};function sgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,s.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}sgn.isMDXComponent=!0;const cgn={toc:[]};function ign(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}ign.isMDXComponent=!0;const agn={toc:[]};function lgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},agn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,s.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}lgn.isMDXComponent=!0;const ugn={toc:[]};function mgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ugn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}mgn.isMDXComponent=!0;const dgn={toc:[]};function hgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,s.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}hgn.isMDXComponent=!0;const kgn={toc:[]};function ygn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}ygn.isMDXComponent=!0;const fgn={toc:[]};function Mgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}Mgn.isMDXComponent=!0;const Dgn={toc:[]};function wgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}wgn.isMDXComponent=!0;const _gn={toc:[]};function Xgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_gn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}Xgn.isMDXComponent=!0;const ggn={toc:[]};function Tgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ggn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}function xgn(t){let{id:n}=t;const e=o[n]??p.Fragment;return p.createElement(e,null)}Tgn.isMDXComponent=!0},79322:(t,n,e)=>{e.d(n,{Z:()=>m});var o=e(2784),p=e(30956),r=e(28698);const s="toggle_S_IX",c="collapsed_wdUB",i="collapse_TjTN",a="inverse_g6vW",l="clearFix_HQ1T";var u=e(6277);function m(t){let{comment:n,full:e=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@remarks"===n}))}),[n]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==n?void 0:n.summaryId}),o.createElement(p.Z,{id:null==r?void 0:r.contentId}),e&&o.createElement(d,{comment:n}))}function d(t){let{comment:n}=t;const[e,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@preview"===n}))}),[n]),h=(0,o.useMemo)((()=>{var t;return(null==n||null==(t=n.blockTags)?void 0:t.filter((t=>{let{tag:n}=t;return"@example"===n})))??[]}),[n]),k=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@defaultValue"===n}))}),[n]),y=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@deprecated"===n}))}),[n]),f=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@see"===n}))}),[n]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==d?void 0:d.contentId}),h.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(s,e&&c),onClick:t=>{t.preventDefault(),m(!e)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:e},o.createElement("div",{className:i},h.map((t=>o.createElement(p.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,a)})),k&&o.createElement(o.Fragment,null,"Default Value:"," ",o.createElement("code",null,k.content.map((t=>t.text)).join(""))),y&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(p.Z,{id:y.contentId})),f&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(p.Z,{id:f.contentId})))}},31930:(t,n,e)=>{e.d(n,{Z:()=>Ot});var o=e(2784),p=e(37390),r=e(66835),s=e(80068),c=e(6277),i=e(68569);const a={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=e(7896);function u(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({width:n,height:e,"aria-hidden":"true",viewBox:"0 0 24 24"},p),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:n,highlight:e,onClick:p,link:l}=t;const m=(0,r.F)(),d=(0,s.s2)();return o.createElement("div",{className:(0,c.Z)(i.Z.codeBlockContent,a.codeBlock,e&&a.highlight,p&&a.pointer)},o.createElement("pre",{onClick:p,onKeyDown:t=>{"Enter"===t.key&&(null==p||p())},tabIndex:0,ref:m.codeBlockRef,className:(0,c.Z)(i.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:i.Z.codeBlockLines,style:d},n)),l&&o.createElement("div",{className:i.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=e(39318);function h(t){let{children:n}=t;return o.createElement(d.Z,{as:"div",className:(0,c.Z)(a.codeBlockContainer,"language-typescript")},n)}var k=e(89817);function y(t){let{children:n,type:e,to:p,id:r,tooltip:c}=t;const i=(0,s.Ld)(e);return p?o.createElement(k.Z,(0,l.Z)({id:r,to:p,"data-tooltip":c},i),n):o.createElement("span",(0,l.Z)({id:r},i),n)}let f,M;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(f||(f={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(M||(M={}));const D={[f.None]:a.none,[f.Angle]:a.angle,[f.Curly]:a.curly,[f.Square]:a.square,[f.Parentheses]:a.parentheses};function w(t){let{children:n,type:e,separator:p=M.Comma}=t;return o.createElement("span",{className:(0,c.Z)(a.list,D[e??f.None])},o.createElement("span",{className:(0,c.Z)(a.elements,p!==M.Comma&&a.left)},(Array.isArray(n)?n:[n]).flatMap(((t,n)=>o.createElement("span",{"data-separator":p,key:n,className:a.element},t)))))}var _=e(88617);function X(t){var n;let{type:e}=t;const p=(0,_.RU)(e.project),r=null==p?void 0:p[e.id],s=e.externalUrl??(0,_.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(y,{to:s,type:s?"class-name":"constant",tooltip:!0},e.name),!(null==(n=e.typeArguments)||!n.length)&&o.createElement(w,{type:f.Angle},e.typeArguments.map(((t,n)=>o.createElement(E,{key:n,type:t})))))}function g(t){let{type:n}=t;return o.createElement(y,{type:"keyword"},n.name)}function T(t){let{type:n}=t;return n.elements?o.createElement(w,{type:f.Square},n.elements.map(((t,n)=>o.createElement(E,{key:n,type:t})))):o.createElement(o.Fragment,null,"[]")}function x(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:n.elementType}),"[]")}function C(t){let{type:n}=t;return o.createElement(w,{type:f.Parentheses,separator:M.Pipe},n.types.map(((t,n)=>o.createElement(E,{key:n,type:t}))))}function v(t){let{type:n}=t;const[e,p]=(0,o.useMemo)((()=>{if(null===n.value)return["null","keyword"];switch(typeof n.value){case"object":return[(n.value.negative?"-":"")+n.value.value,"number"];case"boolean":return[n.value,"keyword"];case"number":return[n.value,"number"];case"string":return[`'${n.value}'`,"string"];default:return[n.value,"constant"]}}),[n.value]);return o.createElement(y,{type:p},e)}function L(t){let{type:n}=t;return n.asserts?o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"asserts "),o.createElement(y,null,n.name," ")):o.createElement(o.Fragment,null,o.createElement(y,null,n.name," "),o.createElement(y,{type:"keyword"},"is "),o.createElement(E,{type:n.targetType}))}function Z(t){let{type:n}=t;const e=(0,_.in)();return o.createElement($,{reflection:e(n.declaration)})}function b(t){let{type:n}=t;return o.createElement(w,{type:f.Parentheses,separator:M.Ampersand},n.types.map(((t,n)=>o.createElement(E,{key:n,type:t}))))}function N(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"string"},"`",n.head),n.tail.map(((t,n)=>{let[e,p]=t;return o.createElement(o.Fragment,null,"${",o.createElement(E,{key:n,type:e}),"}",o.createElement(y,{type:"string"},p))})),o.createElement(y,{type:"string"},"`"))}function z(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"typeof "),o.createElement(E,{type:n.queryType}))}function A(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:n.checkType}),o.createElement(y,{type:"keyword"}," extends "),o.createElement(E,{type:n.extendsType})," ? ",o.createElement(E,{type:n.trueType})," : ",o.createElement(E,{type:n.falseType}))}function W(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"infer "),o.createElement(y,{type:"constant"},n.name))}function R(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:n.objectType}),"[",o.createElement(E,{type:n.indexType}),"]")}function I(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},n.operator," "),o.createElement(E,{type:n.target}))}function S(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(w,{type:f.Curly},o.createElement(o.Fragment,null,"[",o.createElement(y,{type:"class"},n.parameter),o.createElement(y,{type:"keyword"}," in "),o.createElement(E,{type:n.parameterType}),"]: ",o.createElement(E,{type:n.templateType}))))}function P(t){let{type:n}=t;return o.createElement(o.Fragment,null,n.name,": ",o.createElement(E,{type:n.element}))}function E(t){const n=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return I;case"conditional":return A;case"reflection":return Z;case"query":return z;case"named-tuple-member":return P;case"union":return C;case"intrinsic":return g;case"literal":return v;case"reference":return X;case"predicate":return L;case"tuple":return T;case"array":return x;case"intersection":return b;case"inferred":return W;case"mapped":return S;case"template-literal":return N;case"indexedAccess":return R}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(n,t)}function B(t){let{flags:n,explicitAccessModifier:e}=t;const p=[];return null!=n&&n.isAbstract&&p.push("abstract"),null!=n&&n.isStatic&&p.push("static"),null!=n&&n.isConst&&p.push("const"),null!=n&&n.isReadonly&&p.push("readonly"),null!=n&&n.isPrivate&&p.push("private"),null!=n&&n.isProtected&&p.push("protected"),(null==n||!n.isPublic)&&(!e||null!=n&&n.isProtected||null!=n&&n.isPrivate)||p.push("public"),o.createElement(o.Fragment,null,p.map((t=>o.createElement(y,{key:t,type:"keyword"},t," "))))}function G(t){let{reflection:n}=t;const e="__namedParameters"===n.name?"{...}":n.name;return o.createElement(o.Fragment,null,o.createElement(B,{flags:n.flags}),n.flags.isRest&&"...",o.createElement(y,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"plain"},e),n.flags.isOptional&&"?",": ",n.type&&o.createElement(E,{type:n.type}),n.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(y,{type:"plain"},n.defaultValue)))}function O(t){let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(B,{flags:n.flags}),n.varianceModifier&&o.createElement(y,{type:"keyword"},n.varianceModifier," "),o.createElement(y,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"class-name"},n.name),n.type&&o.createElement(o.Fragment,null," extends ",o.createElement(E,{type:n.type})),n.default&&o.createElement(o.Fragment,null," = ",o.createElement(E,{type:n.default})))}function U(t){var n,e;let{reflection:r,flags:s}=t;const c=(0,_.in)(),i="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(B,{flags:s??r.flags,explicitAccessModifier:!i}),r.kind===p.W.GetSignature&&o.createElement(y,{type:"keyword"},"get "),r.kind===p.W.SetSignature&&o.createElement(y,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(y,{to:r.overwrites.externalUrl??(0,_.Gr)(c(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===p.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(y,{to:"#",type:"keyword"},"new")," ",o.createElement(y,{type:"plain"},r.type.name)):i?"":o.createElement(y,{type:"function"},r.name),!(null==(n=r.typeParameter)||!n.length)&&o.createElement(w,{type:f.Angle},r.typeParameter.map((t=>o.createElement(O,{key:t.id,reflection:c(t)})))),null!=(e=r.parameters)&&e.length?o.createElement(w,{type:f.Parentheses},r.parameters.map((t=>o.createElement(G,{key:t,reflection:c(t)})))):"()",r.type&&o.createElement(o.Fragment,null,i?" => ":": ",o.createElement(E,{type:r.type})))}function F(t){let{reflection:n}=t;return o.createElement(G,{reflection:n})}const q={[p.W.Namespace]:"namespace",[p.W.Enum]:"enum",[p.W.Class]:"class",[p.W.Interface]:"interface"};function V(t){var n,e,p;let{reflection:r}=t;const s=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(B,{flags:r.flags}),o.createElement(y,{type:"keyword"},q[r.kind]," "),o.createElement(y,{type:"class-name"},r.name),!(null==(n=r.typeParameters)||!n.length)&&o.createElement(w,{type:f.Angle},r.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:s(t)}))))," ",!(null==(e=r.extendedTypes)||!e.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"extends "),o.createElement(w,null,r.extendedTypes.map(((t,n)=>o.createElement(E,{key:n,type:t}))))),!(null==(p=r.implementedTypes)||!p.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"implements "),o.createElement(w,null,r.implementedTypes.map(((t,n)=>o.createElement(E,{key:n,type:t}))))))}function j(t){let{reflection:n}=t;const e=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(B,{flags:n.flags}),o.createElement(y,{type:"keyword"},"type "),o.createElement(y,{type:"class-name"},n.name),n.typeParameters&&o.createElement(w,{type:f.Angle},n.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:e(t)}))))," = ",o.createElement(E,{type:n.type}))}function H(t){let{reflection:n}=t;const e=(0,_.in)();return n.signatures?o.createElement(U,{reflection:n.signatures[0]}):n.children?o.createElement(w,{type:f.Curly},n.children.map((t=>o.createElement($,{key:t.id,reflection:e(t)})))):o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"unknown"))}function Q(t){var n;let{reflection:e}=t;const p=(null==(n=e.signatures)?void 0:n[0])??e.getSignature??e.setSignature??e.indexSignature;return o.createElement(U,{reflection:p})}function $(t){let{reflection:n}=t;const e=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:case p.W.Module:case p.W.EnumMember:case p.W.Variable:case p.W.Function:break;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return V;case p.W.Constructor:return U;case p.W.Property:return F;case p.W.Method:return Q;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:break;case p.W.TypeLiteral:return H;case p.W.TypeParameter:return O;case p.W.Accessor:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return j;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.id]);return o.createElement(e,{reflection:n})}function Y(t){let{children:n}=t;const e=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!e.current)return;const t=e.current.closest("pre");if(t.scrollWidth>t.clientWidth){const n=Array.from(e.current.querySelectorAll(`.${a.elements}`)).sort(((t,n)=>function(t,n){return t>n?1:t<n?-1:0}(n.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&n.length>0;)n.shift().classList.add(a.wrap)}})),o.createElement(o.Fragment,null,n&&o.createElement("span",{ref:e,className:(0,c.Z)(a.line,"token-line")},n),o.createElement("br",null))}var K=e(79322),J=e(30956);function tt(t){let{parameters:n}=t;const e=(0,_.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(O,{reflection:t})),o.createElement(J.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{parameters:n}=t;const e=(0,_.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(G,{reflection:t})),o.createElement(J.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{signatures:n,flags:e,source:p}=t;const r=(0,_.in)(),s=(0,o.useMemo)((()=>n.map(r)),[n]),[c,i]=(0,o.useState)(s[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,s.map((t=>o.createElement(m,{link:null==p?void 0:p.url,key:t.id,highlight:n.length>1&&t.id===c.id,onClick:n.length>1?()=>i(t):void 0},o.createElement(Y,null,o.createElement(U,{reflection:t,flags:e})))))),o.createElement(K.Z,{comment:c.comment}),o.createElement(tt,{parameters:c.typeParameter}),o.createElement(nt,{parameters:c.parameters}))}var ot=e(57708);function pt(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0},p),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",st="filters_z1iC",ct="icon_ROIU";function it(){const t=(0,o.useRef)(null),[n,e]=(0,o.useState)(!1),[p,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const n=n=>{t.current&&!t.current.contains(n.target)&&e(!1)};return document.addEventListener("mousedown",n),document.addEventListener("touchstart",n),()=>{document.removeEventListener("mousedown",n),document.removeEventListener("touchstart",n)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,c.Z)("dropdown dropdown--right margin-bottom--md",n&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),e(!n)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),e(!n))}},"Filters",o.createElement(pt,{className:ct})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,c.Z)("dropdown__link",p.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:p.private,onChange:t=>{r({...p,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&e(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,c.Z)("dropdown__link",p.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:p.inherited,onChange:t=>{r({...p,inherited:t.target.checked})}}),"Inherited members")))))}function at(t){let{children:n,kind:e}=t;return e===p.W.Class||e===p.W.Interface?o.createElement("div",{className:(0,c.Z)("row",rt)},o.createElement("div",{className:(0,c.Z)("col",st)},o.createElement(it,null)),o.createElement("div",{className:"col"},n)):o.createElement(o.Fragment,null,n)}var lt=e(53181),ut=e(83851),mt=e(24126),dt=e(32424),ht=e(42244),kt=e(24155);function yt(t){return function(t){var n;return(null==(n=o.Children.map(t,(t=>{if(!t||(0,o.isValidElement)(t)&&function(t){const{props:n}=t;return!!n&&"object"==typeof n&&"value"in n}(t))return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:n.filter(Boolean))??[]}(t).map((t=>{let{props:{value:n,label:e,attributes:o,default:p}}=t;return{value:n,label:e,attributes:o,default:p}}))}function ft(t){const{values:n,children:e}=t;return(0,o.useMemo)((()=>{const t=n??yt(e);return function(t){const n=(0,ht.l)(t,((t,n)=>t.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[n,e])}function Mt(t){let{value:n,tabValues:e}=t;return e.some((t=>t.value===n))}function Dt(t){let{queryString:n=!1,groupId:e}=t;const p=(0,lt.k6)(),r=function(t){let{queryString:n=!1,groupId:e}=t;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!e)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return e??null}({queryString:n,groupId:e});return[(0,dt._X)(r),(0,o.useCallback)((t=>{if(!r)return;const n=new URLSearchParams(p.location.search);n.set(r,t),p.replace({...p.location,search:n.toString()})}),[r,p])]}function wt(t){const{defaultValue:n,queryString:e=!1,groupId:p}=t,r=ft(t),[s,c]=(0,o.useState)((()=>function(t){let{defaultValue:n,tabValues:e}=t;if(0===e.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!Mt({value:n,tabValues:e}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${e.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const o=e.find((t=>t.default))??e[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:n,tabValues:r}))),[i,a]=Dt({queryString:e,groupId:p}),[l,u]=function(t){let{groupId:n}=t;const e=function(t){return t?`docusaurus.tab.${t}`:null}(n),[p,r]=(0,kt.Nk)(e);return[p,(0,o.useCallback)((t=>{e&&r.set(t)}),[e,r])]}({groupId:p}),m=(()=>{const t=i??l;return Mt({value:t,tabValues:r})?t:null})();(0,o.useLayoutEffect)((()=>{m&&c(m)}),[m]);return{selectedValue:s,selectValue:(0,o.useCallback)((t=>{if(!Mt({value:t,tabValues:r}))throw new Error(`Can't select invalid tab value=${t}`);c(t),a(t),u(t)}),[a,u,r]),tabValues:r}}var _t=e(89741);const Xt="tabList_M0Dn",gt="tabItem_ysIP";function Tt(t){let{className:n,block:e,selectedValue:p,selectValue:r,tabValues:s}=t;const i=[],{blockElementScrollPositionUntilNextRender:a}=(0,mt.o5)(),u=t=>{const n=t.currentTarget,e=i.indexOf(n),o=s[e].value;o!==p&&(a(n),r(o))},m=t=>{var n;let e=null;switch(t.key){case"Enter":u(t);break;case"ArrowRight":{const n=i.indexOf(t.currentTarget)+1;e=i[n]??i[0];break}case"ArrowLeft":{const n=i.indexOf(t.currentTarget)-1;e=i[n]??i[i.length-1];break}}null==(n=e)||n.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":e},n)},s.map((t=>{let{value:n,label:e,attributes:r}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:p===n?0:-1,"aria-selected":p===n,key:n,ref:t=>i.push(t),onKeyDown:m,onClick:u},r,{className:(0,c.Z)("tabs__item",gt,null==r?void 0:r.className,{"tabs__item--active":p===n})}),e??n)})))}function xt(t){let{lazy:n,children:e,selectedValue:p}=t;const r=(Array.isArray(e)?e:[e]).filter(Boolean);if(n){const t=r.find((t=>t.props.value===p));return t?(0,o.cloneElement)(t,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},r.map(((t,n)=>(0,o.cloneElement)(t,{key:n,hidden:t.props.value!==p}))))}function Ct(t){const n=wt(t);return o.createElement("div",{className:(0,c.Z)("tabs-container",Xt)},o.createElement(Tt,(0,l.Z)({},t,n)),o.createElement(xt,(0,l.Z)({},t,n)))}function vt(t){const n=(0,_t.Z)();return o.createElement(Ct,(0,l.Z)({key:String(n)},t))}const Lt="tabItem_OMyP";function Zt(t){let{children:n,hidden:e,className:p}=t;return o.createElement("div",{role:"tabpanel",className:(0,c.Z)(Lt,p),hidden:e},n)}function bt(t){let{group:n}=t;return"Constructors"===n.title&&0===n.external.length&&1===n.nested.length?o.createElement(Ot,{reflection:n.nested[0]}):o.createElement(o.Fragment,null,n.external.length>0&&o.createElement("ul",null,n.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t})))))),n.nested.length>0&&n.nested.map(((t,n)=>o.createElement(o.Fragment,{key:t.id},n>0&&o.createElement("hr",null),o.createElement(Ot,{reflection:t})))))}function Nt(t){let{group:n,project:e}=t;const p=(0,lt.TH)(),r=(0,_.RU)(e),s=p.hash.split("-")[0].slice(1),[c]=(0,ot.mN)(),i=(0,o.useMemo)((()=>(n.categories??[n]).map((t=>function(t,n,e){const o=[],p=[],r=[];for(const s of t.children){const t=n[s];t&&(0,ot.It)(e,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:r}}(t,r,c))).filter((t=>!!t))),[n,r,c]);return(0,o.useEffect)((()=>{if(1===i.length)return;const t=p.hash.split("-")[0].slice(1);for(const n of i)if(n.anchors.includes(t))return}),[p.hash,i]),0===i.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h2",id:n.title},n.title),i.length>1?o.createElement(vt,{groupId:n.title},i.map((t=>o.createElement(Zt,{default:t.anchors.includes(s),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(bt,{group:t}))))):o.createElement(bt,{group:i[0]}))}function zt(t){var n,e,p,r,s;let{reflection:c}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(n=c.sources)||null==(e=n[0])?void 0:e.url},o.createElement(Y,null,o.createElement($,{reflection:c})))),o.createElement(at,{kind:c.kind},o.createElement(K.Z,{comment:c.comment})),o.createElement(tt,{parameters:c.typeParameters}),(null==(p=c.implementedBy)?void 0:p.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,c.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),(null==(r=c.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,c.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),c.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:c.signatures})),null==(s=c.groups)?void 0:s.map((t=>o.createElement(Nt,{group:t,key:t.title,project:c.project}))))}function At(t){var n;let{reflection:e,headless:p}=t;const r=[...e.signatures??[],e.setSignature,e.getSignature,e.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!p&&(e.hasOwnPage?o.createElement("h1",null,e.name):o.createElement(ut.Z,{as:"h3",id:e.anchor},o.createElement("code",null,e.name))),o.createElement(et,{signatures:r,flags:e.flags,source:null==(n=e.sources)?void 0:n[0]}),e.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:e.inheritedFrom}))),e.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(X,{type:e.overwrites}))))}function Wt(t){var n,e;let{reflection:p,headless:r}=t;return o.createElement(o.Fragment,null,!r&&(p.hasOwnPage?o.createElement("h1",null,p.name):o.createElement(ut.Z,{as:"h3",id:p.anchor},o.createElement("code",null,p.name))),o.createElement(h,null,o.createElement(m,{link:null==(n=p.sources)||null==(e=n[0])?void 0:e.url},o.createElement(Y,null,o.createElement(F,{reflection:p})))),o.createElement(K.Z,{comment:p.comment}),p.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:p.inheritedFrom}))))}function Rt(t){var n,e,p;let{reflection:r}=t;const s=(0,_.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(n=r.sources)||null==(e=n[0])?void 0:e.url},o.createElement(Y,null,o.createElement($,{reflection:r})))),o.createElement(K.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:r.signatures})),null==(p=r.groups)?void 0:p.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>s[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Ot,{key:t.id,reflection:t})))))))}var It=e(78128);function St(t){var n;let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(It.Z,{language:"ts"},"import ","{...}",' from "',e.importPath,'";'),o.createElement(at,{kind:e.kind},o.createElement(K.Z,{comment:e.comment})),null==(n=e.groups)?void 0:n.map((t=>o.createElement(Nt,{group:t,key:t.title,project:e.project}))))}const Pt="cardContainer_ybwo",Et="cardTitle_Ehd1",Bt="cardDescription_b6wr";function Gt(t){let{reflection:n}=t;const e=(0,_.RU)(n.project),p=n.groups[0].children.map((t=>e[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,c.Z)("row")},p.map((t=>{var n;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(k.Z,{href:t.href,className:(0,c.Z)("card padding--lg",Pt)},o.createElement("h2",{className:(0,c.Z)("text--truncate",Et)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,c.Z)("text--truncate",Bt)},(null==(n=t.comment)?void 0:n.summaryText)??"\xa0")))}))))}function Ot(t){let{reflection:n,headless:e=!1}=t;const r=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:return Gt;case p.W.Module:return St;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return zt;case p.W.Function:case p.W.Accessor:case p.W.Constructor:case p.W.Method:return At;case p.W.Variable:case p.W.Property:case p.W.EnumMember:return Wt;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:case p.W.TypeLiteral:case p.W.TypeParameter:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return Rt;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.kind]);return o.createElement(r,{reflection:n,headless:e})}},37390:(t,n,e)=>{let o;e.d(n,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},88617:(t,n,e)=>{e.d(n,{Gr:()=>a,RU:()=>s,gs:()=>r,in:()=>c,rG:()=>i});var o=e(2784);const p=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:n,lookup:e,urlLookup:r}=t;return o.createElement(p.Provider,{value:{lookup:e,urlLookup:r}},n)}function s(t){const{lookup:n}=(0,o.useContext)(p);return n[t]}function c(){const{lookup:t}=(0,o.useContext)(p);return n=>{if("number"==typeof(null==n?void 0:n.project))return t[n.project][n.id]}}function i(){const{urlLookup:t,lookup:n}=(0,o.useContext)(p);return e=>{var o;const p=t[e];return p?(null==(o=n[p.projectId])?void 0:o[p.id])??null:null}}function a(t){if(t)return t.href}},80068:(t,n,e)=>{e.d(n,{Ld:()=>c,Y0:()=>s,s2:()=>i});var o=e(2784),p=e(50822);const r=o.createContext(null);function s(t){let{children:n}=t;const e=(0,p.p)(),s=(0,o.useMemo)((()=>function(t,n){const{plain:e}=t,o=Object.create(null),p=t.styles.reduce(((t,e)=>{const{languages:o,style:p}=e;return o&&!o.includes(n)||e.types.forEach((n=>{t[n]={...t[n],...p}})),t}),o);return p.root=e,p.plain={...e,backgroundColor:null},p}(e,"typescript")),[e]);return o.createElement(r.Provider,{value:s},n)}function c(t){void 0===t&&(t="plain");const n=(0,o.useContext)(r);return{className:`token ${t}`,style:n[t]??n.plain}}function i(t){void 0===t&&(t="plain");const n=(0,o.useContext)(r);return n[t]??n.plain}},57708:(t,n,e)=>{e.d(n,{It:()=>m,Wy:()=>l,mN:()=>u});var o=e(2784),p=e(31263),r=e(89741);const s="api-filters",c=p.Z.canUseDOM?localStorage.getItem(s):null,i=c?JSON.parse(c):{inherited:!0,private:!1},a=o.createContext([i,()=>{}]);function l(t){let{children:n}=t;const[e,p]=(0,o.useState)(i),c=(0,r.Z)();return o.createElement(a.Provider,{value:[e,t=>{c&&localStorage.setItem(s,JSON.stringify(t)),p(t)}]},n)}function u(){return(0,o.useContext)(a)}function m(t,n){var e,o;const p=(null==(e=n.flags)?void 0:e.isPrivate)||(null==(o=n.flags)?void 0:o.isProtected);if(!t.private&&p)return!1;const r=!!n.inheritedFrom;return!(!t.inherited&&r)}},25192:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>c,metadata:()=>a,toc:()=>u});var o=e(7896),p=(e(2784),e(30876)),r=e(42072),s=e(52665);const c={sidebar_position:10,slug:"/transitions"},i="Transitions",a={unversionedId:"getting-started/transitions",id:"getting-started/transitions",title:"Transitions",description:"Transitions allow you to customize the way scenes transition from one into",source:"@site/docs/getting-started/transitions.mdx",sourceDirName:"getting-started",slug:"/transitions",permalink:"/docs/transitions",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/getting-started/transitions.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",sidebarPosition:10,frontMatter:{sidebar_position:10,slug:"/transitions"},sidebar:"docs",previous:{title:"Time Events",permalink:"/docs/time-events"},next:{title:"Logging",permalink:"/docs/logging"}},l={},u=[{value:"Before we start",id:"before-we-start",level:2},{value:"Pre-made transitions",id:"pre-made-transitions",level:2},{value:"<code>slideTransition</code>",id:"slidetransition",level:3},{value:"<code>zoomInTransition</code>",id:"zoomintransition",level:3},{value:"<code>zoomOutTransition</code>",id:"zoomouttransition",level:3},{value:"<code>fadeTransition</code>",id:"fadetransition",level:3},{value:"Custom transitions",id:"custom-transitions",level:2},{value:"Animate when transitioning",id:"animate-when-transitioning",level:2}],m={toc:u};function d(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},m,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"transitions"},"Transitions"),(0,p.kt)("p",null,"Transitions allow you to customize the way scenes transition from one into\nanother. A transition is an animation performed at the beginning of the scene.\nIt can modify the context of both the current and the previous scene."),(0,p.kt)("h2",{id:"before-we-start"},"Before we start"),(0,p.kt)("div",{className:"row"},(0,p.kt)("div",{className:"col"},(0,p.kt)("p",null,"Make sure your project contains at least two scenes. In this example, we've\nprepared ",(0,p.kt)("inlineCode",{parentName:"p"},"firstScene.tsx")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"secondScene.tsx"),", and configured our project to\ndisplay one after the other. We'll be setting up our transitions in the second\nscene."),(0,p.kt)("p",null,"Make sure to put something different in both scenes to easier see the\ntransitions.")),(0,p.kt)("div",{className:"col"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre"},"my-animation/\n\u2514\u2500 src/\n   \u251c\u2500 scenes/\n   \u2502  \u251c\u2500 firstScene.tsx\n   \u2502  \u2514\u2500 secondScene.tsx\n   \u2514\u2500 project.ts\n")))),(0,p.kt)("h2",{id:"pre-made-transitions"},"Pre-made transitions"),(0,p.kt)("p",null,"Motion Canvas comes with a set of common transitions in a form of easy-to-use\ngenerators. To use them, ",(0,p.kt)("inlineCode",{parentName:"p"},"yield*")," the transition generator at the beginning of\nthe new scene:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/scenes/secondScene.tsx"',title:'"src/scenes/secondScene.tsx"'},"export default makeScene2D(function* (view) {\n  // set up the scene:\n  view.add(/* your nodes here */);\n\n  // perform a slide transition to the left:\n  yield* slideTransition(Direction.Left);\n\n  // proceed with the animation\n  yield* waitFor(3);\n});\n")),(0,p.kt)(s.Z,{small:!0,name:"transitions",link:"transitions-second",mdxType:"AnimationPlayer"}),(0,p.kt)("admonition",{type:"caution"},(0,p.kt)("p",{parentName:"admonition"},"Make sure to add nodes to the view before yielding the transition generator.\nOtherwise, your scene will remain empty until the transition ends.")),(0,p.kt)("p",null,"All available transitions are listed below:"),(0,p.kt)("h3",{id:"slidetransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"slideTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#slideTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"zoomintransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"zoomInTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#zoomInTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"zoomouttransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"zoomOutTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#zoomOutTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"fadetransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"fadeTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#fadeTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"custom-transitions"},"Custom transitions"),(0,p.kt)("p",null,"You can use the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/transitions#useTransition"},(0,p.kt)("inlineCode",{parentName:"a"},"useTransition"))," function\nto implement custom transitions. It allows you to specify two callbacks that\nwill modify the contexts of the current and previous scene respectively. The\nvalue it returns is a callback that you need to call once you finish the\ntransition."),(0,p.kt)("p",null,"The transition template looks as follows:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// set up the transition\nconst endTransition = useTransition(\n  currentContext => {\n    // modify the context of the current scene\n  },\n  previousContext => {\n    // modify the context of the previous scene\n  },\n);\n\n// perform animations\n\n// finish the transition\nendTransition();\n")),(0,p.kt)("p",null,"Here's how you could implement a simple slide transition:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"export function* slideTransition(\n  direction: Direction = Direction.Top,\n  duration = 0.6,\n): ThreadGenerator {\n  const size = useScene().getSize();\n  const position = size.getOriginOffset(direction).scale(2);\n  const previousPosition = Vector2.createSignal();\n  const currentPosition = Vector2.createSignal(position);\n\n  // set up the transition\n  const endTransition = useTransition(\n    // modify the context of the current scene\n    ctx => ctx.translate(currentPosition.x(), currentPosition.y()),\n    // modify the context of the previous scene\n    ctx => ctx.translate(previousPosition.x(), previousPosition.y()),\n  );\n\n  // perform animations\n  yield* all(\n    previousPosition(position.scale(-1), duration),\n    currentPosition(Vector2.zero, duration),\n  );\n\n  // finish the transition\n  endTransition();\n}\n")),(0,p.kt)("h2",{id:"animate-when-transitioning"},"Animate when transitioning"),(0,p.kt)("p",null,"By default, Motion Canvas will transition to the next scene once the generator\nof the current scene has reached the end. In this case, the scene will freeze\nfor the duration of the transition. You can use the\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#finishScene"},(0,p.kt)("inlineCode",{parentName:"a"},"finishScene"))," function to trigger the transition\nearly, allowing the animation to continue while transitioning:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"export default makeScene2D(function* (view) {\n  yield* animationOne();\n  // trigger the transition early:\n  finishScene();\n  // continue animating:\n  yield* animationTwo();\n});\n")))}d.isMDXComponent=!0}}]);
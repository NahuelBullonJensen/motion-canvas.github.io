(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[3239],{61532:t=>{function e(t){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}e.keys=()=>[],e.resolve=e,e.id=61532,t.exports=e},70989:(t,e,n)=>{"use strict";n.d(e,{A:()=>M});var o=n(93091),r=n(88104),s=n(15688);function p(t,e){return void 0===e&&(e=t=>t),(n,o)=>{n[`getDefault${(0,s.k)(o)}`]=function(){this.requestLayoutUpdate();const n=this.element.style[t];this.element.style[t]="";const o=e.call(this,this.styles.getPropertyValue(t));return this.element.style[t]=n,o}}}var i=n(46350),c=n(5788),a=n(29797),l=n(23357),u=n(98378),m=n(74534),d=n(67292),h=n(20092),f=n(11258),y=n(53693),k=n(68003),w=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class M extends h.N{get columnGap(){return this.gap.x}get rowGap(){return this.gap.y}getX(){return this.isLayoutRoot()?this.x.context.getter():this.computedPosition().x}setX(t){this.x.context.setter(t)}getY(){return this.isLayoutRoot()?this.y.context.getter():this.computedPosition().y}setY(t){this.y.context.setter(t)}get width(){return this.size.x}get height(){return this.size.y}getWidth(){return this.computedSize().width}setWidth(t){this.width.context.setter(t)}*tweenWidth(t,e,n,o){const r=this.desiredSize().x,s="number"!=typeof r||"number"!=typeof t;let p,i;p=s?this.size.x():r,s?(this.size.x(t),i=this.size.x()):i=t,this.size.x(p),s&&this.lockSize(),yield*(0,m.i)(e,(t=>this.size.x(o(p,i,n(t))))),this.size.x(t),s&&this.releaseSize()}getHeight(){return this.computedSize().height}setHeight(t){this.height.context.setter(t)}*tweenHeight(t,e,n,o){const r=this.desiredSize().y,s="number"!=typeof r||"number"!=typeof t;let p,i;p=s?this.size.y():r,s?(this.size.y(t),i=this.size.y()):i=t,this.size.y(p),s&&this.lockSize(),yield*(0,m.i)(e,(t=>this.size.y(o(p,i,n(t))))),this.size.y(t),s&&this.releaseSize()}desiredSize(){return{x:this.width.context.getter(),y:this.height.context.getter()}}*tweenSize(t,e,n,o){const r=this.desiredSize();let s,p;s="number"!=typeof r.x||"number"!=typeof r.y?this.size():new a.F(r),"object"==typeof t&&"number"==typeof t.x&&"number"==typeof t.y?p=new a.F(t):(this.size(t),p=this.size()),this.size(s),this.lockSize(),yield*(0,m.i)(e,(t=>this.size(o(s,p,n(t))))),this.releaseSize(),this.size(t)}constructor(t){super(t)}lockSize(){this.sizeLockCounter(this.sizeLockCounter()+1)}releaseSize(){this.sizeLockCounter(this.sizeLockCounter()-1)}parentTransform(){let t=this.parent();for(;t;){if(t instanceof M)return t;t=t.parent()}return null}anchorPosition(){const t=this.computedSize(),e=this.offset();return t.scale(.5).mul(e)}layoutEnabled(){var t;return this.layout()??(null==(t=this.parentTransform())?void 0:t.layoutEnabled())??!1}isLayoutRoot(){var t;return!this.layoutEnabled()||!(null!=(t=this.parentTransform())&&t.layoutEnabled())}localToParent(){const t=new DOMMatrix;t.translateSelf(this.x(),this.y()),t.rotateSelf(0,0,this.rotation()),t.scaleSelf(this.scale.x(),this.scale.y());const e=this.offset();if(!e.exactlyEquals(a.F.zero)){const n=this.size().mul(e).scale(-.5);t.translateSelf(n.x,n.y)}return t}scalingRotationMatrix(){const t=new DOMMatrix;t.rotateSelf(0,0,this.rotation()),t.scaleSelf(this.scale.x(),this.scale.y());const e=this.offset();if(!e.exactlyEquals(a.F.zero)){const n=this.size().mul(e).scale(-.5);t.translateSelf(n.x,n.y)}return t}getComputedLayout(){return new l.b(this.element.getBoundingClientRect())}computedPosition(){this.requestLayoutUpdate();const t=this.getComputedLayout(),e=new a.F(t.x+t.width/2*this.offset.x(),t.y+t.height/2*this.offset.y()),n=this.parentTransform();if(n){const o=n.getComputedLayout();e.x-=o.x+(o.width-t.width)/2,e.y-=o.y+(o.height-t.height)/2}return e}computedSize(){return this.requestLayoutUpdate(),this.getComputedLayout().size}requestLayoutUpdate(){const t=this.parentTransform();this.appendedToView()?(null==t||t.requestFontUpdate(),this.updateLayout()):t.requestLayoutUpdate()}appendedToView(){const t=this.isLayoutRoot();return t&&this.view().element.append(this.element),t}updateLayout(){if(this.applyFont(),this.applyFlex(),this.layoutEnabled()){const t=this.layoutChildren();for(const e of t)e.updateLayout()}}layoutChildren(){const t=[...this.children()],e=[],n=[];for(;t.length;){const o=t.shift();o instanceof M?(e.push(o),n.push(o.element)):o&&t.unshift(...o.children())}return this.element.replaceChildren(...n),e}requestFontUpdate(){var t;this.appendedToView(),null==(t=this.parentTransform())||t.requestFontUpdate(),this.applyFont()}getCacheBBox(){return l.b.fromSizeCentered(this.computedSize())}draw(t){if(this.clip()){const e=this.computedSize();if(0===e.width||0===e.height)return;t.beginPath(),t.rect(e.width/-2,e.height/-2,e.width,e.height),t.closePath(),t.clip()}this.drawChildren(t)}drawOverlay(t,e){const n=this.computedSize(),o=n.mul(this.offset()).scale(.5).transformAsPoint(e),r=l.b.fromSizeCentered(n),s=r.transformCorners(e),p=r.addSpacing(this.padding().scale(-1)).transformCorners(e),i=r.addSpacing(this.margin()).transformCorners(e);t.beginPath(),(0,f.pS)(t,i),(0,f.pS)(t,s),t.closePath(),t.fillStyle="rgba(255,193,125,0.6)",t.fill("evenodd"),t.beginPath(),(0,f.pS)(t,s),(0,f.pS)(t,p),t.closePath(),t.fillStyle="rgba(180,255,147,0.6)",t.fill("evenodd"),t.beginPath(),(0,f.pS)(t,s),t.closePath(),t.lineWidth=1,t.strokeStyle="white",t.stroke(),t.beginPath(),(0,f.wp)(t,o),t.stroke()}getOriginDelta(t){const e=this.computedSize().scale(.5),n=this.offset().mul(e);if(t===u.aP.Middle)return n.flipped;return(0,u.WS)(t).mul(e).sub(n)}moveOffset(t){const e=this.computedSize().scale(.5),n=this.offset().mul(e),o=t.mul(e);this.offset(t),this.position(this.position().add(o).sub(n))}parsePixels(t){return null===t?"":`${t}px`}parseLength(t){return null===t?"":"string"==typeof t?t:`${t}px`}applyFlex(){this.element.style.position=this.isLayoutRoot()?"absolute":"relative";const t=this.desiredSize();this.element.style.width=this.parseLength(t.x),this.element.style.height=this.parseLength(t.y),this.element.style.maxWidth=this.parseLength(this.maxWidth()),this.element.style.minWidth=this.parseLength(this.minWidth()),this.element.style.maxHeight=this.parseLength(this.maxHeight()),this.element.style.minHeight=this.parseLength(this.minHeight()),this.element.style.aspectRatio=null===this.ratio()?"":this.ratio().toString(),this.element.style.marginTop=this.parsePixels(this.margin.top()),this.element.style.marginBottom=this.parsePixels(this.margin.bottom()),this.element.style.marginLeft=this.parsePixels(this.margin.left()),this.element.style.marginRight=this.parsePixels(this.margin.right()),this.element.style.paddingTop=this.parsePixels(this.padding.top()),this.element.style.paddingBottom=this.parsePixels(this.padding.bottom()),this.element.style.paddingLeft=this.parsePixels(this.padding.left()),this.element.style.paddingRight=this.parsePixels(this.padding.right()),this.element.style.flexDirection=this.direction(),this.element.style.flexBasis=this.parseLength(this.basis()),this.element.style.flexWrap=this.wrap(),this.element.style.justifyContent=this.justifyContent(),this.element.style.alignContent=this.alignContent(),this.element.style.alignItems=this.alignItems(),this.element.style.alignSelf=this.alignSelf(),this.element.style.columnGap=this.parseLength(this.gap.x()),this.element.style.rowGap=this.parseLength(this.gap.y()),this.sizeLockCounter()>0?(this.element.style.flexGrow="0",this.element.style.flexShrink="0"):(this.element.style.flexGrow=this.grow().toString(),this.element.style.flexShrink=this.shrink().toString())}applyFont(){if(this.element.style.fontFamily=this.fontFamily.isInitial()?"":this.fontFamily(),this.element.style.fontSize=this.fontSize.isInitial()?"":`${this.fontSize()}px`,this.element.style.fontStyle=this.fontStyle.isInitial()?"":this.fontStyle(),this.lineHeight.isInitial())this.element.style.lineHeight="";else{const t=this.lineHeight();this.element.style.lineHeight="string"==typeof t?(parseFloat(t)/100).toString():`${t}px`}if(this.element.style.fontWeight=this.fontWeight.isInitial()?"":this.fontWeight().toString(),this.element.style.letterSpacing=this.letterSpacing.isInitial()?"":`${this.letterSpacing()}px`,this.element.style.textAlign=this.textAlign.isInitial()?"":this.textAlign(),this.textWrap.isInitial())this.element.style.whiteSpace="";else{const t=this.textWrap();this.element.style.whiteSpace="boolean"==typeof t?t?"normal":"nowrap":t}}dispose(){var t;super.dispose(),null==(t=this.sizeLockCounter)||t.context.dispose(),this.element&&(this.element.remove(),this.element.innerHTML=""),this.element=null,this.styles=null}hit(t){const e=t.transformAsPoint(this.localToParent().inverse());return this.cacheBBox().includes(e)?super.hit(t)??this:null}}function D(t){return(e,n)=>{(0,o.td)()(e,n),(0,o.r_)(!1)(e,n);const r=(0,o.uN)(e,n);r.getter=function(){return this.getOriginDelta(t).transformAsPoint(this.localToParent())},r.setter=function(e){return this.position((0,k.Pj)(e,(e=>this.getOriginDelta(t).transform(this.scalingRotationMatrix()).flipped.add(e)))),this}}}w([(0,o.nn)(null),(0,o.td)()],M.prototype,"layout",void 0),w([(0,o.nn)(null),(0,o.td)()],M.prototype,"maxWidth",void 0),w([(0,o.nn)(null),(0,o.td)()],M.prototype,"maxHeight",void 0),w([(0,o.nn)(null),(0,o.td)()],M.prototype,"minWidth",void 0),w([(0,o.nn)(null),(0,o.td)()],M.prototype,"minHeight",void 0),w([(0,o.nn)(null),(0,o.td)()],M.prototype,"ratio",void 0),w([(0,y.g)("margin")],M.prototype,"margin",void 0),w([(0,y.g)("padding")],M.prototype,"padding",void 0),w([(0,o.nn)("row"),(0,o.td)()],M.prototype,"direction",void 0),w([(0,o.nn)(null),(0,o.td)()],M.prototype,"basis",void 0),w([(0,o.nn)(0),(0,o.td)()],M.prototype,"grow",void 0),w([(0,o.nn)(1),(0,o.td)()],M.prototype,"shrink",void 0),w([(0,o.nn)("nowrap"),(0,o.td)()],M.prototype,"wrap",void 0),w([(0,o.nn)("start"),(0,o.td)()],M.prototype,"justifyContent",void 0),w([(0,o.nn)("normal"),(0,o.td)()],M.prototype,"alignContent",void 0),w([(0,o.nn)("stretch"),(0,o.td)()],M.prototype,"alignItems",void 0),w([(0,o.nn)("auto"),(0,o.td)()],M.prototype,"alignSelf",void 0),w([(0,o.nn)(0),(0,r.y)({x:"columnGap",y:"rowGap"})],M.prototype,"gap",void 0),w([p("font-family"),(0,o.td)()],M.prototype,"fontFamily",void 0),w([p("font-size",parseFloat),(0,o.td)()],M.prototype,"fontSize",void 0),w([p("font-style"),(0,o.td)()],M.prototype,"fontStyle",void 0),w([p("font-weight",parseInt),(0,o.td)()],M.prototype,"fontWeight",void 0),w([p("line-height",parseFloat),(0,o.td)()],M.prototype,"lineHeight",void 0),w([p("letter-spacing",(t=>"normal"===t?0:parseFloat(t))),(0,o.td)()],M.prototype,"letterSpacing",void 0),w([p("white-space",(t=>"pre"===t?"pre":"normal"===t)),(0,o.td)()],M.prototype,"textWrap",void 0),w([(0,o.nn)("inherit"),(0,o.td)()],M.prototype,"textDirection",void 0),w([p("text-align"),(0,o.td)()],M.prototype,"textAlign",void 0),w([(0,o.nn)({x:null,y:null}),(0,r.y)({x:"width",y:"height"})],M.prototype,"size",void 0),w([(0,d.C)()],M.prototype,"tweenWidth",null),w([(0,d.C)()],M.prototype,"tweenHeight",null),w([(0,i.F)()],M.prototype,"desiredSize",null),w([(0,d.C)()],M.prototype,"tweenSize",null),w([(0,r.y)("offset")],M.prototype,"offset",void 0),w([D(u.aP.Top)],M.prototype,"top",void 0),w([D(u.aP.Bottom)],M.prototype,"bottom",void 0),w([D(u.aP.Left)],M.prototype,"left",void 0),w([D(u.aP.Right)],M.prototype,"right",void 0),w([D(u.aP.TopLeft)],M.prototype,"topLeft",void 0),w([D(u.aP.TopRight)],M.prototype,"topRight",void 0),w([D(u.aP.BottomLeft)],M.prototype,"bottomLeft",void 0),w([D(u.aP.BottomRight)],M.prototype,"bottomRight",void 0),w([(0,o.nn)(!1),(0,o.td)()],M.prototype,"clip",void 0),w([(0,o.nn)(0),(0,o.td)()],M.prototype,"sizeLockCounter",void 0),w([(0,i.F)()],M.prototype,"parentTransform",null),w([(0,i.F)()],M.prototype,"anchorPosition",null),w([(0,i.F)()],M.prototype,"layoutEnabled",null),w([(0,i.F)()],M.prototype,"isLayoutRoot",null),w([(0,i.F)()],M.prototype,"scalingRotationMatrix",null),w([(0,i.F)()],M.prototype,"computedPosition",null),w([(0,i.F)()],M.prototype,"computedSize",null),w([(0,i.F)()],M.prototype,"requestLayoutUpdate",null),w([(0,i.F)()],M.prototype,"appendedToView",null),w([(0,i.F)()],M.prototype,"updateLayout",null),w([(0,i.F)()],M.prototype,"layoutChildren",null),w([(0,i.F)()],M.prototype,"requestFontUpdate",null),w([(0,i.F)()],M.prototype,"applyFlex",null),w([(0,i.F)()],M.prototype,"applyFont",null),(0,c.f)(M.prototype,(t=>{t.element=document.createElement("div"),t.element.style.display="flex",t.element.style.boxSizing="border-box",t.styles=getComputedStyle(t.element)}))},20092:(t,e,n)=>{"use strict";n.d(e,{N:()=>v});var o=n(93091),r=n(88104),s=n(46350),p=n(43595),i=n(29797),c=n(74741),a=n(23357),l=n(49111),u=n(3163);var m=n(97074),d=n(74534),h=n(13170),f=n(67292),y=n(11258),k=n(97140);const w={invert:{name:"invert"},sepia:{name:"sepia"},grayscale:{name:"grayscale"},brightness:{name:"brightness",default:1},contrast:{name:"contrast",default:1},saturate:{name:"saturate",default:1},hue:{name:"hue-rotate",unit:"deg",scale:1},blur:{name:"blur",transform:!0,unit:"px",scale:1}};class M{get name(){return this.props.name}get default(){return this.props.default}constructor(t){this.props={name:"invert",default:0,unit:"%",scale:100,transform:!1,...t,value:t.value??t.default??0},this.value=(0,k.g)(this.props.value,h.UI,this)}isActive(){return this.value()!==this.props.default}serialize(t){let e=this.value();return this.props.transform&&(e=(0,c.X)(e,t)),`${this.props.name}(${e*this.props.scale}${this.props.unit})`}}var D=n(5376),_=n(5788),g=n(16249),X=n(68003);class x extends g.V{constructor(t,e){var n;super(t,h.o0,e),n=this;for(const o in w){const t=w[o];Object.defineProperty(this.invokable,o,{value:function(e,o,r){var s,p,i;if(void 0===r&&(r=m.qb),void 0===e)return(null==(p=n.get())||null==(i=p.find((e=>e.name===t.name)))?void 0:i.value())??t.default??0;let c=null==(s=n.get())?void 0:s.find((e=>e.name===t.name));return c||(c=new M(t),n.set([...n.get(),c])),void 0===o?(c.value(e),n.owner):c.value(e,o,r)}})}}*tweener(t,e,n){const o=this.get(),r=(0,X.Wg)(t);if(function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n].name!==e[n].name)return!1;return!0}(o,r))return yield*(0,D.$)(...o.map(((t,o)=>t.value(r[o].value(),e,n)))),void this.set(r);for(const i of r)i.value(i.default);const s=r.map((t=>t.value.context.raw())),p=o.length>0&&r.length>0?e/2:e;o.length>0&&(yield*(0,D.$)(...o.map((t=>t.value(t.default,p,n))))),this.set(r),r.length>0&&(yield*(0,D.$)(...r.map(((t,e)=>t.value(s[e],p,n)))))}}var C=n(76062),T=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class v{get x(){return this.position.x}get y(){return this.position.y}getAbsolutePosition(){const t=this.localToWorld();return new i.F(t.m41,t.m42)}setAbsolutePosition(t){this.position((0,X.Pj)(t,(t=>new i.F(t).transformAsPoint(this.worldToParent()))))}getAbsoluteRotation(){const t=this.localToWorld();return i.F.degrees(t.m11,t.m12)}setAbsoluteRotation(t){this.rotation((0,X.Pj)(t,(t=>(0,c.$)(t,this.worldToParent()))))}getAbsoluteScale(){const t=this.localToWorld();return new i.F(i.F.magnitude(t.m11,t.m12),i.F.magnitude(t.m21,t.m22))}setAbsoluteScale(t){this.scale((0,X.Pj)(t,(t=>this.getRelativeScale(new i.F(t)))))}getRelativeScale(t){var e;const n=(null==(e=this.parent())?void 0:e.absoluteScale())??i.F.one;return t.div(n)}*tweenCompositeOperation(t,e,n){const o=(0,X.Wg)(t);"source-over"===o?(yield*this.compositeOverride(1,e,n),this.compositeOverride(0),this.compositeOperation(o)):(this.compositeOperation(o),this.compositeOverride(1),yield*this.compositeOverride(0,e,n))}absoluteOpacity(){var t;return((null==(t=this.parent())?void 0:t.absoluteOpacity())??1)*this.opacity()}hasFilters(){return!!this.filters().find((t=>t.isActive()))}hasShadow(){return!!this.shadowColor()&&(this.shadowBlur()>0||0!==this.shadowOffset.x()||0!==this.shadowOffset.y())}filterString(){let t="";const e=this.compositeToWorld();for(const n of this.filters())n.isActive()&&(t+=" "+n.serialize(e));return t}setChildren(t){this.spawner(t)}getChildren(){return this.spawnChildren(),this.realChildren}spawnChildren(){const t=this.spawner();if((0,X.PG)(this.spawner.context.raw())){const e=new Set;for(const n of t){const t=n.parent.context.raw();if(t&&t!==this)throw new l.t("The spawner returned a node that already has a parent","A spawner should either create entirely new nodes or reuse nodes from a pool.");n.parent(this),e.add(n.key)}for(const t of this.realChildren)e.has(t.key)||t.parent(null);this.realChildren=t}else this.realChildren=t}sortedChildren(){return[...this.children()].sort(((t,e)=>Math.sign(t.zIndex()-e.zIndex())))}constructor(t){let{children:e,spawner:n,key:r,...s}=t;this.compositeOverride=(0,k.g)(0),this.stateStack=[],this.realChildren=[],this.parent=(0,k.g)(null),this.properties=(0,o.RG)(this);const p=(0,u.$r)();this.key=p.registerNode(this,r),this.view2D=p.getView(),this.creationStack=(new Error).stack,(0,o.Xd)(this,s),this.add(e),n&&this.children(n)}localToWorld(){const t=this.parent();return t?t.localToWorld().multiply(this.localToParent()):this.localToParent()}worldToLocal(){return this.localToWorld().inverse()}worldToParent(){var t;return(null==(t=this.parent())?void 0:t.worldToLocal())??new DOMMatrix}localToParent(){const t=new DOMMatrix;return t.translateSelf(this.position.x(),this.position.y()),t.rotateSelf(0,0,this.rotation()),t.scaleSelf(this.scale.x(),this.scale.y()),t}compositeToWorld(){var t;return(null==(t=this.compositeRoot())?void 0:t.localToWorld())??new DOMMatrix}compositeRoot(){var t;return this.composite()?this:(null==(t=this.parent())?void 0:t.compositeRoot())??null}compositeToLocal(){const t=this.compositeRoot();if(t){const e=this.worldToLocal();return e.m44=1,t.localToWorld().multiply(e)}return new DOMMatrix}view(){return this.view2D}add(t){return this.insert(t,1/0)}insert(t,e){void 0===e&&(e=0);const n=Array.isArray(t)?t:[t];if(0===n.length)return this;const o=this.children(),r=o.slice(0,e);for(const s of n)s instanceof v&&(r.push(s),s.remove(),s.parent(this));return r.push(...o.slice(e)),this.children(r),this}remove(){const t=this.parent();return null===t||(t.children(t.children().filter((t=>t!==this))),this.parent(null)),this}move(t){void 0===t&&(t=1);const e=this.parent();if(0===t||!e)return this;const n=e.children(),o=[];if(t>0)for(let r=0;r<n.length;r++){const e=n[r];if(e===this){const e=r+t;for(;r<e&&r+1<n.length;r++)o[r]=n[r+1]}o[r]=e}else for(let r=n.length-1;r>=0;r--){const e=n[r];if(e===this){const e=r+t;for(;r>e&&r>0;r--)o[r]=n[r-1]}o[r]=e}return e.children(o),this}moveUp(){return this.move(1)}moveDown(){return this.move(-1)}moveToTop(){return this.move(1/0)}moveToBottom(){return this.move(-1/0)}moveTo(t){const e=this.parent();if(!e)return this;const n=t-e.children().indexOf(this);return this.move(n)}moveBelow(t,e){void 0===e&&(e=!1);const n=this.parent();if(!n)return this;if(t.parent()!==n)return(0,u.wL)().error("Cannot position nodes relative to each other if they don't belong to the same parent."),this;const o=n.children(),r=o.indexOf(this),s=o.indexOf(t);if(!e&&r<s)return this;const p=s-r-1;return this.move(p)}moveAbove(t,e){void 0===e&&(e=!1);const n=this.parent();if(!n)return this;if(t.parent()!==n)return(0,u.wL)().error("Cannot position nodes relative to each other if they don't belong to the same parent."),this;const o=n.children(),r=o.indexOf(this),s=o.indexOf(t);if(!e&&r>s)return this;const p=s-r+1;return this.move(p)}reparent(t){const e=this.absolutePosition(),n=this.absoluteRotation(),o=this.absoluteScale();t.add(this),this.absolutePosition(e),this.absoluteRotation(n),this.absoluteScale(o)}removeChildren(){for(const t of this.children())t.remove()}dispose(){this.stateStack=[];for(const{signal:t}of this)null==t||t.context.dispose()}clone(t){void 0===t&&(t={});const e={...t};(0,X.PG)(this.spawner.context.raw())?e.spawner=this.spawner.context.raw():this.children().length>0&&(e.children??(e.children=this.children().map((t=>t.clone()))));for(const{key:n,meta:o,signal:r}of this)if(o.cloneable&&!(n in e))if(o.compound)for(const[t,s]of o.compoundEntries)s in e||(e[s]=r[t].context.raw());else e[n]=r.context.raw();return this.instantiate(e)}snapshotClone(t){void 0===t&&(t={});const e={...this.getState(),...t};return this.children().length>0&&(e.children??(e.children=this.children().map((t=>t.snapshotClone())))),this.instantiate(e)}reactiveClone(t){void 0===t&&(t={});const e={...t};this.children().length>0&&(e.children??(e.children=this.children().map((t=>t.reactiveClone()))));for(const{key:n,meta:o,signal:r}of this)o.cloneable&&!(n in e)&&(e[n]=()=>r());return this.instantiate(e)}instantiate(t){return void 0===t&&(t={}),new this.constructor(t)}requiresCache(){return this.cache()||this.opacity()<1||"source-over"!==this.compositeOperation()||this.hasFilters()||this.hasShadow()}cacheCanvas(){const t=document.createElement("canvas").getContext("2d");if(!t)throw new Error("Could not create a cache canvas");return t}cachedCanvas(){const t=this.cacheCanvas(),e=this.worldSpaceCacheBBox(),n=this.localToWorld();return t.canvas.width=e.width,t.canvas.height=e.height,t.setTransform(n.a,n.b,n.c,n.d,n.e-e.x,n.f-e.y),this.draw(t),t}getCacheBBox(){return new a.b}cacheBBox(){const t=this.getCacheBBox(),e=this.children();if(0===e.length)return t;const n=t.corners;for(const o of e){const t=o.fullCacheBBox(),e=o.localToParent();n.push(...t.corners.map((t=>t.transformAsPoint(e))))}return a.b.fromPoints(...n)}fullCacheBBox(){const t=this.compositeToLocal(),e=this.shadowOffset().transform(t),n=(0,c.X)(this.shadowBlur(),t),o=this.cacheBBox().expand(2*this.filters.blur()+n);return e.x<0?(o.x+=e.x,o.width-=e.x):o.width+=e.x,e.y<0?(o.y+=e.y,o.height-=e.y):o.height+=e.y,o}worldSpaceCacheBBox(){const t=a.b.fromSizeCentered(this.view().size()),e=a.b.fromPoints(...t.transformCorners(this.view().localToWorld())),n=a.b.fromPoints(...this.cacheBBox().transformCorners(this.localToWorld()));return e.intersection(n).pixelPerfect}setupDrawFromCache(t){if(t.globalCompositeOperation=this.compositeOperation(),t.globalAlpha*=this.opacity(),this.hasFilters()&&(t.filter=this.filterString()),this.hasShadow()){const e=this.compositeToWorld(),n=this.shadowOffset().transform(e),o=(0,c.X)(this.shadowBlur(),e);t.shadowColor=this.shadowColor().serialize(),t.shadowBlur=o,t.shadowOffsetX=n.x,t.shadowOffsetY=n.y}}render(t){if(!(this.absoluteOpacity()<=0)){if(t.save(),this.transformContext(t),this.requiresCache()){const e=this.worldSpaceCacheBBox();if(0!==e.width&&0!==e.height){this.setupDrawFromCache(t);const n=this.cachedCanvas(),o=this.compositeOverride(),r=this.worldToLocal();t.transform(r.a,r.b,r.c,r.d,r.e,r.f),t.drawImage(n.canvas,e.position.x,e.position.y),o>0&&(t.save(),t.globalAlpha*=o,t.globalCompositeOperation="source-over",t.drawImage(n.canvas,e.position.x,e.position.y),t.restore())}}else this.draw(t);t.restore()}}draw(t){this.drawChildren(t)}drawChildren(t){for(const e of this.sortedChildren())e.render(t)}drawOverlay(t,e){const n=this.cacheBBox().transformCorners(e),o=this.getCacheBBox().transformCorners(e);t.strokeStyle="white",t.lineWidth=1,t.beginPath(),(0,y.pS)(t,n),t.closePath(),t.stroke(),t.strokeStyle="blue",t.beginPath(),(0,y.pS)(t,o),t.closePath(),t.stroke()}transformContext(t){const e=this.localToParent();t.transform(e.a,e.b,e.c,e.d,e.e,e.f)}hit(t){let e=null;const n=t.transformAsPoint(this.localToParent().inverse());for(const o of this.children().reverse())if(e=o.hit(n),e)break;return e}collectAsyncResources(){for(const t of this.children())t.collectAsyncResources()}async toPromise(){let t=C.k.consumePromises();do{await Promise.all(t.map((t=>t.promise))),this.collectAsyncResources(),t=C.k.consumePromises()}while(t.length>0);return this}getState(){const t={};for(const{key:e,meta:n,signal:o}of this)n.cloneable&&!(e in t)&&(t[e]=o());return t}applyState(t){for(const e in t){const n=this.signalByKey(e);n&&n(t[e])}}save(){this.stateStack.push(this.getState())}restore(t,e){void 0===e&&(e=m.qb);const n=this.stateStack.pop();if(void 0===n)return;const o=this.getState();for(const r in n)o[r]===n[r]&&delete n[r];return(0,d.i)(t,(t=>{const r=e(t),s=Object.keys(n).reduce(((t,e)=>(t[e]=(0,h.o0)(o[e],n[e],r),t)),{});this.applyState(s)}))}*[Symbol.iterator](){for(const t in this.properties){const e=this.properties[t],n=this.signalByKey(t);yield{meta:e,signal:n,key:t}}}signalByKey(t){return this[t]}}T([(0,r.y)()],v.prototype,"position",void 0),T([(0,o.YS)(i.F),(0,o.r_)(!1),(0,o.td)()],v.prototype,"absolutePosition",void 0),T([(0,o.nn)(0),(0,o.td)()],v.prototype,"rotation",void 0),T([(0,o.r_)(!1),(0,o.td)()],v.prototype,"absoluteRotation",void 0),T([(0,o.nn)(i.F.one),(0,r.y)("scale")],v.prototype,"scale",void 0),T([(0,o.YS)(i.F),(0,o.r_)(!1),(0,o.td)()],v.prototype,"absoluteScale",void 0),T([(0,o.nn)(0),(0,o.td)()],v.prototype,"zIndex",void 0),T([(0,o.nn)(!1),(0,o.td)()],v.prototype,"cache",void 0),T([(0,o.nn)(!1),(0,o.td)()],v.prototype,"composite",void 0),T([(0,o.nn)("source-over"),(0,o.td)()],v.prototype,"compositeOperation",void 0),T([(0,f.C)()],v.prototype,"tweenCompositeOperation",null),T([(0,o.nn)(1),(0,o.td)()],v.prototype,"opacity",void 0),T([(0,s.F)()],v.prototype,"absoluteOpacity",null),T([(t,e)=>{const n=(0,o.J)(t,e);(0,_.f)(t,(t=>{t[e]=new x(n.default??[],t).toSignal()}))}],v.prototype,"filters",void 0),T([(0,o.nn)("#0000"),(0,p.j)()],v.prototype,"shadowColor",void 0),T([(0,o.nn)(0),(0,o.td)()],v.prototype,"shadowBlur",void 0),T([(0,r.y)("shadowOffset")],v.prototype,"shadowOffset",void 0),T([(0,s.F)()],v.prototype,"hasFilters",null),T([(0,s.F)()],v.prototype,"hasShadow",null),T([(0,s.F)()],v.prototype,"filterString",null),T([(0,o.Oq)(!1),(0,o.r_)(!1),(0,o.nn)([]),(0,o.td)()],v.prototype,"spawner",void 0),T([(0,o.Oq)(!1),(0,o.r_)(!1),(0,o.td)()],v.prototype,"children",void 0),T([(0,s.F)()],v.prototype,"spawnChildren",null),T([(0,s.F)()],v.prototype,"sortedChildren",null),T([(0,s.F)()],v.prototype,"localToWorld",null),T([(0,s.F)()],v.prototype,"worldToLocal",null),T([(0,s.F)()],v.prototype,"worldToParent",null),T([(0,s.F)()],v.prototype,"localToParent",null),T([(0,s.F)()],v.prototype,"compositeToWorld",null),T([(0,s.F)()],v.prototype,"compositeRoot",null),T([(0,s.F)()],v.prototype,"compositeToLocal",null),T([(0,s.F)()],v.prototype,"cacheCanvas",null),T([(0,s.F)()],v.prototype,"cachedCanvas",null),T([(0,s.F)()],v.prototype,"cacheBBox",null),T([(0,s.F)()],v.prototype,"fullCacheBBox",null),T([(0,s.F)()],v.prototype,"worldSpaceCacheBBox",null),v.prototype.isClass=!0},15498:(t,e,n)=>{"use strict";n.d(e,{U:()=>a});var o=n(23357),r=n(13730),s=n(11258),p=n(93091),i=n(53693),c=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class a extends r.b{constructor(t){super(t)}getPath(){const t=new Path2D,e=this.radius(),n=this.smoothCorners(),r=this.cornerSharpness(),p=o.b.fromSizeCentered(this.size());return(0,s.Zy)(t,p,e,n,r),t}getCacheBBox(){return super.getCacheBBox().expand(this.rippleSize())}getRipplePath(){const t=new Path2D,e=this.rippleSize(),n=this.radius().addScalar(e),r=this.smoothCorners(),p=this.cornerSharpness(),i=o.b.fromSizeCentered(this.size()).expand(e);return(0,s.Zy)(t,i,n,r,p),t}}c([(0,i.g)("radius")],a.prototype,"radius",void 0),c([(0,p.nn)(!1),(0,p.td)()],a.prototype,"smoothCorners",void 0),c([(0,p.nn)(.6),(0,p.td)()],a.prototype,"cornerSharpness",void 0)},13730:(t,e,n)=>{"use strict";n.d(e,{b:()=>h});var o=n(93091),r=n(46350),s=n(70989),p=n(67292),i=n(97074),c=n(13170),a=n(11258),l=n(30204);function u(){return(t,e)=>{(0,o.td)()(t,e),(0,o.E2)(a.av)(t,e),(0,o.JI)(l.I.lerp)(t,e),(0,o.nn)(null)(t,e)}}var m=n(97140),d=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class h extends s.A{rippleSize(){return(0,i.ad)(this.rippleStrength(),0,50)}constructor(t){super(t),this.rippleStrength=(0,m.g)(0)}applyText(t){t.direction=this.textDirection(),this.element.dir=this.textDirection()}applyStyle(t){t.fillStyle=(0,a.ho)(this.fill(),t),t.strokeStyle=(0,a.ho)(this.stroke(),t),t.lineWidth=this.lineWidth(),t.lineJoin=this.lineJoin(),t.lineCap=this.lineCap(),t.setLineDash(this.lineDash()),t.lineDashOffset=this.lineDashOffset(),this.antialiased()||(t.filter="url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxmaWx0ZXIgaWQ9ImZpbHRlciIgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj48ZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVGdW5jUiB0eXBlPSJpZGVudGl0eSIvPjxmZUZ1bmNHIHR5cGU9ImlkZW50aXR5Ii8+PGZlRnVuY0IgdHlwZT0iaWRlbnRpdHkiLz48ZmVGdW5jQSB0eXBlPSJkaXNjcmV0ZSIgdGFibGVWYWx1ZXM9IjAgMSIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj48L2ZpbHRlcj48L3N2Zz4=#filter)")}draw(t){this.drawShape(t),this.clip()&&t.clip(this.getPath()),this.drawChildren(t)}drawShape(t){const e=this.getPath(),n=this.lineWidth()>0&&null!==this.stroke(),o=null!==this.fill();t.save(),this.applyStyle(t),this.drawRipple(t),this.strokeFirst()?(n&&t.stroke(e),o&&t.fill(e)):(o&&t.fill(e),n&&t.stroke(e)),t.restore()}getCacheBBox(){return super.getCacheBBox().expand(this.lineWidth()/2)}getPath(){return new Path2D}getRipplePath(){return new Path2D}drawRipple(t){const e=this.rippleStrength();if(e>0){const n=this.getRipplePath();t.save(),t.globalAlpha*=(0,c.UI)(.54,0,e),t.fill(n),t.restore()}}*ripple(t){void 0===t&&(t=1),this.rippleStrength(0),yield*this.rippleStrength(1,t,i.GE),this.rippleStrength(0)}}d([u()],h.prototype,"fill",void 0),d([u()],h.prototype,"stroke",void 0),d([(0,o.nn)(!1),(0,o.td)()],h.prototype,"strokeFirst",void 0),d([(0,o.nn)(0),(0,o.td)()],h.prototype,"lineWidth",void 0),d([(0,o.nn)("miter"),(0,o.td)()],h.prototype,"lineJoin",void 0),d([(0,o.nn)("butt"),(0,o.td)()],h.prototype,"lineCap",void 0),d([(0,o.nn)([]),(0,o.td)()],h.prototype,"lineDash",void 0),d([(0,o.nn)(0),(0,o.td)()],h.prototype,"lineDashOffset",void 0),d([(0,o.nn)(!0),(0,o.td)()],h.prototype,"antialiased",void 0),d([(0,r.F)()],h.prototype,"rippleSize",null),d([(0,r.F)()],h.prototype,"getPath",null),d([(0,p.C)()],h.prototype,"ripple",null)},70419:(t,e,n)=>{"use strict";n.d(e,{h:()=>c});var o=n(15498),r=n(93091),s=n(88733),p=n(79116),i=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class c extends o.U{constructor(t){super({composite:!0,fontFamily:"Roboto",fontSize:48,lineHeight:"120%",textWrap:!1,fontStyle:"normal",...t}),this.view2D=this,c.shadowRoot.append(this.element),this.applyFlex()}transformContext(){}dispose(){this.removeChildren(),super.dispose()}render(t){this.computedSize(),this.computedPosition(),super.render(t)}requestLayoutUpdate(){this.updateLayout()}requestFontUpdate(){this.applyFont()}view(){return this}}i([(0,r.nn)(s.q.Paused),(0,r.td)()],c.prototype,"playbackState",void 0),i([(0,r.td)()],c.prototype,"assetHash",void 0),i([(0,p.V)((()=>{const t="motion-canvas-2d-frame";let e=document.querySelector(`#${t}`);return e||(e=document.createElement("div"),e.id=t,e.style.position="absolute",e.style.pointerEvents="none",e.style.top="0",e.style.left="0",e.style.opacity="0",e.style.overflow="hidden",document.body.prepend(e)),e.shadowRoot??e.attachShadow({mode:"open"})}))],c,"shadowRoot",void 0)},43595:(t,e,n)=>{"use strict";n.d(e,{j:()=>s});var o=n(30204),r=n(93091);function s(){return(t,e)=>{(0,r.td)()(t,e),(0,r.YS)(o.I)(t,e)}}},37060:(t,e,n)=>{"use strict";n.d(e,{I:()=>u});var o=n(3163),r=n(93091),s=n(5788),p=n(13170),i=n(46096),c=n(16249),a=n(834),l=n(68003);function u(t){return(e,n)=>{const u=(0,r.J)(e,n);u.compound=!0,u.compoundEntries=Object.entries(t),(0,s.f)(e,(t=>{if(!u.parser)return void(0,o.wL)().error(`Missing parser decorator for "${n.toString()}"`);const e=u.default,r=u.parser.bind(t),s=new i.N(u.compoundEntries.map((n=>{let[o,s]=n;const i=new c.V((0,l.Pj)(e,(t=>r(t)[o])),p.UI,t,void 0,(0,a.f)(void 0,t,s)).toSignal();return[o,i]})),r,e,u.interpolationFunction??p.o0,t,(0,a.f)(u,t,n));t[n]=s.toSignal()}))}}},46350:(t,e,n)=>{"use strict";n.d(e,{F:()=>s});var o=n(5788),r=n(73662);function s(){return(t,e)=>{(0,o.f)(t,(t=>{const n=Object.getPrototypeOf(t)[e];t[e]=(0,r.D)(n.bind(t),t)}))}}},5788:(t,e,n)=>{"use strict";n.d(e,{f:()=>r,j:()=>s});const o=Symbol.for("@motion-canvas/2d/decorators/initializers");function r(t,e){if(t[o]){if(t[o]&&!Object.prototype.hasOwnProperty.call(t,o)){const e=Object.getPrototypeOf(t);t[o]=[...e[o]]}}else t[o]=[];t[o].push(e)}function s(t,e){if(t[o])try{t[o].forEach((n=>n(t,e)))}catch(n){throw n.inspect??(n.inspect=t.key),n}}},93091:(t,e,n)=>{"use strict";n.d(e,{E2:()=>k,J:()=>u,JI:()=>y,Oq:()=>D,RG:()=>m,Xd:()=>d,YS:()=>w,nn:()=>f,r_:()=>M,td:()=>h,uN:()=>l});var o=n(13170),r=n(5788),s=n(15688),p=n(3163),i=n(834),c=n(16249);const a=Symbol.for("@motion-canvas/2d/decorators/properties");function l(t,e){var n;return(null==(n=t[a])?void 0:n[e])??null}function u(t,e){let n;return t[a]?t[a]&&!Object.prototype.hasOwnProperty.call(t,a)?t[a]=n=Object.fromEntries(Object.entries(t[a]).map((t=>{let[e,n]=t;return[e,{...n}]}))):n=t[a]:t[a]=n={},n[e]??(n[e]={cloneable:!0,inspectable:!0,compoundEntries:[]}),n[e]}function m(t){return t&&"object"==typeof t?t[a]??{}:{}}function d(t,e){(0,r.j)(t);for(const[n,o]of Object.entries(m(t))){const r=t[n];if(r.reset(),void 0!==e[n]&&r(e[n]),void 0!==o.compoundEntries)for(const[t,n]of o.compoundEntries)n in e&&r[t](e[n])}}function h(){return(t,e)=>{const n=u(t,e);(0,r.f)(t,(t=>{var r,p;const a=null==(r=t[`getDefault${(0,s.k)(e)}`])?void 0:r.bind(t),l=new c.V(a??n.default,n.interpolationFunction??o.o0,t,null==(p=n.parser)?void 0:p.bind(t),(0,i.f)(n,t,e));t[e]=l.toSignal()}))}}function f(t){return(e,n)=>{const o=l(e,n);o?o.default=t:(0,p.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function y(t){return(e,n)=>{const o=l(e,n);o?o.interpolationFunction=t:(0,p.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function k(t){return(e,n)=>{const o=l(e,n);o?o.parser=t:(0,p.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function w(t){return(e,n)=>{const o=l(e,n);o?(o.parser=e=>new t(e),"lerp"in t&&(o.interpolationFunction??(o.interpolationFunction=t.lerp))):(0,p.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function M(t){return void 0===t&&(t=!0),(e,n)=>{const o=l(e,n);o?o.cloneable=t:(0,p.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function D(t){return void 0===t&&(t=!0),(e,n)=>{const o=l(e,n);o?o.inspectable=t:(0,p.wL)().error(`Missing property decorator for "${n.toString()}"`)}}},53693:(t,e,n)=>{"use strict";n.d(e,{g:()=>p});var o=n(43188),r=n(37060),s=n(93091);function p(t){return(e,n)=>{(0,r.I)({top:t?`${t}Top`:"top",right:t?`${t}Right`:"right",bottom:t?`${t}Bottom`:"bottom",left:t?`${t}Left`:"left"})(e,n),(0,s.YS)(o.K)(e,n)}}},88104:(t,e,n)=>{"use strict";n.d(e,{y:()=>p});var o=n(29797),r=n(37060),s=n(93091);function p(t){return(e,n)=>{(0,r.I)("object"==typeof t?t:{x:t?`${t}X`:"x",y:t?`${t}Y`:"y"})(e,n),(0,s.YS)(o.F)(e,n)}}},15914:(t,e,n)=>{"use strict";n.d(e,{r:()=>v});var o=n(92673),r=n(82344),s=n(11726);var p=n(80638),i=n(5881),c=n(97140);class a{constructor(t){this.scene=t,this.signals={},this.variables={},this.handleReset=()=>{this.signals={}},t.onReset.subscribe(this.handleReset)}get(t,e){var n;return(n=this.signals)[t]??(n[t]=(0,c.g)(this.variables[t]??e)),()=>this.signals[t]()}updateSignals(t){this.variables=t,Object.keys(t).map((e=>{e in this.signals&&this.signals[e](t[e])}))}}var l,u=n(1323),m=n(96881),d=n(42075),h=n(67292),f=n(3163),y=n(97715);!function(t){t[t.BeforeRender=0]="BeforeRender",t[t.BeginRender=1]="BeginRender",t[t.FinishRender=2]="FinishRender",t[t.AfterRender=3]="AfterRender"}(l||(l={}));class k{get onBeforeRender(){return this.beforeRender.subscribable}get onBeginRender(){return this.beginRender.subscribable}get onFinishRender(){return this.finishRender.subscribable}get onAfterRender(){return this.afterRender.subscribable}constructor(t){this.scene=t,this.beforeRender=new m.p,this.beginRender=new m.p,this.finishRender=new m.p,this.afterRender=new m.p,this.scene.onRenderLifecycle.subscribe((t=>{let[e,n]=t;switch(e){case l.BeforeRender:return this.beforeRender.dispatch(n);case l.BeginRender:return this.beginRender.dispatch(n);case l.FinishRender:return this.finishRender.dispatch(n);case l.AfterRender:return this.afterRender.dispatch(n)}})),this.scene.onReset.subscribe((()=>{this.beforeRender.clear(),this.beginRender.clear(),this.finishRender.clear(),this.afterRender.clear()}))}}var w,M=n(23357);!function(t){t[t.Initial=0]="Initial",t[t.AfterTransitionIn=1]="AfterTransitionIn",t[t.CanTransitionOut=2]="CanTransitionOut",t[t.Finished=3]="Finished"}(w||(w={}));var D=n(76062),_=n(88733);class g{get onChanged(){return this.slides.subscribable}constructor(t){this.scene=t,this.slides=new u.G([]),this.lookup=new Map,this.collisionLookup=new Set,this.current=null,this.canResume=!1,this.waitsForId=null,this.targetId=null,this.handleReload=()=>{this.lookup.clear(),this.collisionLookup.clear(),this.current=null,this.waitsForId=null,this.targetId=null},this.handleReset=()=>{this.collisionLookup.clear(),this.current=null,this.waitsForId=null},this.handleRecalculated=()=>{this.slides.current=[...this.lookup.values()]},this.scene.onReloaded.subscribe(this.handleReload),this.scene.onReset.subscribe(this.handleReset),this.scene.onRecalculated.subscribe(this.handleRecalculated)}setTarget(t){this.targetId=t}resume(){this.canResume=!0}isWaitingFor(t){return this.waitsForId===t}isWaiting(){return null!==this.waitsForId}didHappen(t){if(null===this.current)return!1;for(const n of this.lookup.keys()){var e;if(n===t)return!0;if(n===(null==(e=this.current)?void 0:e.id))return!1}return!1}getCurrent(){return this.current}register(t,e){if(null!==this.waitsForId)throw new Error(`The animation already waits for a slide: ${this.waitsForId}.`);const n=this.toId(t);this.scene.playback.state!==_.q.Presenting&&(this.lookup.has(n)||this.lookup.set(n,{id:n,name:t,time:e,scene:this.scene,stack:(new Error).stack}),this.collisionLookup.has(t)?this.scene.logger.warn({message:`A slide named "${t}" already exists.`,stack:(new Error).stack}):this.collisionLookup.add(t)),this.waitsForId=n,this.current=this.lookup.get(n)??null,this.canResume=!1}shouldWait(t){const e=this.toId(t);if(this.waitsForId!==e)throw new Error(`The animation waits for a different slide: ${this.waitsForId}.`);if(!this.lookup.get(e))throw new Error(`Could not find the "${t}" slide.`);let n=this.canResume;return this.scene.playback.state!==_.q.Presenting&&(n=e!==this.targetId),n&&(this.waitsForId=null),!n}toId(t){return`${this.scene.name}:${t}`}}class X{get firstFrame(){return this.cache.current.firstFrame}get lastFrame(){return this.firstFrame+this.cache.current.duration}get onCacheChanged(){return this.cache.subscribable}get onReloaded(){return this.reloaded.subscribable}get onRecalculated(){return this.recalculated.subscribable}get onThreadChanged(){return this.thread.subscribable}get onRenderLifecycle(){return this.renderLifecycle.subscribable}get onReset(){return this.afterReset.subscribable}get LifecycleEvents(){return this.logger.warn("LifecycleEvents is deprecated. Use lifecycleEvents instead."),this.lifecycleEvents}get previous(){return this.previousScene}constructor(t){this.cache=new u.G({firstFrame:0,transitionDuration:0,duration:0,lastFrame:0}),this.reloaded=new m.p,this.recalculated=new m.p,this.thread=new u.G(null),this.renderLifecycle=new m.p,this.afterReset=new m.p,this.lifecycleEvents=new k(this),this.previousScene=null,this.runner=null,this.state=w.Initial,this.cached=!1,this.counters={},this.name=t.name,this.size=t.size,this.resolutionScale=t.resolutionScale,this.logger=t.logger,this.playback=t.playback,this.meta=t.meta,this.runnerFactory=t.config,this.creationStack=t.stack,(0,d.G)(this.runnerFactory,(0,h.C)(this.name)),this.timeEvents=new t.timeEventsClass(this),this.variables=new a(this),this.slides=new g(this),this.random=new s.k(this.meta.seed.get())}update(){}async render(t){let e=D.k.consumePromises(),n=0;do{n++,await Promise.all(e.map((t=>t.promise))),t.save();const o=M.b.fromSizeCentered(this.getSize());t.clearRect(o.x,o.y,o.width,o.height),this.execute((()=>this.draw(t))),t.restore(),e=D.k.consumePromises()}while(e.length>0&&n<10);n>1&&this.logger.debug(`render iterations: ${n}`)}reload(t){let{config:e,size:n,stack:o,resolutionScale:r}=void 0===t?{}:t;e&&(this.runnerFactory=e),n&&(this.size=n),r&&(this.resolutionScale=r),o&&(this.creationStack=o),this.cached=!1,this.reloaded.dispatch()}async recalculate(t){const e=this.cache.current;if(e.firstFrame=this.playback.frame,e.lastFrame=e.firstFrame+e.duration,this.isCached())return t(e.lastFrame),void(this.cache.current={...e});for(e.transitionDuration=-1,await this.reset();!this.canTransitionOut();)e.transitionDuration<0&&this.state===w.AfterTransitionIn&&(e.transitionDuration=this.playback.frame-e.firstFrame),t(this.playback.frame+1),await this.next();-1===e.transitionDuration&&(e.transitionDuration=0),e.lastFrame=this.playback.frame,e.duration=e.lastFrame-e.firstFrame,await new Promise((t=>setTimeout(t,0))),this.cached=!0,this.cache.current={...e},this.recalculated.dispatch()}async next(){if(!this.runner)return;let t=this.execute((()=>this.runner.next()));for(this.update();t.value;){if((0,p.x)(t.value)){const e=await t.value.toPromise();t=this.execute((()=>this.runner.next(e)))}else if((0,i.t)(t.value)){const e=await t.value;t=this.execute((()=>this.runner.next(e)))}else this.logger.warn({message:"Invalid value yielded by the scene.",object:t.value}),t=this.execute((()=>this.runner.next(t.value)));this.update()}const e=D.k.consumePromises();var n;e.length>0&&(await Promise.all(e.map((t=>t.promise))),this.logger.error({message:"Tried to access an asynchronous property before the node was ready. Make sure to yield the node before accessing the property.",stack:e[0].stack,inspect:(null==(n=e[0].owner)?void 0:n.key)??void 0}));t.done&&(this.state=w.Finished)}async reset(t){void 0===t&&(t=null),this.counters={},this.previousScene=t,this.random=new s.k(this.meta.seed.get()),this.runner=(0,i.C)((()=>this.runnerFactory(this.getView())),(t=>{this.thread.current=t})),this.state=w.AfterTransitionIn,this.afterReset.dispatch(),await this.next()}getSize(){return this.size}isAfterTransitionIn(){return this.state===w.AfterTransitionIn}canTransitionOut(){return this.state===w.CanTransitionOut||this.state===w.Finished}isFinished(){return this.state===w.Finished}enterInitial(){this.state===w.AfterTransitionIn?this.state=w.Initial:this.logger.warn(`Scene ${this.name} entered initial in an unexpected state: ${this.state}`)}enterAfterTransitionIn(){this.state===w.Initial?this.state=w.AfterTransitionIn:this.logger.warn(`Scene ${this.name} transitioned in an unexpected state: ${this.state}`)}enterCanTransitionOut(){this.state===w.AfterTransitionIn||this.state===w.Initial?this.state=w.CanTransitionOut:this.logger.warn(`Scene ${this.name} was marked as finished in an unexpected state: ${this.state}`)}isCached(){return this.cached}execute(t){let e;(0,f.DO)(this),(0,y.wA)(this.playback);try{e=t()}finally{(0,y.Mh)(this.playback),(0,f.ug)(this)}return e}}var x=n(29797),C=n(70419);class T extends X{constructor(t){super(t),this.view=null,this.registeredNodes={},this.nodeCounters={},this.assetHash=Date.now().toString(),this.recreateView()}getView(){return this.view}next(){var t;return null==(t=this.getView())||t.playbackState(this.playback.state),super.next()}draw(t){t.save(),this.renderLifecycle.dispatch([l.BeforeRender,t]),t.save(),this.renderLifecycle.dispatch([l.BeginRender,t]),this.getView().playbackState(this.playback.state),this.getView().render(t),this.renderLifecycle.dispatch([l.FinishRender,t]),t.restore(),this.renderLifecycle.dispatch([l.AfterRender,t]),t.restore()}reset(t){for(const n in this.registeredNodes)try{this.registeredNodes[n].dispose()}catch(e){this.logger.error(e)}return this.registeredNodes={},this.nodeCounters={},this.recreateView(),super.reset(t)}inspectPosition(t,e){return this.execute((()=>{var n;return(null==(n=this.getView().hit(new x.F(t,e).scale(this.resolutionScale)))?void 0:n.key)??null}))}validateInspection(t){var e;return(null==(e=this.getNode(t))?void 0:e.key)??null}inspectAttributes(t){const e=this.getNode(t);if(!e)return null;const n={stack:e.creationStack,key:e.key};for(const{key:o,meta:r,signal:s}of e)r.inspectable&&(n[o]=s());return n}drawOverlay(t,e,n){const o=this.getNode(t);o&&this.execute((()=>{o.drawOverlay(n,e.scale(1/this.resolutionScale,1/this.resolutionScale).multiplySelf(o.localToWorld()))}))}registerNode(t,e){var n,o;const r=(null==(n=t.constructor)?void 0:n.name)??"unknown";(o=this.nodeCounters)[r]??(o[r]=0);const s=this.nodeCounters[r]++;return e??(e=`${this.name}/${r}[${s}]`),this.registeredNodes[e]=t,e}getNode(t){return"string"!=typeof t?null:this.registeredNodes[t]??null}recreateView(){this.execute((()=>{const t=this.getSize();this.view=new C.h({position:t.scale(this.resolutionScale/2),scale:this.resolutionScale,assetHash:this.assetHash,size:t})}))}}function v(t){return{klass:T,config:t,stack:(new Error).stack,meta:new o.v("scene",{version:new r.C("version",1),timeEvents:new r.C("time events",[]),seed:new r.C("seed",s.k.createSeed())})}}},11258:(t,e,n)=>{"use strict";n.d(e,{Nb:()=>X,JQ:()=>x,av:()=>d,AE:()=>w,pS:()=>_,wp:()=>g,is:()=>k,Zy:()=>f,kZ:()=>D,Ao:()=>M,pt:()=>C,ho:()=>h});var o=n(93091),r=n(88104),s=n(46350),p=n(30204),i=n(68003),c=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class a{constructor(t){(0,o.Xd)(this,t)}canvasGradient(t){let e;switch(this.type()){case"linear":e=t.createLinearGradient(this.from.x(),this.from.y(),this.to.x(),this.to.y());break;case"conic":e=t.createConicGradient(this.angle(),this.from.x(),this.from.y());break;case"radial":e=t.createRadialGradient(this.from.x(),this.from.y(),this.fromRadius(),this.to.x(),this.to.y(),this.toRadius())}for(const{offset:n,color:o}of this.stops())e.addColorStop((0,i.Wg)(n),new p.I((0,i.Wg)(o)).serialize());return e}}c([(0,o.nn)("linear"),(0,o.td)()],a.prototype,"type",void 0),c([(0,r.y)("from")],a.prototype,"from",void 0),c([(0,r.y)("to")],a.prototype,"to",void 0),c([(0,o.nn)(0),(0,o.td)()],a.prototype,"angle",void 0),c([(0,o.nn)(0),(0,o.td)()],a.prototype,"fromRadius",void 0),c([(0,o.nn)(0),(0,o.td)()],a.prototype,"toRadius",void 0),c([(0,o.nn)([]),(0,o.td)()],a.prototype,"stops",void 0),c([(0,s.F)()],a.prototype,"canvasGradient",null);var l=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class u{constructor(t){(0,o.Xd)(this,t)}canvasPattern(t){return t.createPattern(this.image(),this.repetition())}}l([(0,o.td)()],u.prototype,"image",void 0),l([(0,o.nn)(null),(0,o.td)()],u.prototype,"repetition",void 0),l([(0,s.F)()],u.prototype,"canvasPattern",null);var m=n(29797);function d(t){return null===t?null:t instanceof a||t instanceof u?t:new p.I(t)}function h(t,e){return null===t?"":t instanceof p.I?t.serialize():t instanceof a?t.canvasGradient(e):t instanceof u?t.canvasPattern(e)??"":""}function f(t,e,n,o,r){if(0===n.top&&0===n.right&&0===n.bottom&&0===n.left)return void function(t,e){t.rect(e.x,e.y,e.width,e.height)}(t,e);const s=y(n.top,n.right,n.left,e),p=y(n.right,n.top,n.bottom,e),i=y(n.bottom,n.left,n.right,e),c=y(n.left,n.bottom,n.top,e);if(o){const n=t=>t-t*r;return t.moveTo(e.left+s,e.top),t.lineTo(e.right-p,e.top),t.bezierCurveTo(e.right-n(p),e.top,e.right,e.top+n(p),e.right,e.top+p),t.lineTo(e.right,e.bottom-i),t.bezierCurveTo(e.right,e.bottom-n(i),e.right-n(i),e.bottom,e.right-i,e.bottom),t.lineTo(e.left+c,e.bottom),t.bezierCurveTo(e.left+n(c),e.bottom,e.left,e.bottom-n(c),e.left,e.bottom-c),t.lineTo(e.left,e.top+s),void t.bezierCurveTo(e.left,e.top+n(s),e.left+n(s),e.top,e.left+s,e.top)}t.moveTo(e.left+s,e.top),t.arcTo(e.right,e.top,e.right,e.bottom,p),t.arcTo(e.right,e.bottom,e.left,e.bottom,i),t.arcTo(e.left,e.bottom,e.left,e.top,c),t.arcTo(e.left,e.top,e.right,e.top,s)}function y(t,e,n,o){const r=t+e>o.width?o.width*(t/(t+e)):t,s=t+n>o.height?o.height*(t/(t+n)):t;return Math.min(r,s)}function k(t,e,n){const o=e.size.scale(.5);for(let r=0;r<=n;r++){const e=2*r*Math.PI/n,s=m.F.fromRadians(e).perpendicular.mul(o);0==r?M(t,s):D(t,s)}t.closePath()}function w(t,e,n,o){o?t.drawImage(e,n.x,n.y,n.width,n.height,o.x,o.y,o.width,o.height):t.drawImage(e,n.x,n.y,n.width,n.height)}function M(t,e){t.moveTo(e.x,e.y)}function D(t,e){t.lineTo(e.x,e.y)}function _(t,e){if(!(e.length<2)){M(t,e[0]);for(const n of e.slice(1))D(t,n)}}function g(t,e,n){void 0===n&&(n=8),D(t,e.addY(-n)),D(t,e.addY(n)),D(t,e),D(t,e.addX(-n)),X(t,e,n)}function X(t,e,n,o,r,s){void 0===o&&(o=0),void 0===r&&(r=2*Math.PI),void 0===s&&(s=!1),t.arc(e.x,e.y,n,o,r,s)}function x(t,e,n,o){t.bezierCurveTo(e.x,e.y,n.x,n.y,o.x,o.y)}function C(t,e,n){t.quadraticCurveTo(e.x,e.y,n.x,n.y)}},834:(t,e,n)=>{"use strict";n.d(e,{f:()=>r});var o=n(15688);function r(t,e,n){void 0===t&&(t={});const r={};if(n&&e){const s=t.setter??(null==e?void 0:e[`set${(0,o.k)(n)}`]);s&&(r.setter=s.bind(e));const p=t.getter??(null==e?void 0:e[`get${(0,o.k)(n)}`]);p&&(r.getter=p.bind(e));const i=t.tweener??(null==e?void 0:e[`tween${(0,o.k)(n)}`]);i&&(r.tweener=i.bind(e))}return r}},88733:(t,e,n)=>{"use strict";n.d(e,{q:()=>o,r:()=>s});var o,r=n(1323);!function(t){t[t.Playing=0]="Playing",t[t.Rendering=1]="Rendering",t[t.Paused=2]="Paused",t[t.Presenting=3]="Presenting"}(o||(o={}));class s{constructor(){this.frame=0,this.speed=1,this.fps=30,this.duration=0,this.finished=!1,this.slides=[],this.previousScene=null,this.state=o.Paused,this.currentSceneReference=null,this.scenes=new r.G([])}get onSceneChanged(){if(null===this.currentSceneReference)throw new Error("PlaybackManager has not been properly initialized");return this.currentSceneReference.subscribable}get onScenesRecalculated(){return this.scenes.subscribable}get currentScene(){if(null===this.currentSceneReference)throw new Error("PlaybackManager has not been properly initialized");return this.currentSceneReference.current}set currentScene(t){if(!t)throw new Error("Invalid scene.");this.currentSceneReference??(this.currentSceneReference=new r.G(t)),this.currentSceneReference.current=t}setup(t){this.scenes.current=t,this.currentScene=t[0]}async progress(){return this.finished=await this.next(),this.finished}async seek(t){if(t<=this.frame||this.currentScene.isCached()&&this.currentScene.lastFrame<t){const e=this.findBestScene(t);e!==this.currentScene?(this.previousScene=null,this.currentScene=e,this.frame=this.currentScene.firstFrame,await this.currentScene.reset()):this.frame>=t&&(this.previousScene=null,this.frame=this.currentScene.firstFrame,await this.currentScene.reset())}for(this.finished=!1;this.frame<t&&!this.finished;)this.finished=await this.next();return this.finished}async goBack(){let t=this.currentScene.slides.getCurrent();if(t&&this.currentScene.slides.isWaiting()){const e=this.slides.indexOf(t);t=this.slides[e-1]}await this.seekSlide(t)}async goForward(){const t=this.currentScene.slides.getCurrent(),e=this.slides.indexOf(t);await this.seekSlide(this.slides[e+1])}async goTo(t){await this.seekSlide(this.slides.find((e=>e.id===t)))}async seekSlide(t){if(void 0===t&&(t=null),!t)return;const{id:e,scene:n}=t;for((this.currentScene!==n||this.currentScene.slides.didHappen(e))&&(this.previousScene=null,this.currentScene=n,this.frame=this.currentScene.firstFrame,this.currentScene.slides.setTarget(e),await this.currentScene.reset()),this.finished=!1,this.currentScene.slides.setTarget(e);!this.currentScene.slides.isWaitingFor(e)&&!this.finished;)this.finished=await this.next();return this.currentScene.slides.setTarget(null),this.finished}async reset(){this.previousScene=null,this.currentScene=this.scenes.current[0],this.frame=0,await this.currentScene.reset()}reload(t){this.scenes.current.forEach((e=>e.reload(t)))}async recalculate(){this.previousScene=null,this.slides=[];const t=this.speed;this.frame=0,this.speed=1;const e=[];try{for(const t of this.scenes.current)await t.recalculate((t=>{this.frame=t})),this.slides.push(...t.slides.onChanged.current),e.push(t)}finally{this.speed=t}this.scenes.current=e,this.duration=this.frame}async next(){if(this.previousScene&&(await this.previousScene.next(),this.currentScene.isFinished()&&(this.previousScene=null)),this.frame+=this.speed,this.currentScene.isFinished())return!0;if(await this.currentScene.next(),this.previousScene&&this.currentScene.isAfterTransitionIn()&&(this.previousScene=null),this.currentScene.canTransitionOut()){this.previousScene=this.currentScene;const t=this.getNextScene(this.previousScene);t&&(this.currentScene=t,await this.currentScene.reset(this.previousScene)),t&&!this.currentScene.isAfterTransitionIn()||(this.previousScene=null)}return this.currentScene.isFinished()}findBestScene(t){let e=this.scenes.current[0];for(const n of this.scenes.current){if(!n.isCached()||n.lastFrame>t)return n;e=n}return e}getNextScene(t){const e=this.scenes.current;if(!t)return e[0];const n=e.findIndex((e=>e===t));return n<0?null:e[n+1]??null}}},2672:(t,e,n)=>{"use strict";n.d(e,{J:()=>f});var o=n(88733),r=n(1323),s=n(3163);class p{get onDataChanged(){return this.data.subscribable}constructor(t){this.logger=t,this.data=new r.G(null),this.context=new AudioContext,this.audioElement=new Audio,this.source=null,this.error=!1,this.abortController=null,this.offset=0}getTime(){return this.toAbsoluteTime(this.audioElement.currentTime)}setTime(t){this.audioElement.currentTime=this.toRelativeTime(t)}setOffset(t){this.offset=t}setMuted(t){this.audioElement.muted=t}setSource(t){var e;this.source=t,this.audioElement.src=t,null==(e=this.abortController)||e.abort(),this.abortController=new AbortController,this.loadData(this.abortController.signal).catch((t=>{"AbortError"!==t.name&&this.logger.error(t)}))}isInRange(t){return t>=this.offset&&t<this.audioElement.duration}toRelativeTime(t){return Math.max(0,t-this.offset)}toAbsoluteTime(t){return t+this.offset}isReady(){return this.source&&!this.error}async setPaused(t){if(this.source&&this.audioElement.paused!==t)if(t)this.audioElement.pause();else try{return await this.audioElement.play(),this.error=!1,!0}catch(e){this.error||(0,s.wL)().error(e),this.error=!0}return!1}async loadData(t){if(this.data.current=null,!this.source)return;const e=await fetch(this.source,{signal:t}),n=await e.arrayBuffer();if(t.aborted)return;const o=await this.decodeAudioData(n);if(t.aborted)return;const r=256,s=~~(o.length/r),p=[];let i=0;for(let c=0;c<o.numberOfChannels;c++){const t=o.getChannelData(c);for(let e=0;e<s;e++){const n=~~(e*r),o=~~(n+r);let s=t[n],a=s;for(let e=n;e<o;e++){const n=t[e];n>a&&(a=n),n<s&&(s=n)}(0===c||a>p[2*e])&&(p[2*e]=a),(0===c||s<p[2*e+1])&&(p[2*e+1]=s),a>i&&(i=a),Math.abs(s)>i&&(i=Math.abs(s))}}this.data.current={peaks:p,absoluteMax:i,length:s,sampleRate:o.sampleRate/r*2}}decodeAudioData(t){return new Promise(((e,n)=>this.context.decodeAudioData(t,e,n)))}}var i=n(13170),c=n(11395);class a extends c.p{async dispatch(t){await Promise.all(this.notifySubscribers(t))}}var l=n(96881),u=n(29797);class m{constructor(t){this.playback=t}secondsToFrames(t){return Math.ceil(t*this.playback.fps)}framesToSeconds(t){return t/this.playback.fps}get time(){return this.framesToSeconds(this.playback.frame)}get frame(){return this.playback.frame}get speed(){return this.playback.speed}get fps(){return this.playback.fps}get state(){return this.playback.state}}var d=n(15649);class h{get onChanged(){return this.events.subscribable}constructor(t){this.scene=t,this.events=new r.G([]),this.registeredEvents={},this.lookup={},this.collisionLookup=new Set,this.previousReference=[],this.didEventsChange=!1,this.preserveTiming=!0,this.handleReload=()=>{this.registeredEvents={},this.collisionLookup.clear()},this.handleRecalculated=()=>{var t;this.preserveTiming=!0,this.events.current=Object.values(this.registeredEvents),(this.didEventsChange||((null==(t=this.previousReference)?void 0:t.length)??0)!==this.events.current.length)&&(this.didEventsChange=!1,this.previousReference=Object.values(this.registeredEvents).map((t=>({name:t.name,targetTime:t.targetTime}))),this.scene.meta.timeEvents.set(this.previousReference))},this.handleReset=()=>{this.collisionLookup.clear()},this.handleMetaChanged=t=>{t!==this.previousReference&&(this.previousReference=t,this.load(t),this.scene.reload())},this.previousReference=t.meta.timeEvents.get(),this.load(this.previousReference),t.onReloaded.subscribe(this.handleReload),t.onRecalculated.subscribe(this.handleRecalculated),t.onReset.subscribe(this.handleReset),t.meta.timeEvents.onChanged.subscribe(this.handleMetaChanged,!1)}set(t,e,n){void 0===n&&(n=!0),this.lookup[t]&&this.lookup[t].offset!==e&&(this.preserveTiming=n,this.lookup[t]={...this.lookup[t],targetTime:this.lookup[t].initialTime+e,offset:e},this.registeredEvents[t]=this.lookup[t],this.events.current=Object.values(this.registeredEvents),this.didEventsChange=!0,this.scene.reload())}register(t,e){if(this.collisionLookup.has(t))return this.scene.logger.error({message:`name "${t}" has already been used for another event name.`,stack:(new Error).stack}),0;if(this.collisionLookup.add(t),this.lookup[t]){let n=!1;const o={...this.lookup[t]},r=(new Error).stack;o.stack!==r&&(o.stack=r,n=!0),o.initialTime!==e&&(o.initialTime=e,n=!0);const s=Math.max(0,o.targetTime-o.initialTime);this.preserveTiming&&o.offset!==s&&(o.offset=s,n=!0);const p=o.initialTime+o.offset;this.preserveTiming||o.targetTime===p||(this.didEventsChange=!0,o.targetTime=p,n=!0),n&&(this.lookup[t]=o)}else this.didEventsChange=!0,this.lookup[t]={name:t,initialTime:e,targetTime:e,offset:0,stack:(new Error).stack};return this.registeredEvents[t]=this.lookup[t],this.lookup[t].offset}load(t){for(const e of t){const t=this.lookup[e.name]??{name:e.name,initialTime:0,offset:0};this.lookup[e.name]={...t,targetTime:e.targetTime}}}}class f{get onRender(){return this.render.subscribable}get onStateChanged(){return this.playerState.subscribable}get onFrameChanged(){return this.frame.subscribable}get onDurationChanged(){return this.duration.subscribable}get onRecalculated(){return this.recalculated.subscribable}get startFrame(){return Math.min(this.playback.duration,this.status.secondsToFrames(this.startTime))}get endFrame(){return Math.min(this.playback.duration,this.status.secondsToFrames(this.endTime))}get finished(){return this.playback.finished||this.playback.frame>=this.endFrame}constructor(t,e,n,s){var i,c;void 0===e&&(e={}),void 0===n&&(n={}),void 0===s&&(s=-1),this.project=t,this.settings=e,this.initialState=n,this.initialFrame=s,this.render=new a,this.frame=new r.G(0),this.duration=new r.G(0),this.recalculated=new l.p,this.lock=new d.L,this.startTime=0,this.endTime=1/0,this.requestId=null,this.renderTime=0,this.requestedSeek=-1,this.requestedRecalculation=!0,this.active=!1,this.playerState=new r.G({loop:!0,muted:!0,speed:1,...n,paused:!0}),this.requestedSeek=s,this.logger=this.project.logger,this.playback=new o.r,this.status=new m(this.playback),this.audio=new p(this.logger),this.size=e.size??new u.F(1920,1080),this.resolutionScale=e.resolutionScale??1,this.startTime=(null==(i=e.range)?void 0:i[0])??0,this.endTime=(null==(c=e.range)?void 0:c[1])??1/0,this.playback.fps=e.fps??60,this.audio.setOffset(e.audioOffset??0),t.audio&&this.audio.setSource(t.audio);const f=[];for(const o of t.scenes){var y;const e=new o.klass({...o,playback:this.status,logger:this.project.logger,size:this.size,resolutionScale:this.resolutionScale,timeEventsClass:h});null==(y=o.onReplaced)||y.subscribe((t=>{e.reload(t)}),!1),e.onReloaded.subscribe((()=>this.requestRecalculation())),e.variables.updateSignals(t.variables??{}),f.push(e)}this.playback.setup(f),this.activate()}async configure(t){await this.lock.acquire();let e=this.playback.frame,n=!1;if(this.startTime=t.range[0],this.endTime=t.range[1],this.playback.fps!==t.fps){const o=t.fps/this.playback.fps;this.playback.fps=t.fps,e=Math.floor(e*o),n=!0}t.size.exactlyEquals(this.size)&&t.resolutionScale===this.resolutionScale||(this.size=t.size,this.resolutionScale=t.resolutionScale,this.playback.reload({size:this.size,resolutionScale:this.resolutionScale})),void 0!==t.audioOffset&&this.audio.setOffset(t.audioOffset),this.lock.release(),n&&(this.playback.reload(),this.frame.current=e,this.requestRecalculation(),this.requestedSeek=e)}requestSeek(t){this.requestedSeek=this.clampRange(t)}requestPreviousFrame(){this.requestedSeek=this.frame.current-this.playback.speed}requestNextFrame(){this.requestedSeek=this.frame.current+this.playback.speed}requestReset(){this.requestedSeek=0}toggleLoop(t){void 0===t&&(t=!this.playerState.current.loop),t!==this.playerState.current.loop&&(this.playerState.current={...this.playerState.current,loop:t})}togglePlayback(t){void 0===t&&(t=this.playerState.current.paused),t===this.playerState.current.paused&&(this.playerState.current={...this.playerState.current,paused:!t},t&&!this.playerState.current.loop&&this.playback.frame===this.playback.duration&&this.requestReset())}toggleAudio(t){void 0===t&&(t=this.playerState.current.muted),t===this.playerState.current.muted&&(this.playerState.current={...this.playerState.current,muted:!t})}setSpeed(t){t!==this.playerState.current.speed&&(this.playback.speed=t,this.playback.reload(),this.playerState.current={...this.playerState.current,speed:t},this.requestRecalculation())}setVariables(t){for(const e of this.playback.onScenesRecalculated.current)e.variables.updateSignals(t)}activate(){this.active=!0,this.request()}deactivate(){this.active=!1,null!==this.requestId&&(cancelAnimationFrame(this.requestId),this.requestId=null)}requestRecalculation(){this.requestedRecalculation=!0,this.request()}async prepare(){const t={...this.playerState.current,seek:this.requestedSeek};if(this.requestedSeek=-1,this.requestedRecalculation){t.seek<0&&(t.seek=this.playback.frame);try{await this.playback.recalculate(),this.duration.current=this.playback.frame,this.recalculated.dispatch()}catch(n){throw this.requestSeek(t.seek),n}finally{this.requestedRecalculation=!1}}(!t.loop&&this.finished&&!t.paused&&t.seek<0||this.endFrame===this.startFrame)&&(this.togglePlayback(!1),t.paused=!0),t.loop&&(t.seek>this.endFrame||this.finished&&!t.paused)&&this.startFrame!==this.endTime&&(t.seek=this.startFrame);const e=t.paused||this.finished||!this.audio.isInRange(this.status.time);return await this.audio.setPaused(e)&&this.syncAudio(-3),this.audio.setMuted(t.muted),t}async run(){const t=await this.prepare(),e=this.playback.state;if(this.playback.state=t.paused?o.q.Paused:o.q.Playing,t.seek>=0||!this.isInRange(this.status.frame)){const e=t.seek<0?this.status.frame:t.seek,n=this.clampRange(e);this.logger.profile("seek time"),await this.playback.seek(n),this.logger.profile("seek time"),this.syncAudio(-3)}else{if(t.paused||1===t.speed&&this.audio.isReady()&&this.audio.isInRange(this.status.time)&&this.audio.getTime()<this.status.time)return t.paused&&e!==o.q.Paused&&await this.render.dispatch(),!t.paused&&this.status.time>this.audio.getTime()+.02&&this.syncAudio(),void this.request();if(this.audio.isReady()&&1===t.speed&&this.audio.isInRange(this.status.time)&&this.status.framesToSeconds(this.playback.frame+1)<this.audio.getTime()-.02){const t=this.status.secondsToFrames(this.audio.getTime());await this.playback.seek(t)}else this.status.frame<this.endFrame&&(await this.playback.progress(),1!==t.speed&&this.syncAudio())}!t.paused&&this.playback.currentScene.slides.isWaiting()&&(this.togglePlayback(!1),t.paused=!0),await this.render.dispatch(),this.frame.current=this.playback.frame,this.request()}request(){this.active&&(this.requestId??(this.requestId=requestAnimationFrame((async t=>{if(this.requestId=null,t-this.renderTime>=1e3/(this.status.fps+5)){this.renderTime=t,await this.lock.acquire();try{await this.run()}catch(e){this.logger.error(e)}this.lock.release()}else this.request()}))))}clampRange(t){return(0,i.uZ)(this.startFrame,this.endFrame,t)}isInRange(t){return t>=this.startFrame&&t<=this.endFrame}syncAudio(t){void 0===t&&(t=0),this.audio.setTime(this.status.framesToSeconds(this.playback.frame+t))}}},9989:(t,e,n)=>{"use strict";n.d(e,{H:()=>s});var o=n(1119),r=n(29797);class s{get canvasSize(){return this.size.scale(this.resolutionScale)}constructor(){this.background=null,this.resolutionScale=1,this.colorSpace="srgb",this.size=r.F.zero,this.finalBuffer=document.createElement("canvas"),this.currentBuffer=document.createElement("canvas"),this.previousBuffer=document.createElement("canvas");const t=this.colorSpace;this.context=(0,o.f)({colorSpace:t},this.finalBuffer),this.currentContext=(0,o.f)({colorSpace:t},this.currentBuffer),this.previousContext=(0,o.f)({colorSpace:t},this.previousBuffer)}configure(t){let{colorSpace:e=this.colorSpace,size:n=this.size,resolutionScale:r=this.resolutionScale,background:s=this.background}=t;e!==this.colorSpace&&(this.colorSpace=e,this.context=(0,o.f)({colorSpace:e},this.finalBuffer),this.currentContext=(0,o.f)({colorSpace:e},this.currentBuffer),this.previousContext=(0,o.f)({colorSpace:e},this.previousBuffer)),n.exactlyEquals(this.size)&&r===this.resolutionScale||(this.resolutionScale=r,this.size=n,this.resizeCanvas(this.context),this.resizeCanvas(this.currentContext),this.resizeCanvas(this.previousContext)),this.background="string"==typeof s?s:(null==s?void 0:s.serialize())??null}async render(t,e){e&&(this.transformCanvas(this.previousContext),await e.render(this.previousContext)),this.transformCanvas(this.currentContext),await t.render(this.currentContext);const n=this.canvasSize;this.context.clearRect(0,0,n.width,n.height),this.background&&(this.context.save(),this.context.fillStyle=this.background,this.context.fillRect(0,0,n.width,n.height),this.context.restore()),e&&this.context.drawImage(this.previousBuffer,0,0),this.context.drawImage(this.currentBuffer,0,0)}transformCanvas(t){const e=this.canvasSize.scale(.5);t.setTransform(this.resolutionScale,0,0,this.resolutionScale,e.x,e.y)}resizeCanvas(t){const e=this.canvasSize;t.canvas.width=e.width,t.canvas.height=e.height}}},42075:(t,e,n)=>{"use strict";function o(t){const e={[t.name]:t},n=Object.getOwnPropertyDescriptor(e,t.name);if(n){for(var o=arguments.length,r=new Array(o>1?o-1:0),s=1;s<o;s++)r[s-1]=arguments[s];for(let o=r.length-1;o>=0;o--)r[o](e,t.name,n)}}n.d(e,{G:()=>o})},79116:(t,e,n)=>{"use strict";n.d(e,{V:()=>r});const o=Symbol.for("@motion-canvas/core/decorators/UNINITIALIZED");function r(t){return(e,n)=>{let r=o;Object.defineProperty(e,n,{get(){return r===o&&(r=t.call(this)),r}})}}},67292:(t,e,n)=>{"use strict";function o(t){return function(e,n,o){o.value.prototype.name=t??n,o.value.prototype.threadable=!0}}n.d(e,{C:()=>o})},96881:(t,e,n)=>{"use strict";n.d(e,{p:()=>r});var o=n(11395);class r extends o.p{dispatch(t){this.notifySubscribers(t)}}},11395:(t,e,n)=>{"use strict";n.d(e,{l:()=>r,p:()=>o});class o{constructor(){this.subscribable=new r(this),this.subscribers=new Set}subscribe(t){return this.subscribers.add(t),()=>this.unsubscribe(t)}unsubscribe(t){this.subscribers.delete(t)}clear(){this.subscribers.clear()}notifySubscribers(t){return[...this.subscribers].map((e=>e(t)))}}class r{constructor(t){this.dispatcher=t}subscribe(t){return this.dispatcher.subscribe(t)}unsubscribe(t){this.dispatcher.unsubscribe(t)}}},1323:(t,e,n)=>{"use strict";n.d(e,{G:()=>r});var o=n(11395);class r extends o.p{set current(t){this.value=t,this.notifySubscribers(t)}get current(){return this.value}constructor(t){super(),this.value=t,this.subscribable=new s(this)}subscribe(t,e){void 0===e&&(e=!0);const n=super.subscribe(t);return e&&t(this.value),n}}class s extends o.l{get current(){return this.dispatcher.current}subscribe(t,e){return void 0===e&&(e=!0),this.dispatcher.subscribe(t,e)}}},5376:(t,e,n)=>{"use strict";n.d(e,{$:()=>p});var o=n(51284),r=n(42075),s=n(67292);function*p(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];for(const o of e)yield o;yield*(0,o.v)(...e)}(0,r.G)(p,(0,s.C)())},77396:(t,e,n)=>{"use strict";n.d(e,{K:()=>r});var o=n(75168);function r(t,e){let n;return"string"==typeof t?(n=e(),(0,o.i)(n,t)):(n=t(),(0,o.i)(n,n)),n}},84266:(t,e,n)=>{"use strict";n.d(e,{A:()=>c,X:()=>a});var o=n(42075),r=n(67292),s=n(30092),p=n(56632),i=n(97715);function*c(t,e){yield*a((0,s.Y)(t)),e&&(yield*e)}function*a(t,e){void 0===t&&(t=0);const n=(0,p.nn)(),o=(0,i.te)().framesToSeconds(1),r=n.time()+t;for(;r-o>n.fixed;)yield;n.time(r),e&&(yield*e)}(0,o.G)(c,(0,r.C)()),(0,o.G)(a,(0,r.C)())},82344:(t,e,n)=>{"use strict";n.d(e,{C:()=>r});var o=n(1323);class r{get onChanged(){return this.value.subscribable}get onDisabled(){return this.disabled.subscribable}constructor(t,e){this.name=t,this.type=void 0,this.spacing=!1,this.disabled=new o.G(!1),this.value=new o.G(e)}get(){return this.value.current}set(t){this.value.current=this.parse(t)}parse(t){return t}serialize(){return this.value.current}clone(){return new this.constructor(this.name,this.get())}disable(t){return void 0===t&&(t=!0),this.disabled.current=t,this}space(t){return void 0===t&&(t=!0),this.spacing=t,this}}},92673:(t,e,n)=>{"use strict";n.d(e,{v:()=>p});var o=n(82344),r=n(1323);class s extends o.C{get onFieldsChanged(){return this.event.subscribable}constructor(t,e){const n=new Map(Object.entries(e));super(t,Object.fromEntries(Array.from(n,(t=>{let[e,n]=t;return[e,n.get()]})))),this.type=Object,this.ignoreChange=!1,this.customFields={},this.handleChange=()=>{this.ignoreChange||(this.value.current=this.transform("get"))},this.event=new r.G([...n.values()]),this.fields=n;for(const[o,r]of this.fields)Object.defineProperty(this,o,{value:r}),r.onChanged.subscribe(this.handleChange)}set(t){this.ignoreChange=!0;for(const[e,n]of Object.entries(t)){const t=this.fields.get(e);t?t.set(n):this.customFields[e]=n}this.ignoreChange=!1,this.handleChange()}serialize(){return this.transform("serialize")}clone(){return new this.constructor(this.name,this.transform("clone"))}transform(t){return{...Object.fromEntries(Array.from(this.fields,(e=>{let[n,o]=e;return[n,o[t]()]}))),...this.customFields}}}const p=s},11726:(t,e,n)=>{"use strict";n.d(e,{k:()=>s});var o=n(13170),r=n(37762);class s{constructor(t){this.state=t}static createSeed(){return Math.floor(4294967296*Math.random())}nextFloat(t,e){return void 0===t&&(t=0),void 0===e&&(e=1),(0,o.UI)(t,e,this.next())}nextInt(t,e){void 0===t&&(t=0),void 0===e&&(e=4294967296);let n=Math.floor((0,o.UI)(t,e,this.next()));return n===e&&(n=t),n}floatArray(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,r.w)(t).map((()=>this.nextFloat(e,n)))}intArray(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=4294967296),(0,r.w)(t).map((()=>this.nextInt(e,n)))}spawn(){return new s(this.nextInt())}next(){this.state|=0,this.state=this.state+1831565813|0;let t=Math.imul(this.state^this.state>>>15,1|this.state);return t=t+Math.imul(t^t>>>7,61|t)^t,((t^t>>>14)>>>0)/4294967296}}},46096:(t,e,n)=>{"use strict";n.d(e,{N:()=>p});var o=n(13170),r=n(16249),s=n(68003);class p extends r.V{constructor(t,e,n,p,i,c){var a;void 0===i&&(i=void 0),void 0===c&&(c={}),super(void 0,p,i,e,c),this.entries=t,this.signals=[],this.parser=e;for(const l of t){let t,p;Array.isArray(l)?([t,p]=l,(a=p.context).owner??(a.owner=this)):(t=l,p=new r.V((0,s.Pj)(n,(t=>e(t)[l])),o.UI,i??this.invokable).toSignal()),this.signals.push([t,p]),Object.defineProperty(this.invokable,t,{value:p})}}toSignal(){return this.invokable}parse(t){return this.parser(t)}getter(){return this.parse(Object.fromEntries(this.signals.map((t=>{let[e,n]=t;return[e,n()]}))))}setter(t){if((0,s.PG)(t))for(const[e,n]of this.signals)n((()=>this.parser(t())[e]));else{const e=this.parse(t);for(const[t,n]of this.signals)n(e[t])}return this.owner}reset(){for(const[,t]of this.signals)t.reset();return this.owner}save(){for(const[,t]of this.signals)t.save();return this.owner}}},81865:(t,e,n)=>{"use strict";n.d(e,{h:()=>p});var o=n(3163),r=n(90031),s=n(76062);class p extends s.k{constructor(t,e){super(e),this.factory=t,this.markDirty()}toSignal(){return this.invokable}dispose(){super.dispose(),this.last=void 0}invoke(){if(this.event.isRaised()){this.clearDependencies(),this.startCollecting();try{this.last=this.factory(...arguments)}catch(e){var t;(0,o.wL)().error({...(0,r.d)(e),inspect:null==(t=this.owner)?void 0:t.key})}this.finishCollecting()}return this.event.reset(),this.collect(),this.last}}},76062:(t,e,n)=>{"use strict";n.d(e,{k:()=>p});var o=n(11395);class r extends o.p{constructor(){super(...arguments),this.value=!1}raise(){this.value||(this.value=!0,this.notifySubscribers())}reset(){this.value=!1}isRaised(){return this.value}subscribe(t){const e=super.subscribe(t);return this.value&&t(),e}}var s=n(49111);class p{static collectPromise(t,e){void 0===e&&(e=null);const n={promise:t,value:e,stack:(new Error).stack},o=this.collectionStack.at(-1);return o&&(n.owner=o.owner),t.then((t=>{n.value=t,null==o||o.markDirty()})).finally((()=>{this.promises=this.promises.filter((t=>t!==n))})),this.promises.push(n),n}static consumePromises(){return this.promises}constructor(t){this.owner=t,this.dependencies=new Set,this.event=new r,this.markDirty=()=>this.event.raise(),this.invokable=this.invoke.bind(this),Object.defineProperty(this.invokable,"context",{value:this}),Object.defineProperty(this.invokable,"toPromise",{value:this.toPromise.bind(this)})}invoke(){}startCollecting(){if(p.collectionSet.has(this))throw new s.t("A circular dependency occurred between signals.","This can happen when signals reference each other in a loop.\n        Try using the attached stack trace to locate said loop.");p.collectionSet.add(this),p.collectionStack.push(this)}finishCollecting(){if(p.collectionSet.delete(this),p.collectionStack.pop()!==this)throw new Error("collectStart/collectEnd was called out of order.")}clearDependencies(){this.dependencies.forEach((t=>t.unsubscribe(this.markDirty))),this.dependencies.clear()}collect(){const t=p.collectionStack.at(-1);t&&(t.dependencies.add(this.event.subscribable),this.event.subscribe(t.markDirty))}dispose(){this.clearDependencies(),this.event.clear(),this.owner=null}async toPromise(){let t=p.consumePromises();do{await Promise.all(t.map((t=>t.promise))),this.invokable(),t=p.consumePromises()}while(t.length>0);return this.invokable}}p.collectionSet=new Set,p.collectionStack=[],p.promises=[]},16249:(t,e,n)=>{"use strict";n.d(e,{V:()=>m});var o=n(97074),r=n(74534),s=n(3163),p=n(90031),i=n(77396),c=n(84266),a=n(76062),l=n(68003),u=n(60771);class m extends a.k{constructor(t,e,n,o,r){void 0===n&&(n=void 0),void 0===o&&(o=t=>t),void 0===r&&(r={}),super(n),this.initial=t,this.interpolation=e,this.parser=o,Object.defineProperty(this.invokable,"reset",{value:this.reset.bind(this)}),Object.defineProperty(this.invokable,"save",{value:this.save.bind(this)}),Object.defineProperty(this.invokable,"isInitial",{value:this.isInitial.bind(this)}),void 0!==this.initial&&(this.current=this.initial,this.markDirty(),(0,l.PG)(this.initial)||(this.last=this.parse(this.initial))),this.extensions={getter:this.getter.bind(this),setter:this.setter.bind(this),tweener:this.tweener.bind(this),...r}}toSignal(){return this.invokable}parse(t){return this.parser(t)}set(t){return this.extensions.setter(t),this.owner}setter(t){return t===u.T&&(t=this.initial),this.current===t||(this.current=t,this.markDirty(),this.clearDependencies(),(0,l.PG)(t)||(this.last=this.parse(t))),this.owner}get(){return this.extensions.getter()}getter(){if(this.event.isRaised()&&(0,l.PG)(this.current)){this.clearDependencies(),this.startCollecting();try{this.last=this.parse(this.current())}catch(e){var t;(0,s.wL)().error({...(0,p.d)(e),inspect:null==(t=this.owner)?void 0:t.key})}this.finishCollecting()}return this.event.reset(),this.collect(),this.last}invoke(t,e,n,r){if(void 0===n&&(n=o.qb),void 0===r&&(r=this.interpolation),void 0===t)return this.get();if(void 0===e)return this.set(t);return this.createQueue(n,r).to(t,e)}createQueue(t,e){var n=this;const o=this.get(),r=[],s=(0,i.K)((function*(){for(;r.length>0;)yield*r.shift()}));return s.to=function(o,p,i,c){return void 0===i&&(i=t),void 0===c&&(c=e),t=i,e=c,r.push(n.tween(o,p,i,c)),s},s.back=function(p,i,c){return void 0===i&&(i=t),void 0===c&&(c=e),t=i,e=c,r.push(n.tween(o,p,t,e)),s},s.wait=t=>(r.push((0,c.X)(t)),s),s.run=t=>(r.push(t),s),s.do=t=>(r.push((0,i.K)((function*(){t()}))),s),s}*tween(t,e,n,o){t===u.T&&(t=this.initial),yield*this.extensions.tweener(t,e,n,o),this.set(t)}*tweener(t,e,n,o){const s=this.get();yield*(0,r.i)(e,(e=>{this.set(o(s,this.parse((0,l.Wg)(t)),n(e)))}))}dispose(){super.dispose(),this.initial=void 0,this.current=void 0,this.last=void 0}reset(){return void 0!==this.initial&&this.set(this.initial),this.owner}save(){return this.set(this.get())}isInitial(){return this.collect(),this.current===this.initial}raw(){return this.current}}},73662:(t,e,n)=>{"use strict";n.d(e,{D:()=>r});var o=n(81865);function r(t,e){return new o.h(t,e).toSignal()}},97140:(t,e,n)=>{"use strict";n.d(e,{g:()=>s});var o=n(13170),r=n(16249);function s(t,e,n){return void 0===e&&(e=o.o0),new r.V(t,e,n).toSignal()}},60771:(t,e,n)=>{"use strict";n.d(e,{T:()=>o});const o=Symbol.for("@motion-canvas/core/signals/default")},68003:(t,e,n)=>{"use strict";function o(t){return"function"==typeof t}function r(t,e){return o(t)?()=>e(t()):e(t)}function s(t){return o(t)?t():t}n.d(e,{PG:()=>o,Pj:()=>r,Wg:()=>s})},50580:(t,e,n)=>{"use strict";n.d(e,{j:()=>p});var o=n(56632),r=n(97140),s=n(75168);class p{get fixed(){return this.fixedTime}get canceled(){var t;return this.isCanceled||((null==(t=this.parent)?void 0:t.canceled)??!1)}get paused(){var t;return this.isPaused||((null==(t=this.parent)?void 0:t.paused)??!1)}constructor(t){this.runner=t,this.children=[],this.time=(0,r.g)(0),this.parent=null,this.isCanceled=!1,this.isPaused=!1,this.fixedTime=0}next(){if(this.paused)return{value:null,done:!1};(0,o.h$)(this);const t=this.runner.next(this.value);return(0,o.kw)(this),this.value=null,t}update(t){this.paused||(this.time(this.time()+t),this.fixedTime+=t),this.children=this.children.filter((t=>!t.canceled))}add(t){t.cancel(),t.parent=this,t.isCanceled=!1,t.time(this.time()),t.fixedTime=this.fixedTime,this.children.push(t),(0,s.i)(t.runner,`unknown ${this.children.length}`)}cancel(){this.isCanceled=!0,this.parent=null}pause(t){this.isPaused=t}}},80638:(t,e,n)=>{"use strict";function o(t){return t&&("object"==typeof t||"function"==typeof t)&&"toPromise"in t}function r(t){return null!==t&&"object"==typeof t&&Symbol.iterator in t&&"next"in t}n.d(e,{R:()=>r,x:()=>o})},51284:(t,e,n)=>{"use strict";n.d(e,{v:()=>p});var o=n(42075),r=n(67292),s=n(56632);function*p(t){let e=!0;for(var n=arguments.length,o=new Array(n>1?n-1:0),r=1;r<n;r++)o[r-1]=arguments[r];"boolean"==typeof t?e=t:o.push(t);const p=(0,s.nn)(),i=o.map((t=>p.children.find((e=>e.runner===t)))).filter((t=>t)),c=p.time();let a;if(e){for(;i.find((t=>!t.canceled));)yield;a=Math.max(...i.map((t=>t.time())))}else{for(;!i.find((t=>t.canceled));)yield;const t=i.filter((t=>t.canceled));a=Math.min(...t.map((t=>t.time())))}p.time(Math.max(c,a))}(0,o.G)(p,(0,r.C)())},75168:(t,e,n)=>{"use strict";function o(t,e){const n=Object.getPrototypeOf(t);n.threadable||(n.threadable=!0,n.name="string"==typeof e?e:r(e))}function r(t){return Object.getPrototypeOf(t).name??null}n.d(e,{i:()=>o,z:()=>r})},5881:(t,e,n)=>{"use strict";n.d(e,{C:()=>l,t:()=>a});var o=n(42075),r=n(67292),s=n(50580),p=n(80638),i=n(75168),c=n(97715);function a(t){return"function"==typeof(null==t?void 0:t.then)}function*l(t,e){const n=(0,c.te)(),o=t();(0,i.i)(o,"root");const r=new s.j(o);null==e||e(r);let a=[r];for(;a.length>0;){const t=[],e=[...a],o=n.framesToSeconds(1)*n.speed;for(;e.length>0;){const n=e.pop();if(!n||n.canceled)continue;const r=n.next();if(r.done)n.cancel();else if((0,p.R)(r.value)){const t=new s.j(r.value);n.value=r.value,n.add(t),e.push(n),e.push(t)}else r.value?(n.value=yield r.value,e.push(n)):(n.update(o),t.unshift(n))}a=t.filter((t=>!t.canceled)),a.length>0&&(yield)}}(0,o.G)(l,(0,r.C)())},13170:(t,e,n)=>{"use strict";n.d(e,{JC:()=>s,UI:()=>i,Vz:()=>u,a2:()=>c,o0:()=>p,uZ:()=>a,vl:()=>l});var o=n(3163),r=n(29797);function s(t,e,n){if(e.length>=t.length){const o=Math.floor(e.length*n),r=Math.floor(i(t.length-1,e.length,n));let s="";for(let n=0;n<e.length;n++)n<o?s+=e[n]:(t[n]||n<=r)&&(s+=t[n]??e[n]);return s}{const o=Math.round(t.length*(1-n)),r=Math.floor(i(t.length+1,e.length,n)),s=[];for(let n=t.length-1;n>=0;n--)n<o?s.unshift(t[n]):(e[n]||n<r)&&s.unshift(e[n]??t[n]);return s.join("")}}function p(t,e,n,r){if(void 0===r&&(r=!1),0===n)return t;if(1===n)return e;if(null!=t&&null!=e){if("number"==typeof t&&"number"==typeof e)return i(t,e,n);if("string"==typeof t&&"string"==typeof e)return s(t,e,n);if("boolean"==typeof t&&"boolean"==typeof e)return n<.5?t:e;if("lerp"in t)return t.lerp(e,n);if(t&&e&&"object"==typeof t&&"object"==typeof e)if(Array.isArray(t)&&Array.isArray(e)){if(t.length===e.length)return t.map(((t,o)=>p(t,e[o],n)))}else{let o=!1;if(t instanceof Map||e instanceof Map||(o=!0,t=new Map(Object.entries(t)),e=new Map(Object.entries(e))),t instanceof Map&&e instanceof Map){const r=new Map;for(const o of new Set([...t.keys(),...e.keys()])){const s=p(t.get(o),e.get(o),n,!0);void 0!==s&&r.set(o,s)}return o?Object.fromEntries(r):r}}return e}r||(0,o.wL)().warn(`Attempting to lerp ${t} -> ${e} may result in unexpected behavior.`)}function i(t,e,n){return t+(e-t)*n}function c(t,e,n,o,r){return n+(r-t)*(o-n)/(e-t)}function a(t,e,n){return n<t?t:n>e?e:n}function l(t,e,n,o,r){const s=c(t,e,n,o,r);return n>o&&([n,o]=[o,n]),a(n,o,s)}function u(t,e,n){let o=e;n>1?n=1/n:o=!o;const s=i(o?Math.acos(a(-1,1,1-t)):Math.asin(t),i(0,Math.PI/2,t),n);let p=Math.sin(s),c=1-Math.cos(s);return e&&([p,c]=[c,p]),new r.F(p,c)}},97074:(t,e,n)=>{"use strict";n.d(e,{BH:()=>E,Bl:()=>b,C6:()=>F,FG:()=>c,Fs:()=>i,GE:()=>P,Ge:()=>C,Ij:()=>z,J7:()=>y,Kx:()=>Z,Mg:()=>X,N1:()=>s,O$:()=>r,Q9:()=>u,SJ:()=>B,UE:()=>W,Y3:()=>f,Yw:()=>I,ad:()=>_,cv:()=>U,du:()=>N,eE:()=>G,e_:()=>D,ei:()=>x,en:()=>O,g4:()=>h,hN:()=>g,hl:()=>a,j$:()=>T,jv:()=>S,lj:()=>v,mC:()=>A,n5:()=>k,pl:()=>w,qS:()=>L,qb:()=>d,rz:()=>M,sK:()=>j,to:()=>l,vh:()=>p,w2:()=>m,zk:()=>R});var o=n(13170);function r(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,o.a2)(-1,1,e,n,Math.sin(t))}function s(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.cos(t*Math.PI/2),(0,o.UI)(e,n,t)}function p(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=Math.sin(t*Math.PI/2),(0,o.UI)(e,n,t)}function i(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=-(Math.cos(Math.PI*t)-1)/2,(0,o.UI)(e,n,t)}function c(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t,(0,o.UI)(e,n,t)}function a(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,2),(0,o.UI)(e,n,t)}function l(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2,(0,o.UI)(e,n,t)}function u(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t*t,(0,o.UI)(e,n,t)}function m(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,3),(0,o.UI)(e,n,t)}function d(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,(0,o.UI)(e,n,t)}function h(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t*t*t,(0,o.UI)(e,n,t)}function f(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,4),(0,o.UI)(e,n,t)}function y(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?8*t*t*t*t:1-Math.pow(-2*t+2,4)/2,(0,o.UI)(e,n,t)}function k(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t*t*t*t,(0,o.UI)(e,n,t)}function w(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,5),(0,o.UI)(e,n,t)}function M(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?16*t*t*t*t*t:1-Math.pow(-2*t+2,5)/2,(0,o.UI)(e,n,t)}function D(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=0===t?0:Math.pow(2,10*t-10),(0,o.UI)(e,n,t)}function _(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1===t?1:1-Math.pow(2,-10*t),(0,o.UI)(e,n,t)}function g(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=0===t?0:1===t?1:t<.5?Math.pow(2,20*t-10)/2:(2-Math.pow(2,-20*t+10))/2,(0,o.UI)(e,n,t)}function X(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.sqrt(1-Math.pow(t,2)),(0,o.UI)(e,n,t)}function x(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=Math.sqrt(1-Math.pow(t-1,2)),(0,o.UI)(e,n,t)}function C(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?(1-Math.sqrt(1-Math.pow(2*t,2)))/2:(Math.sqrt(1-Math.pow(-2*t+2,2))+1)/2,(0,o.UI)(e,n,t)}function T(t){return void 0===t&&(t=1.70158),function(e,n,r){return void 0===n&&(n=0),void 0===r&&(r=1),e=(t+1)*e*e*e-t*e*e,(0,o.UI)(n,r,e)}}function v(t){return void 0===t&&(t=1.70158),function(e,n,r){return void 0===n&&(n=0),void 0===r&&(r=1),e=1+(t+1)*Math.pow(e-1,3)+t*Math.pow(e-1,2),(0,o.UI)(n,r,e)}}function b(t,e){return void 0===t&&(t=1.70158),void 0===e&&(e=1.525),function(n,r,s){return void 0===r&&(r=0),void 0===s&&(s=1),n=n<.5?Math.pow(2*n,2)*(2*(t*e+1)*n-t*e)/2:(Math.pow(2*n-2,2)*((t*e+1)*(2*n-2)+t*e)+2)/2,(0,o.UI)(r,s,n)}}function L(t){return void 0===t&&(t=2.094395),function(e,n,r){return void 0===n&&(n=0),void 0===r&&(r=1),e=0===e?0:1===e?1:-Math.pow(2,10*e-10)*Math.sin((10*e-10.75)*t),(0,o.UI)(n,r,e)}}function Z(t){return void 0===t&&(t=2.094395),function(e,n,r){return void 0===n&&(n=0),void 0===r&&(r=1),e=0===e?0:1===e?1:Math.pow(2,-10*e)*Math.sin((10*e-.75)*t)+1,(0,o.UI)(n,r,e)}}function N(t){return void 0===t&&(t=1.39626),function(e,n,r){return void 0===n&&(n=0),void 0===r&&(r=1),e=0===e?0:1===e?1:e<.5?-Math.pow(2,20*e-10)*Math.sin((20*e-11.125)*t)/2:Math.pow(2,-20*e+10)*Math.sin((20*e-11.125)*t)/2+1,(0,o.UI)(n,r,e)}}function S(t,e){void 0===t&&(t=7.5625),void 0===e&&(e=2.75);const n=R(t,e);return function(t,e,o){return void 0===e&&(e=0),void 0===o&&(o=1),1-n(1-t,e,o)}}function R(t,e){return void 0===t&&(t=7.5625),void 0===e&&(e=2.75),function(n,r,s){return void 0===r&&(r=0),void 0===s&&(s=1),n<1/e?n*=t*n:n=n<2/e?t*(n-=1.505/e)*n+.75:n<2.5/e?t*(n-=2.25/e)*n+.9375:t*(n-=2.625/e)*n+.984375,(0,o.UI)(r,s,n)}}function z(t,e){void 0===t&&(t=7.5625),void 0===e&&(e=2.75);const n=R(t,e);return function(t,e,o){return void 0===e&&(e=0),void 0===o&&(o=1),t<.5?(1-n(1-2*t,e,o))/2:(1+n(2*t-1,e,o))/2}}function P(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,o.UI)(e,n,t)}function A(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,o.a2)(-1,1,e,n,Math.cos(t))}const I=T(),W=v(),E=b(),B=S(),F=R(),O=z(),G=L(),j=Z(),U=N()},74534:(t,e,n)=>{"use strict";n.d(e,{i:()=>p});var o=n(42075),r=n(67292),s=n(56632);function*p(t,e,n){const o=(0,s.nn)(),r=o.time(),p=o.time()+t;for(e(0,0);p>o.fixed;){const n=o.fixed-r;n>0&&e(n/t,n),yield}o.time(p),e(1,t),null==n||n(1,t)}(0,o.G)(p,(0,r.C)())},23357:(t,e,n)=>{"use strict";n.d(e,{b:()=>p});var o=n(29797),r=n(13170),s=n(46096);class p{static createSignal(t,e){return void 0===e&&(e=p.lerp),new s.N(["x","y","width","height"],(t=>new p(t)),t,e).toSignal()}static lerp(t,e,n){let s,i,c,a;return"number"==typeof n?s=i=c=a=n:n instanceof o.F?(s=c=n.x,i=a=n.y):(s=n.x,i=n.y,c=n.width,a=n.height),new p((0,r.UI)(t.x,e.x,s),(0,r.UI)(t.y,e.y,i),(0,r.UI)(t.width,e.width,c),(0,r.UI)(t.height,e.height,a))}static arcLerp(t,e,n,o,s){return void 0===o&&(o=!1),s??(s=(t.position.sub(e.position).ctg+t.size.sub(e.size).ctg)/2),p.lerp(t,e,(0,r.Vz)(n,o,s))}static fromSizeCentered(t){return new p(-t.width/2,-t.height/2,t.width,t.height)}static fromPoints(){let t=1/0,e=1/0,n=-1/0,o=-1/0;for(var r=arguments.length,s=new Array(r),i=0;i<r;i++)s[i]=arguments[i];for(const p of s)p.x>n&&(n=p.x),p.x<t&&(t=p.x),p.y>o&&(o=p.y),p.y<e&&(e=p.y);return new p(t,e,n-t,o-e)}static fromBBoxes(){let t=1/0,e=1/0,n=-1/0,o=-1/0;for(var r=arguments.length,s=new Array(r),i=0;i<r;i++)s[i]=arguments[i];for(const p of s){const r=p.x+p.width;r>n&&(n=r),p.x<t&&(t=p.x);const s=p.y+p.height;s>o&&(o=s),p.y<e&&(e=p.y)}return new p(t,e,n-t,o-e)}lerp(t,e){return p.lerp(this,t,e)}get position(){return new o.F(this.x,this.y)}set position(t){this.x=t.x,this.y=t.y}get size(){return new o.F(this.width,this.height)}get center(){return new o.F(this.x+this.width/2,this.y+this.height/2)}get left(){return this.x}set left(t){this.width+=this.x-t,this.x=t}get right(){return this.x+this.width}set right(t){this.width=t-this.x}get top(){return this.y}set top(t){this.height+=this.y-t,this.y=t}get bottom(){return this.y+this.height}set bottom(t){this.height=t-this.y}get topLeft(){return this.position}get topRight(){return new o.F(this.x+this.width,this.y)}get bottomLeft(){return new o.F(this.x,this.y+this.height)}get bottomRight(){return new o.F(this.x+this.width,this.y+this.height)}get corners(){return[this.topLeft,this.topRight,this.bottomRight,this.bottomLeft]}get pixelPerfect(){return new p(Math.floor(this.x),Math.floor(this.y),Math.ceil(this.width+1),Math.ceil(this.height+1))}constructor(t,e,n,r){if(void 0===e&&(e=0),void 0===n&&(n=0),void 0===r&&(r=0),this.x=0,this.y=0,this.width=0,this.height=0,null!=t){if("number"==typeof t)return this.x=t,this.y=e,this.width=n,void(this.height=r);if(t instanceof o.F)return this.x=t.x,this.y=t.y,void(e instanceof o.F&&(this.width=e.x,this.height=e.y));if(Array.isArray(t))return this.x=t[0],this.y=t[1],this.width=t[2],void(this.height=t[3]);this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height}}transform(t){return new p(this.position.transformAsPoint(t),this.size.transform(t))}transformCorners(t){return this.corners.map((e=>e.transformAsPoint(t)))}expand(t){return new p(this.x-t,this.y-t,this.width+2*t,this.height+2*t)}addSpacing(t){const e=new p(this);return e.left-=t.left,e.top-=t.top,e.right+=t.right,e.bottom+=t.bottom,e}includes(t){return t.x>=this.x&&t.x<=this.x+this.width&&t.y>=this.y&&t.y<=this.y+this.height}intersects(t){return this.left<t.right&&this.right>t.left&&this.top<t.bottom&&this.bottom>t.top}intersection(t){const e=new p;return this.intersects(t)&&(e.left=Math.max(this.left,t.left),e.top=Math.max(this.top,t.top),e.right=Math.min(this.right,t.right),e.bottom=Math.min(this.bottom,t.bottom)),e}toSymbol(){return p.symbol}serialize(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}p.symbol=Symbol.for("@motion-canvas/core/types/Rect")},30204:(t,e,n)=>{"use strict";n.d(e,{I:()=>o.Color});var o=n(5392),r=n(16249);o.Color.symbol=o.Color.prototype.symbol=Symbol.for("@motion-canvas/core/types/Color"),o.Color.lerp=o.Color.prototype.lerp=function(t,e,n,r){void 0===r&&(r="lch"),"string"==typeof t&&(t=new o.Color(t)),"string"==typeof e&&(e=new o.Color(e));const s=t instanceof o.Color,p=e instanceof o.Color;return s||(t=p?e.alpha(0):new o.Color("rgba(0, 0, 0, 0)")),p||(e=s?t.alpha(0):new o.Color("rgba(0, 0, 0, 0)")),(0,o.mix)(t,e,n,r)},o.Color.createLerp=o.Color.prototype.createLerp=t=>(e,n,r)=>o.Color.lerp(e,n,r,t),o.Color.createSignal=function(t,e){return void 0===e&&(e=o.Color.lerp),new r.V(t,e,void 0,(t=>new o.Color(t))).toSignal()},o.Color.prototype.toSymbol=()=>o.Color.symbol,o.Color.prototype.serialize=function(){return this.css()},o.Color.prototype.lerp=function(t,e,n){return o.Color.lerp(this,t,e,n)}},74741:(t,e,n)=>{"use strict";n.d(e,{$:()=>r,X:()=>s});var o=n(29797);function r(t,e){return o.F.fromDegrees(t).transform(e).degrees}function s(t,e){return o.F.magnitude(e.m11,e.m12)*t}},98378:(t,e,n)=>{"use strict";n.d(e,{M5:()=>o,Nm:()=>r,WS:()=>c,aP:()=>s,lk:()=>i});var o,r,s,p=n(29797);function i(t,e){return void 0===e&&(e=o.Horizontal|o.Vertical),e&o.Vertical&&(t&r.Top?t=t&~r.Top|r.Bottom:t&r.Bottom&&(t=t&~r.Bottom|r.Top)),e&o.Horizontal&&(t&r.Left?t=t&~r.Left|r.Right:t&r.Right&&(t=t&~r.Right|r.Left)),t}function c(t){if(t===s.Middle)return p.F.zero;let e=0;t&r.Left?e=-1:t&r.Right&&(e=1);let n=0;return t&r.Top?n=-1:t&r.Bottom&&(n=1),new p.F(e,n)}!function(t){t[t.Vertical=1]="Vertical",t[t.Horizontal=2]="Horizontal"}(o||(o={})),function(t){t[t.Top=4]="Top",t[t.Bottom=8]="Bottom",t[t.Left=16]="Left",t[t.Right=32]="Right"}(r||(r={})),function(t){t[t.Middle=3]="Middle",t[t.Top=5]="Top",t[t.Bottom=9]="Bottom",t[t.Left=18]="Left",t[t.Right=34]="Right",t[t.TopLeft=20]="TopLeft",t[t.TopRight=36]="TopRight",t[t.BottomLeft=24]="BottomLeft",t[t.BottomRight=40]="BottomRight"}(s||(s={}))},43188:(t,e,n)=>{"use strict";n.d(e,{K:()=>s});var o=n(13170),r=n(46096);class s{static createSignal(t,e){return void 0===e&&(e=s.lerp),new r.N(["top","right","bottom","left"],(t=>new s(t)),t,e).toSignal()}static lerp(t,e,n){return new s((0,o.UI)(t.top,e.top,n),(0,o.UI)(t.right,e.right,n),(0,o.UI)(t.bottom,e.bottom,n),(0,o.UI)(t.left,e.left,n))}get x(){return this.left+this.right}get y(){return this.top+this.bottom}constructor(t,e,n,o){if(void 0===t&&(t=0),this.top=0,this.right=0,this.bottom=0,this.left=0,null!=t){if(Array.isArray(t)&&(o=t[3],n=t[2],e=t[1],t=t[0]),"number"==typeof t)return this.top=t,this.right=void 0!==e?e:t,this.bottom=void 0!==n?n:t,void(this.left=void 0!==o?o:void 0!==e?e:t);this.top=t.top,this.right=t.right,this.bottom=t.bottom,this.left=t.left}}lerp(t,e){return s.lerp(this,t,e)}scale(t){return new s(this.top*t,this.right*t,this.bottom*t,this.left*t)}addScalar(t){return new s(this.top+t,this.right+t,this.bottom+t,this.left+t)}toSymbol(){return s.symbol}serialize(){return{top:this.top,right:this.right,bottom:this.bottom,left:this.left}}}s.symbol=Symbol.for("@motion-canvas/core/types/Spacing")},57292:(t,e,n)=>{"use strict";n.d(e,{I:()=>o,P:()=>r});const o=1e-6;function r(t){return t&&"object"==typeof t&&"toSymbol"in t}},29797:(t,e,n)=>{"use strict";n.d(e,{F:()=>c});var o=n(13170),r=n(98378),s=n(57292),p=n(46096),i=n(48733);class c{static createSignal(t,e,n){return void 0===e&&(e=c.lerp),new p.N(["x","y"],(t=>new c(t)),t,e,n).toSignal()}static lerp(t,e,n){let r,s;return"number"==typeof n?r=s=n:(r=n.x,s=n.y),new c((0,o.UI)(t.x,e.x,r),(0,o.UI)(t.y,e.y,s))}static arcLerp(t,e,n,r,s){return void 0===r&&(r=!1),s??(s=t.sub(e).ctg),c.lerp(t,e,(0,o.Vz)(n,r,s))}static createArcLerp(t,e){return(n,o,r)=>c.arcLerp(n,o,r,t,e)}static fromOrigin(t){const e=new c;return t===r.aP.Middle||(t&r.Nm.Left?e.x=-1:t&r.Nm.Right&&(e.x=1),t&r.Nm.Top?e.y=-1:t&r.Nm.Bottom&&(e.y=1)),e}static fromScalar(t){return new c(t,t)}static fromRadians(t){return new c(Math.cos(t),Math.sin(t))}static fromDegrees(t){return c.fromRadians(t*i.q)}static radians(t,e){return Math.atan2(e,t)}static degrees(t,e){return c.radians(t,e)*i.I}static magnitude(t,e){return Math.sqrt(t*t+e*e)}static squaredMagnitude(t,e){return t*t+e*e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}get magnitude(){return c.magnitude(this.x,this.y)}get squaredMagnitude(){return c.squaredMagnitude(this.x,this.y)}get normalized(){return this.scale(1/c.magnitude(this.x,this.y))}get safe(){return new c(isNaN(this.x)?0:this.x,isNaN(this.y)?0:this.y)}get flipped(){return new c(-this.x,-this.y)}get floored(){return new c(Math.floor(this.x),Math.floor(this.y))}get perpendicular(){return new c(this.y,-this.x)}get radians(){return c.radians(this.x,this.y)}get degrees(){return c.degrees(this.x,this.y)}get ctg(){return this.x/this.y}constructor(t,e){if(this.x=0,this.y=0,null!=t){if("object"!=typeof t)return this.x=t,void(this.y=e??t);if(Array.isArray(t))return this.x=t[0],void(this.y=t[1]);if("width"in t)return this.x=t.width,void(this.y=t.height);this.x=t.x,this.y=t.y}}lerp(t,e){return c.lerp(this,t,e)}getOriginOffset(t){const e=c.fromOrigin(t);return e.x*=this.x/2,e.y*=this.y/2,e}scale(t){return new c(this.x*t,this.y*t)}transformAsPoint(t){return new c(this.x*t.m11+this.y*t.m21+t.m41,this.x*t.m12+this.y*t.m22+t.m42)}transform(t){return new c(this.x*t.m11+this.y*t.m21,this.x*t.m12+this.y*t.m22)}mul(t){const e=new c(t);return new c(this.x*e.x,this.y*e.y)}div(t){const e=new c(t);return new c(this.x/e.x,this.y/e.y)}add(t){const e=new c(t);return new c(this.x+e.x,this.y+e.y)}sub(t){const e=new c(t);return new c(this.x-e.x,this.y-e.y)}dot(t){const e=new c(t);return this.x*e.x+this.y*e.y}mod(t){const e=new c(t);return new c(this.x%e.x,this.y%e.y)}addX(t){return new c(this.x+t,this.y)}addY(t){return new c(this.x,this.y+t)}toSymbol(){return c.symbol}serialize(){return{x:this.x,y:this.y}}exactlyEquals(t){return this.x===t.x&&this.y===t.y}equals(t,e){return void 0===e&&(e=s.I),Math.abs(this.x-t.x)<=e+Number.EPSILON&&Math.abs(this.y-t.y)<=e+Number.EPSILON}}c.symbol=Symbol.for("@motion-canvas/core/types/Vector2"),c.zero=new c,c.one=new c(1,1),c.right=new c(1,0),c.left=new c(-1,0),c.up=new c(0,1),c.down=new c(0,-1)},49111:(t,e,n)=>{"use strict";n.d(e,{t:()=>o});class o extends Error{constructor(t,e){super(t),this.remarks=e}}},15649:(t,e,n)=>{"use strict";n.d(e,{L:()=>o});class o{constructor(){this.resolveCurrent=null,this.current=null}async acquire(){for(;this.current;)await this.current;this.current=new Promise((t=>{this.resolveCurrent=t}))}release(){var t;this.current=null,null==(t=this.resolveCurrent)||t.call(this),this.resolveCurrent=null}}},15688:(t,e,n)=>{"use strict";function o(t){return t[0].toUpperCase()+t.slice(1)}n.d(e,{k:()=>o})},90031:(t,e,n)=>{"use strict";function o(t){return{message:t.message,stack:t.stack,remarks:t.remarks}}n.d(e,{d:()=>o})},1119:(t,e,n)=>{"use strict";function o(t,e){void 0===e&&(e=document.createElement("canvas"));const n=e.getContext("2d",t);if(!n)throw new Error("Could not create a 2D context.");return n}n.d(e,{f:()=>o})},48733:(t,e,n)=>{"use strict";n.d(e,{I:()=>o,q:()=>r});const o=180/Math.PI,r=Math.PI/180},37762:(t,e,n)=>{"use strict";function o(t,e,n){let o=0,r=t;void 0!==e&&(o=t,r=e),n=void 0===n?o<r?1:-1:n;const s=[];let p=Math.max(Math.ceil((r-o)/n),0),i=0;for(;p--;)s[i++]=o,o+=n;return s}n.d(e,{w:()=>o})},30092:(t,e,n)=>{"use strict";n.d(e,{Y:()=>s});var o=n(3163),r=n(56632);function s(t){const e=(0,o.$r)(),n=(0,r.nn)();return e.timeEvents.register(t,n.time())}},97715:(t,e,n)=>{"use strict";n.d(e,{Mh:()=>p,te:()=>r,wA:()=>s});const o=[];function r(){const t=o.at(-1);if(!t)throw new Error("The playback is not available in the current context.");return t}function s(t){o.push(t)}function p(t){if(o.pop()!==t)throw new Error("startPlayback/endPlayback were called out of order.")}},3163:(t,e,n)=>{"use strict";n.d(e,{$r:()=>r,DO:()=>s,ug:()=>p,vl:()=>c,wL:()=>i});const o=[];function r(){const t=o.at(-1);if(!t)throw new Error("The scene is not available in the current context.");return t}function s(t){o.push(t)}function p(t){if(o.pop()!==t)throw new Error("startScene/endScene were called out of order.")}function i(){var t;return(null==(t=o.at(-1))?void 0:t.logger)??console}function c(){r().enterCanTransitionOut()}},56632:(t,e,n)=>{"use strict";n.d(e,{h$:()=>p,kw:()=>i,nn:()=>s});var o=n(49111);const r=[];function s(){const t=r.at(-1);if(!t)throw new o.t("The thread is not available in the current context.","<p><code>useThread()</code> can only be called from within generator functions.\n      It&#39;s not available during rendering.</p>\n");return t}function p(t){r.push(t)}function i(t){if(r.pop()!==t)throw new Error("startThread/endThread was called out of order.")}},69573:(t,e,n)=>{"use strict";n.d(e,{Z:()=>r});var o=n(2784);function r(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"}))}},10700:(t,e,n)=>{"use strict";n.d(e,{Z:()=>r});var o=n(2784);function r(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M3 15h8v-2H3v2zm0 4h8v-2H3v2zm0-8h8V9H3v2zm0-6v2h8V5H3zm10 0h8v14h-8V5z"}))}},48015:(t,e,n)=>{"use strict";n.d(e,{Z:()=>r});var o=n(2784);function r(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z"}))}},64415:(t,e,n)=>{"use strict";n.r(e),n.d(e,{default:()=>h});var o=n(2784),r=n(42104),s=n(49072),p=n(76183),i=n(31930),c=n(88617),a=n(80068),l=n(57708),u=n(70532),m=n(37390),d=n(89741);function h(t){var e,n,h;let{route:f}=t;const y=(0,c.RU)(f.projectId),k=y[f.reflectionId],[w]=(0,l.mN)(),M=(0,d.Z)(),D=(0,o.useMemo)((()=>{const t=[];if(!k.groups||k.kind===m.W.Project)return t;for(const e of k.groups)if(t.push({value:e.title,id:e.title,level:2}),e.children)for(const n of e.children){const e=y[n];!e||e.hasOwnPage||M&&!(0,l.It)(w,e)||t.push({value:`<code>${e.name}</code>`,id:e.anchor,level:3})}return t}),[w,k,M]);return o.createElement(p.b,{content:{frontMatter:{},metadata:{id:k.docId,unversionedId:k.docId,version:"current",title:k.name,description:null==(e=k.comment)?void 0:e.summaryText,slug:k.url,permalink:k.url,editUrl:(null==(n=k.sources)||null==(h=n[0])?void 0:h.url)??void 0,draft:!1,tags:[],frontMatter:{},next:k.next,previous:k.previous},toc:D,assets:{}}},o.createElement(a.Y0,null,o.createElement(r.Z,null),o.createElement(u.Z,null,o.createElement(s.Z,null,o.createElement(i.Z,{reflection:k})))))}},30956:(t,e,n)=>{"use strict";n.d(e,{Z:()=>CXe});var o={};n.r(o),n.d(o,{content_0_0:()=>c,content_0_10:()=>w,content_0_100:()=>te,content_0_1000:()=>Ek,content_0_1002:()=>Fk,content_0_1004:()=>Gk,content_0_1006:()=>Uk,content_0_1008:()=>Vk,content_0_1010:()=>$k,content_0_1012:()=>Jk,content_0_1014:()=>Kk,content_0_1016:()=>ew,content_0_1018:()=>ow,content_0_102:()=>ne,content_0_1020:()=>sw,content_0_1022:()=>iw,content_0_1024:()=>aw,content_0_1026:()=>uw,content_0_1028:()=>dw,content_0_1030:()=>fw,content_0_1032:()=>kw,content_0_1034:()=>Mw,content_0_1036:()=>_w,content_0_1038:()=>Xw,content_0_104:()=>re,content_0_1040:()=>Cw,content_0_1042:()=>vw,content_0_1044:()=>Lw,content_0_1046:()=>Nw,content_0_1048:()=>Rw,content_0_1050:()=>Pw,content_0_1052:()=>Iw,content_0_1054:()=>Ew,content_0_1056:()=>Fw,content_0_1058:()=>Gw,content_0_106:()=>pe,content_0_1060:()=>Uw,content_0_1062:()=>Vw,content_0_1064:()=>$w,content_0_1066:()=>Jw,content_0_1068:()=>Kw,content_0_1070:()=>eM,content_0_1072:()=>oM,content_0_1074:()=>sM,content_0_1076:()=>iM,content_0_1078:()=>aM,content_0_108:()=>ce,content_0_1080:()=>uM,content_0_1082:()=>dM,content_0_1084:()=>fM,content_0_1086:()=>kM,content_0_1088:()=>MM,content_0_1090:()=>_M,content_0_1092:()=>XM,content_0_1094:()=>CM,content_0_1096:()=>vM,content_0_1098:()=>LM,content_0_110:()=>le,content_0_1100:()=>NM,content_0_1102:()=>RM,content_0_1104:()=>PM,content_0_1106:()=>IM,content_0_1108:()=>EM,content_0_1110:()=>FM,content_0_1112:()=>GM,content_0_1114:()=>UM,content_0_1116:()=>VM,content_0_112:()=>me,content_0_114:()=>he,content_0_116:()=>ye,content_0_118:()=>we,content_0_12:()=>D,content_0_120:()=>De,content_0_122:()=>ge,content_0_124:()=>xe,content_0_126:()=>Te,content_0_128:()=>be,content_0_130:()=>Ze,content_0_132:()=>Se,content_0_134:()=>ze,content_0_136:()=>Ae,content_0_138:()=>We,content_0_14:()=>g,content_0_140:()=>Be,content_0_142:()=>Oe,content_0_144:()=>je,content_0_146:()=>qe,content_0_148:()=>He,content_0_150:()=>Qe,content_0_152:()=>Ye,content_0_154:()=>tn,content_0_156:()=>nn,content_0_158:()=>rn,content_0_16:()=>x,content_0_160:()=>pn,content_0_162:()=>an,content_0_164:()=>un,content_0_166:()=>dn,content_0_168:()=>fn,content_0_170:()=>kn,content_0_172:()=>Mn,content_0_174:()=>_n,content_0_176:()=>Xn,content_0_178:()=>Cn,content_0_18:()=>T,content_0_180:()=>vn,content_0_182:()=>Ln,content_0_184:()=>Nn,content_0_186:()=>Rn,content_0_188:()=>Pn,content_0_190:()=>In,content_0_192:()=>En,content_0_194:()=>Fn,content_0_196:()=>Gn,content_0_198:()=>Un,content_0_2:()=>l,content_0_20:()=>b,content_0_200:()=>Vn,content_0_202:()=>$n,content_0_204:()=>Jn,content_0_206:()=>Kn,content_0_208:()=>eo,content_0_210:()=>oo,content_0_212:()=>so,content_0_214:()=>io,content_0_216:()=>ao,content_0_218:()=>uo,content_0_22:()=>Z,content_0_220:()=>ho,content_0_222:()=>yo,content_0_224:()=>wo,content_0_226:()=>Do,content_0_228:()=>go,content_0_230:()=>xo,content_0_232:()=>To,content_0_234:()=>bo,content_0_236:()=>Zo,content_0_238:()=>So,content_0_24:()=>S,content_0_240:()=>zo,content_0_242:()=>Ao,content_0_244:()=>Wo,content_0_246:()=>Bo,content_0_248:()=>Oo,content_0_250:()=>jo,content_0_252:()=>qo,content_0_254:()=>Ho,content_0_256:()=>Qo,content_0_258:()=>Yo,content_0_26:()=>z,content_0_260:()=>tr,content_0_262:()=>nr,content_0_264:()=>rr,content_0_266:()=>pr,content_0_268:()=>cr,content_0_270:()=>lr,content_0_272:()=>mr,content_0_274:()=>hr,content_0_276:()=>yr,content_0_278:()=>wr,content_0_28:()=>A,content_0_280:()=>Dr,content_0_282:()=>gr,content_0_284:()=>xr,content_0_286:()=>Tr,content_0_288:()=>br,content_0_290:()=>Zr,content_0_292:()=>Sr,content_0_294:()=>zr,content_0_296:()=>Ar,content_0_298:()=>Wr,content_0_30:()=>W,content_0_300:()=>Br,content_0_302:()=>Or,content_0_304:()=>jr,content_0_306:()=>qr,content_0_308:()=>Hr,content_0_310:()=>Qr,content_0_312:()=>Yr,content_0_314:()=>ts,content_0_316:()=>ns,content_0_318:()=>rs,content_0_32:()=>B,content_0_320:()=>ps,content_0_322:()=>cs,content_0_324:()=>ls,content_0_326:()=>ms,content_0_328:()=>hs,content_0_330:()=>ys,content_0_332:()=>ws,content_0_334:()=>Ds,content_0_336:()=>gs,content_0_338:()=>xs,content_0_34:()=>O,content_0_340:()=>Ts,content_0_342:()=>bs,content_0_344:()=>Zs,content_0_346:()=>Ss,content_0_348:()=>zs,content_0_350:()=>As,content_0_352:()=>Ws,content_0_354:()=>Bs,content_0_356:()=>Os,content_0_358:()=>js,content_0_36:()=>j,content_0_360:()=>qs,content_0_362:()=>Hs,content_0_364:()=>Qs,content_0_366:()=>Ys,content_0_368:()=>tp,content_0_370:()=>np,content_0_372:()=>rp,content_0_374:()=>pp,content_0_376:()=>cp,content_0_378:()=>lp,content_0_38:()=>q,content_0_380:()=>mp,content_0_382:()=>hp,content_0_384:()=>yp,content_0_386:()=>wp,content_0_388:()=>Dp,content_0_390:()=>gp,content_0_392:()=>xp,content_0_394:()=>Tp,content_0_396:()=>bp,content_0_398:()=>Zp,content_0_4:()=>m,content_0_40:()=>H,content_0_400:()=>Sp,content_0_402:()=>zp,content_0_404:()=>Ap,content_0_406:()=>Wp,content_0_408:()=>Bp,content_0_410:()=>Op,content_0_412:()=>jp,content_0_414:()=>qp,content_0_416:()=>Hp,content_0_418:()=>Qp,content_0_42:()=>Q,content_0_420:()=>Yp,content_0_422:()=>ti,content_0_424:()=>ni,content_0_426:()=>ri,content_0_428:()=>pi,content_0_430:()=>ci,content_0_432:()=>li,content_0_434:()=>mi,content_0_436:()=>hi,content_0_438:()=>yi,content_0_44:()=>Y,content_0_440:()=>wi,content_0_442:()=>Di,content_0_444:()=>gi,content_0_446:()=>xi,content_0_448:()=>Ti,content_0_450:()=>bi,content_0_452:()=>Zi,content_0_454:()=>Si,content_0_456:()=>zi,content_0_458:()=>Ai,content_0_46:()=>tt,content_0_460:()=>Wi,content_0_462:()=>Bi,content_0_464:()=>Oi,content_0_466:()=>ji,content_0_468:()=>qi,content_0_470:()=>Hi,content_0_472:()=>Qi,content_0_474:()=>Yi,content_0_476:()=>tc,content_0_478:()=>nc,content_0_48:()=>nt,content_0_480:()=>rc,content_0_482:()=>pc,content_0_484:()=>cc,content_0_486:()=>lc,content_0_488:()=>mc,content_0_490:()=>hc,content_0_492:()=>yc,content_0_494:()=>wc,content_0_496:()=>Dc,content_0_498:()=>gc,content_0_50:()=>rt,content_0_500:()=>xc,content_0_502:()=>Tc,content_0_504:()=>bc,content_0_506:()=>Zc,content_0_508:()=>Sc,content_0_510:()=>zc,content_0_512:()=>Ac,content_0_514:()=>Wc,content_0_516:()=>Bc,content_0_518:()=>Oc,content_0_52:()=>pt,content_0_520:()=>jc,content_0_522:()=>qc,content_0_524:()=>Hc,content_0_526:()=>Qc,content_0_528:()=>Yc,content_0_530:()=>ta,content_0_532:()=>na,content_0_534:()=>ra,content_0_536:()=>pa,content_0_538:()=>ca,content_0_54:()=>ct,content_0_540:()=>la,content_0_542:()=>ma,content_0_544:()=>ha,content_0_546:()=>ya,content_0_548:()=>wa,content_0_550:()=>Da,content_0_552:()=>ga,content_0_554:()=>xa,content_0_556:()=>Ta,content_0_558:()=>ba,content_0_56:()=>lt,content_0_560:()=>Za,content_0_562:()=>Sa,content_0_564:()=>za,content_0_566:()=>Aa,content_0_568:()=>Wa,content_0_570:()=>Ba,content_0_572:()=>Oa,content_0_574:()=>ja,content_0_576:()=>qa,content_0_578:()=>Ha,content_0_58:()=>mt,content_0_580:()=>Qa,content_0_582:()=>Ya,content_0_584:()=>tl,content_0_586:()=>nl,content_0_588:()=>rl,content_0_590:()=>pl,content_0_592:()=>cl,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>yl,content_0_602:()=>wl,content_0_604:()=>Dl,content_0_606:()=>gl,content_0_608:()=>xl,content_0_610:()=>Tl,content_0_612:()=>bl,content_0_614:()=>Zl,content_0_616:()=>Sl,content_0_618:()=>zl,content_0_62:()=>yt,content_0_620:()=>Al,content_0_622:()=>Wl,content_0_624:()=>Bl,content_0_626:()=>Ol,content_0_628:()=>jl,content_0_630:()=>ql,content_0_632:()=>Hl,content_0_634:()=>Ql,content_0_636:()=>Yl,content_0_638:()=>tu,content_0_64:()=>wt,content_0_640:()=>nu,content_0_642:()=>ru,content_0_644:()=>pu,content_0_646:()=>cu,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>yu,content_0_656:()=>wu,content_0_658:()=>Du,content_0_66:()=>Dt,content_0_660:()=>gu,content_0_662:()=>xu,content_0_664:()=>Tu,content_0_666:()=>bu,content_0_668:()=>Zu,content_0_670:()=>Su,content_0_672:()=>zu,content_0_674:()=>Au,content_0_676:()=>Wu,content_0_678:()=>Bu,content_0_68:()=>gt,content_0_680:()=>Ou,content_0_682:()=>ju,content_0_684:()=>qu,content_0_686:()=>Hu,content_0_688:()=>Qu,content_0_690:()=>Yu,content_0_692:()=>tm,content_0_694:()=>nm,content_0_696:()=>rm,content_0_698:()=>pm,content_0_70:()=>xt,content_0_700:()=>cm,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>ym,content_0_710:()=>wm,content_0_712:()=>Dm,content_0_714:()=>gm,content_0_716:()=>xm,content_0_718:()=>Tm,content_0_72:()=>Tt,content_0_720:()=>bm,content_0_722:()=>Zm,content_0_724:()=>Sm,content_0_726:()=>zm,content_0_728:()=>Am,content_0_730:()=>Wm,content_0_732:()=>Bm,content_0_734:()=>Om,content_0_736:()=>jm,content_0_738:()=>qm,content_0_74:()=>bt,content_0_740:()=>Hm,content_0_742:()=>Qm,content_0_744:()=>Ym,content_0_746:()=>td,content_0_748:()=>nd,content_0_750:()=>rd,content_0_752:()=>pd,content_0_754:()=>cd,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>Zt,content_0_760:()=>hd,content_0_762:()=>yd,content_0_764:()=>wd,content_0_766:()=>Dd,content_0_768:()=>gd,content_0_770:()=>xd,content_0_772:()=>Td,content_0_774:()=>bd,content_0_776:()=>Zd,content_0_778:()=>Sd,content_0_78:()=>St,content_0_780:()=>zd,content_0_782:()=>Ad,content_0_784:()=>Wd,content_0_786:()=>Bd,content_0_788:()=>Od,content_0_790:()=>jd,content_0_792:()=>qd,content_0_794:()=>Hd,content_0_796:()=>Qd,content_0_798:()=>Yd,content_0_8:()=>y,content_0_80:()=>zt,content_0_800:()=>th,content_0_802:()=>nh,content_0_804:()=>rh,content_0_806:()=>ph,content_0_808:()=>ch,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>yh,content_0_818:()=>wh,content_0_82:()=>At,content_0_820:()=>Dh,content_0_822:()=>gh,content_0_824:()=>xh,content_0_826:()=>Th,content_0_828:()=>bh,content_0_830:()=>Zh,content_0_832:()=>Sh,content_0_834:()=>zh,content_0_836:()=>Ah,content_0_838:()=>Wh,content_0_84:()=>Wt,content_0_840:()=>Bh,content_0_842:()=>Oh,content_0_844:()=>jh,content_0_846:()=>qh,content_0_848:()=>Hh,content_0_850:()=>Qh,content_0_852:()=>Yh,content_0_854:()=>tf,content_0_856:()=>nf,content_0_858:()=>rf,content_0_86:()=>Bt,content_0_860:()=>pf,content_0_862:()=>af,content_0_864:()=>uf,content_0_866:()=>df,content_0_868:()=>ff,content_0_870:()=>kf,content_0_872:()=>Mf,content_0_874:()=>_f,content_0_876:()=>Xf,content_0_878:()=>Cf,content_0_88:()=>Ot,content_0_880:()=>vf,content_0_882:()=>Lf,content_0_884:()=>Nf,content_0_886:()=>Rf,content_0_888:()=>Pf,content_0_890:()=>If,content_0_892:()=>Ef,content_0_894:()=>Ff,content_0_896:()=>Gf,content_0_898:()=>Uf,content_0_90:()=>jt,content_0_900:()=>Vf,content_0_902:()=>$f,content_0_904:()=>Jf,content_0_906:()=>Kf,content_0_908:()=>ey,content_0_910:()=>oy,content_0_912:()=>sy,content_0_914:()=>iy,content_0_916:()=>ay,content_0_918:()=>uy,content_0_92:()=>qt,content_0_920:()=>dy,content_0_922:()=>fy,content_0_924:()=>ky,content_0_926:()=>My,content_0_928:()=>_y,content_0_930:()=>Xy,content_0_932:()=>Cy,content_0_934:()=>vy,content_0_936:()=>Ly,content_0_938:()=>Ny,content_0_94:()=>Ht,content_0_940:()=>Ry,content_0_942:()=>Py,content_0_944:()=>Iy,content_0_946:()=>Ey,content_0_948:()=>Fy,content_0_950:()=>Gy,content_0_952:()=>Uy,content_0_954:()=>Vy,content_0_956:()=>$y,content_0_958:()=>Jy,content_0_96:()=>Qt,content_0_960:()=>Ky,content_0_962:()=>ek,content_0_964:()=>ok,content_0_966:()=>sk,content_0_968:()=>ik,content_0_970:()=>ak,content_0_972:()=>uk,content_0_974:()=>dk,content_0_976:()=>fk,content_0_978:()=>kk,content_0_98:()=>Yt,content_0_980:()=>Mk,content_0_982:()=>_k,content_0_984:()=>Xk,content_0_986:()=>Ck,content_0_988:()=>vk,content_0_990:()=>Lk,content_0_992:()=>Nk,content_0_994:()=>Rk,content_0_996:()=>Pk,content_0_998:()=>Ik,content_2321_0:()=>$M,content_2321_10:()=>sD,content_2321_100:()=>F_,content_2321_1000:()=>XW,content_2321_1002:()=>CW,content_2321_1004:()=>vW,content_2321_1006:()=>LW,content_2321_1008:()=>NW,content_2321_1010:()=>RW,content_2321_1012:()=>PW,content_2321_1014:()=>IW,content_2321_1016:()=>EW,content_2321_1018:()=>FW,content_2321_102:()=>G_,content_2321_1020:()=>GW,content_2321_1022:()=>UW,content_2321_1024:()=>VW,content_2321_1026:()=>$W,content_2321_1028:()=>JW,content_2321_1030:()=>KW,content_2321_1032:()=>eE,content_2321_1034:()=>oE,content_2321_1036:()=>sE,content_2321_1038:()=>iE,content_2321_104:()=>U_,content_2321_1040:()=>aE,content_2321_1042:()=>uE,content_2321_1044:()=>dE,content_2321_1046:()=>fE,content_2321_1048:()=>kE,content_2321_1050:()=>ME,content_2321_1052:()=>_E,content_2321_1054:()=>XE,content_2321_1056:()=>CE,content_2321_1058:()=>vE,content_2321_106:()=>V_,content_2321_1060:()=>LE,content_2321_1062:()=>NE,content_2321_1064:()=>RE,content_2321_1066:()=>PE,content_2321_1068:()=>IE,content_2321_1070:()=>EE,content_2321_1072:()=>FE,content_2321_1074:()=>GE,content_2321_1076:()=>UE,content_2321_1078:()=>VE,content_2321_108:()=>$_,content_2321_1080:()=>$E,content_2321_1082:()=>JE,content_2321_1084:()=>KE,content_2321_1086:()=>eB,content_2321_1088:()=>oB,content_2321_1090:()=>sB,content_2321_1092:()=>iB,content_2321_1094:()=>aB,content_2321_1096:()=>uB,content_2321_1098:()=>dB,content_2321_110:()=>J_,content_2321_1100:()=>fB,content_2321_1102:()=>kB,content_2321_1104:()=>MB,content_2321_1106:()=>_B,content_2321_1108:()=>XB,content_2321_1110:()=>CB,content_2321_1112:()=>vB,content_2321_1114:()=>LB,content_2321_1116:()=>NB,content_2321_1118:()=>RB,content_2321_112:()=>K_,content_2321_1120:()=>PB,content_2321_1122:()=>IB,content_2321_1124:()=>EB,content_2321_1126:()=>FB,content_2321_1128:()=>GB,content_2321_1130:()=>UB,content_2321_1132:()=>VB,content_2321_1134:()=>$B,content_2321_1136:()=>JB,content_2321_1138:()=>KB,content_2321_114:()=>eg,content_2321_1140:()=>eF,content_2321_1142:()=>oF,content_2321_1144:()=>sF,content_2321_1146:()=>iF,content_2321_1148:()=>aF,content_2321_1150:()=>uF,content_2321_1152:()=>dF,content_2321_1154:()=>fF,content_2321_1156:()=>kF,content_2321_1158:()=>MF,content_2321_116:()=>og,content_2321_1160:()=>_F,content_2321_1162:()=>XF,content_2321_1164:()=>CF,content_2321_1166:()=>vF,content_2321_1168:()=>LF,content_2321_1170:()=>NF,content_2321_1172:()=>RF,content_2321_1174:()=>PF,content_2321_1176:()=>IF,content_2321_1178:()=>EF,content_2321_118:()=>sg,content_2321_1180:()=>FF,content_2321_1182:()=>GF,content_2321_1184:()=>UF,content_2321_1186:()=>VF,content_2321_1188:()=>$F,content_2321_1190:()=>JF,content_2321_1192:()=>KF,content_2321_1194:()=>eO,content_2321_1196:()=>oO,content_2321_1198:()=>sO,content_2321_12:()=>iD,content_2321_120:()=>ig,content_2321_1200:()=>iO,content_2321_1202:()=>aO,content_2321_1204:()=>uO,content_2321_1206:()=>dO,content_2321_1208:()=>fO,content_2321_1210:()=>kO,content_2321_1212:()=>MO,content_2321_1214:()=>_O,content_2321_1216:()=>XO,content_2321_1218:()=>CO,content_2321_122:()=>ag,content_2321_1220:()=>vO,content_2321_1222:()=>LO,content_2321_1224:()=>NO,content_2321_1226:()=>RO,content_2321_1228:()=>PO,content_2321_1230:()=>IO,content_2321_1232:()=>EO,content_2321_1234:()=>FO,content_2321_1236:()=>GO,content_2321_1238:()=>UO,content_2321_124:()=>ug,content_2321_1240:()=>VO,content_2321_1242:()=>$O,content_2321_1244:()=>JO,content_2321_1246:()=>KO,content_2321_1248:()=>eG,content_2321_1250:()=>oG,content_2321_1252:()=>sG,content_2321_1254:()=>iG,content_2321_1256:()=>aG,content_2321_1258:()=>uG,content_2321_126:()=>dg,content_2321_1260:()=>dG,content_2321_1262:()=>fG,content_2321_1264:()=>kG,content_2321_1266:()=>MG,content_2321_1268:()=>_G,content_2321_1270:()=>XG,content_2321_1272:()=>CG,content_2321_1274:()=>vG,content_2321_1276:()=>LG,content_2321_1278:()=>NG,content_2321_128:()=>fg,content_2321_1280:()=>RG,content_2321_1282:()=>PG,content_2321_1284:()=>IG,content_2321_1286:()=>EG,content_2321_1288:()=>FG,content_2321_1290:()=>GG,content_2321_1292:()=>UG,content_2321_1294:()=>VG,content_2321_1296:()=>$G,content_2321_1298:()=>JG,content_2321_130:()=>kg,content_2321_1300:()=>KG,content_2321_1302:()=>ej,content_2321_1304:()=>oj,content_2321_1306:()=>sj,content_2321_1308:()=>ij,content_2321_1310:()=>aj,content_2321_1312:()=>uj,content_2321_1314:()=>dj,content_2321_1316:()=>fj,content_2321_1318:()=>kj,content_2321_132:()=>Mg,content_2321_1320:()=>Mj,content_2321_1322:()=>_j,content_2321_1324:()=>Xj,content_2321_1326:()=>Cj,content_2321_1328:()=>vj,content_2321_1330:()=>Lj,content_2321_1332:()=>Nj,content_2321_1334:()=>Rj,content_2321_1336:()=>Pj,content_2321_1338:()=>Ij,content_2321_134:()=>_g,content_2321_1340:()=>Ej,content_2321_1342:()=>Fj,content_2321_1344:()=>Gj,content_2321_1346:()=>Uj,content_2321_1348:()=>Vj,content_2321_1350:()=>$j,content_2321_1352:()=>Jj,content_2321_1354:()=>Kj,content_2321_1356:()=>eU,content_2321_1358:()=>oU,content_2321_136:()=>Xg,content_2321_1360:()=>sU,content_2321_1362:()=>iU,content_2321_1364:()=>aU,content_2321_1366:()=>uU,content_2321_1368:()=>dU,content_2321_1370:()=>fU,content_2321_1372:()=>kU,content_2321_1374:()=>MU,content_2321_1376:()=>_U,content_2321_1378:()=>XU,content_2321_138:()=>Cg,content_2321_1380:()=>CU,content_2321_1382:()=>vU,content_2321_1384:()=>LU,content_2321_1386:()=>NU,content_2321_1388:()=>RU,content_2321_1390:()=>PU,content_2321_1392:()=>IU,content_2321_1394:()=>EU,content_2321_1396:()=>FU,content_2321_1398:()=>GU,content_2321_14:()=>aD,content_2321_140:()=>vg,content_2321_1400:()=>UU,content_2321_1402:()=>VU,content_2321_1404:()=>$U,content_2321_1406:()=>JU,content_2321_1408:()=>KU,content_2321_1410:()=>eq,content_2321_1412:()=>oq,content_2321_1414:()=>sq,content_2321_1416:()=>iq,content_2321_1418:()=>aq,content_2321_142:()=>Lg,content_2321_1420:()=>uq,content_2321_1422:()=>dq,content_2321_1424:()=>fq,content_2321_1426:()=>kq,content_2321_1428:()=>Mq,content_2321_1430:()=>_q,content_2321_1432:()=>Xq,content_2321_1434:()=>Cq,content_2321_1436:()=>vq,content_2321_1438:()=>Lq,content_2321_144:()=>Ng,content_2321_1440:()=>Nq,content_2321_1442:()=>Rq,content_2321_1444:()=>Pq,content_2321_1446:()=>Iq,content_2321_1448:()=>Eq,content_2321_1450:()=>Fq,content_2321_1452:()=>Gq,content_2321_1454:()=>Uq,content_2321_1456:()=>Vq,content_2321_1458:()=>$q,content_2321_146:()=>Rg,content_2321_1460:()=>Jq,content_2321_1462:()=>Kq,content_2321_1464:()=>eV,content_2321_1466:()=>oV,content_2321_1468:()=>sV,content_2321_1470:()=>iV,content_2321_1472:()=>aV,content_2321_1474:()=>uV,content_2321_1476:()=>dV,content_2321_1478:()=>fV,content_2321_148:()=>Pg,content_2321_1480:()=>kV,content_2321_1482:()=>MV,content_2321_1484:()=>_V,content_2321_1486:()=>XV,content_2321_1488:()=>CV,content_2321_1490:()=>vV,content_2321_1492:()=>LV,content_2321_1494:()=>NV,content_2321_1496:()=>RV,content_2321_1498:()=>PV,content_2321_150:()=>Ig,content_2321_1500:()=>IV,content_2321_1502:()=>EV,content_2321_1504:()=>FV,content_2321_1506:()=>GV,content_2321_1508:()=>UV,content_2321_1510:()=>VV,content_2321_1512:()=>$V,content_2321_1514:()=>JV,content_2321_1516:()=>KV,content_2321_1518:()=>eH,content_2321_152:()=>Eg,content_2321_1520:()=>oH,content_2321_1522:()=>sH,content_2321_1524:()=>iH,content_2321_1526:()=>aH,content_2321_1528:()=>uH,content_2321_1530:()=>dH,content_2321_1532:()=>fH,content_2321_1534:()=>kH,content_2321_1536:()=>MH,content_2321_1538:()=>_H,content_2321_154:()=>Fg,content_2321_1540:()=>XH,content_2321_1542:()=>CH,content_2321_1544:()=>vH,content_2321_1546:()=>LH,content_2321_1548:()=>NH,content_2321_1550:()=>RH,content_2321_1552:()=>PH,content_2321_1554:()=>IH,content_2321_1556:()=>EH,content_2321_1558:()=>FH,content_2321_156:()=>Gg,content_2321_1560:()=>GH,content_2321_1562:()=>UH,content_2321_1564:()=>VH,content_2321_1566:()=>$H,content_2321_1568:()=>JH,content_2321_1570:()=>KH,content_2321_1572:()=>e$,content_2321_1574:()=>o$,content_2321_1576:()=>s$,content_2321_1578:()=>i$,content_2321_158:()=>Ug,content_2321_1580:()=>a$,content_2321_1582:()=>u$,content_2321_1584:()=>d$,content_2321_1586:()=>f$,content_2321_1588:()=>k$,content_2321_1590:()=>M$,content_2321_1592:()=>_$,content_2321_1594:()=>X$,content_2321_1596:()=>C$,content_2321_1598:()=>v$,content_2321_16:()=>uD,content_2321_160:()=>Vg,content_2321_1600:()=>L$,content_2321_1602:()=>N$,content_2321_1604:()=>R$,content_2321_1606:()=>P$,content_2321_1608:()=>I$,content_2321_1610:()=>E$,content_2321_1612:()=>F$,content_2321_1614:()=>G$,content_2321_1616:()=>U$,content_2321_1618:()=>V$,content_2321_162:()=>$g,content_2321_1620:()=>$$,content_2321_1622:()=>J$,content_2321_1624:()=>K$,content_2321_1626:()=>eQ,content_2321_1628:()=>oQ,content_2321_1630:()=>sQ,content_2321_1632:()=>iQ,content_2321_1634:()=>aQ,content_2321_1636:()=>uQ,content_2321_1638:()=>dQ,content_2321_164:()=>Jg,content_2321_1640:()=>fQ,content_2321_1642:()=>kQ,content_2321_1644:()=>MQ,content_2321_1646:()=>_Q,content_2321_1648:()=>XQ,content_2321_1650:()=>CQ,content_2321_1652:()=>vQ,content_2321_1654:()=>LQ,content_2321_1656:()=>NQ,content_2321_1658:()=>RQ,content_2321_166:()=>Kg,content_2321_1660:()=>PQ,content_2321_1662:()=>IQ,content_2321_1664:()=>EQ,content_2321_1666:()=>FQ,content_2321_1668:()=>GQ,content_2321_1670:()=>UQ,content_2321_1672:()=>VQ,content_2321_1674:()=>$Q,content_2321_1676:()=>JQ,content_2321_1678:()=>KQ,content_2321_168:()=>eX,content_2321_1680:()=>eJ,content_2321_1682:()=>oJ,content_2321_1684:()=>sJ,content_2321_1686:()=>iJ,content_2321_1688:()=>aJ,content_2321_1690:()=>uJ,content_2321_1692:()=>dJ,content_2321_1694:()=>fJ,content_2321_1696:()=>kJ,content_2321_1698:()=>MJ,content_2321_170:()=>oX,content_2321_1700:()=>_J,content_2321_1702:()=>XJ,content_2321_1704:()=>CJ,content_2321_1706:()=>vJ,content_2321_1708:()=>LJ,content_2321_1710:()=>NJ,content_2321_1712:()=>RJ,content_2321_1714:()=>PJ,content_2321_1716:()=>IJ,content_2321_1718:()=>EJ,content_2321_172:()=>sX,content_2321_1720:()=>FJ,content_2321_1722:()=>GJ,content_2321_1724:()=>UJ,content_2321_1726:()=>VJ,content_2321_1728:()=>$J,content_2321_1730:()=>JJ,content_2321_1732:()=>KJ,content_2321_1734:()=>eY,content_2321_1736:()=>oY,content_2321_1738:()=>sY,content_2321_174:()=>iX,content_2321_1740:()=>iY,content_2321_1742:()=>aY,content_2321_1744:()=>uY,content_2321_1746:()=>dY,content_2321_1748:()=>fY,content_2321_1750:()=>kY,content_2321_1752:()=>MY,content_2321_1754:()=>_Y,content_2321_1756:()=>XY,content_2321_1758:()=>CY,content_2321_176:()=>aX,content_2321_1760:()=>vY,content_2321_1762:()=>LY,content_2321_1764:()=>NY,content_2321_1766:()=>RY,content_2321_1768:()=>PY,content_2321_1770:()=>IY,content_2321_1772:()=>EY,content_2321_1774:()=>FY,content_2321_1776:()=>GY,content_2321_1778:()=>UY,content_2321_178:()=>uX,content_2321_1780:()=>VY,content_2321_1782:()=>$Y,content_2321_1784:()=>JY,content_2321_1786:()=>KY,content_2321_1788:()=>eK,content_2321_1790:()=>oK,content_2321_1792:()=>sK,content_2321_1794:()=>iK,content_2321_1796:()=>aK,content_2321_1798:()=>uK,content_2321_18:()=>dD,content_2321_180:()=>dX,content_2321_1800:()=>dK,content_2321_1802:()=>fK,content_2321_1804:()=>kK,content_2321_1806:()=>MK,content_2321_1808:()=>_K,content_2321_1810:()=>XK,content_2321_1812:()=>CK,content_2321_1814:()=>vK,content_2321_1816:()=>LK,content_2321_1818:()=>NK,content_2321_182:()=>fX,content_2321_1820:()=>RK,content_2321_1822:()=>PK,content_2321_1824:()=>IK,content_2321_1826:()=>EK,content_2321_1828:()=>FK,content_2321_1830:()=>GK,content_2321_1832:()=>UK,content_2321_1834:()=>VK,content_2321_1836:()=>$K,content_2321_1838:()=>JK,content_2321_184:()=>kX,content_2321_1840:()=>KK,content_2321_1842:()=>e0,content_2321_1844:()=>o0,content_2321_1846:()=>s0,content_2321_1848:()=>i0,content_2321_1850:()=>a0,content_2321_1852:()=>u0,content_2321_1854:()=>d0,content_2321_1856:()=>f0,content_2321_1858:()=>k0,content_2321_186:()=>MX,content_2321_1860:()=>M0,content_2321_1862:()=>_0,content_2321_1864:()=>X0,content_2321_1866:()=>C0,content_2321_1868:()=>v0,content_2321_1870:()=>L0,content_2321_1872:()=>N0,content_2321_1874:()=>R0,content_2321_1876:()=>P0,content_2321_1878:()=>I0,content_2321_188:()=>_X,content_2321_1880:()=>E0,content_2321_1882:()=>F0,content_2321_1884:()=>G0,content_2321_1886:()=>U0,content_2321_1888:()=>V0,content_2321_1890:()=>$0,content_2321_1892:()=>J0,content_2321_1894:()=>K0,content_2321_1896:()=>e2,content_2321_1898:()=>o2,content_2321_190:()=>XX,content_2321_1900:()=>s2,content_2321_1902:()=>i2,content_2321_1904:()=>a2,content_2321_1906:()=>u2,content_2321_1908:()=>d2,content_2321_1910:()=>f2,content_2321_1912:()=>k2,content_2321_1914:()=>M2,content_2321_1916:()=>_2,content_2321_1918:()=>X2,content_2321_192:()=>CX,content_2321_1920:()=>C2,content_2321_1922:()=>v2,content_2321_1924:()=>L2,content_2321_1926:()=>N2,content_2321_1928:()=>R2,content_2321_1930:()=>P2,content_2321_1932:()=>I2,content_2321_1934:()=>E2,content_2321_1936:()=>F2,content_2321_1938:()=>G2,content_2321_194:()=>vX,content_2321_1940:()=>U2,content_2321_1942:()=>V2,content_2321_1944:()=>$2,content_2321_1946:()=>J2,content_2321_1948:()=>K2,content_2321_1950:()=>e1,content_2321_1952:()=>o1,content_2321_1954:()=>s1,content_2321_1956:()=>i1,content_2321_1958:()=>a1,content_2321_196:()=>LX,content_2321_1960:()=>u1,content_2321_1962:()=>d1,content_2321_1964:()=>f1,content_2321_1966:()=>k1,content_2321_1968:()=>M1,content_2321_1970:()=>_1,content_2321_1972:()=>X1,content_2321_1974:()=>C1,content_2321_1976:()=>v1,content_2321_1978:()=>L1,content_2321_198:()=>NX,content_2321_1980:()=>N1,content_2321_1982:()=>R1,content_2321_1984:()=>P1,content_2321_1986:()=>I1,content_2321_1988:()=>E1,content_2321_1990:()=>F1,content_2321_1992:()=>G1,content_2321_1994:()=>U1,content_2321_1996:()=>V1,content_2321_1998:()=>$1,content_2321_2:()=>JM,content_2321_20:()=>fD,content_2321_200:()=>RX,content_2321_2000:()=>J1,content_2321_2002:()=>K1,content_2321_2004:()=>e3,content_2321_2006:()=>o3,content_2321_2008:()=>s3,content_2321_2010:()=>i3,content_2321_2012:()=>a3,content_2321_2014:()=>u3,content_2321_2016:()=>d3,content_2321_2018:()=>f3,content_2321_202:()=>PX,content_2321_2020:()=>k3,content_2321_2022:()=>M3,content_2321_2024:()=>_3,content_2321_2026:()=>X3,content_2321_2028:()=>C3,content_2321_2030:()=>v3,content_2321_2032:()=>L3,content_2321_2034:()=>N3,content_2321_2036:()=>R3,content_2321_2038:()=>P3,content_2321_204:()=>IX,content_2321_2040:()=>I3,content_2321_2042:()=>E3,content_2321_2044:()=>F3,content_2321_2046:()=>G3,content_2321_2048:()=>U3,content_2321_2050:()=>V3,content_2321_2052:()=>$3,content_2321_2054:()=>J3,content_2321_2056:()=>K3,content_2321_2058:()=>e4,content_2321_206:()=>EX,content_2321_2060:()=>o4,content_2321_2062:()=>s4,content_2321_2064:()=>i4,content_2321_2066:()=>a4,content_2321_2068:()=>u4,content_2321_2070:()=>d4,content_2321_2072:()=>f4,content_2321_2074:()=>k4,content_2321_2076:()=>M4,content_2321_2078:()=>_4,content_2321_208:()=>FX,content_2321_2080:()=>X4,content_2321_2082:()=>C4,content_2321_2084:()=>v4,content_2321_2086:()=>L4,content_2321_2088:()=>N4,content_2321_2090:()=>R4,content_2321_2092:()=>P4,content_2321_2094:()=>I4,content_2321_2096:()=>E4,content_2321_2098:()=>F4,content_2321_210:()=>GX,content_2321_2100:()=>G4,content_2321_2102:()=>U4,content_2321_2104:()=>V4,content_2321_2106:()=>$4,content_2321_2108:()=>J4,content_2321_2110:()=>K4,content_2321_2112:()=>e6,content_2321_2114:()=>o6,content_2321_2116:()=>s6,content_2321_2118:()=>i6,content_2321_212:()=>UX,content_2321_2120:()=>a6,content_2321_2122:()=>u6,content_2321_2124:()=>d6,content_2321_2126:()=>f6,content_2321_2128:()=>k6,content_2321_2130:()=>M6,content_2321_2132:()=>_6,content_2321_2134:()=>X6,content_2321_2136:()=>C6,content_2321_2138:()=>v6,content_2321_214:()=>VX,content_2321_2140:()=>L6,content_2321_2142:()=>N6,content_2321_2144:()=>R6,content_2321_2146:()=>P6,content_2321_2148:()=>I6,content_2321_2150:()=>E6,content_2321_2152:()=>F6,content_2321_2154:()=>G6,content_2321_2156:()=>U6,content_2321_2158:()=>V6,content_2321_216:()=>$X,content_2321_2160:()=>$6,content_2321_2162:()=>J6,content_2321_2164:()=>K6,content_2321_2166:()=>e8,content_2321_2168:()=>o8,content_2321_2170:()=>s8,content_2321_2172:()=>i8,content_2321_2174:()=>a8,content_2321_2176:()=>u8,content_2321_2178:()=>d8,content_2321_218:()=>JX,content_2321_2180:()=>f8,content_2321_2182:()=>k8,content_2321_2184:()=>M8,content_2321_2186:()=>_8,content_2321_2188:()=>X8,content_2321_2190:()=>C8,content_2321_2192:()=>v8,content_2321_2194:()=>L8,content_2321_2196:()=>N8,content_2321_2198:()=>R8,content_2321_22:()=>kD,content_2321_220:()=>KX,content_2321_2200:()=>P8,content_2321_2202:()=>I8,content_2321_2204:()=>E8,content_2321_2206:()=>F8,content_2321_2208:()=>G8,content_2321_2210:()=>U8,content_2321_2212:()=>V8,content_2321_2214:()=>$8,content_2321_2216:()=>J8,content_2321_2218:()=>K8,content_2321_222:()=>ex,content_2321_2220:()=>e5,content_2321_2222:()=>o5,content_2321_2224:()=>s5,content_2321_2226:()=>i5,content_2321_2228:()=>a5,content_2321_2230:()=>u5,content_2321_2232:()=>d5,content_2321_2234:()=>f5,content_2321_2236:()=>k5,content_2321_2238:()=>M5,content_2321_224:()=>ox,content_2321_2240:()=>_5,content_2321_2242:()=>X5,content_2321_2244:()=>C5,content_2321_2246:()=>v5,content_2321_2248:()=>L5,content_2321_2250:()=>N5,content_2321_2252:()=>R5,content_2321_2254:()=>P5,content_2321_2256:()=>I5,content_2321_2258:()=>E5,content_2321_226:()=>sx,content_2321_2260:()=>F5,content_2321_2262:()=>G5,content_2321_2264:()=>U5,content_2321_2266:()=>V5,content_2321_2268:()=>$5,content_2321_2270:()=>J5,content_2321_2272:()=>K5,content_2321_2274:()=>e7,content_2321_2276:()=>o7,content_2321_2278:()=>s7,content_2321_228:()=>ix,content_2321_2280:()=>i7,content_2321_2282:()=>a7,content_2321_2284:()=>u7,content_2321_2286:()=>d7,content_2321_2288:()=>f7,content_2321_2290:()=>k7,content_2321_2292:()=>M7,content_2321_2294:()=>_7,content_2321_2296:()=>X7,content_2321_2298:()=>C7,content_2321_230:()=>ax,content_2321_2300:()=>v7,content_2321_2302:()=>L7,content_2321_2304:()=>N7,content_2321_2306:()=>R7,content_2321_2308:()=>P7,content_2321_2310:()=>I7,content_2321_2312:()=>E7,content_2321_2314:()=>F7,content_2321_2316:()=>G7,content_2321_2318:()=>U7,content_2321_232:()=>ux,content_2321_2320:()=>V7,content_2321_2322:()=>$7,content_2321_2324:()=>J7,content_2321_2326:()=>K7,content_2321_2328:()=>e9,content_2321_2330:()=>o9,content_2321_2332:()=>s9,content_2321_2334:()=>i9,content_2321_2336:()=>a9,content_2321_2338:()=>u9,content_2321_234:()=>dx,content_2321_2340:()=>d9,content_2321_2342:()=>f9,content_2321_2344:()=>k9,content_2321_2346:()=>M9,content_2321_2348:()=>_9,content_2321_2350:()=>X9,content_2321_2352:()=>C9,content_2321_2354:()=>v9,content_2321_2356:()=>L9,content_2321_2358:()=>N9,content_2321_236:()=>fx,content_2321_2360:()=>R9,content_2321_2362:()=>P9,content_2321_2364:()=>I9,content_2321_2366:()=>E9,content_2321_2368:()=>F9,content_2321_2370:()=>G9,content_2321_2372:()=>U9,content_2321_2374:()=>V9,content_2321_2376:()=>$9,content_2321_2378:()=>J9,content_2321_238:()=>kx,content_2321_2380:()=>K9,content_2321_2382:()=>ett,content_2321_2384:()=>ott,content_2321_2386:()=>stt,content_2321_2388:()=>itt,content_2321_2390:()=>att,content_2321_2392:()=>utt,content_2321_2394:()=>dtt,content_2321_2396:()=>ftt,content_2321_2398:()=>ktt,content_2321_24:()=>MD,content_2321_240:()=>Mx,content_2321_2400:()=>Mtt,content_2321_2402:()=>_tt,content_2321_2404:()=>Xtt,content_2321_2406:()=>Ctt,content_2321_2408:()=>vtt,content_2321_2410:()=>Ltt,content_2321_2412:()=>Ntt,content_2321_2414:()=>Rtt,content_2321_2416:()=>Ptt,content_2321_2418:()=>Itt,content_2321_242:()=>_x,content_2321_2420:()=>Ett,content_2321_2422:()=>Ftt,content_2321_2424:()=>Gtt,content_2321_2426:()=>Utt,content_2321_2428:()=>Vtt,content_2321_2430:()=>$tt,content_2321_2432:()=>Jtt,content_2321_2434:()=>Ktt,content_2321_2436:()=>eet,content_2321_2438:()=>oet,content_2321_244:()=>Xx,content_2321_2440:()=>set,content_2321_2442:()=>iet,content_2321_2444:()=>aet,content_2321_2446:()=>met,content_2321_2448:()=>het,content_2321_2450:()=>yet,content_2321_2452:()=>wet,content_2321_2454:()=>Det,content_2321_2456:()=>get,content_2321_2458:()=>xet,content_2321_246:()=>Cx,content_2321_2460:()=>Tet,content_2321_2462:()=>bet,content_2321_2464:()=>Zet,content_2321_2466:()=>Set,content_2321_2468:()=>zet,content_2321_2470:()=>Aet,content_2321_2472:()=>Wet,content_2321_2474:()=>Bet,content_2321_2476:()=>Oet,content_2321_2478:()=>jet,content_2321_248:()=>vx,content_2321_2480:()=>qet,content_2321_2482:()=>Het,content_2321_2484:()=>Qet,content_2321_2486:()=>Yet,content_2321_2488:()=>tnt,content_2321_2490:()=>nnt,content_2321_2492:()=>rnt,content_2321_2494:()=>pnt,content_2321_2496:()=>cnt,content_2321_2498:()=>lnt,content_2321_250:()=>Lx,content_2321_2500:()=>mnt,content_2321_2502:()=>hnt,content_2321_2504:()=>ynt,content_2321_2506:()=>wnt,content_2321_2508:()=>Dnt,content_2321_2510:()=>gnt,content_2321_2512:()=>xnt,content_2321_2514:()=>Tnt,content_2321_2516:()=>bnt,content_2321_2518:()=>Znt,content_2321_252:()=>Nx,content_2321_2520:()=>Snt,content_2321_2522:()=>znt,content_2321_2524:()=>Ant,content_2321_2526:()=>Wnt,content_2321_2528:()=>Bnt,content_2321_2530:()=>Ont,content_2321_2532:()=>jnt,content_2321_2534:()=>qnt,content_2321_2536:()=>Hnt,content_2321_2538:()=>Qnt,content_2321_254:()=>Rx,content_2321_2540:()=>Ynt,content_2321_2542:()=>tot,content_2321_2544:()=>not,content_2321_2546:()=>rot,content_2321_2548:()=>pot,content_2321_2550:()=>cot,content_2321_2552:()=>lot,content_2321_2554:()=>mot,content_2321_2556:()=>hot,content_2321_2558:()=>yot,content_2321_256:()=>Px,content_2321_2560:()=>wot,content_2321_2562:()=>Dot,content_2321_2564:()=>got,content_2321_2566:()=>xot,content_2321_2568:()=>Tot,content_2321_2570:()=>bot,content_2321_2572:()=>Zot,content_2321_2574:()=>Sot,content_2321_2576:()=>zot,content_2321_2578:()=>Aot,content_2321_258:()=>Ix,content_2321_2580:()=>Wot,content_2321_2582:()=>Bot,content_2321_2584:()=>Oot,content_2321_2586:()=>jot,content_2321_2588:()=>qot,content_2321_2590:()=>Hot,content_2321_2592:()=>Qot,content_2321_2594:()=>Yot,content_2321_2596:()=>trt,content_2321_2598:()=>nrt,content_2321_26:()=>_D,content_2321_260:()=>Ex,content_2321_2600:()=>rrt,content_2321_2602:()=>prt,content_2321_2604:()=>crt,content_2321_2606:()=>lrt,content_2321_2608:()=>mrt,content_2321_2610:()=>hrt,content_2321_2612:()=>yrt,content_2321_2614:()=>wrt,content_2321_2616:()=>Drt,content_2321_2618:()=>grt,content_2321_262:()=>Fx,content_2321_2620:()=>xrt,content_2321_2622:()=>Trt,content_2321_2624:()=>brt,content_2321_2626:()=>Zrt,content_2321_2628:()=>Srt,content_2321_2630:()=>zrt,content_2321_2632:()=>Art,content_2321_2634:()=>Wrt,content_2321_2636:()=>Brt,content_2321_2638:()=>Ort,content_2321_264:()=>Gx,content_2321_2640:()=>jrt,content_2321_2642:()=>qrt,content_2321_2644:()=>Hrt,content_2321_2646:()=>Qrt,content_2321_2648:()=>Yrt,content_2321_2650:()=>tst,content_2321_2652:()=>nst,content_2321_2654:()=>rst,content_2321_2656:()=>pst,content_2321_2658:()=>cst,content_2321_266:()=>Ux,content_2321_2660:()=>lst,content_2321_2662:()=>mst,content_2321_2664:()=>hst,content_2321_2666:()=>yst,content_2321_2668:()=>wst,content_2321_2670:()=>Dst,content_2321_2672:()=>gst,content_2321_2674:()=>xst,content_2321_2676:()=>Tst,content_2321_2678:()=>bst,content_2321_268:()=>Vx,content_2321_2680:()=>Zst,content_2321_2682:()=>Sst,content_2321_2684:()=>zst,content_2321_2686:()=>Ast,content_2321_2688:()=>Wst,content_2321_2690:()=>Bst,content_2321_2692:()=>Ost,content_2321_2694:()=>jst,content_2321_2696:()=>qst,content_2321_2698:()=>Hst,content_2321_270:()=>$x,content_2321_2700:()=>Qst,content_2321_2702:()=>Yst,content_2321_2704:()=>tpt,content_2321_2706:()=>npt,content_2321_2708:()=>rpt,content_2321_2710:()=>ppt,content_2321_2712:()=>cpt,content_2321_2714:()=>lpt,content_2321_2716:()=>mpt,content_2321_2718:()=>hpt,content_2321_272:()=>Jx,content_2321_2720:()=>ypt,content_2321_2722:()=>wpt,content_2321_2724:()=>Dpt,content_2321_2726:()=>gpt,content_2321_2728:()=>xpt,content_2321_2730:()=>Tpt,content_2321_2732:()=>bpt,content_2321_2734:()=>Zpt,content_2321_2736:()=>Spt,content_2321_2738:()=>zpt,content_2321_274:()=>Kx,content_2321_2740:()=>Apt,content_2321_2742:()=>Wpt,content_2321_2744:()=>Bpt,content_2321_2746:()=>Opt,content_2321_2748:()=>jpt,content_2321_2750:()=>qpt,content_2321_2752:()=>Hpt,content_2321_2754:()=>Qpt,content_2321_2756:()=>Ypt,content_2321_2758:()=>tit,content_2321_276:()=>eC,content_2321_2760:()=>nit,content_2321_2762:()=>rit,content_2321_2764:()=>pit,content_2321_2766:()=>cit,content_2321_2768:()=>lit,content_2321_2770:()=>mit,content_2321_2772:()=>hit,content_2321_2774:()=>yit,content_2321_2776:()=>wit,content_2321_2778:()=>Dit,content_2321_278:()=>oC,content_2321_2780:()=>git,content_2321_2782:()=>xit,content_2321_2784:()=>Tit,content_2321_2786:()=>bit,content_2321_2788:()=>Zit,content_2321_2790:()=>Sit,content_2321_2792:()=>zit,content_2321_2794:()=>Ait,content_2321_2796:()=>Wit,content_2321_2798:()=>Bit,content_2321_28:()=>XD,content_2321_280:()=>sC,content_2321_2800:()=>Oit,content_2321_2802:()=>jit,content_2321_2804:()=>qit,content_2321_2806:()=>Hit,content_2321_2808:()=>Qit,content_2321_2810:()=>Yit,content_2321_2812:()=>tct,content_2321_2814:()=>nct,content_2321_2816:()=>rct,content_2321_2818:()=>pct,content_2321_282:()=>iC,content_2321_2820:()=>cct,content_2321_2822:()=>lct,content_2321_2824:()=>mct,content_2321_2826:()=>hct,content_2321_2828:()=>yct,content_2321_2830:()=>wct,content_2321_2832:()=>Dct,content_2321_2834:()=>gct,content_2321_2836:()=>xct,content_2321_2838:()=>Tct,content_2321_284:()=>aC,content_2321_2840:()=>bct,content_2321_2842:()=>Zct,content_2321_2844:()=>Sct,content_2321_2846:()=>zct,content_2321_2848:()=>Act,content_2321_2850:()=>Wct,content_2321_2852:()=>Bct,content_2321_2854:()=>Oct,content_2321_2856:()=>jct,content_2321_2858:()=>qct,content_2321_286:()=>uC,content_2321_2860:()=>Hct,content_2321_2862:()=>Qct,content_2321_2864:()=>Yct,content_2321_2866:()=>tat,content_2321_2868:()=>nat,content_2321_2870:()=>rat,content_2321_2872:()=>pat,content_2321_2874:()=>cat,content_2321_2876:()=>lat,content_2321_2878:()=>mat,content_2321_288:()=>dC,content_2321_2880:()=>hat,content_2321_2882:()=>yat,content_2321_2884:()=>wat,content_2321_2886:()=>Dat,content_2321_2888:()=>gat,content_2321_2890:()=>xat,content_2321_2892:()=>Tat,content_2321_2894:()=>bat,content_2321_2896:()=>Zat,content_2321_2898:()=>Sat,content_2321_290:()=>fC,content_2321_2900:()=>zat,content_2321_2902:()=>Aat,content_2321_2904:()=>Wat,content_2321_2906:()=>Bat,content_2321_2908:()=>Oat,content_2321_2910:()=>jat,content_2321_2912:()=>qat,content_2321_2914:()=>Hat,content_2321_2916:()=>Qat,content_2321_2918:()=>Yat,content_2321_292:()=>kC,content_2321_2920:()=>tlt,content_2321_2922:()=>nlt,content_2321_2924:()=>rlt,content_2321_2926:()=>plt,content_2321_2928:()=>clt,content_2321_2930:()=>llt,content_2321_2932:()=>mlt,content_2321_2934:()=>hlt,content_2321_2936:()=>ylt,content_2321_2938:()=>wlt,content_2321_294:()=>MC,content_2321_2940:()=>Dlt,content_2321_2942:()=>glt,content_2321_2944:()=>xlt,content_2321_2946:()=>Tlt,content_2321_2948:()=>blt,content_2321_2950:()=>Zlt,content_2321_2952:()=>Slt,content_2321_2954:()=>zlt,content_2321_2956:()=>Alt,content_2321_2958:()=>Wlt,content_2321_296:()=>_C,content_2321_2960:()=>Blt,content_2321_2962:()=>Olt,content_2321_2964:()=>jlt,content_2321_2966:()=>qlt,content_2321_2968:()=>Hlt,content_2321_2970:()=>Qlt,content_2321_2972:()=>Ylt,content_2321_2974:()=>tut,content_2321_2976:()=>nut,content_2321_2978:()=>rut,content_2321_298:()=>XC,content_2321_2980:()=>put,content_2321_2982:()=>cut,content_2321_2984:()=>lut,content_2321_2986:()=>mut,content_2321_2988:()=>hut,content_2321_2990:()=>yut,content_2321_2992:()=>wut,content_2321_2994:()=>Dut,content_2321_2996:()=>gut,content_2321_2998:()=>xut,content_2321_30:()=>CD,content_2321_300:()=>CC,content_2321_3000:()=>Tut,content_2321_3002:()=>but,content_2321_3004:()=>Zut,content_2321_3006:()=>Sut,content_2321_3008:()=>zut,content_2321_3010:()=>Aut,content_2321_3012:()=>Wut,content_2321_3014:()=>But,content_2321_3016:()=>Out,content_2321_3018:()=>jut,content_2321_302:()=>vC,content_2321_3020:()=>qut,content_2321_3022:()=>Hut,content_2321_3024:()=>Qut,content_2321_3026:()=>Yut,content_2321_3028:()=>tmt,content_2321_3030:()=>nmt,content_2321_3032:()=>rmt,content_2321_3034:()=>pmt,content_2321_3036:()=>cmt,content_2321_3038:()=>lmt,content_2321_304:()=>LC,content_2321_3040:()=>mmt,content_2321_3042:()=>hmt,content_2321_3044:()=>ymt,content_2321_3046:()=>wmt,content_2321_3048:()=>Dmt,content_2321_3050:()=>gmt,content_2321_3052:()=>xmt,content_2321_3054:()=>Tmt,content_2321_3056:()=>bmt,content_2321_3058:()=>Zmt,content_2321_306:()=>NC,content_2321_3060:()=>Smt,content_2321_3062:()=>zmt,content_2321_3064:()=>Amt,content_2321_3066:()=>Wmt,content_2321_3068:()=>Bmt,content_2321_3070:()=>Omt,content_2321_3072:()=>jmt,content_2321_3074:()=>qmt,content_2321_3076:()=>Hmt,content_2321_3078:()=>Qmt,content_2321_308:()=>RC,content_2321_3080:()=>Ymt,content_2321_3082:()=>tdt,content_2321_3084:()=>ndt,content_2321_3086:()=>rdt,content_2321_3088:()=>pdt,content_2321_3090:()=>cdt,content_2321_3092:()=>ldt,content_2321_3094:()=>mdt,content_2321_3096:()=>hdt,content_2321_3098:()=>ydt,content_2321_310:()=>PC,content_2321_3100:()=>wdt,content_2321_3102:()=>Ddt,content_2321_3104:()=>gdt,content_2321_3106:()=>xdt,content_2321_3108:()=>Tdt,content_2321_3110:()=>bdt,content_2321_3112:()=>Zdt,content_2321_3114:()=>Sdt,content_2321_3116:()=>zdt,content_2321_3118:()=>Adt,content_2321_312:()=>IC,content_2321_3120:()=>Wdt,content_2321_3122:()=>Bdt,content_2321_3124:()=>Odt,content_2321_3126:()=>jdt,content_2321_3128:()=>qdt,content_2321_3130:()=>Hdt,content_2321_3132:()=>Qdt,content_2321_3134:()=>Ydt,content_2321_3136:()=>tht,content_2321_3138:()=>nht,content_2321_314:()=>EC,content_2321_3140:()=>rht,content_2321_3142:()=>pht,content_2321_3144:()=>cht,content_2321_3146:()=>lht,content_2321_3148:()=>mht,content_2321_3150:()=>hht,content_2321_3152:()=>yht,content_2321_3154:()=>wht,content_2321_3156:()=>Dht,content_2321_3158:()=>ght,content_2321_316:()=>FC,content_2321_3160:()=>xht,content_2321_3162:()=>Tht,content_2321_3164:()=>bht,content_2321_3166:()=>Zht,content_2321_3168:()=>Sht,content_2321_3170:()=>zht,content_2321_3172:()=>Aht,content_2321_3174:()=>Wht,content_2321_3176:()=>Bht,content_2321_3178:()=>Oht,content_2321_318:()=>GC,content_2321_3180:()=>jht,content_2321_3182:()=>qht,content_2321_3184:()=>Hht,content_2321_3186:()=>Qht,content_2321_3188:()=>Yht,content_2321_3190:()=>tft,content_2321_3192:()=>nft,content_2321_3194:()=>rft,content_2321_3196:()=>pft,content_2321_3198:()=>cft,content_2321_32:()=>vD,content_2321_320:()=>UC,content_2321_3200:()=>lft,content_2321_3202:()=>mft,content_2321_3204:()=>hft,content_2321_3206:()=>yft,content_2321_3208:()=>wft,content_2321_3210:()=>Dft,content_2321_3212:()=>gft,content_2321_3214:()=>xft,content_2321_3216:()=>Tft,content_2321_3218:()=>bft,content_2321_322:()=>VC,content_2321_3220:()=>Zft,content_2321_3222:()=>Sft,content_2321_3224:()=>zft,content_2321_3226:()=>Aft,content_2321_3228:()=>Wft,content_2321_3230:()=>Bft,content_2321_3232:()=>Oft,content_2321_3234:()=>jft,content_2321_3236:()=>qft,content_2321_3238:()=>Hft,content_2321_324:()=>$C,content_2321_3240:()=>Qft,content_2321_3242:()=>Yft,content_2321_3244:()=>tyt,content_2321_3246:()=>nyt,content_2321_3248:()=>ryt,content_2321_3250:()=>pyt,content_2321_3252:()=>cyt,content_2321_3254:()=>lyt,content_2321_3256:()=>myt,content_2321_3258:()=>hyt,content_2321_326:()=>JC,content_2321_3260:()=>yyt,content_2321_3262:()=>wyt,content_2321_3264:()=>Dyt,content_2321_3266:()=>gyt,content_2321_3268:()=>xyt,content_2321_3270:()=>Tyt,content_2321_3272:()=>byt,content_2321_3274:()=>Zyt,content_2321_3276:()=>Syt,content_2321_3278:()=>zyt,content_2321_328:()=>KC,content_2321_3280:()=>Ayt,content_2321_3282:()=>Wyt,content_2321_3284:()=>Byt,content_2321_3286:()=>Oyt,content_2321_3288:()=>jyt,content_2321_3290:()=>qyt,content_2321_3292:()=>Hyt,content_2321_3294:()=>Qyt,content_2321_3296:()=>Yyt,content_2321_3298:()=>tkt,content_2321_330:()=>eT,content_2321_3300:()=>nkt,content_2321_3302:()=>rkt,content_2321_3304:()=>pkt,content_2321_3306:()=>ckt,content_2321_3308:()=>lkt,content_2321_3310:()=>mkt,content_2321_3312:()=>hkt,content_2321_3314:()=>ykt,content_2321_3316:()=>wkt,content_2321_3318:()=>Dkt,content_2321_332:()=>oT,content_2321_3320:()=>gkt,content_2321_3322:()=>xkt,content_2321_3324:()=>Tkt,content_2321_3326:()=>bkt,content_2321_3328:()=>Zkt,content_2321_3330:()=>Skt,content_2321_3332:()=>zkt,content_2321_3334:()=>Akt,content_2321_3336:()=>Wkt,content_2321_3338:()=>Bkt,content_2321_334:()=>sT,content_2321_3340:()=>Okt,content_2321_3342:()=>jkt,content_2321_3344:()=>qkt,content_2321_3346:()=>Hkt,content_2321_3348:()=>Qkt,content_2321_3350:()=>Ykt,content_2321_3352:()=>twt,content_2321_3354:()=>nwt,content_2321_3356:()=>rwt,content_2321_3358:()=>pwt,content_2321_336:()=>iT,content_2321_3360:()=>cwt,content_2321_3362:()=>lwt,content_2321_3364:()=>mwt,content_2321_3366:()=>hwt,content_2321_3368:()=>ywt,content_2321_3370:()=>wwt,content_2321_3372:()=>Dwt,content_2321_3374:()=>gwt,content_2321_3376:()=>xwt,content_2321_3378:()=>Twt,content_2321_338:()=>aT,content_2321_3380:()=>bwt,content_2321_3382:()=>Zwt,content_2321_3384:()=>Swt,content_2321_3386:()=>zwt,content_2321_3388:()=>Awt,content_2321_3390:()=>Wwt,content_2321_3392:()=>Bwt,content_2321_3394:()=>Owt,content_2321_3396:()=>jwt,content_2321_3398:()=>qwt,content_2321_34:()=>LD,content_2321_340:()=>uT,content_2321_3400:()=>Hwt,content_2321_3402:()=>Qwt,content_2321_3404:()=>Ywt,content_2321_3406:()=>tMt,content_2321_3408:()=>nMt,content_2321_3410:()=>rMt,content_2321_3412:()=>pMt,content_2321_3414:()=>cMt,content_2321_3416:()=>lMt,content_2321_3418:()=>mMt,content_2321_342:()=>dT,content_2321_3420:()=>hMt,content_2321_3422:()=>yMt,content_2321_3424:()=>wMt,content_2321_3426:()=>DMt,content_2321_3428:()=>gMt,content_2321_3430:()=>xMt,content_2321_3432:()=>TMt,content_2321_3434:()=>bMt,content_2321_3436:()=>ZMt,content_2321_3438:()=>SMt,content_2321_344:()=>fT,content_2321_3440:()=>zMt,content_2321_3442:()=>AMt,content_2321_3444:()=>WMt,content_2321_3446:()=>BMt,content_2321_3448:()=>OMt,content_2321_3450:()=>jMt,content_2321_3452:()=>qMt,content_2321_3454:()=>HMt,content_2321_3456:()=>QMt,content_2321_3458:()=>YMt,content_2321_346:()=>kT,content_2321_3460:()=>tDt,content_2321_3462:()=>nDt,content_2321_3464:()=>rDt,content_2321_3466:()=>pDt,content_2321_3468:()=>cDt,content_2321_3470:()=>lDt,content_2321_3472:()=>mDt,content_2321_3474:()=>hDt,content_2321_3476:()=>yDt,content_2321_3478:()=>wDt,content_2321_348:()=>MT,content_2321_3480:()=>DDt,content_2321_3482:()=>gDt,content_2321_3484:()=>xDt,content_2321_3486:()=>TDt,content_2321_3488:()=>bDt,content_2321_3490:()=>ZDt,content_2321_3492:()=>SDt,content_2321_3494:()=>zDt,content_2321_3496:()=>ADt,content_2321_3498:()=>WDt,content_2321_350:()=>_T,content_2321_3500:()=>BDt,content_2321_3502:()=>ODt,content_2321_3504:()=>jDt,content_2321_3506:()=>qDt,content_2321_3508:()=>HDt,content_2321_3510:()=>QDt,content_2321_3512:()=>YDt,content_2321_3514:()=>t_t,content_2321_3516:()=>n_t,content_2321_3518:()=>r_t,content_2321_352:()=>XT,content_2321_3520:()=>p_t,content_2321_3522:()=>c_t,content_2321_3524:()=>l_t,content_2321_3526:()=>m_t,content_2321_3528:()=>h_t,content_2321_3530:()=>y_t,content_2321_3532:()=>w_t,content_2321_3534:()=>D_t,content_2321_3536:()=>g_t,content_2321_3538:()=>x_t,content_2321_354:()=>CT,content_2321_3540:()=>T_t,content_2321_3542:()=>b_t,content_2321_3544:()=>Z_t,content_2321_3546:()=>S_t,content_2321_3548:()=>z_t,content_2321_3550:()=>A_t,content_2321_3552:()=>W_t,content_2321_3554:()=>B_t,content_2321_3556:()=>O_t,content_2321_3558:()=>j_t,content_2321_356:()=>vT,content_2321_3560:()=>q_t,content_2321_3562:()=>H_t,content_2321_3564:()=>Q_t,content_2321_3566:()=>Y_t,content_2321_3568:()=>tgt,content_2321_3570:()=>ngt,content_2321_3572:()=>rgt,content_2321_3574:()=>pgt,content_2321_3576:()=>cgt,content_2321_3578:()=>lgt,content_2321_358:()=>LT,content_2321_3580:()=>mgt,content_2321_3582:()=>hgt,content_2321_3584:()=>ygt,content_2321_3586:()=>wgt,content_2321_3588:()=>Dgt,content_2321_3590:()=>ggt,content_2321_3592:()=>xgt,content_2321_3594:()=>Tgt,content_2321_3596:()=>bgt,content_2321_3598:()=>Zgt,content_2321_36:()=>ND,content_2321_360:()=>NT,content_2321_3600:()=>Sgt,content_2321_3602:()=>zgt,content_2321_3604:()=>Agt,content_2321_3606:()=>Wgt,content_2321_3608:()=>Bgt,content_2321_3610:()=>Ogt,content_2321_3612:()=>jgt,content_2321_3614:()=>qgt,content_2321_3616:()=>Hgt,content_2321_3618:()=>Qgt,content_2321_362:()=>RT,content_2321_3620:()=>Ygt,content_2321_3622:()=>tXt,content_2321_3624:()=>nXt,content_2321_3626:()=>rXt,content_2321_3628:()=>pXt,content_2321_3630:()=>cXt,content_2321_3632:()=>lXt,content_2321_3634:()=>mXt,content_2321_3636:()=>hXt,content_2321_3638:()=>yXt,content_2321_364:()=>PT,content_2321_3640:()=>wXt,content_2321_3642:()=>DXt,content_2321_3644:()=>gXt,content_2321_3646:()=>xXt,content_2321_3648:()=>TXt,content_2321_3650:()=>bXt,content_2321_3652:()=>ZXt,content_2321_3654:()=>SXt,content_2321_3656:()=>zXt,content_2321_3658:()=>AXt,content_2321_366:()=>IT,content_2321_3660:()=>WXt,content_2321_3662:()=>BXt,content_2321_3664:()=>OXt,content_2321_3666:()=>jXt,content_2321_3668:()=>qXt,content_2321_3670:()=>HXt,content_2321_3672:()=>QXt,content_2321_3674:()=>YXt,content_2321_3676:()=>txt,content_2321_3678:()=>nxt,content_2321_368:()=>ET,content_2321_3680:()=>rxt,content_2321_3682:()=>pxt,content_2321_3684:()=>cxt,content_2321_3686:()=>lxt,content_2321_3688:()=>mxt,content_2321_3690:()=>hxt,content_2321_3692:()=>yxt,content_2321_3694:()=>wxt,content_2321_3696:()=>Dxt,content_2321_3698:()=>gxt,content_2321_370:()=>FT,content_2321_3700:()=>xxt,content_2321_3702:()=>Txt,content_2321_3704:()=>bxt,content_2321_3706:()=>Zxt,content_2321_3708:()=>Sxt,content_2321_3710:()=>zxt,content_2321_3712:()=>Axt,content_2321_3714:()=>Wxt,content_2321_3716:()=>Bxt,content_2321_3718:()=>Oxt,content_2321_372:()=>GT,content_2321_3720:()=>jxt,content_2321_3722:()=>qxt,content_2321_3724:()=>Hxt,content_2321_3726:()=>Qxt,content_2321_3728:()=>Yxt,content_2321_3730:()=>tCt,content_2321_3732:()=>nCt,content_2321_3734:()=>rCt,content_2321_3736:()=>pCt,content_2321_3738:()=>cCt,content_2321_374:()=>UT,content_2321_3740:()=>lCt,content_2321_3742:()=>mCt,content_2321_3744:()=>hCt,content_2321_3746:()=>yCt,content_2321_3748:()=>wCt,content_2321_3750:()=>DCt,content_2321_3752:()=>gCt,content_2321_3754:()=>xCt,content_2321_3756:()=>TCt,content_2321_3758:()=>bCt,content_2321_376:()=>VT,content_2321_3760:()=>ZCt,content_2321_3762:()=>SCt,content_2321_3764:()=>zCt,content_2321_3766:()=>ACt,content_2321_3768:()=>WCt,content_2321_3770:()=>BCt,content_2321_3772:()=>OCt,content_2321_3774:()=>jCt,content_2321_3776:()=>qCt,content_2321_3778:()=>HCt,content_2321_378:()=>$T,content_2321_3780:()=>QCt,content_2321_3782:()=>YCt,content_2321_3784:()=>tTt,content_2321_3786:()=>nTt,content_2321_3788:()=>rTt,content_2321_3790:()=>pTt,content_2321_3792:()=>cTt,content_2321_3794:()=>lTt,content_2321_3796:()=>mTt,content_2321_3798:()=>hTt,content_2321_38:()=>RD,content_2321_380:()=>JT,content_2321_3800:()=>yTt,content_2321_3802:()=>wTt,content_2321_3804:()=>DTt,content_2321_3806:()=>gTt,content_2321_3808:()=>xTt,content_2321_3810:()=>TTt,content_2321_3812:()=>bTt,content_2321_3814:()=>ZTt,content_2321_3816:()=>STt,content_2321_3818:()=>zTt,content_2321_382:()=>KT,content_2321_3820:()=>ATt,content_2321_3822:()=>WTt,content_2321_3824:()=>BTt,content_2321_3826:()=>OTt,content_2321_3828:()=>jTt,content_2321_3830:()=>qTt,content_2321_3832:()=>HTt,content_2321_3834:()=>QTt,content_2321_3836:()=>YTt,content_2321_3838:()=>tvt,content_2321_384:()=>ev,content_2321_3840:()=>nvt,content_2321_3842:()=>rvt,content_2321_3844:()=>pvt,content_2321_3846:()=>cvt,content_2321_3848:()=>lvt,content_2321_3850:()=>mvt,content_2321_3852:()=>hvt,content_2321_3854:()=>yvt,content_2321_3856:()=>wvt,content_2321_3858:()=>Dvt,content_2321_386:()=>ov,content_2321_3860:()=>gvt,content_2321_3862:()=>xvt,content_2321_3864:()=>Tvt,content_2321_3866:()=>bvt,content_2321_3868:()=>Zvt,content_2321_3870:()=>Svt,content_2321_3872:()=>zvt,content_2321_3874:()=>Avt,content_2321_3876:()=>Wvt,content_2321_3878:()=>Bvt,content_2321_388:()=>sv,content_2321_3880:()=>Ovt,content_2321_3882:()=>jvt,content_2321_3884:()=>qvt,content_2321_3886:()=>Hvt,content_2321_3888:()=>Qvt,content_2321_3890:()=>Yvt,content_2321_3892:()=>tbt,content_2321_3894:()=>nbt,content_2321_3896:()=>rbt,content_2321_3898:()=>pbt,content_2321_390:()=>iv,content_2321_3900:()=>cbt,content_2321_3902:()=>lbt,content_2321_3904:()=>mbt,content_2321_3906:()=>hbt,content_2321_3908:()=>ybt,content_2321_3910:()=>wbt,content_2321_3912:()=>Dbt,content_2321_3914:()=>gbt,content_2321_3916:()=>xbt,content_2321_3918:()=>Tbt,content_2321_392:()=>av,content_2321_3920:()=>bbt,content_2321_3922:()=>Zbt,content_2321_3924:()=>Sbt,content_2321_3926:()=>zbt,content_2321_3928:()=>Abt,content_2321_3930:()=>Wbt,content_2321_3932:()=>Bbt,content_2321_3934:()=>Obt,content_2321_3936:()=>jbt,content_2321_3938:()=>qbt,content_2321_394:()=>uv,content_2321_3940:()=>Hbt,content_2321_3942:()=>Qbt,content_2321_3944:()=>Ybt,content_2321_3946:()=>tLt,content_2321_3948:()=>nLt,content_2321_3950:()=>rLt,content_2321_3952:()=>pLt,content_2321_3954:()=>cLt,content_2321_3956:()=>lLt,content_2321_3958:()=>mLt,content_2321_396:()=>dv,content_2321_3960:()=>hLt,content_2321_3962:()=>yLt,content_2321_3964:()=>wLt,content_2321_3966:()=>DLt,content_2321_3968:()=>gLt,content_2321_3970:()=>xLt,content_2321_3972:()=>TLt,content_2321_3974:()=>bLt,content_2321_3976:()=>ZLt,content_2321_3978:()=>SLt,content_2321_398:()=>fv,content_2321_3980:()=>zLt,content_2321_3982:()=>ALt,content_2321_3984:()=>WLt,content_2321_3986:()=>BLt,content_2321_3988:()=>OLt,content_2321_3990:()=>jLt,content_2321_3992:()=>qLt,content_2321_3994:()=>HLt,content_2321_3996:()=>QLt,content_2321_3998:()=>YLt,content_2321_4:()=>KM,content_2321_40:()=>PD,content_2321_400:()=>kv,content_2321_4000:()=>tZt,content_2321_4002:()=>nZt,content_2321_4004:()=>rZt,content_2321_4006:()=>pZt,content_2321_4008:()=>cZt,content_2321_4010:()=>lZt,content_2321_4012:()=>mZt,content_2321_4014:()=>hZt,content_2321_4016:()=>yZt,content_2321_4018:()=>wZt,content_2321_402:()=>Mv,content_2321_4020:()=>DZt,content_2321_4022:()=>gZt,content_2321_4024:()=>xZt,content_2321_4026:()=>TZt,content_2321_4028:()=>bZt,content_2321_4030:()=>ZZt,content_2321_4032:()=>SZt,content_2321_4034:()=>zZt,content_2321_4036:()=>AZt,content_2321_4038:()=>WZt,content_2321_404:()=>_v,content_2321_4040:()=>BZt,content_2321_4042:()=>OZt,content_2321_4044:()=>jZt,content_2321_4046:()=>qZt,content_2321_4048:()=>HZt,content_2321_4050:()=>QZt,content_2321_4052:()=>YZt,content_2321_4054:()=>tNt,content_2321_4056:()=>nNt,content_2321_4058:()=>rNt,content_2321_406:()=>Xv,content_2321_4060:()=>pNt,content_2321_4062:()=>cNt,content_2321_4064:()=>lNt,content_2321_4066:()=>mNt,content_2321_4068:()=>hNt,content_2321_4070:()=>yNt,content_2321_4072:()=>wNt,content_2321_4074:()=>DNt,content_2321_4076:()=>gNt,content_2321_4078:()=>xNt,content_2321_408:()=>Cv,content_2321_4080:()=>TNt,content_2321_4082:()=>bNt,content_2321_4084:()=>ZNt,content_2321_4086:()=>SNt,content_2321_4088:()=>zNt,content_2321_4090:()=>ANt,content_2321_4092:()=>WNt,content_2321_4094:()=>BNt,content_2321_4096:()=>ONt,content_2321_4098:()=>jNt,content_2321_410:()=>vv,content_2321_4100:()=>qNt,content_2321_4102:()=>HNt,content_2321_4104:()=>QNt,content_2321_4106:()=>YNt,content_2321_4108:()=>tSt,content_2321_4110:()=>nSt,content_2321_4112:()=>rSt,content_2321_4114:()=>pSt,content_2321_4116:()=>cSt,content_2321_4118:()=>lSt,content_2321_412:()=>Lv,content_2321_4120:()=>mSt,content_2321_4122:()=>hSt,content_2321_4124:()=>ySt,content_2321_4126:()=>wSt,content_2321_4128:()=>DSt,content_2321_4130:()=>gSt,content_2321_4132:()=>xSt,content_2321_4134:()=>TSt,content_2321_4136:()=>bSt,content_2321_4138:()=>ZSt,content_2321_414:()=>Nv,content_2321_4140:()=>SSt,content_2321_4142:()=>zSt,content_2321_4144:()=>ASt,content_2321_4146:()=>WSt,content_2321_4148:()=>BSt,content_2321_4150:()=>OSt,content_2321_4152:()=>jSt,content_2321_4154:()=>qSt,content_2321_4156:()=>HSt,content_2321_4158:()=>QSt,content_2321_416:()=>Rv,content_2321_4160:()=>YSt,content_2321_4162:()=>tRt,content_2321_4164:()=>nRt,content_2321_4166:()=>rRt,content_2321_4168:()=>pRt,content_2321_4170:()=>cRt,content_2321_4172:()=>lRt,content_2321_4174:()=>mRt,content_2321_4176:()=>hRt,content_2321_4178:()=>yRt,content_2321_418:()=>Pv,content_2321_4180:()=>wRt,content_2321_4182:()=>DRt,content_2321_4184:()=>gRt,content_2321_4186:()=>xRt,content_2321_4188:()=>TRt,content_2321_4190:()=>bRt,content_2321_4192:()=>ZRt,content_2321_4194:()=>SRt,content_2321_4196:()=>zRt,content_2321_4198:()=>ARt,content_2321_42:()=>ID,content_2321_420:()=>Iv,content_2321_4200:()=>WRt,content_2321_4202:()=>BRt,content_2321_4204:()=>ORt,content_2321_4206:()=>jRt,content_2321_4208:()=>qRt,content_2321_4210:()=>HRt,content_2321_4212:()=>QRt,content_2321_4214:()=>YRt,content_2321_4216:()=>tzt,content_2321_4218:()=>nzt,content_2321_422:()=>Ev,content_2321_4220:()=>rzt,content_2321_4222:()=>pzt,content_2321_4224:()=>czt,content_2321_4226:()=>lzt,content_2321_4228:()=>mzt,content_2321_4230:()=>hzt,content_2321_4232:()=>yzt,content_2321_4234:()=>wzt,content_2321_4236:()=>Dzt,content_2321_4238:()=>gzt,content_2321_424:()=>Fv,content_2321_4240:()=>xzt,content_2321_4242:()=>Tzt,content_2321_4244:()=>bzt,content_2321_4246:()=>Zzt,content_2321_4248:()=>Szt,content_2321_4250:()=>zzt,content_2321_4252:()=>Azt,content_2321_4254:()=>Wzt,content_2321_4256:()=>Bzt,content_2321_4258:()=>Ozt,content_2321_426:()=>Gv,content_2321_4260:()=>jzt,content_2321_4262:()=>qzt,content_2321_4264:()=>Hzt,content_2321_4266:()=>Qzt,content_2321_4268:()=>Yzt,content_2321_4270:()=>tPt,content_2321_4272:()=>nPt,content_2321_4274:()=>rPt,content_2321_4276:()=>pPt,content_2321_4278:()=>cPt,content_2321_428:()=>Uv,content_2321_4280:()=>lPt,content_2321_4282:()=>mPt,content_2321_4284:()=>hPt,content_2321_4286:()=>yPt,content_2321_4288:()=>wPt,content_2321_4290:()=>DPt,content_2321_4292:()=>gPt,content_2321_4294:()=>xPt,content_2321_4296:()=>TPt,content_2321_4298:()=>bPt,content_2321_430:()=>Vv,content_2321_4300:()=>ZPt,content_2321_4302:()=>SPt,content_2321_4304:()=>zPt,content_2321_4306:()=>APt,content_2321_4308:()=>WPt,content_2321_4310:()=>BPt,content_2321_4312:()=>OPt,content_2321_4314:()=>jPt,content_2321_4316:()=>qPt,content_2321_4318:()=>HPt,content_2321_432:()=>$v,content_2321_4320:()=>QPt,content_2321_4322:()=>YPt,content_2321_4324:()=>tAt,content_2321_4326:()=>nAt,content_2321_4328:()=>rAt,content_2321_4330:()=>pAt,content_2321_4332:()=>cAt,content_2321_4334:()=>lAt,content_2321_4336:()=>mAt,content_2321_4338:()=>hAt,content_2321_434:()=>Jv,content_2321_4340:()=>yAt,content_2321_4342:()=>wAt,content_2321_4344:()=>DAt,content_2321_4346:()=>gAt,content_2321_4348:()=>xAt,content_2321_4350:()=>TAt,content_2321_4352:()=>bAt,content_2321_4354:()=>ZAt,content_2321_4356:()=>SAt,content_2321_4358:()=>zAt,content_2321_436:()=>Kv,content_2321_4360:()=>AAt,content_2321_4362:()=>WAt,content_2321_4364:()=>BAt,content_2321_4366:()=>OAt,content_2321_4368:()=>jAt,content_2321_4370:()=>qAt,content_2321_4372:()=>HAt,content_2321_4374:()=>QAt,content_2321_4376:()=>YAt,content_2321_4378:()=>tIt,content_2321_438:()=>eb,content_2321_4380:()=>nIt,content_2321_4382:()=>rIt,content_2321_4384:()=>pIt,content_2321_4386:()=>cIt,content_2321_4388:()=>lIt,content_2321_4390:()=>mIt,content_2321_4392:()=>hIt,content_2321_4394:()=>yIt,content_2321_4396:()=>wIt,content_2321_4398:()=>DIt,content_2321_44:()=>ED,content_2321_440:()=>ob,content_2321_4400:()=>gIt,content_2321_4402:()=>xIt,content_2321_4404:()=>TIt,content_2321_4406:()=>bIt,content_2321_4408:()=>ZIt,content_2321_4410:()=>SIt,content_2321_4412:()=>zIt,content_2321_4414:()=>AIt,content_2321_4416:()=>WIt,content_2321_4418:()=>BIt,content_2321_442:()=>sb,content_2321_4420:()=>OIt,content_2321_4422:()=>jIt,content_2321_4424:()=>qIt,content_2321_4426:()=>HIt,content_2321_4428:()=>QIt,content_2321_4430:()=>YIt,content_2321_4432:()=>tWt,content_2321_4434:()=>nWt,content_2321_4436:()=>rWt,content_2321_4438:()=>pWt,content_2321_444:()=>ib,content_2321_4440:()=>cWt,content_2321_4442:()=>lWt,content_2321_4444:()=>mWt,content_2321_4446:()=>hWt,content_2321_4448:()=>yWt,content_2321_4450:()=>wWt,content_2321_4452:()=>DWt,content_2321_4454:()=>gWt,content_2321_4456:()=>xWt,content_2321_4458:()=>TWt,content_2321_446:()=>ab,content_2321_4460:()=>bWt,content_2321_4462:()=>ZWt,content_2321_4464:()=>SWt,content_2321_4466:()=>zWt,content_2321_4468:()=>AWt,content_2321_4470:()=>WWt,content_2321_4472:()=>BWt,content_2321_4474:()=>OWt,content_2321_4476:()=>jWt,content_2321_4478:()=>qWt,content_2321_448:()=>ub,content_2321_4480:()=>HWt,content_2321_4482:()=>QWt,content_2321_4484:()=>YWt,content_2321_4486:()=>tEt,content_2321_4488:()=>nEt,content_2321_4490:()=>rEt,content_2321_4492:()=>pEt,content_2321_4494:()=>cEt,content_2321_4496:()=>lEt,content_2321_4498:()=>mEt,content_2321_450:()=>db,content_2321_4500:()=>hEt,content_2321_4502:()=>yEt,content_2321_4504:()=>wEt,content_2321_4506:()=>DEt,content_2321_4508:()=>gEt,content_2321_4510:()=>xEt,content_2321_4512:()=>TEt,content_2321_4514:()=>bEt,content_2321_4516:()=>ZEt,content_2321_4518:()=>SEt,content_2321_452:()=>fb,content_2321_4520:()=>zEt,content_2321_4522:()=>AEt,content_2321_4524:()=>WEt,content_2321_4526:()=>BEt,content_2321_4528:()=>OEt,content_2321_4530:()=>jEt,content_2321_4532:()=>qEt,content_2321_4534:()=>HEt,content_2321_4536:()=>QEt,content_2321_4538:()=>YEt,content_2321_454:()=>kb,content_2321_4540:()=>tBt,content_2321_4542:()=>nBt,content_2321_4544:()=>rBt,content_2321_4546:()=>pBt,content_2321_4548:()=>cBt,content_2321_4550:()=>lBt,content_2321_4552:()=>mBt,content_2321_4554:()=>hBt,content_2321_4556:()=>yBt,content_2321_4558:()=>wBt,content_2321_456:()=>Mb,content_2321_4560:()=>DBt,content_2321_4562:()=>gBt,content_2321_4564:()=>xBt,content_2321_4566:()=>TBt,content_2321_4568:()=>bBt,content_2321_4570:()=>ZBt,content_2321_4572:()=>SBt,content_2321_4574:()=>zBt,content_2321_4576:()=>ABt,content_2321_4578:()=>WBt,content_2321_458:()=>_b,content_2321_4580:()=>BBt,content_2321_4582:()=>OBt,content_2321_4584:()=>jBt,content_2321_4586:()=>qBt,content_2321_4588:()=>HBt,content_2321_4590:()=>QBt,content_2321_4592:()=>YBt,content_2321_4594:()=>tFt,content_2321_4596:()=>nFt,content_2321_4598:()=>rFt,content_2321_46:()=>FD,content_2321_460:()=>Xb,content_2321_4600:()=>pFt,content_2321_4602:()=>cFt,content_2321_4604:()=>lFt,content_2321_4606:()=>mFt,content_2321_4608:()=>hFt,content_2321_4610:()=>yFt,content_2321_4612:()=>wFt,content_2321_4614:()=>DFt,content_2321_4616:()=>gFt,content_2321_4618:()=>xFt,content_2321_462:()=>Cb,content_2321_4620:()=>TFt,content_2321_4622:()=>bFt,content_2321_4624:()=>ZFt,content_2321_4626:()=>SFt,content_2321_4628:()=>zFt,content_2321_4630:()=>AFt,content_2321_4632:()=>WFt,content_2321_4634:()=>BFt,content_2321_4636:()=>OFt,content_2321_4638:()=>jFt,content_2321_464:()=>vb,content_2321_4640:()=>qFt,content_2321_4642:()=>HFt,content_2321_4644:()=>QFt,content_2321_4646:()=>YFt,content_2321_4648:()=>tOt,content_2321_4650:()=>nOt,content_2321_4652:()=>rOt,content_2321_4654:()=>pOt,content_2321_4656:()=>cOt,content_2321_4658:()=>lOt,content_2321_466:()=>Lb,content_2321_4660:()=>mOt,content_2321_4662:()=>hOt,content_2321_4664:()=>yOt,content_2321_4666:()=>wOt,content_2321_4668:()=>DOt,content_2321_4670:()=>gOt,content_2321_4672:()=>xOt,content_2321_4674:()=>TOt,content_2321_4676:()=>bOt,content_2321_4678:()=>ZOt,content_2321_468:()=>Nb,content_2321_4680:()=>SOt,content_2321_4682:()=>zOt,content_2321_4684:()=>AOt,content_2321_4686:()=>WOt,content_2321_4688:()=>BOt,content_2321_4690:()=>OOt,content_2321_4692:()=>jOt,content_2321_4694:()=>qOt,content_2321_4696:()=>HOt,content_2321_4698:()=>QOt,content_2321_470:()=>Rb,content_2321_4700:()=>YOt,content_2321_4702:()=>tGt,content_2321_4704:()=>nGt,content_2321_4706:()=>rGt,content_2321_4708:()=>pGt,content_2321_4710:()=>cGt,content_2321_4712:()=>lGt,content_2321_4714:()=>mGt,content_2321_4716:()=>hGt,content_2321_4718:()=>yGt,content_2321_472:()=>Pb,content_2321_4720:()=>wGt,content_2321_4722:()=>DGt,content_2321_4724:()=>gGt,content_2321_4726:()=>xGt,content_2321_4728:()=>TGt,content_2321_4730:()=>bGt,content_2321_4732:()=>ZGt,content_2321_4734:()=>SGt,content_2321_4736:()=>zGt,content_2321_4738:()=>AGt,content_2321_474:()=>Ib,content_2321_4740:()=>WGt,content_2321_4742:()=>BGt,content_2321_4744:()=>OGt,content_2321_4746:()=>jGt,content_2321_4748:()=>qGt,content_2321_4750:()=>HGt,content_2321_4752:()=>QGt,content_2321_4754:()=>YGt,content_2321_4756:()=>tjt,content_2321_4758:()=>njt,content_2321_476:()=>Eb,content_2321_4760:()=>rjt,content_2321_4762:()=>pjt,content_2321_4764:()=>cjt,content_2321_4766:()=>ljt,content_2321_4768:()=>mjt,content_2321_4770:()=>hjt,content_2321_4772:()=>yjt,content_2321_4774:()=>wjt,content_2321_4776:()=>Djt,content_2321_4778:()=>gjt,content_2321_478:()=>Fb,content_2321_4780:()=>xjt,content_2321_4782:()=>Tjt,content_2321_4784:()=>bjt,content_2321_4786:()=>Zjt,content_2321_4788:()=>Sjt,content_2321_4790:()=>zjt,content_2321_4792:()=>Ajt,content_2321_4794:()=>Wjt,content_2321_4796:()=>Bjt,content_2321_4798:()=>Ojt,content_2321_48:()=>GD,content_2321_480:()=>Gb,content_2321_4800:()=>jjt,content_2321_4802:()=>qjt,content_2321_4804:()=>Hjt,content_2321_4806:()=>Qjt,content_2321_4808:()=>Yjt,content_2321_4810:()=>tUt,content_2321_4812:()=>nUt,content_2321_4814:()=>rUt,content_2321_4816:()=>pUt,content_2321_4818:()=>cUt,content_2321_482:()=>Ub,content_2321_4820:()=>lUt,content_2321_4822:()=>mUt,content_2321_4824:()=>hUt,content_2321_4826:()=>yUt,content_2321_4828:()=>wUt,content_2321_4830:()=>DUt,content_2321_4832:()=>gUt,content_2321_4834:()=>xUt,content_2321_4836:()=>TUt,content_2321_4838:()=>bUt,content_2321_484:()=>Vb,content_2321_4840:()=>ZUt,content_2321_4842:()=>SUt,content_2321_4844:()=>zUt,content_2321_4846:()=>AUt,content_2321_4848:()=>WUt,content_2321_4850:()=>BUt,content_2321_4852:()=>OUt,content_2321_4854:()=>jUt,content_2321_4856:()=>qUt,content_2321_4858:()=>HUt,content_2321_486:()=>$b,content_2321_4860:()=>QUt,content_2321_4862:()=>YUt,content_2321_4864:()=>tqt,content_2321_4866:()=>nqt,content_2321_4868:()=>rqt,content_2321_4870:()=>pqt,content_2321_4872:()=>cqt,content_2321_4874:()=>lqt,content_2321_4876:()=>mqt,content_2321_4878:()=>hqt,content_2321_488:()=>Jb,content_2321_4880:()=>yqt,content_2321_4882:()=>wqt,content_2321_4884:()=>Dqt,content_2321_4886:()=>gqt,content_2321_4888:()=>xqt,content_2321_4890:()=>Tqt,content_2321_4892:()=>bqt,content_2321_4894:()=>Zqt,content_2321_4896:()=>Sqt,content_2321_4898:()=>zqt,content_2321_490:()=>Kb,content_2321_4900:()=>Aqt,content_2321_4902:()=>Wqt,content_2321_4904:()=>Bqt,content_2321_4906:()=>Oqt,content_2321_4908:()=>jqt,content_2321_4910:()=>qqt,content_2321_4912:()=>Hqt,content_2321_4914:()=>Qqt,content_2321_4916:()=>Yqt,content_2321_4918:()=>tVt,content_2321_492:()=>eL,content_2321_4920:()=>nVt,content_2321_4922:()=>rVt,content_2321_4924:()=>pVt,content_2321_4926:()=>cVt,content_2321_4928:()=>lVt,content_2321_4930:()=>mVt,content_2321_4932:()=>hVt,content_2321_4934:()=>yVt,content_2321_4936:()=>wVt,content_2321_4938:()=>DVt,content_2321_494:()=>oL,content_2321_4940:()=>gVt,content_2321_4942:()=>xVt,content_2321_4944:()=>TVt,content_2321_4946:()=>bVt,content_2321_4948:()=>ZVt,content_2321_4950:()=>SVt,content_2321_4952:()=>zVt,content_2321_4954:()=>AVt,content_2321_4956:()=>WVt,content_2321_4958:()=>BVt,content_2321_496:()=>sL,content_2321_4960:()=>OVt,content_2321_4962:()=>jVt,content_2321_4964:()=>qVt,content_2321_4966:()=>HVt,content_2321_4968:()=>QVt,content_2321_4970:()=>YVt,content_2321_4972:()=>tHt,content_2321_4974:()=>nHt,content_2321_4976:()=>rHt,content_2321_4978:()=>pHt,content_2321_498:()=>iL,content_2321_4980:()=>cHt,content_2321_4982:()=>lHt,content_2321_4984:()=>mHt,content_2321_4986:()=>hHt,content_2321_4988:()=>yHt,content_2321_4990:()=>wHt,content_2321_4992:()=>DHt,content_2321_4994:()=>gHt,content_2321_4996:()=>xHt,content_2321_4998:()=>THt,content_2321_50:()=>UD,content_2321_500:()=>aL,content_2321_5000:()=>bHt,content_2321_5002:()=>ZHt,content_2321_5004:()=>SHt,content_2321_5006:()=>zHt,content_2321_5008:()=>AHt,content_2321_5010:()=>WHt,content_2321_5012:()=>BHt,content_2321_5014:()=>OHt,content_2321_5016:()=>jHt,content_2321_5018:()=>qHt,content_2321_502:()=>uL,content_2321_5020:()=>HHt,content_2321_5022:()=>QHt,content_2321_5024:()=>YHt,content_2321_5026:()=>t$t,content_2321_5028:()=>n$t,content_2321_5030:()=>r$t,content_2321_5032:()=>p$t,content_2321_5034:()=>c$t,content_2321_5036:()=>l$t,content_2321_5038:()=>m$t,content_2321_504:()=>dL,content_2321_5040:()=>h$t,content_2321_5042:()=>y$t,content_2321_5044:()=>w$t,content_2321_5046:()=>D$t,content_2321_5048:()=>g$t,content_2321_5050:()=>x$t,content_2321_5052:()=>T$t,content_2321_5054:()=>b$t,content_2321_5056:()=>Z$t,content_2321_5058:()=>S$t,content_2321_506:()=>fL,content_2321_5060:()=>z$t,content_2321_5062:()=>A$t,content_2321_5064:()=>W$t,content_2321_5066:()=>B$t,content_2321_5068:()=>O$t,content_2321_5070:()=>j$t,content_2321_5072:()=>q$t,content_2321_5074:()=>H$t,content_2321_5076:()=>Q$t,content_2321_5078:()=>Y$t,content_2321_508:()=>kL,content_2321_5080:()=>tQt,content_2321_5082:()=>nQt,content_2321_5084:()=>rQt,content_2321_5086:()=>pQt,content_2321_5088:()=>cQt,content_2321_5090:()=>lQt,content_2321_5092:()=>mQt,content_2321_5094:()=>hQt,content_2321_5096:()=>yQt,content_2321_5098:()=>wQt,content_2321_510:()=>ML,content_2321_5100:()=>DQt,content_2321_5102:()=>gQt,content_2321_5104:()=>xQt,content_2321_5106:()=>TQt,content_2321_5108:()=>bQt,content_2321_5110:()=>ZQt,content_2321_5112:()=>SQt,content_2321_5114:()=>zQt,content_2321_5116:()=>AQt,content_2321_5118:()=>WQt,content_2321_512:()=>_L,content_2321_5120:()=>BQt,content_2321_5122:()=>OQt,content_2321_5124:()=>jQt,content_2321_5126:()=>qQt,content_2321_5128:()=>HQt,content_2321_5130:()=>QQt,content_2321_5132:()=>YQt,content_2321_5134:()=>tJt,content_2321_5136:()=>nJt,content_2321_5138:()=>rJt,content_2321_514:()=>XL,content_2321_5140:()=>pJt,content_2321_5142:()=>cJt,content_2321_5144:()=>lJt,content_2321_5146:()=>mJt,content_2321_5148:()=>hJt,content_2321_5150:()=>yJt,content_2321_5152:()=>wJt,content_2321_5154:()=>DJt,content_2321_5156:()=>gJt,content_2321_5158:()=>xJt,content_2321_516:()=>CL,content_2321_5160:()=>TJt,content_2321_5162:()=>bJt,content_2321_5164:()=>ZJt,content_2321_5166:()=>SJt,content_2321_5168:()=>zJt,content_2321_5170:()=>AJt,content_2321_5172:()=>WJt,content_2321_5174:()=>BJt,content_2321_5176:()=>OJt,content_2321_5178:()=>jJt,content_2321_518:()=>vL,content_2321_5180:()=>qJt,content_2321_5182:()=>HJt,content_2321_5184:()=>QJt,content_2321_5186:()=>YJt,content_2321_5188:()=>tYt,content_2321_5190:()=>nYt,content_2321_5192:()=>rYt,content_2321_5194:()=>pYt,content_2321_5196:()=>cYt,content_2321_5198:()=>lYt,content_2321_52:()=>VD,content_2321_520:()=>LL,content_2321_5200:()=>mYt,content_2321_5202:()=>hYt,content_2321_5204:()=>yYt,content_2321_5206:()=>wYt,content_2321_5208:()=>DYt,content_2321_5210:()=>gYt,content_2321_5212:()=>xYt,content_2321_5214:()=>TYt,content_2321_5216:()=>bYt,content_2321_5218:()=>ZYt,content_2321_522:()=>NL,content_2321_5220:()=>SYt,content_2321_5222:()=>zYt,content_2321_5224:()=>AYt,content_2321_5226:()=>WYt,content_2321_5228:()=>BYt,content_2321_5230:()=>OYt,content_2321_5232:()=>jYt,content_2321_5234:()=>qYt,content_2321_5236:()=>HYt,content_2321_5238:()=>QYt,content_2321_524:()=>RL,content_2321_5240:()=>YYt,content_2321_5242:()=>tKt,content_2321_5244:()=>nKt,content_2321_5246:()=>rKt,content_2321_5248:()=>pKt,content_2321_5250:()=>cKt,content_2321_5252:()=>lKt,content_2321_5254:()=>mKt,content_2321_5256:()=>hKt,content_2321_5258:()=>yKt,content_2321_526:()=>PL,content_2321_5260:()=>wKt,content_2321_5262:()=>DKt,content_2321_5264:()=>gKt,content_2321_5266:()=>xKt,content_2321_5268:()=>TKt,content_2321_5270:()=>bKt,content_2321_5272:()=>ZKt,content_2321_5274:()=>SKt,content_2321_5276:()=>zKt,content_2321_5278:()=>AKt,content_2321_528:()=>IL,content_2321_5280:()=>WKt,content_2321_5282:()=>BKt,content_2321_5284:()=>OKt,content_2321_5286:()=>jKt,content_2321_5288:()=>qKt,content_2321_5290:()=>HKt,content_2321_5292:()=>QKt,content_2321_5294:()=>YKt,content_2321_5296:()=>t0t,content_2321_5298:()=>n0t,content_2321_530:()=>EL,content_2321_5300:()=>r0t,content_2321_5302:()=>p0t,content_2321_5304:()=>c0t,content_2321_5306:()=>l0t,content_2321_5308:()=>m0t,content_2321_5310:()=>h0t,content_2321_5312:()=>y0t,content_2321_5314:()=>w0t,content_2321_5316:()=>D0t,content_2321_5318:()=>g0t,content_2321_532:()=>FL,content_2321_5320:()=>x0t,content_2321_5322:()=>T0t,content_2321_5324:()=>b0t,content_2321_5326:()=>Z0t,content_2321_5328:()=>S0t,content_2321_5330:()=>z0t,content_2321_5332:()=>A0t,content_2321_5334:()=>W0t,content_2321_5336:()=>B0t,content_2321_5338:()=>O0t,content_2321_534:()=>GL,content_2321_5340:()=>j0t,content_2321_5342:()=>q0t,content_2321_5344:()=>H0t,content_2321_5346:()=>Q0t,content_2321_5348:()=>Y0t,content_2321_5350:()=>t2t,content_2321_5352:()=>n2t,content_2321_5354:()=>r2t,content_2321_5356:()=>p2t,content_2321_5358:()=>c2t,content_2321_536:()=>UL,content_2321_5360:()=>l2t,content_2321_5362:()=>m2t,content_2321_5364:()=>h2t,content_2321_5366:()=>y2t,content_2321_5368:()=>w2t,content_2321_5370:()=>D2t,content_2321_5372:()=>g2t,content_2321_5374:()=>x2t,content_2321_5376:()=>T2t,content_2321_5378:()=>b2t,content_2321_538:()=>VL,content_2321_5380:()=>Z2t,content_2321_5382:()=>S2t,content_2321_5384:()=>z2t,content_2321_5386:()=>A2t,content_2321_5388:()=>W2t,content_2321_5390:()=>B2t,content_2321_5392:()=>O2t,content_2321_5394:()=>j2t,content_2321_5396:()=>q2t,content_2321_5398:()=>H2t,content_2321_54:()=>$D,content_2321_540:()=>$L,content_2321_5400:()=>Q2t,content_2321_5402:()=>Y2t,content_2321_5404:()=>t1t,content_2321_5406:()=>n1t,content_2321_5408:()=>r1t,content_2321_5410:()=>p1t,content_2321_5412:()=>c1t,content_2321_5414:()=>l1t,content_2321_5416:()=>m1t,content_2321_5418:()=>h1t,content_2321_542:()=>JL,content_2321_5420:()=>y1t,content_2321_5422:()=>w1t,content_2321_5424:()=>D1t,content_2321_5426:()=>g1t,content_2321_5428:()=>x1t,content_2321_5430:()=>T1t,content_2321_5432:()=>b1t,content_2321_5434:()=>Z1t,content_2321_5436:()=>S1t,content_2321_5438:()=>z1t,content_2321_544:()=>KL,content_2321_5440:()=>A1t,content_2321_5442:()=>W1t,content_2321_5444:()=>B1t,content_2321_5446:()=>O1t,content_2321_5448:()=>j1t,content_2321_5450:()=>q1t,content_2321_5452:()=>H1t,content_2321_5454:()=>Q1t,content_2321_5456:()=>Y1t,content_2321_5458:()=>t3t,content_2321_546:()=>eZ,content_2321_5460:()=>n3t,content_2321_5462:()=>r3t,content_2321_5464:()=>p3t,content_2321_5466:()=>c3t,content_2321_5468:()=>l3t,content_2321_5470:()=>m3t,content_2321_5472:()=>h3t,content_2321_5474:()=>y3t,content_2321_5476:()=>w3t,content_2321_5478:()=>D3t,content_2321_548:()=>oZ,content_2321_5480:()=>g3t,content_2321_5482:()=>x3t,content_2321_5484:()=>T3t,content_2321_5486:()=>b3t,content_2321_5488:()=>Z3t,content_2321_5490:()=>S3t,content_2321_5492:()=>z3t,content_2321_5494:()=>A3t,content_2321_5496:()=>W3t,content_2321_5498:()=>B3t,content_2321_550:()=>sZ,content_2321_5500:()=>O3t,content_2321_5502:()=>j3t,content_2321_5504:()=>q3t,content_2321_5506:()=>H3t,content_2321_5508:()=>Q3t,content_2321_5510:()=>Y3t,content_2321_5512:()=>t4t,content_2321_5514:()=>n4t,content_2321_5516:()=>r4t,content_2321_5518:()=>p4t,content_2321_552:()=>iZ,content_2321_5520:()=>c4t,content_2321_5522:()=>l4t,content_2321_5524:()=>m4t,content_2321_5526:()=>h4t,content_2321_5528:()=>y4t,content_2321_5530:()=>w4t,content_2321_5532:()=>D4t,content_2321_5534:()=>g4t,content_2321_5536:()=>x4t,content_2321_5538:()=>T4t,content_2321_554:()=>aZ,content_2321_5540:()=>b4t,content_2321_5542:()=>Z4t,content_2321_5544:()=>S4t,content_2321_5546:()=>z4t,content_2321_5548:()=>A4t,content_2321_5550:()=>W4t,content_2321_5552:()=>B4t,content_2321_5554:()=>O4t,content_2321_5556:()=>j4t,content_2321_5558:()=>q4t,content_2321_556:()=>uZ,content_2321_5560:()=>H4t,content_2321_5562:()=>Q4t,content_2321_5564:()=>Y4t,content_2321_5566:()=>t6t,content_2321_5568:()=>n6t,content_2321_5570:()=>r6t,content_2321_5572:()=>p6t,content_2321_5574:()=>c6t,content_2321_5576:()=>l6t,content_2321_5578:()=>m6t,content_2321_558:()=>dZ,content_2321_5580:()=>h6t,content_2321_5582:()=>y6t,content_2321_5584:()=>w6t,content_2321_5586:()=>D6t,content_2321_5588:()=>g6t,content_2321_5590:()=>x6t,content_2321_5592:()=>T6t,content_2321_5594:()=>b6t,content_2321_5596:()=>Z6t,content_2321_5598:()=>S6t,content_2321_56:()=>JD,content_2321_560:()=>fZ,content_2321_5600:()=>z6t,content_2321_5602:()=>A6t,content_2321_5604:()=>W6t,content_2321_5606:()=>B6t,content_2321_5608:()=>O6t,content_2321_5610:()=>j6t,content_2321_5612:()=>q6t,content_2321_5614:()=>H6t,content_2321_5616:()=>Q6t,content_2321_5618:()=>Y6t,content_2321_562:()=>kZ,content_2321_5620:()=>t8t,content_2321_5622:()=>n8t,content_2321_5624:()=>r8t,content_2321_5626:()=>p8t,content_2321_5628:()=>c8t,content_2321_5630:()=>l8t,content_2321_5632:()=>m8t,content_2321_5634:()=>h8t,content_2321_5636:()=>y8t,content_2321_5638:()=>w8t,content_2321_564:()=>MZ,content_2321_5640:()=>D8t,content_2321_5642:()=>g8t,content_2321_5644:()=>x8t,content_2321_5646:()=>T8t,content_2321_5648:()=>b8t,content_2321_5650:()=>Z8t,content_2321_5652:()=>S8t,content_2321_5654:()=>z8t,content_2321_5656:()=>A8t,content_2321_5658:()=>W8t,content_2321_566:()=>_Z,content_2321_5660:()=>B8t,content_2321_5662:()=>O8t,content_2321_5664:()=>j8t,content_2321_5666:()=>q8t,content_2321_5668:()=>H8t,content_2321_5670:()=>Q8t,content_2321_5672:()=>Y8t,content_2321_5674:()=>t5t,content_2321_5676:()=>n5t,content_2321_5678:()=>r5t,content_2321_568:()=>XZ,content_2321_5680:()=>p5t,content_2321_5682:()=>c5t,content_2321_5684:()=>l5t,content_2321_5686:()=>m5t,content_2321_5688:()=>h5t,content_2321_5690:()=>y5t,content_2321_5692:()=>w5t,content_2321_5694:()=>D5t,content_2321_5696:()=>g5t,content_2321_5698:()=>x5t,content_2321_570:()=>CZ,content_2321_5700:()=>T5t,content_2321_5702:()=>b5t,content_2321_5704:()=>Z5t,content_2321_5706:()=>S5t,content_2321_5708:()=>z5t,content_2321_5710:()=>A5t,content_2321_5712:()=>W5t,content_2321_5714:()=>B5t,content_2321_5716:()=>O5t,content_2321_5718:()=>j5t,content_2321_572:()=>vZ,content_2321_5720:()=>q5t,content_2321_5722:()=>H5t,content_2321_5724:()=>Q5t,content_2321_5726:()=>Y5t,content_2321_5728:()=>t7t,content_2321_5730:()=>n7t,content_2321_5732:()=>r7t,content_2321_5734:()=>p7t,content_2321_5736:()=>c7t,content_2321_5738:()=>l7t,content_2321_574:()=>LZ,content_2321_5740:()=>m7t,content_2321_5742:()=>h7t,content_2321_5744:()=>y7t,content_2321_5746:()=>w7t,content_2321_5748:()=>D7t,content_2321_5750:()=>g7t,content_2321_5752:()=>x7t,content_2321_5754:()=>T7t,content_2321_5756:()=>b7t,content_2321_5758:()=>Z7t,content_2321_576:()=>NZ,content_2321_5760:()=>S7t,content_2321_5762:()=>z7t,content_2321_5764:()=>A7t,content_2321_5766:()=>W7t,content_2321_5768:()=>B7t,content_2321_5770:()=>O7t,content_2321_5772:()=>j7t,content_2321_5774:()=>q7t,content_2321_5776:()=>H7t,content_2321_5778:()=>Q7t,content_2321_578:()=>RZ,content_2321_5780:()=>Y7t,content_2321_5782:()=>t9t,content_2321_5784:()=>n9t,content_2321_5786:()=>r9t,content_2321_5788:()=>p9t,content_2321_5790:()=>c9t,content_2321_5792:()=>l9t,content_2321_5794:()=>m9t,content_2321_5796:()=>h9t,content_2321_5798:()=>y9t,content_2321_58:()=>KD,content_2321_580:()=>PZ,content_2321_5800:()=>w9t,content_2321_5802:()=>D9t,content_2321_5804:()=>g9t,content_2321_5806:()=>x9t,content_2321_5808:()=>T9t,content_2321_5810:()=>b9t,content_2321_5812:()=>Z9t,content_2321_5814:()=>S9t,content_2321_5816:()=>z9t,content_2321_5818:()=>A9t,content_2321_582:()=>IZ,content_2321_5820:()=>W9t,content_2321_5822:()=>B9t,content_2321_5824:()=>O9t,content_2321_5826:()=>j9t,content_2321_5828:()=>q9t,content_2321_5830:()=>H9t,content_2321_5832:()=>Q9t,content_2321_5834:()=>Y9t,content_2321_5836:()=>tte,content_2321_5838:()=>nte,content_2321_584:()=>EZ,content_2321_5840:()=>rte,content_2321_5842:()=>pte,content_2321_5844:()=>cte,content_2321_5846:()=>lte,content_2321_5848:()=>mte,content_2321_5850:()=>hte,content_2321_5852:()=>yte,content_2321_5854:()=>wte,content_2321_5856:()=>Dte,content_2321_5858:()=>gte,content_2321_586:()=>FZ,content_2321_5860:()=>xte,content_2321_5862:()=>Tte,content_2321_5864:()=>bte,content_2321_5866:()=>Zte,content_2321_5868:()=>Ste,content_2321_5870:()=>zte,content_2321_5872:()=>Ate,content_2321_5874:()=>Wte,content_2321_5876:()=>Bte,content_2321_5878:()=>Ote,content_2321_588:()=>GZ,content_2321_5880:()=>jte,content_2321_5882:()=>qte,content_2321_5884:()=>Hte,content_2321_5886:()=>Qte,content_2321_5888:()=>Yte,content_2321_5890:()=>tee,content_2321_5892:()=>nee,content_2321_5894:()=>ree,content_2321_5896:()=>pee,content_2321_5898:()=>cee,content_2321_590:()=>UZ,content_2321_5900:()=>lee,content_2321_5902:()=>mee,content_2321_5904:()=>hee,content_2321_5906:()=>yee,content_2321_5908:()=>wee,content_2321_5910:()=>Dee,content_2321_5912:()=>gee,content_2321_5914:()=>xee,content_2321_5916:()=>Tee,content_2321_5918:()=>bee,content_2321_592:()=>VZ,content_2321_5920:()=>Zee,content_2321_5922:()=>See,content_2321_5924:()=>zee,content_2321_5926:()=>Aee,content_2321_5928:()=>Wee,content_2321_5930:()=>Bee,content_2321_5932:()=>Oee,content_2321_5934:()=>jee,content_2321_5936:()=>qee,content_2321_5938:()=>Hee,content_2321_594:()=>$Z,content_2321_5940:()=>Qee,content_2321_5942:()=>Yee,content_2321_5944:()=>tne,content_2321_5946:()=>nne,content_2321_5948:()=>rne,content_2321_5950:()=>pne,content_2321_5952:()=>cne,content_2321_5954:()=>lne,content_2321_5956:()=>mne,content_2321_5958:()=>hne,content_2321_596:()=>JZ,content_2321_5960:()=>yne,content_2321_5962:()=>wne,content_2321_5964:()=>Dne,content_2321_5966:()=>gne,content_2321_5968:()=>xne,content_2321_5970:()=>Tne,content_2321_5972:()=>bne,content_2321_5974:()=>Zne,content_2321_5976:()=>Sne,content_2321_5978:()=>zne,content_2321_598:()=>KZ,content_2321_5980:()=>Ane,content_2321_5982:()=>Wne,content_2321_5984:()=>Bne,content_2321_5986:()=>One,content_2321_5988:()=>jne,content_2321_5990:()=>qne,content_2321_5992:()=>Hne,content_2321_5994:()=>Qne,content_2321_5996:()=>Yne,content_2321_5998:()=>toe,content_2321_6:()=>eD,content_2321_60:()=>e_,content_2321_600:()=>eN,content_2321_6000:()=>noe,content_2321_6002:()=>roe,content_2321_6004:()=>poe,content_2321_6006:()=>coe,content_2321_6008:()=>loe,content_2321_6010:()=>moe,content_2321_6012:()=>hoe,content_2321_6014:()=>yoe,content_2321_6016:()=>woe,content_2321_6018:()=>Doe,content_2321_602:()=>oN,content_2321_6020:()=>goe,content_2321_6022:()=>xoe,content_2321_6024:()=>Toe,content_2321_6026:()=>boe,content_2321_6028:()=>Zoe,content_2321_6030:()=>Soe,content_2321_6032:()=>zoe,content_2321_6034:()=>Aoe,content_2321_6036:()=>Woe,content_2321_6038:()=>Boe,content_2321_604:()=>sN,content_2321_6040:()=>Ooe,content_2321_6042:()=>joe,content_2321_6044:()=>qoe,content_2321_6046:()=>Hoe,content_2321_6048:()=>Qoe,content_2321_6050:()=>Yoe,content_2321_6052:()=>tre,content_2321_6054:()=>nre,content_2321_6056:()=>rre,content_2321_6058:()=>pre,content_2321_606:()=>iN,content_2321_6060:()=>cre,content_2321_6062:()=>lre,content_2321_6064:()=>mre,content_2321_6066:()=>hre,content_2321_6068:()=>yre,content_2321_6070:()=>wre,content_2321_6072:()=>Dre,content_2321_6074:()=>gre,content_2321_6076:()=>xre,content_2321_6078:()=>Tre,content_2321_608:()=>aN,content_2321_6080:()=>bre,content_2321_6082:()=>Zre,content_2321_6084:()=>Sre,content_2321_6086:()=>zre,content_2321_6088:()=>Are,content_2321_6090:()=>Wre,content_2321_6092:()=>Bre,content_2321_6094:()=>Ore,content_2321_6096:()=>jre,content_2321_6098:()=>qre,content_2321_610:()=>uN,content_2321_6100:()=>Hre,content_2321_6102:()=>Qre,content_2321_6104:()=>Yre,content_2321_6106:()=>tse,content_2321_6108:()=>nse,content_2321_6110:()=>rse,content_2321_6112:()=>pse,content_2321_6114:()=>cse,content_2321_6116:()=>lse,content_2321_6118:()=>mse,content_2321_612:()=>dN,content_2321_6120:()=>hse,content_2321_6122:()=>yse,content_2321_6124:()=>wse,content_2321_6126:()=>Dse,content_2321_6128:()=>gse,content_2321_6130:()=>xse,content_2321_6132:()=>Tse,content_2321_6134:()=>bse,content_2321_6136:()=>Zse,content_2321_6138:()=>Sse,content_2321_614:()=>fN,content_2321_6140:()=>zse,content_2321_6142:()=>Ase,content_2321_6144:()=>Wse,content_2321_6146:()=>Bse,content_2321_6148:()=>Ose,content_2321_6150:()=>jse,content_2321_6152:()=>qse,content_2321_6154:()=>Hse,content_2321_6156:()=>Qse,content_2321_6158:()=>Yse,content_2321_616:()=>kN,content_2321_6160:()=>tpe,content_2321_6162:()=>npe,content_2321_6164:()=>rpe,content_2321_6166:()=>ppe,content_2321_6168:()=>cpe,content_2321_6170:()=>lpe,content_2321_6172:()=>mpe,content_2321_6174:()=>hpe,content_2321_6176:()=>ype,content_2321_6178:()=>wpe,content_2321_618:()=>MN,content_2321_6180:()=>Dpe,content_2321_6182:()=>gpe,content_2321_6184:()=>xpe,content_2321_6186:()=>Tpe,content_2321_6188:()=>bpe,content_2321_6190:()=>Zpe,content_2321_6192:()=>Spe,content_2321_6194:()=>zpe,content_2321_6196:()=>Ape,content_2321_6198:()=>Wpe,content_2321_62:()=>o_,content_2321_620:()=>_N,content_2321_6200:()=>Bpe,content_2321_6202:()=>Ope,content_2321_6204:()=>jpe,content_2321_6206:()=>qpe,content_2321_6208:()=>Hpe,content_2321_6210:()=>Qpe,content_2321_6212:()=>Ype,content_2321_6214:()=>tie,content_2321_6216:()=>nie,content_2321_6218:()=>rie,content_2321_622:()=>XN,content_2321_6220:()=>pie,content_2321_6222:()=>cie,content_2321_6224:()=>lie,content_2321_6226:()=>mie,content_2321_6228:()=>hie,content_2321_6230:()=>yie,content_2321_6232:()=>wie,content_2321_6234:()=>Die,content_2321_6236:()=>gie,content_2321_6238:()=>xie,content_2321_624:()=>CN,content_2321_6240:()=>Tie,content_2321_6242:()=>bie,content_2321_6244:()=>Zie,content_2321_6246:()=>Sie,content_2321_6248:()=>zie,content_2321_6250:()=>Aie,content_2321_6252:()=>Wie,content_2321_6254:()=>Bie,content_2321_6256:()=>Oie,content_2321_6258:()=>jie,content_2321_626:()=>vN,content_2321_6260:()=>qie,content_2321_6262:()=>Hie,content_2321_6264:()=>Qie,content_2321_6266:()=>Yie,content_2321_6268:()=>tce,content_2321_6270:()=>nce,content_2321_6272:()=>rce,content_2321_6274:()=>pce,content_2321_6276:()=>cce,content_2321_6278:()=>lce,content_2321_628:()=>LN,content_2321_6280:()=>mce,content_2321_6282:()=>hce,content_2321_6284:()=>yce,content_2321_6286:()=>wce,content_2321_6288:()=>Dce,content_2321_6290:()=>gce,content_2321_6292:()=>xce,content_2321_6294:()=>Tce,content_2321_6296:()=>bce,content_2321_6298:()=>Zce,content_2321_630:()=>NN,content_2321_6300:()=>Sce,content_2321_6302:()=>zce,content_2321_6304:()=>Ace,content_2321_6306:()=>Wce,content_2321_6308:()=>Bce,content_2321_6310:()=>Oce,content_2321_6312:()=>jce,content_2321_6314:()=>qce,content_2321_6316:()=>Hce,content_2321_6318:()=>Qce,content_2321_632:()=>RN,content_2321_6320:()=>Yce,content_2321_6322:()=>tae,content_2321_6324:()=>nae,content_2321_6326:()=>rae,content_2321_6328:()=>pae,content_2321_6330:()=>cae,content_2321_6332:()=>lae,content_2321_6334:()=>mae,content_2321_6336:()=>hae,content_2321_6338:()=>yae,content_2321_634:()=>PN,content_2321_6340:()=>wae,content_2321_6342:()=>Dae,content_2321_6344:()=>gae,content_2321_6346:()=>xae,content_2321_6348:()=>Tae,content_2321_6350:()=>bae,content_2321_6352:()=>Zae,content_2321_6354:()=>Sae,content_2321_6356:()=>zae,content_2321_6358:()=>Aae,content_2321_636:()=>IN,content_2321_6360:()=>Wae,content_2321_6362:()=>Bae,content_2321_6364:()=>Oae,content_2321_6366:()=>jae,content_2321_6368:()=>qae,content_2321_6370:()=>Hae,content_2321_6372:()=>Qae,content_2321_6374:()=>Yae,content_2321_6376:()=>tle,content_2321_6378:()=>nle,content_2321_638:()=>EN,content_2321_6380:()=>rle,content_2321_6382:()=>ple,content_2321_6384:()=>cle,content_2321_6386:()=>lle,content_2321_6388:()=>mle,content_2321_6390:()=>hle,content_2321_6392:()=>yle,content_2321_6394:()=>wle,content_2321_6396:()=>Dle,content_2321_6398:()=>gle,content_2321_64:()=>s_,content_2321_640:()=>FN,content_2321_6400:()=>xle,content_2321_6402:()=>Tle,content_2321_6404:()=>ble,content_2321_6406:()=>Zle,content_2321_6408:()=>Sle,content_2321_6410:()=>zle,content_2321_6412:()=>Ale,content_2321_6414:()=>Wle,content_2321_6416:()=>Ble,content_2321_6418:()=>Ole,content_2321_642:()=>GN,content_2321_6420:()=>jle,content_2321_6422:()=>qle,content_2321_6424:()=>Hle,content_2321_6426:()=>Qle,content_2321_6428:()=>Yle,content_2321_6430:()=>tue,content_2321_6432:()=>nue,content_2321_6434:()=>rue,content_2321_6436:()=>pue,content_2321_6438:()=>cue,content_2321_644:()=>UN,content_2321_6440:()=>lue,content_2321_6442:()=>mue,content_2321_6444:()=>hue,content_2321_6446:()=>yue,content_2321_6448:()=>wue,content_2321_6450:()=>Due,content_2321_6452:()=>gue,content_2321_6454:()=>xue,content_2321_6456:()=>Tue,content_2321_6458:()=>bue,content_2321_646:()=>VN,content_2321_6460:()=>Zue,content_2321_6462:()=>Sue,content_2321_6464:()=>zue,content_2321_6466:()=>Aue,content_2321_6468:()=>Wue,content_2321_6470:()=>Bue,content_2321_6472:()=>Oue,content_2321_6474:()=>jue,content_2321_6476:()=>que,content_2321_6478:()=>Hue,content_2321_648:()=>$N,content_2321_6480:()=>Que,content_2321_6482:()=>Yue,content_2321_6484:()=>tme,content_2321_6486:()=>nme,content_2321_6488:()=>rme,content_2321_6490:()=>pme,content_2321_6492:()=>cme,content_2321_6494:()=>lme,content_2321_6496:()=>mme,content_2321_6498:()=>hme,content_2321_650:()=>JN,content_2321_6500:()=>yme,content_2321_6502:()=>wme,content_2321_6504:()=>Dme,content_2321_6506:()=>gme,content_2321_6508:()=>xme,content_2321_6510:()=>Tme,content_2321_6512:()=>bme,content_2321_6514:()=>Zme,content_2321_6516:()=>Sme,content_2321_6518:()=>zme,content_2321_652:()=>KN,content_2321_6520:()=>Ame,content_2321_6522:()=>Wme,content_2321_6524:()=>Bme,content_2321_6526:()=>Ome,content_2321_6528:()=>jme,content_2321_6530:()=>qme,content_2321_6532:()=>Hme,content_2321_6534:()=>Qme,content_2321_6536:()=>Yme,content_2321_6538:()=>tde,content_2321_654:()=>eS,content_2321_6540:()=>nde,content_2321_6542:()=>rde,content_2321_6544:()=>pde,content_2321_6546:()=>cde,content_2321_6548:()=>lde,content_2321_6550:()=>mde,content_2321_6552:()=>hde,content_2321_6554:()=>yde,content_2321_6556:()=>wde,content_2321_6558:()=>Dde,content_2321_656:()=>oS,content_2321_6560:()=>gde,content_2321_6562:()=>xde,content_2321_6564:()=>Tde,content_2321_6566:()=>bde,content_2321_6568:()=>Zde,content_2321_6570:()=>Sde,content_2321_6572:()=>zde,content_2321_6574:()=>Ade,content_2321_6576:()=>Wde,content_2321_6578:()=>Bde,content_2321_658:()=>sS,content_2321_6580:()=>Ode,content_2321_6582:()=>jde,content_2321_6584:()=>qde,content_2321_6586:()=>Hde,content_2321_6588:()=>Qde,content_2321_6590:()=>Yde,content_2321_6592:()=>the,content_2321_6594:()=>nhe,content_2321_6596:()=>rhe,content_2321_6598:()=>phe,content_2321_66:()=>i_,content_2321_660:()=>iS,content_2321_6600:()=>che,content_2321_6602:()=>lhe,content_2321_6604:()=>mhe,content_2321_6606:()=>hhe,content_2321_6608:()=>yhe,content_2321_6610:()=>whe,content_2321_6612:()=>Dhe,content_2321_6614:()=>ghe,content_2321_6616:()=>xhe,content_2321_6618:()=>The,content_2321_662:()=>aS,content_2321_6620:()=>bhe,content_2321_6622:()=>Zhe,content_2321_6624:()=>She,content_2321_6626:()=>zhe,content_2321_6628:()=>Ahe,content_2321_6630:()=>Whe,content_2321_6632:()=>Bhe,content_2321_6634:()=>Ohe,content_2321_6636:()=>jhe,content_2321_6638:()=>qhe,content_2321_664:()=>uS,content_2321_6640:()=>Hhe,content_2321_6642:()=>Qhe,content_2321_6644:()=>Yhe,content_2321_6646:()=>tfe,content_2321_6648:()=>nfe,content_2321_6650:()=>rfe,content_2321_6652:()=>pfe,content_2321_6654:()=>cfe,content_2321_6656:()=>lfe,content_2321_6658:()=>mfe,content_2321_666:()=>dS,content_2321_6660:()=>hfe,content_2321_6662:()=>yfe,content_2321_6664:()=>wfe,content_2321_6666:()=>Dfe,content_2321_6668:()=>gfe,content_2321_6670:()=>xfe,content_2321_6672:()=>Tfe,content_2321_6674:()=>bfe,content_2321_6676:()=>Zfe,content_2321_6678:()=>Sfe,content_2321_668:()=>fS,content_2321_6680:()=>zfe,content_2321_6682:()=>Afe,content_2321_6684:()=>Wfe,content_2321_6686:()=>Bfe,content_2321_6688:()=>Ofe,content_2321_6690:()=>jfe,content_2321_6692:()=>qfe,content_2321_6694:()=>Hfe,content_2321_6696:()=>Qfe,content_2321_6698:()=>Yfe,content_2321_670:()=>kS,content_2321_6700:()=>tye,content_2321_6702:()=>nye,content_2321_6704:()=>rye,content_2321_6706:()=>pye,content_2321_6708:()=>cye,content_2321_6710:()=>lye,content_2321_6712:()=>mye,content_2321_6714:()=>hye,content_2321_6716:()=>yye,content_2321_6718:()=>wye,content_2321_672:()=>MS,content_2321_6720:()=>Dye,content_2321_6722:()=>gye,content_2321_6724:()=>xye,content_2321_6726:()=>Tye,content_2321_6728:()=>bye,content_2321_6730:()=>Zye,content_2321_6732:()=>Sye,content_2321_6734:()=>zye,content_2321_6736:()=>Aye,content_2321_6738:()=>Wye,content_2321_674:()=>_S,content_2321_6740:()=>Bye,content_2321_6742:()=>Oye,content_2321_6744:()=>jye,content_2321_6746:()=>qye,content_2321_6748:()=>Hye,content_2321_6750:()=>Qye,content_2321_6752:()=>Yye,content_2321_6754:()=>tke,content_2321_6756:()=>nke,content_2321_6758:()=>rke,content_2321_676:()=>XS,content_2321_6760:()=>pke,content_2321_6762:()=>cke,content_2321_6764:()=>lke,content_2321_6766:()=>mke,content_2321_6768:()=>hke,content_2321_6770:()=>yke,content_2321_6772:()=>wke,content_2321_6774:()=>Dke,content_2321_6776:()=>gke,content_2321_6778:()=>xke,content_2321_678:()=>CS,content_2321_6780:()=>Tke,content_2321_6782:()=>bke,content_2321_6784:()=>Zke,content_2321_6786:()=>Ske,content_2321_6788:()=>zke,content_2321_6790:()=>Ake,content_2321_6792:()=>Wke,content_2321_6794:()=>Bke,content_2321_6796:()=>Oke,content_2321_6798:()=>jke,content_2321_68:()=>a_,content_2321_680:()=>vS,content_2321_6800:()=>qke,content_2321_6802:()=>Hke,content_2321_6804:()=>Qke,content_2321_6806:()=>Yke,content_2321_6808:()=>twe,content_2321_6810:()=>nwe,content_2321_6812:()=>rwe,content_2321_6814:()=>pwe,content_2321_6816:()=>cwe,content_2321_6818:()=>lwe,content_2321_682:()=>LS,content_2321_6820:()=>mwe,content_2321_6822:()=>hwe,content_2321_6824:()=>ywe,content_2321_6826:()=>wwe,content_2321_6828:()=>Dwe,content_2321_6830:()=>gwe,content_2321_6832:()=>xwe,content_2321_6834:()=>Twe,content_2321_6836:()=>bwe,content_2321_6838:()=>Zwe,content_2321_684:()=>NS,content_2321_6840:()=>Swe,content_2321_6842:()=>zwe,content_2321_6844:()=>Awe,content_2321_6846:()=>Wwe,content_2321_6848:()=>Bwe,content_2321_6850:()=>Owe,content_2321_6852:()=>jwe,content_2321_6854:()=>qwe,content_2321_6856:()=>Hwe,content_2321_6858:()=>Qwe,content_2321_686:()=>RS,content_2321_6860:()=>Ywe,content_2321_6862:()=>tMe,content_2321_6864:()=>nMe,content_2321_6866:()=>rMe,content_2321_6868:()=>pMe,content_2321_6870:()=>cMe,content_2321_6872:()=>lMe,content_2321_6874:()=>mMe,content_2321_6876:()=>hMe,content_2321_6878:()=>yMe,content_2321_688:()=>PS,content_2321_6880:()=>wMe,content_2321_6882:()=>DMe,content_2321_6884:()=>gMe,content_2321_6886:()=>xMe,content_2321_6888:()=>TMe,content_2321_6890:()=>bMe,content_2321_6892:()=>ZMe,content_2321_6894:()=>SMe,content_2321_6896:()=>zMe,content_2321_6898:()=>AMe,content_2321_690:()=>IS,content_2321_6900:()=>WMe,content_2321_6902:()=>BMe,content_2321_6904:()=>OMe,content_2321_6906:()=>jMe,content_2321_6908:()=>qMe,content_2321_6910:()=>HMe,content_2321_6912:()=>QMe,content_2321_6914:()=>YMe,content_2321_6916:()=>tDe,content_2321_6918:()=>nDe,content_2321_692:()=>ES,content_2321_6920:()=>rDe,content_2321_6922:()=>pDe,content_2321_6924:()=>cDe,content_2321_6926:()=>lDe,content_2321_6928:()=>mDe,content_2321_6930:()=>hDe,content_2321_6932:()=>yDe,content_2321_6934:()=>wDe,content_2321_6936:()=>DDe,content_2321_6938:()=>gDe,content_2321_694:()=>FS,content_2321_6940:()=>xDe,content_2321_6942:()=>TDe,content_2321_6944:()=>bDe,content_2321_6946:()=>ZDe,content_2321_6948:()=>SDe,content_2321_6950:()=>zDe,content_2321_6952:()=>ADe,content_2321_6954:()=>WDe,content_2321_6956:()=>BDe,content_2321_6958:()=>ODe,content_2321_696:()=>GS,content_2321_6960:()=>jDe,content_2321_6962:()=>qDe,content_2321_6964:()=>HDe,content_2321_6966:()=>QDe,content_2321_6968:()=>YDe,content_2321_6970:()=>t_e,content_2321_6972:()=>n_e,content_2321_6974:()=>r_e,content_2321_6976:()=>p_e,content_2321_6978:()=>c_e,content_2321_698:()=>US,content_2321_6980:()=>l_e,content_2321_6982:()=>m_e,content_2321_6984:()=>h_e,content_2321_6986:()=>y_e,content_2321_6988:()=>w_e,content_2321_6990:()=>D_e,content_2321_6992:()=>g_e,content_2321_6994:()=>x_e,content_2321_6996:()=>T_e,content_2321_6998:()=>b_e,content_2321_70:()=>u_,content_2321_700:()=>VS,content_2321_7000:()=>Z_e,content_2321_7002:()=>S_e,content_2321_7004:()=>z_e,content_2321_7006:()=>A_e,content_2321_7008:()=>W_e,content_2321_7010:()=>B_e,content_2321_7012:()=>O_e,content_2321_7014:()=>j_e,content_2321_7016:()=>q_e,content_2321_7018:()=>H_e,content_2321_702:()=>$S,content_2321_7020:()=>Q_e,content_2321_7022:()=>Y_e,content_2321_7024:()=>tge,content_2321_7026:()=>nge,content_2321_7028:()=>rge,content_2321_7030:()=>pge,content_2321_7032:()=>cge,content_2321_7034:()=>lge,content_2321_7036:()=>mge,content_2321_7038:()=>hge,content_2321_704:()=>JS,content_2321_7040:()=>yge,content_2321_7042:()=>wge,content_2321_7044:()=>Dge,content_2321_7046:()=>gge,content_2321_7048:()=>xge,content_2321_7050:()=>Tge,content_2321_7052:()=>bge,content_2321_7054:()=>Zge,content_2321_7056:()=>Sge,content_2321_7058:()=>zge,content_2321_706:()=>KS,content_2321_7060:()=>Age,content_2321_7062:()=>Wge,content_2321_7064:()=>Bge,content_2321_7066:()=>Oge,content_2321_7068:()=>jge,content_2321_7070:()=>qge,content_2321_7072:()=>Hge,content_2321_7074:()=>Qge,content_2321_7076:()=>Yge,content_2321_7078:()=>tXe,content_2321_708:()=>eR,content_2321_7080:()=>nXe,content_2321_7082:()=>rXe,content_2321_7084:()=>pXe,content_2321_7086:()=>cXe,content_2321_7088:()=>lXe,content_2321_7090:()=>mXe,content_2321_7092:()=>hXe,content_2321_7094:()=>yXe,content_2321_7096:()=>wXe,content_2321_7098:()=>DXe,content_2321_710:()=>oR,content_2321_7100:()=>gXe,content_2321_7102:()=>xXe,content_2321_712:()=>sR,content_2321_714:()=>iR,content_2321_716:()=>aR,content_2321_718:()=>uR,content_2321_72:()=>d_,content_2321_720:()=>dR,content_2321_722:()=>fR,content_2321_724:()=>kR,content_2321_726:()=>MR,content_2321_728:()=>_R,content_2321_730:()=>XR,content_2321_732:()=>CR,content_2321_734:()=>vR,content_2321_736:()=>LR,content_2321_738:()=>NR,content_2321_74:()=>f_,content_2321_740:()=>RR,content_2321_742:()=>PR,content_2321_744:()=>IR,content_2321_746:()=>ER,content_2321_748:()=>FR,content_2321_750:()=>GR,content_2321_752:()=>UR,content_2321_754:()=>VR,content_2321_756:()=>$R,content_2321_758:()=>JR,content_2321_76:()=>k_,content_2321_760:()=>KR,content_2321_762:()=>ez,content_2321_764:()=>oz,content_2321_766:()=>sz,content_2321_768:()=>iz,content_2321_770:()=>az,content_2321_772:()=>uz,content_2321_774:()=>dz,content_2321_776:()=>fz,content_2321_778:()=>kz,content_2321_78:()=>M_,content_2321_780:()=>Mz,content_2321_782:()=>_z,content_2321_784:()=>Xz,content_2321_786:()=>Cz,content_2321_788:()=>vz,content_2321_790:()=>Lz,content_2321_792:()=>Nz,content_2321_794:()=>Rz,content_2321_796:()=>Pz,content_2321_798:()=>Iz,content_2321_8:()=>oD,content_2321_80:()=>__,content_2321_800:()=>Ez,content_2321_802:()=>Fz,content_2321_804:()=>Gz,content_2321_806:()=>Uz,content_2321_808:()=>Vz,content_2321_810:()=>$z,content_2321_812:()=>Jz,content_2321_814:()=>Kz,content_2321_816:()=>eP,content_2321_818:()=>oP,content_2321_82:()=>X_,content_2321_820:()=>sP,content_2321_822:()=>iP,content_2321_824:()=>aP,content_2321_826:()=>uP,content_2321_828:()=>dP,content_2321_830:()=>fP,content_2321_832:()=>kP,content_2321_834:()=>MP,content_2321_836:()=>_P,content_2321_838:()=>XP,content_2321_84:()=>C_,content_2321_840:()=>CP,content_2321_842:()=>vP,content_2321_844:()=>LP,content_2321_846:()=>NP,content_2321_848:()=>RP,content_2321_850:()=>PP,content_2321_852:()=>IP,content_2321_854:()=>EP,content_2321_856:()=>FP,content_2321_858:()=>GP,content_2321_86:()=>v_,content_2321_860:()=>UP,content_2321_862:()=>VP,content_2321_864:()=>$P,content_2321_866:()=>JP,content_2321_868:()=>KP,content_2321_870:()=>eA,content_2321_872:()=>oA,content_2321_874:()=>sA,content_2321_876:()=>iA,content_2321_878:()=>aA,content_2321_88:()=>L_,content_2321_880:()=>uA,content_2321_882:()=>dA,content_2321_884:()=>fA,content_2321_886:()=>kA,content_2321_888:()=>MA,content_2321_890:()=>_A,content_2321_892:()=>XA,content_2321_894:()=>CA,content_2321_896:()=>vA,content_2321_898:()=>LA,content_2321_90:()=>N_,content_2321_900:()=>NA,content_2321_902:()=>RA,content_2321_904:()=>PA,content_2321_906:()=>IA,content_2321_908:()=>EA,content_2321_910:()=>FA,content_2321_912:()=>GA,content_2321_914:()=>UA,content_2321_916:()=>VA,content_2321_918:()=>$A,content_2321_92:()=>R_,content_2321_920:()=>JA,content_2321_922:()=>KA,content_2321_924:()=>eI,content_2321_926:()=>oI,content_2321_928:()=>sI,content_2321_930:()=>iI,content_2321_932:()=>aI,content_2321_934:()=>uI,content_2321_936:()=>dI,content_2321_938:()=>fI,content_2321_94:()=>P_,content_2321_940:()=>kI,content_2321_942:()=>MI,content_2321_944:()=>_I,content_2321_946:()=>XI,content_2321_948:()=>CI,content_2321_950:()=>vI,content_2321_952:()=>LI,content_2321_954:()=>NI,content_2321_956:()=>RI,content_2321_958:()=>PI,content_2321_96:()=>I_,content_2321_960:()=>II,content_2321_962:()=>EI,content_2321_964:()=>FI,content_2321_966:()=>GI,content_2321_968:()=>UI,content_2321_970:()=>VI,content_2321_972:()=>$I,content_2321_974:()=>JI,content_2321_976:()=>KI,content_2321_978:()=>eW,content_2321_98:()=>E_,content_2321_980:()=>oW,content_2321_982:()=>sW,content_2321_984:()=>iW,content_2321_986:()=>aW,content_2321_988:()=>uW,content_2321_990:()=>dW,content_2321_992:()=>fW,content_2321_994:()=>kW,content_2321_996:()=>MW,content_2321_998:()=>_W});var r=n(2784),s=n(7896),p=n(30876);const i={toc:[]};function c(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},i,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Property decorators."))}c.isMDXComponent=!0;const a={toc:[]};function l(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},a,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,p.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a lazy decorator."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function that returns the value of this property."))}h.isMDXComponent=!0;const f={toc:[]};function y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},f,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscriptions and triggering of events."))}y.isMDXComponent=!0;const k={toc:[]};function w(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},k,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,p.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}w.isMDXComponent=!0;const M={toc:[]};function D(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},M,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}D.isMDXComponent=!0;const _={toc:[]};function g(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches an asynchronous ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}g.isMDXComponent=!0;const X={toc:[]};function x(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},X,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}x.isMDXComponent=!0;const C={toc:[]};function T(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},C,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}T.isMDXComponent=!0;const v={toc:[]};function b(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},v,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}b.isMDXComponent=!0;const L={toc:[]};function Z(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},L,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Z.isMDXComponent=!0;const N={toc:[]};function S(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},N,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}S.isMDXComponent=!0;const R={toc:[]};function z(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},R,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}z.isMDXComponent=!0;const P={toc:[]};function A(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},P,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}A.isMDXComponent=!0;const I={toc:[]};function W(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},I,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}W.isMDXComponent=!0;const E={toc:[]};function B(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},E,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}B.isMDXComponent=!0;const F={toc:[]};function O(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},F,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}O.isMDXComponent=!0;const G={toc:[]};function j(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},G,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}j.isMDXComponent=!0;const U={toc:[]};function q(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},U,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}q.isMDXComponent=!0;const V={toc:[]};function H(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},V,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}H.isMDXComponent=!0;const $={toc:[]};function Q(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Q.isMDXComponent=!0;const J={toc:[]};function Y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},J,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Y.isMDXComponent=!0;const K={toc:[]};function tt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},K,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value argument to subscribers."))}tt.isMDXComponent=!0;const et={toc:[]};function nt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},et,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A base for dispatching ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,p.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}nt.isMDXComponent=!0;const ot={toc:[]};function rt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}rt.isMDXComponent=!0;const st={toc:[]};function pt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},st,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}pt.isMDXComponent=!0;const it={toc:[]};function ct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},it,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}ct.isMDXComponent=!0;const at={toc:[]};function lt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},at,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}ht.isMDXComponent=!0;const ft={toc:[]};function yt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}yt.isMDXComponent=!0;const kt={toc:[]};function wt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}wt.isMDXComponent=!0;const Mt={toc:[]};function Dt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,p.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,p.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}Dt.isMDXComponent=!0;const _t={toc:[]};function gt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}gt.isMDXComponent=!0;const Xt={toc:[]};function xt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}xt.isMDXComponent=!0;const Ct={toc:[]};function Tt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}Tt.isMDXComponent=!0;const vt={toc:[]};function bt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Are subscribers being notified?"))}bt.isMDXComponent=!0;const Lt={toc:[]};function Zt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Notify all current and future subscribers."))}Zt.isMDXComponent=!0;const Nt={toc:[]};function St(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Stop notifying future subscribers."))}St.isMDXComponent=!0;const Rt={toc:[]};function zt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}zt.isMDXComponent=!0;const Pt={toc:[]};function At(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}At.isMDXComponent=!0;const It={toc:[]};function Wt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},It,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Wt.isMDXComponent=!0;const Et={toc:[]};function Bt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Et,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Bt.isMDXComponent=!0;const Ft={toc:[]};function Ot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Ot.isMDXComponent=!0;const Gt={toc:[]};function jt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}jt.isMDXComponent=!0;const Ut={toc:[]};function qt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}qt.isMDXComponent=!0;const Vt={toc:[]};function Ht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}Ht.isMDXComponent=!0;const $t={toc:[]};function Qt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}Qt.isMDXComponent=!0;const Jt={toc:[]};function Yt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Yt.isMDXComponent=!0;const Kt={toc:[]};function te(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}te.isMDXComponent=!0;const ee={toc:[]};function ne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}ne.isMDXComponent=!0;const oe={toc:[]};function re(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}re.isMDXComponent=!0;const se={toc:[]};function pe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},se,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}pe.isMDXComponent=!0;const ie={toc:[]};function ce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ce.isMDXComponent=!0;const ae={toc:[]};function le(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}le.isMDXComponent=!0;const ue={toc:[]};function me(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}me.isMDXComponent=!0;const de={toc:[]};function he(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},de,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}he.isMDXComponent=!0;const fe={toc:[]};function ye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}ye.isMDXComponent=!0;const ke={toc:[]};function we(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}we.isMDXComponent=!0;const Me={toc:[]};function De(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Me,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}De.isMDXComponent=!0;const _e={toc:[]};function ge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}ge.isMDXComponent=!0;const Xe={toc:[]};function xe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}xe.isMDXComponent=!0;const Ce={toc:[]};function Te(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Te.isMDXComponent=!0;const ve={toc:[]};function be(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ve,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}be.isMDXComponent=!0;const Le={toc:[]};function Ze(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Le,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}Ze.isMDXComponent=!0;const Ne={toc:[]};function Se(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}Se.isMDXComponent=!0;const Re={toc:[]};function ze(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Re,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}ze.isMDXComponent=!0;const Pe={toc:[]};function Ae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Ae.isMDXComponent=!0;const Ie={toc:[]};function We(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value."))}We.isMDXComponent=!0;const Ee={toc:[]};function Be(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}Be.isMDXComponent=!0;const Fe={toc:[]};function Oe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Setting the value will immediately notify all subscribers."))}Oe.isMDXComponent=!0;const Ge={toc:[]};function je(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set the current value of this dispatcher."))}je.isMDXComponent=!0;const Ue={toc:[]};function qe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new value."))}qe.isMDXComponent=!0;const Ve={toc:[]};function He(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ve,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}He.isMDXComponent=!0;const $e={toc:[]};function Qe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}Qe.isMDXComponent=!0;const Je={toc:[]};function Ye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Je,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ye.isMDXComponent=!0;const Ke={toc:[]};function tn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}tn.isMDXComponent=!0;const en={toc:[]};function nn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},en,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}nn.isMDXComponent=!0;const on={toc:[]};function rn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},on,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}rn.isMDXComponent=!0;const sn={toc:[]};function pn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}pn.isMDXComponent=!0;const cn={toc:[]};function an(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ln,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}dn.isMDXComponent=!0;const hn={toc:[]};function fn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}fn.isMDXComponent=!0;const yn={toc:[]};function kn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}kn.isMDXComponent=!0;const wn={toc:[]};function Mn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}Mn.isMDXComponent=!0;const Dn={toc:[]};function _n(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Dn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}_n.isMDXComponent=!0;const gn={toc:[]};function Xn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Xn.isMDXComponent=!0;const xn={toc:[]};function Cn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}Cn.isMDXComponent=!0;const Tn={toc:[]};function vn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Tn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}vn.isMDXComponent=!0;const bn={toc:[]};function Ln(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of times the timer has ticked."))}Ln.isMDXComponent=!0;const Zn={toc:[]};function Nn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Zn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator responsible for running this timer."))}Nn.isMDXComponent=!0;const Sn={toc:[]};function Rn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Sn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the timer ticks."))}Rn.isMDXComponent=!0;const zn={toc:[]};function Pn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current iteration index."))}Pn.isMDXComponent=!0;const An={toc:[]};function In(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},An,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}In.isMDXComponent=!0;const Wn={toc:[]};function En(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Wn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}En.isMDXComponent=!0;const Bn={toc:[]};function Fn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Bn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Fn.isMDXComponent=!0;const On={toc:[]};function Gn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},On,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Gn.isMDXComponent=!0;const jn={toc:[]};function Un(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Un.isMDXComponent=!0;const qn={toc:[]};function Vn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Vn.isMDXComponent=!0;const Hn={toc:[]};function $n(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Hn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}$n.isMDXComponent=!0;const Qn={toc:[]};function Jn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Qn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run tasks one after another."))}Jn.isMDXComponent=!0;const Yn={toc:[]};function Kn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Yn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Kn.isMDXComponent=!0;const to={toc:[]};function eo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},to,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}eo.isMDXComponent=!0;const no={toc:[]};function oo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},no,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}oo.isMDXComponent=!0;const ro={toc:[]};function so(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ro,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay in seconds"))}so.isMDXComponent=!0;const po={toc:[]};function io(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},po,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task or callback to run after the delay."))}io.isMDXComponent=!0;const co={toc:[]};function ao(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},co,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}ao.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Call the given callback every N seconds."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interval between subsequent calls."))}ho.isMDXComponent=!0;const fo={toc:[]};function yo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to be called."))}yo.isMDXComponent=!0;const ko={toc:[]};function wo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ko,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each iteration waits until the previous one is completed."))}wo.isMDXComponent=!0;const Mo={toc:[]};function Do(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}Do.isMDXComponent=!0;const _o={toc:[]};function go(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_o,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator N times."))}go.isMDXComponent=!0;const Xo={toc:[]};function xo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The number of iterations."))}xo.isMDXComponent=!0;const Co={toc:[]};function To(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Co,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}To.isMDXComponent=!0;const vo={toc:[]};function bo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}bo.isMDXComponent=!0;const Lo={toc:[]};function Zo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Zo.isMDXComponent=!0;const No={toc:[]};function So(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},No,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run a generator in a loop for the given amount of time."))}So.isMDXComponent=!0;const Ro={toc:[]};function zo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ro,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration in seconds."))}zo.isMDXComponent=!0;const Po={toc:[]};function Ao(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Po,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Ao.isMDXComponent=!0;const Io={toc:[]};function Wo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Io,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Wo.isMDXComponent=!0;const Eo={toc:[]};function Bo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Bo.isMDXComponent=!0;const Fo={toc:[]};function Oo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run a generator in a loop until the given time event."))}Oo.isMDXComponent=!0;const Go={toc:[]};function jo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Go,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The event."))}jo.isMDXComponent=!0;const Uo={toc:[]};function qo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}qo.isMDXComponent=!0;const Vo={toc:[]};function Ho(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Do nothing."))}Ho.isMDXComponent=!0;const $o={toc:[]};function Qo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$o,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Qo.isMDXComponent=!0;const Jo={toc:[]};function Yo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}Yo.isMDXComponent=!0;const Ko={toc:[]};function tr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ko,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}tr.isMDXComponent=!0;const er={toc:[]};function nr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},er,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}nr.isMDXComponent=!0;const or={toc:[]};function rr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},or,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}rr.isMDXComponent=!0;const sr={toc:[]};function pr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional name used when displaying this generator in the UI."))}pr.isMDXComponent=!0;const ir={toc:[]};function cr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ir,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}cr.isMDXComponent=!0;const ar={toc:[]};function lr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ar,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ur,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Start all tasks one after another with a constant delay between."))}hr.isMDXComponent=!0;const fr={toc:[]};function yr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay between each of the tasks."))}yr.isMDXComponent=!0;const kr={toc:[]};function wr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to be run in a sequence."))}wr.isMDXComponent=!0;const Mr={toc:[]};function Dr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}Dr.isMDXComponent=!0;const _r={toc:[]};function gr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_r,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for the given amount of time."))}gr.isMDXComponent=!0;const Xr={toc:[]};function xr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The relative time in seconds."))}xr.isMDXComponent=!0;const Cr={toc:[]};function Tr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}Tr.isMDXComponent=!0;const vr={toc:[]};function br(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}br.isMDXComponent=!0;const Lr={toc:[]};function Zr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}Zr.isMDXComponent=!0;const Nr={toc:[]};function Sr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the given time event."))}Sr.isMDXComponent=!0;const Rr={toc:[]};function zr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the time event."))}zr.isMDXComponent=!0;const Pr={toc:[]};function Ar(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}Ar.isMDXComponent=!0;const Ir={toc:[]};function Wr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ir,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Multi-media management."))}Wr.isMDXComponent=!0;const Er={toc:[]};function Br(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Er,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Br.isMDXComponent=!0;const Fr={toc:[]};function Or(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause/resume the audio."))}Or.isMDXComponent=!0;const Gr={toc:[]};function jr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the audio should be paused or resumed."))}jr.isMDXComponent=!0;const Ur={toc:[]};function qr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ur,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The absolute biggest value from the peaks array."))}qr.isMDXComponent=!0;const Vr={toc:[]};function Hr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of samples taken."))}Hr.isMDXComponent=!0;const $r={toc:[]};function Qr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$r,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Qr.isMDXComponent=!0;const Jr={toc:[]};function Yr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Samples per seconds."))}Yr.isMDXComponent=!0;const Kr={toc:[]};function ts(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Abstract scene representations and related utilities."))}ts.isMDXComponent=!0;const es={toc:[]};function ns(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},es,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Signifies the various stages of a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}ns.isMDXComponent=!0;const os={toc:[]};function rs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},os,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs after a render ends."))}rs.isMDXComponent=!0;const ss={toc:[]};function ps(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ss,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}ps.isMDXComponent=!0;const is={toc:[]};function cs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},is,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,p.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}cs.isMDXComponent=!0;const as={toc:[]};function ls(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},as,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,p.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},us,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes the state of a scene."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ds,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}hs.isMDXComponent=!0;const fs={toc:[]};function ys(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished transitioning in."))}ys.isMDXComponent=!0;const ks={toc:[]};function ws(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ks,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}ws.isMDXComponent=!0;const Ms={toc:[]};function Ds(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ms,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene is ready to transition out."))}Ds.isMDXComponent=!0;const _s={toc:[]};function gs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_s,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoking ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}gs.isMDXComponent=!0;const Xs={toc:[]};function xs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished."))}xs.isMDXComponent=!0;const Cs={toc:[]};function Ts(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has just been created/reset."))}Ts.isMDXComponent=!0;const vs={toc:[]};function bs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The default implementation of the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,p.kt)("p",null,"Uses generators to control the animation."))}bs.isMDXComponent=!0;const Ls={toc:[]};function Zs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ls,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}Zs.isMDXComponent=!0;const Ns={toc:[]};function Ss(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ns,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}Ss.isMDXComponent=!0;const Rs={toc:[]};function zs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}zs.isMDXComponent=!0;const Ps={toc:[]};function As(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ps,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,p.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}As.isMDXComponent=!0;const Is={toc:[]};function Ws(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Is,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,p.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Ws.isMDXComponent=!0;const Es={toc:[]};function Bs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Es,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}Bs.isMDXComponent=!0;const Fs={toc:[]};function Os(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}Os.isMDXComponent=!0;const Gs={toc:[]};function js(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}js.isMDXComponent=!0;const Us={toc:[]};function qs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Us,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}qs.isMDXComponent=!0;const Vs={toc:[]};function Hs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}Hs.isMDXComponent=!0;const $s={toc:[]};function Qs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$s,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Qs.isMDXComponent=!0;const Js={toc:[]};function Ys(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Js,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}Ys.isMDXComponent=!0;const Ks={toc:[]};function tp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ks,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}tp.isMDXComponent=!0;const ep={toc:[]};function np(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ep,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}np.isMDXComponent=!0;const op={toc:[]};function rp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},op,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}rp.isMDXComponent=!0;const sp={toc:[]};function pp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}pp.isMDXComponent=!0;const ip={toc:[]};function cp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ip,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}cp.isMDXComponent=!0;const ap={toc:[]};function lp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ap,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,p.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},up,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoke the given callback in the context of this scene."))}hp.isMDXComponent=!0;const fp={toc:[]};function yp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to invoke."))}yp.isMDXComponent=!0;const kp={toc:[]};function wp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}wp.isMDXComponent=!0;const Mp={toc:[]};function Dp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}Dp.isMDXComponent=!0;const _p={toc:[]};function gp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_p,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}gp.isMDXComponent=!0;const Xp={toc:[]};function xp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}xp.isMDXComponent=!0;const Cp={toc:[]};function Tp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}Tp.isMDXComponent=!0;const vp={toc:[]};function bp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}bp.isMDXComponent=!0;const Lp={toc:[]};function Zp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}Zp.isMDXComponent=!0;const Np={toc:[]};function Sp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Np,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}Sp.isMDXComponent=!0;const Rp={toc:[]};function zp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}zp.isMDXComponent=!0;const Pp={toc:[]};function Ap(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, an updated version of the description."))}Ap.isMDXComponent=!0;const Ip={toc:[]};function Wp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ip,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}Wp.isMDXComponent=!0;const Ep={toc:[]};function Bp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ep,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}Bp.isMDXComponent=!0;const Fp={toc:[]};function Op(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}Op.isMDXComponent=!0;const Gp={toc:[]};function jp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}jp.isMDXComponent=!0;const Up={toc:[]};function qp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Up,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}qp.isMDXComponent=!0;const Vp={toc:[]};function Hp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Lifecycle events for ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Hp.isMDXComponent=!0;const $p={toc:[]};function Qp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$p,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A random number generator based on\n",(0,p.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,p.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Qp.isMDXComponent=!0;const Jp={toc:[]};function Yp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get an array filled with random floats in the given range."))}Yp.isMDXComponent=!0;const Kp={toc:[]};function ti(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The size of the array."))}ti.isMDXComponent=!0;const ei={toc:[]};function ni(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ei,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}ni.isMDXComponent=!0;const oi={toc:[]};function ri(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range."))}ri.isMDXComponent=!0;const si={toc:[]};function pi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},si,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get an array filled with random integers in the given range."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"}),(0,p.kt)("li",{parentName:"ul"})))}pi.isMDXComponent=!0;const ii={toc:[]};function ci(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ii,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The size of the array."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}ci.isMDXComponent=!0;const ai={toc:[]};function li(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ai,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ui,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. Exclusive."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},di,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the next random float in the given range."))}hi.isMDXComponent=!0;const fi={toc:[]};function yi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}yi.isMDXComponent=!0;const ki={toc:[]};function wi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ki,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range."))}wi.isMDXComponent=!0;const Mi={toc:[]};function Di(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the next random integer in the given range."))}Di.isMDXComponent=!0;const _i={toc:[]};function gi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_i,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}gi.isMDXComponent=!0;const Xi={toc:[]};function xi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. Exclusive."))}xi.isMDXComponent=!0;const Ci={toc:[]};function Ti(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ci,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a new independent generator."))}Ti.isMDXComponent=!0;const vi={toc:[]};function bi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get variable signal if exists or create signal if not"))}bi.isMDXComponent=!0;const Li={toc:[]};function Zi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Li,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the variable."))}Zi.isMDXComponent=!0;const Ni={toc:[]};function Si(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ni,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}Si.isMDXComponent=!0;const Ri={toc:[]};function zi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ri,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get variable signal if exists or create signal if not"))}zi.isMDXComponent=!0;const Pi={toc:[]};function Ai(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset all stored signals."))}Ai.isMDXComponent=!0;const Ii={toc:[]};function Wi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ii,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update all signals with new project variable values."))}Wi.isMDXComponent=!0;const Ei={toc:[]};function Bi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ei,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes cached information about the timing of a scene."))}Bi.isMDXComponent=!0;const Fi={toc:[]};function Oi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes a complete scene together with the meta file."))}Oi.isMDXComponent=!0;const Gi={toc:[]};function ji(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Configuration object."))}ji.isMDXComponent=!0;const Ui={toc:[]};function qi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ui,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The class used to instantiate the scene."))}qi.isMDXComponent=!0;const Vi={toc:[]};function Hi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The stack trace at the moment of creation."))}Hi.isMDXComponent=!0;const $i={toc:[]};function Qi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$i,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Qi.isMDXComponent=!0;const Ji={toc:[]};function Yi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ji,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Yi.isMDXComponent=!0;const Ki={toc:[]};function tc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ki,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}tc.isMDXComponent=!0;const ec={toc:[]};function nc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ec,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for the inspected element."))}nc.isMDXComponent=!0;const oc={toc:[]};function rc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element for which to draw an overlay."))}rc.isMDXComponent=!0;const sc={toc:[]};function pc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}pc.isMDXComponent=!0;const ic={toc:[]};function cc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ic,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}cc.isMDXComponent=!0;const ac={toc:[]};function lc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ac,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the attributes of the inspected element."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to inspect."))}hc.isMDXComponent=!0;const fc={toc:[]};function yc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a possible element to inspect at a given position."))}yc.isMDXComponent=!0;const kc={toc:[]};function wc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The x coordinate."))}wc.isMDXComponent=!0;const Mc={toc:[]};function Dc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The y coordinate."))}Dc.isMDXComponent=!0;const _c={toc:[]};function gc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_c,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}gc.isMDXComponent=!0;const Xc={toc:[]};function xc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the inspected element is still valid."))}xc.isMDXComponent=!0;const Cc={toc:[]};function Tc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to validate."))}Tc.isMDXComponent=!0;const vc={toc:[]};function bc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,p.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}bc.isMDXComponent=!0;const Lc={toc:[]};function Zc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main interface for scenes."))}Zc.isMDXComponent=!0;const Nc={toc:[]};function Sc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}Sc.isMDXComponent=!0;const Rc={toc:[]};function zc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}zc.isMDXComponent=!0;const Pc={toc:[]};function Ac(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}Ac.isMDXComponent=!0;const Ic={toc:[]};function Wc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ic,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,p.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Wc.isMDXComponent=!0;const Ec={toc:[]};function Bc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ec,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,p.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Bc.isMDXComponent=!0;const Fc={toc:[]};function Oc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}Oc.isMDXComponent=!0;const Gc={toc:[]};function jc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}jc.isMDXComponent=!0;const Uc={toc:[]};function qc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,p.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}qc.isMDXComponent=!0;const Vc={toc:[]};function Hc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}Hc.isMDXComponent=!0;const $c={toc:[]};function Qc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$c,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}Qc.isMDXComponent=!0;const Jc={toc:[]};function Yc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}Yc.isMDXComponent=!0;const Kc={toc:[]};function ta(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}ta.isMDXComponent=!0;const ea={toc:[]};function na(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ea,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}na.isMDXComponent=!0;const oa={toc:[]};function ra(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}ra.isMDXComponent=!0;const sa={toc:[]};function pa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}pa.isMDXComponent=!0;const ia={toc:[]};function ca(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ia,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}ca.isMDXComponent=!0;const aa={toc:[]};function la(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ua,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,p.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},da,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}ha.isMDXComponent=!0;const fa={toc:[]};function ya(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}ya.isMDXComponent=!0;const ka={toc:[]};function wa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ka,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}wa.isMDXComponent=!0;const Ma={toc:[]};function Da(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ma,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}Da.isMDXComponent=!0;const _a={toc:[]};function ga(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_a,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}ga.isMDXComponent=!0;const Xa={toc:[]};function xa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}xa.isMDXComponent=!0;const Ca={toc:[]};function Ta(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ca,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}Ta.isMDXComponent=!0;const va={toc:[]};function ba(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},va,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}ba.isMDXComponent=!0;const La={toc:[]};function Za(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},La,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}Za.isMDXComponent=!0;const Na={toc:[]};function Sa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Na,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, an updated version of the description."))}Sa.isMDXComponent=!0;const Ra={toc:[]};function za(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ra,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}za.isMDXComponent=!0;const Pa={toc:[]};function Aa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}Aa.isMDXComponent=!0;const Ia={toc:[]};function Wa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ia,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}Wa.isMDXComponent=!0;const Ea={toc:[]};function Ba(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ea,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}Ba.isMDXComponent=!0;const Fa={toc:[]};function Oa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Oa.isMDXComponent=!0;const Ga={toc:[]};function ja(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ga,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each class implementing the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}ja.isMDXComponent=!0;const Ua={toc:[]};function qa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ua,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constructor used when creating new scenes."))}qa.isMDXComponent=!0;const Va={toc:[]};function Ha(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Va,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,p.kt)("inlineCode",{parentName:"a"},"config")),"."))}Ha.isMDXComponent=!0;const $a={toc:[]};function Qa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$a,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes a scene exposed by scene files."))}Qa.isMDXComponent=!0;const Ja={toc:[]};function Ya(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ja,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Configuration object."))}Ya.isMDXComponent=!0;const Ka={toc:[]};function tl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ka,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The class used to instantiate the scene."))}tl.isMDXComponent=!0;const el={toc:[]};function nl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},el,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The stack trace at the moment of creation."))}nl.isMDXComponent=!0;const ol={toc:[]};function rl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ol,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}rl.isMDXComponent=!0;const sl={toc:[]};function pl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A part of the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,p.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}pl.isMDXComponent=!0;const il={toc:[]};function cl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},il,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}cl.isMDXComponent=!0;const al={toc:[]};function ll(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},al,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ul,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}hl.isMDXComponent=!0;const fl={toc:[]};function yl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents attributes of an inspected element."))}yl.isMDXComponent=!0;const kl={toc:[]};function wl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}wl.isMDXComponent=!0;const Ml={toc:[]};function Dl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ml,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents an element to inspect."))}Dl.isMDXComponent=!0;const _l={toc:[]};function gl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_l,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A runtime representation of the scene metadata."))}gl.isMDXComponent=!0;const Xl={toc:[]};function xl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a runtime representation of the scene metadata."))}xl.isMDXComponent=!0;const Cl={toc:[]};function Tl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}Tl.isMDXComponent=!0;const vl={toc:[]};function bl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}bl.isMDXComponent=!0;const Ll={toc:[]};function Zl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ll,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the signal is currently using its initial value."))}Zl.isMDXComponent=!0;const Nl={toc:[]};function Sl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}Sl.isMDXComponent=!0;const Rl={toc:[]};function zl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}zl.isMDXComponent=!0;const Pl={toc:[]};function Al(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}Al.isMDXComponent=!0;const Il={toc:[]};function Wl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Il,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Wl.isMDXComponent=!0;const El={toc:[]};function Bl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},El,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Bl.isMDXComponent=!0;const Fl={toc:[]};function Ol(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Ol.isMDXComponent=!0;const Gl={toc:[]};function jl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}jl.isMDXComponent=!0;const Ul={toc:[]};function ql(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ul,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}ql.isMDXComponent=!0;const Vl={toc:[]};function Hl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}Hl.isMDXComponent=!0;const $l={toc:[]};function Ql(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$l,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the signal is currently using its initial value."))}Ql.isMDXComponent=!0;const Jl={toc:[]};function Yl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}Yl.isMDXComponent=!0;const Kl={toc:[]};function tu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}tu.isMDXComponent=!0;const eu={toc:[]};function nu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}nu.isMDXComponent=!0;const ou={toc:[]};function ru(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ou,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}ru.isMDXComponent=!0;const su={toc:[]};function pu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},su,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}pu.isMDXComponent=!0;const iu={toc:[]};function cu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}cu.isMDXComponent=!0;const au={toc:[]};function lu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},au,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},du,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the signal is currently using its initial value."))}hu.isMDXComponent=!0;const fu={toc:[]};function yu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}yu.isMDXComponent=!0;const ku={toc:[]};function wu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ku,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}wu.isMDXComponent=!0;const Mu={toc:[]};function Du(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Du.isMDXComponent=!0;const _u={toc:[]};function gu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_u,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Tween back to the original value."))}gu.isMDXComponent=!0;const Xu={toc:[]};function xu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the tween."))}xu.isMDXComponent=!0;const Cu={toc:[]};function Tu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function of the tween."))}Tu.isMDXComponent=!0;const vu={toc:[]};function bu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interpolation function of the tween."))}bu.isMDXComponent=!0;const Lu={toc:[]};function Zu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoke the given callback."))}Zu.isMDXComponent=!0;const Nu={toc:[]};function Su(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to invoke."))}Su.isMDXComponent=!0;const Ru={toc:[]};function zu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ru,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given task."))}zu.isMDXComponent=!0;const Pu={toc:[]};function Au(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator to run."))}Au.isMDXComponent=!0;const Iu={toc:[]};function Wu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Iu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Tween to the specified value."))}Wu.isMDXComponent=!0;const Eu={toc:[]};function Bu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for the specified duration."))}Bu.isMDXComponent=!0;const Fu={toc:[]};function Ou(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration to wait."))}Ou.isMDXComponent=!0;const Gu={toc:[]};function ju(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread management."))}ju.isMDXComponent=!0;const Uu={toc:[]};function qu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,p.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}qu.isMDXComponent=!0;const Vu={toc:[]};function Hu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A class representing an individual thread."))}Hu.isMDXComponent=!0;const $u={toc:[]};function Qu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$u,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}Qu.isMDXComponent=!0;const Ju={toc:[]};function Yu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ju,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}Yu.isMDXComponent=!0;const Ku={toc:[]};function tm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ku,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Used by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}tm.isMDXComponent=!0;const em={toc:[]};function nm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},em,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current time of this thread."))}nm.isMDXComponent=!0;const om={toc:[]};function rm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},om,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The next value to be passed to the wrapped generator."))}rm.isMDXComponent=!0;const sm={toc:[]};function pm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}pm.isMDXComponent=!0;const im={toc:[]};function cm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},im,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,p.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}cm.isMDXComponent=!0;const am={toc:[]};function lm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},am,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The fixed time of this thread."))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},um,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress the wrapped generator once."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the thread for the next update cycle."))}hm.isMDXComponent=!0;const fm={toc:[]};function ym(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delta time of the next cycle."))}ym.isMDXComponent=!0;const km={toc:[]};function wm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},km,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a normal function that returns a generator."))}wm.isMDXComponent=!0;const Mm={toc:[]};function Dm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,p.kt)("p",null,"Progress to the next frame:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,p.kt)("p",null,"Run another generator synchronously:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,p.kt)("p",null,"Run another generator concurrently:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,p.kt)("p",null,"Await a Promise:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}Dm.isMDXComponent=!0;const _m={toc:[]};function gm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_m,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}gm.isMDXComponent=!0;const Xm={toc:[]};function xm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Cancel all listed tasks."),(0,p.kt)("p",null,"Example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}xm.isMDXComponent=!0;const Cm={toc:[]};function Tm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to cancel."))}Tm.isMDXComponent=!0;const vm={toc:[]};function bm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}bm.isMDXComponent=!0;const Lm={toc:[]};function Zm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}Zm.isMDXComponent=!0;const Nm={toc:[]};function Sm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Sm.isMDXComponent=!0;const Rm={toc:[]};function zm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible thread ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}zm.isMDXComponent=!0;const Pm={toc:[]};function Am(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}Am.isMDXComponent=!0;const Im={toc:[]};function Wm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Im,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}Wm.isMDXComponent=!0;const Em={toc:[]};function Bm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Em,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}Bm.isMDXComponent=!0;const Fm={toc:[]};function Om(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}Om.isMDXComponent=!0;const Gm={toc:[]};function jm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until listed tasks are finished."))}jm.isMDXComponent=!0;const Um={toc:[]};function qm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Um,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}qm.isMDXComponent=!0;const Vm={toc:[]};function Hm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}Hm.isMDXComponent=!0;const $m={toc:[]};function Qm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$m,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"From the perspective of the external generator, ",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}Qm.isMDXComponent=!0;const Jm={toc:[]};function Ym(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}Ym.isMDXComponent=!0;const Km={toc:[]};function td(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Km,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a context in which generators can be run concurrently."))}td.isMDXComponent=!0;const ed={toc:[]};function nd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ed,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function that returns the generator to run."))}nd.isMDXComponent=!0;const od={toc:[]};function rd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},od,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}rd.isMDXComponent=!0;const sd={toc:[]};function pd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Transitions between scenes."))}pd.isMDXComponent=!0;const id={toc:[]};function cd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},id,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Perform a transition that fades between the scenes."))}cd.isMDXComponent=!0;const ad={toc:[]};function ld(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ad,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ud,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The direction in which to slide."))}hd.isMDXComponent=!0;const fd={toc:[]};function yd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition."))}yd.isMDXComponent=!0;const kd={toc:[]};function wd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}wd.isMDXComponent=!0;const Md={toc:[]};function Dd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Md,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the current scene is rendered."))}Dd.isMDXComponent=!0;const _d={toc:[]};function gd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_d,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the previous scene is rendered."))}gd.isMDXComponent=!0;const Xd={toc:[]};function xd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}xd.isMDXComponent=!0;const Cd={toc:[]};function Td(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The area on which to zoom in."))}Td.isMDXComponent=!0;const vd={toc:[]};function bd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition."))}bd.isMDXComponent=!0;const Ld={toc:[]};function Zd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ld,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}Zd.isMDXComponent=!0;const Nd={toc:[]};function Sd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The area from which to zoom out."))}Sd.isMDXComponent=!0;const Rd={toc:[]};function zd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition."))}zd.isMDXComponent=!0;const Pd={toc:[]};function Ad(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolation and timing of tweens."))}Ad.isMDXComponent=!0;const Id={toc:[]};function Wd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Id,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any old key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,p.kt)("ol",null,(0,p.kt)("li",{parentName:"ol"})))}Wd.isMDXComponent=!0;const Ed={toc:[]};function Bd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ed,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}Bd.isMDXComponent=!0;const Fd={toc:[]};function Od(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}Od.isMDXComponent=!0;const Gd={toc:[]};function jd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}jd.isMDXComponent=!0;const Ud={toc:[]};function qd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ud,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}qd.isMDXComponent=!0;const Vd={toc:[]};function Hd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}Hd.isMDXComponent=!0;const $d={toc:[]};function Qd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$d,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}Qd.isMDXComponent=!0;const Jd={toc:[]};function Yd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}Yd.isMDXComponent=!0;const Kd={toc:[]};function th(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}th.isMDXComponent=!0;const eh={toc:[]};function nh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}nh.isMDXComponent=!0;const oh={toc:[]};function rh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}rh.isMDXComponent=!0;const sh={toc:[]};function ph(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Complex types used in animations."))}ph.isMDXComponent=!0;const ih={toc:[]};function ch(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ih,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,p.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,p.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,p.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,p.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,p.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,p.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}ch.isMDXComponent=!0;const ah={toc:[]};function lh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ah,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the determinant of the matrix."))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,p.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}hh.isMDXComponent=!0;const fh={toc:[]};function yh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the inverse of the matrix."))}yh.isMDXComponent=!0;const kh={toc:[]};function wh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}wh.isMDXComponent=!0;const Mh={toc:[]};function Dh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}Dh.isMDXComponent=!0;const _h={toc:[]};function gh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_h,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the provided matrix to this matrix."))}gh.isMDXComponent=!0;const Xh={toc:[]};function xh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The matrix to add"))}xh.isMDXComponent=!0;const Ch={toc:[]};function Th(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ch,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}Th.isMDXComponent=!0;const vh={toc:[]};function bh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}bh.isMDXComponent=!0;const Lh={toc:[]};function Zh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index of the component vector to retrieve."))}Zh.isMDXComponent=!0;const Nh={toc:[]};function Sh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Sh.isMDXComponent=!0;const Rh={toc:[]};function zh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}zh.isMDXComponent=!0;const Ph={toc:[]};function Ah(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ph,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}Ah.isMDXComponent=!0;const Ih={toc:[]};function Wh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ih,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The matrix to multiply with"))}Wh.isMDXComponent=!0;const Eh={toc:[]};function Bh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}Bh.isMDXComponent=!0;const Fh={toc:[]};function Oh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}Oh.isMDXComponent=!0;const Gh={toc:[]};function jh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value by which to scale each term"))}jh.isMDXComponent=!0;const Uh={toc:[]};function qh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}qh.isMDXComponent=!0;const Vh={toc:[]};function Hh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}Hh.isMDXComponent=!0;const $h={toc:[]};function Qh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$h,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}Qh.isMDXComponent=!0;const Jh={toc:[]};function Yh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The angle by which to rotate the matrix."))}Yh.isMDXComponent=!0;const Kh={toc:[]};function tf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the angle is provided in degrees."))}tf.isMDXComponent=!0;const ef={toc:[]};function nf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ef,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}nf.isMDXComponent=!0;const of={toc:[]};function rf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},of,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}rf.isMDXComponent=!0;const sf={toc:[]};function pf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index of the row to retrieve."))}pf.isMDXComponent=!0;const cf={toc:[]};function af(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If ",(0,p.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,p.kt)("p",null,"If ",(0,p.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,p.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scale the x and y component vectors of the matrix."))}df.isMDXComponent=!0;const hf={toc:[]};function ff(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The factor by which to scale the matrix"))}ff.isMDXComponent=!0;const yf={toc:[]};function kf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}kf.isMDXComponent=!0;const wf={toc:[]};function Mf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}Mf.isMDXComponent=!0;const Df={toc:[]};function _f(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Df,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subtract the provided matrix from this matrix."))}_f.isMDXComponent=!0;const gf={toc:[]};function Xf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The matrix to subract"))}Xf.isMDXComponent=!0;const xf={toc:[]};function Cf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If ",(0,p.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,p.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Cf.isMDXComponent=!0;const Tf={toc:[]};function vf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Tf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}vf.isMDXComponent=!0;const bf={toc:[]};function Lf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}Lf.isMDXComponent=!0;const Zf={toc:[]};function Nf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Zf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The vector by which to translate the matrix"))}Nf.isMDXComponent=!0;const Sf={toc:[]};function Rf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Sf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a two-dimensional vector."))}Rf.isMDXComponent=!0;const zf={toc:[]};function Pf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}Pf.isMDXComponent=!0;const Af={toc:[]};function If(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Af,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}If.isMDXComponent=!0;const Wf={toc:[]};function Ef(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Wf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}Ef.isMDXComponent=!0;const Bf={toc:[]};function Ff(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Bf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,p.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}Ff.isMDXComponent=!0;const Of={toc:[]};function Gf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Of,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if two vectors are equal to each other."))}Gf.isMDXComponent=!0;const jf={toc:[]};function Uf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The vector to compare."))}Uf.isMDXComponent=!0;const qf={toc:[]};function Vf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The allowed error threshold when comparing the vectors."))}Vf.isMDXComponent=!0;const Hf={toc:[]};function $f(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Hf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,p.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}$f.isMDXComponent=!0;const Qf={toc:[]};function Jf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Qf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if two vectors are exactly equal to each other."))}Jf.isMDXComponent=!0;const Yf={toc:[]};function Kf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Yf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The vector to compare."))}Kf.isMDXComponent=!0;const ty={toc:[]};function ey(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ty,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}ey.isMDXComponent=!0;const ny={toc:[]};function oy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ny,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}oy.isMDXComponent=!0;const ry={toc:[]};function sy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ry,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The x component of the vector."))}sy.isMDXComponent=!0;const py={toc:[]};function iy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},py,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The y component of the vector."))}iy.isMDXComponent=!0;const cy={toc:[]};function ay(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}ay.isMDXComponent=!0;const ly={toc:[]};function uy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ly,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The x component of the vector."))}uy.isMDXComponent=!0;const my={toc:[]};function dy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},my,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The y component of the vector."))}dy.isMDXComponent=!0;const hy={toc:[]};function fy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}fy.isMDXComponent=!0;const yy={toc:[]};function ky(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The unclipped RGB components."))}ky.isMDXComponent=!0;const wy={toc:[]};function My(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}My.isMDXComponent=!0;const Dy={toc:[]};function _y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Dy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}_y.isMDXComponent=!0;const gy={toc:[]};function Xy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Xy.isMDXComponent=!0;const xy={toc:[]};function Cy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}Cy.isMDXComponent=!0;const Ty={toc:[]};function vy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ty,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}vy.isMDXComponent=!0;const by={toc:[]};function Ly(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},by,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}Ly.isMDXComponent=!0;const Zy={toc:[]};function Ny(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Zy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}Ny.isMDXComponent=!0;const Sy={toc:[]};function Ry(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Sy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Alias of ",(0,p.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}Ry.isMDXComponent=!0;const zy={toc:[]};function Py(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}Py.isMDXComponent=!0;const Ay={toc:[]};function Iy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ay,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}Iy.isMDXComponent=!0;const Wy={toc:[]};function Ey(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Wy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}Ey.isMDXComponent=!0;const By={toc:[]};function Fy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},By,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,p.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,p.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}Fy.isMDXComponent=!0;const Oy={toc:[]};function Gy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Oy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}Gy.isMDXComponent=!0;const jy={toc:[]};function Uy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,p.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,p.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}Uy.isMDXComponent=!0;const qy={toc:[]};function Vy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}Vy.isMDXComponent=!0;const Hy={toc:[]};function $y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Hy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("strong",{parentName:"p"},"L"),", ",(0,p.kt)("strong",{parentName:"p"},"a"),", and ",(0,p.kt)("strong",{parentName:"p"},"b")," components."))}$y.isMDXComponent=!0;const Qy={toc:[]};function Jy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Qy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}Jy.isMDXComponent=!0;const Yy={toc:[]};function Ky(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Yy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,p.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,p.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}Ky.isMDXComponent=!0;const tk={toc:[]};function ek(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}ek.isMDXComponent=!0;const nk={toc:[]};function ok(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}ok.isMDXComponent=!0;const rk={toc:[]};function sk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}sk.isMDXComponent=!0;const pk={toc:[]};function ik(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}ik.isMDXComponent=!0;const ck={toc:[]};function ak(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ck,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get and set the color opacity."))}ak.isMDXComponent=!0;const lk={toc:[]};function uk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,p.kt)("code",null,"'rgb'")))}uk.isMDXComponent=!0;const mk={toc:[]};function dk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Similar to saturate, but the opposite direction."))}dk.isMDXComponent=!0;const hk={toc:[]};function fk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"set"))}fk.isMDXComponent=!0;const yk={toc:[]};function kk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns a single channel value.\nAlso"))}kk.isMDXComponent=!0;const wk={toc:[]};function Mk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}Mk.isMDXComponent=!0;const Dk={toc:[]};function _k(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Dk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color as hexadecimal string."))}_k.isMDXComponent=!0;const gk={toc:[]};function Xk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,p.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,p.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}Xk.isMDXComponent=!0;const xk={toc:[]};function Ck(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,p.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}Ck.isMDXComponent=!0;const Tk={toc:[]};function vk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Tk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}vk.isMDXComponent=!0;const bk={toc:[]};function Lk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}Lk.isMDXComponent=!0;const Zk={toc:[]};function Nk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Zk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}Nk.isMDXComponent=!0;const Sk={toc:[]};function Rk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Sk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}Rk.isMDXComponent=!0;const zk={toc:[]};function Pk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}Pk.isMDXComponent=!0;const Ak={toc:[]};function Ik(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ak,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}Ik.isMDXComponent=!0;const Wk={toc:[]};function Ek(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Wk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}Ek.isMDXComponent=!0;const Bk={toc:[]};function Fk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Bk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}Fk.isMDXComponent=!0;const Ok={toc:[]};function Gk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ok,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}Gk.isMDXComponent=!0;const jk={toc:[]};function Uk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}Uk.isMDXComponent=!0;const qk={toc:[]};function Vk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert the given origin to a vector representing its offset."))}Vk.isMDXComponent=!0;const Hk={toc:[]};function $k(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Hk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The origin to convert."))}$k.isMDXComponent=!0;const Qk={toc:[]};function Jk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Qk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"General utilities and helper functions."))}Jk.isMDXComponent=!0;const Yk={toc:[]};function Kk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Yk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}Kk.isMDXComponent=!0;const tw={toc:[]};function ew(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Optional override for formatting stack traces"))}ew.isMDXComponent=!0;const nw={toc:[]};function ow(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create .stack property on a target object"))}ow.isMDXComponent=!0;const rw={toc:[]};function sw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}sw.isMDXComponent=!0;const pw={toc:[]};function iw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A constant for converting degrees to radians"))}iw.isMDXComponent=!0;const cw={toc:[]};function aw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}aw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A constant for converting radians to degrees"))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is a shortcut for calling ",(0,p.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}dw.isMDXComponent=!0;const hw={toc:[]};function fw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}fw.isMDXComponent=!0;const yw={toc:[]};function kw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Logs a debug message with an arbitrary payload."))}kw.isMDXComponent=!0;const ww={toc:[]};function Mw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ww,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The payload to log"))}Mw.isMDXComponent=!0;const Dw={toc:[]};function _w(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Dw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Mark the given function as deprecated."))}_w.isMDXComponent=!0;const gw={toc:[]};function Xw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function to deprecate."))}Xw.isMDXComponent=!0;const xw={toc:[]};function Cw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The log message."))}Cw.isMDXComponent=!0;const Tw={toc:[]};function vw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Tw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The optional log remarks."))}vw.isMDXComponent=!0;const bw={toc:[]};function Lw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}Lw.isMDXComponent=!0;const Zw={toc:[]};function Nw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Zw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Mark the current scene as ready to transition out."))}Nw.isMDXComponent=!0;const Sw={toc:[]};function Rw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Sw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}Rw.isMDXComponent=!0;const zw={toc:[]};function Pw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,p.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}Pw.isMDXComponent=!0;const Aw={toc:[]};function Iw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Aw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}Iw.isMDXComponent=!0;const Ww={toc:[]};function Ew(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ww,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}Ew.isMDXComponent=!0;const Bw={toc:[]};function Fw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Bw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The length of the array."))}Fw.isMDXComponent=!0;const Ow={toc:[]};function Gw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ow,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}Gw.isMDXComponent=!0;const jw={toc:[]};function Uw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}Uw.isMDXComponent=!0;const qw={toc:[]};function Vw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}Vw.isMDXComponent=!0;const Hw={toc:[]};function $w(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Hw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}$w.isMDXComponent=!0;const Qw={toc:[]};function Jw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Qw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}Jw.isMDXComponent=!0;const Yw={toc:[]};function Kw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Yw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}Kw.isMDXComponent=!0;const tM={toc:[]};function eM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}eM.isMDXComponent=!0;const nM={toc:[]};function oM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}oM.isMDXComponent=!0;const rM={toc:[]};function sM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value by which to increment or decrement."))}sM.isMDXComponent=!0;const pM={toc:[]};function iM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}iM.isMDXComponent=!0;const cM={toc:[]};function aM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context before render."))}aM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context after render."))}dM.isMDXComponent=!0;const hM={toc:[]};function fM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}fM.isMDXComponent=!0;const yM={toc:[]};function kM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}kM.isMDXComponent=!0;const wM={toc:[]};function MM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the event in seconds."))}MM.isMDXComponent=!0;const DM={toc:[]};function _M(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Register a time event and get its duration in seconds."))}_M.isMDXComponent=!0;const gM={toc:[]};function XM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the event."))}XM.isMDXComponent=!0;const xM={toc:[]};function CM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the playback status."))}CM.isMDXComponent=!0;const TM={toc:[]};function vM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the random number generator for the current scene."))}vM.isMDXComponent=!0;const bM={toc:[]};function LM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the random number generator for the given seed."))}LM.isMDXComponent=!0;const ZM={toc:[]};function NM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The seed for the generator."))}NM.isMDXComponent=!0;const SM={toc:[]};function RM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}RM.isMDXComponent=!0;const zM={toc:[]};function PM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current scene."))}PM.isMDXComponent=!0;const AM={toc:[]};function IM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current thread."))}IM.isMDXComponent=!0;const WM={toc:[]};function EM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}EM.isMDXComponent=!0;const BM={toc:[]};function FM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}FM.isMDXComponent=!0;const OM={toc:[]};function GM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the real time since the start of the animation."))}GM.isMDXComponent=!0;const jM={toc:[]};function UM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This rewrites a remote url like ",(0,p.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,p.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}UM.isMDXComponent=!0;const qM={toc:[]};function VM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Route the given url through a local proxy."))}VM.isMDXComponent=!0;const HM={toc:[]};function $M(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}$M.isMDXComponent=!0;const QM={toc:[]};function JM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n")))}JM.isMDXComponent=!0;const YM={toc:[]};function KM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node for drawing circular shapes."))}KM.isMDXComponent=!0;const tD={toc:[]};function eD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}eD.isMDXComponent=!0;const nD={toc:[]};function oD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}oD.isMDXComponent=!0;const rD={toc:[]};function sD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}sD.isMDXComponent=!0;const pD={toc:[]};function iD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}iD.isMDXComponent=!0;const cD={toc:[]};function aD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}aD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}dD.isMDXComponent=!0;const hD={toc:[]};function fD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}fD.isMDXComponent=!0;const yD={toc:[]};function kD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}kD.isMDXComponent=!0;const wD={toc:[]};function MD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}MD.isMDXComponent=!0;const DD={toc:[]};function _D(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}_D.isMDXComponent=!0;const gD={toc:[]};function XD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}XD.isMDXComponent=!0;const xD={toc:[]};function CD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}CD.isMDXComponent=!0;const TD={toc:[]};function vD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A closed circle will look like a pie chart:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,p.kt)("p",null,"An open one will look like an arc:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}vD.isMDXComponent=!0;const bD={toc:[]};function LD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"false"))}LD.isMDXComponent=!0;const ZD={toc:[]};function ND(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the path of this circle should be closed."))}ND.isMDXComponent=!0;const SD={toc:[]};function RD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property can be used together with ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,p.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}RD.isMDXComponent=!0;const zD={toc:[]};function PD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"360"))}PD.isMDXComponent=!0;const AD={toc:[]};function ID(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ending angle in degrees for the circle sector."))}ID.isMDXComponent=!0;const WD={toc:[]};function ED(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}ED.isMDXComponent=!0;const BD={toc:[]};function FD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}FD.isMDXComponent=!0;const OD={toc:[]};function GD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}GD.isMDXComponent=!0;const jD={toc:[]};function UD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}UD.isMDXComponent=!0;const qD={toc:[]};function VD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}VD.isMDXComponent=!0;const HD={toc:[]};function $D(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}$D.isMDXComponent=!0;const QD={toc:[]};function JD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}JD.isMDXComponent=!0;const YD={toc:[]};function KD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}KD.isMDXComponent=!0;const t_={toc:[]};function e_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},t_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}e_.isMDXComponent=!0;const n_={toc:[]};function o_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},n_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}o_.isMDXComponent=!0;const r_={toc:[]};function s_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},r_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}s_.isMDXComponent=!0;const p_={toc:[]};function i_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},p_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}i_.isMDXComponent=!0;const c_={toc:[]};function a_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},c_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}a_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},l_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},m_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property can be used together with ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,p.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}d_.isMDXComponent=!0;const h_={toc:[]};function f_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},h_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"0"))}f_.isMDXComponent=!0;const y_={toc:[]};function k_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},y_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The starting angle in degrees for the circle sector."))}k_.isMDXComponent=!0;const w_={toc:[]};function M_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},w_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}M_.isMDXComponent=!0;const D_={toc:[]};function __(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},D_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}__.isMDXComponent=!0;const g_={toc:[]};function X_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},g_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}X_.isMDXComponent=!0;const x_={toc:[]};function C_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},x_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}C_.isMDXComponent=!0;const T_={toc:[]};function v_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},T_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}v_.isMDXComponent=!0;const b_={toc:[]};function L_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},b_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}L_.isMDXComponent=!0;const Z_={toc:[]};function N_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Z_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}N_.isMDXComponent=!0;const S_={toc:[]};function R_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},S_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}R_.isMDXComponent=!0;const z_={toc:[]};function P_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},z_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}P_.isMDXComponent=!0;const A_={toc:[]};function I_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},A_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}I_.isMDXComponent=!0;const W_={toc:[]};function E_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},W_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}E_.isMDXComponent=!0;const B_={toc:[]};function F_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},B_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}F_.isMDXComponent=!0;const O_={toc:[]};function G_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},O_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}G_.isMDXComponent=!0;const j_={toc:[]};function U_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},j_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}U_.isMDXComponent=!0;const q_={toc:[]};function V_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},q_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}V_.isMDXComponent=!0;const H_={toc:[]};function $_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},H_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}$_.isMDXComponent=!0;const Q_={toc:[]};function J_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Q_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}J_.isMDXComponent=!0;const Y_={toc:[]};function K_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Y_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}K_.isMDXComponent=!0;const tg={toc:[]};function eg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}eg.isMDXComponent=!0;const ng={toc:[]};function og(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ng,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}og.isMDXComponent=!0;const rg={toc:[]};function sg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}sg.isMDXComponent=!0;const pg={toc:[]};function ig(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}ig.isMDXComponent=!0;const cg={toc:[]};function ag(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}ag.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}dg.isMDXComponent=!0;const hg={toc:[]};function fg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}fg.isMDXComponent=!0;const yg={toc:[]};function kg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}kg.isMDXComponent=!0;const wg={toc:[]};function Mg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Mg.isMDXComponent=!0;const Dg={toc:[]};function _g(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Dg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}_g.isMDXComponent=!0;const gg={toc:[]};function Xg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Xg.isMDXComponent=!0;const xg={toc:[]};function Cg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}Cg.isMDXComponent=!0;const Tg={toc:[]};function vg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Tg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}vg.isMDXComponent=!0;const bg={toc:[]};function Lg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}Lg.isMDXComponent=!0;const Zg={toc:[]};function Ng(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Zg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Ng.isMDXComponent=!0;const Sg={toc:[]};function Rg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Sg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Rg.isMDXComponent=!0;const zg={toc:[]};function Pg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}Pg.isMDXComponent=!0;const Ag={toc:[]};function Ig(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ag,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Ig.isMDXComponent=!0;const Wg={toc:[]};function Eg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Wg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Eg.isMDXComponent=!0;const Bg={toc:[]};function Fg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Bg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Fg.isMDXComponent=!0;const Og={toc:[]};function Gg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Og,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Gg.isMDXComponent=!0;const jg={toc:[]};function Ug(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}Ug.isMDXComponent=!0;const qg={toc:[]};function Vg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}Vg.isMDXComponent=!0;const Hg={toc:[]};function $g(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Hg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}$g.isMDXComponent=!0;const Qg={toc:[]};function Jg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Qg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Jg.isMDXComponent=!0;const Yg={toc:[]};function Kg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Yg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Kg.isMDXComponent=!0;const tX={toc:[]};function eX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}eX.isMDXComponent=!0;const nX={toc:[]};function oX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}oX.isMDXComponent=!0;const rX={toc:[]};function sX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}sX.isMDXComponent=!0;const pX={toc:[]};function iX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}iX.isMDXComponent=!0;const cX={toc:[]};function aX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}aX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dX.isMDXComponent=!0;const hX={toc:[]};function fX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}fX.isMDXComponent=!0;const yX={toc:[]};function kX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}kX.isMDXComponent=!0;const wX={toc:[]};function MX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}MX.isMDXComponent=!0;const DX={toc:[]};function _X(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}_X.isMDXComponent=!0;const gX={toc:[]};function XX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}XX.isMDXComponent=!0;const xX={toc:[]};function CX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}CX.isMDXComponent=!0;const TX={toc:[]};function vX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}vX.isMDXComponent=!0;const bX={toc:[]};function LX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}LX.isMDXComponent=!0;const ZX={toc:[]};function NX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}NX.isMDXComponent=!0;const SX={toc:[]};function RX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}RX.isMDXComponent=!0;const zX={toc:[]};function PX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}PX.isMDXComponent=!0;const AX={toc:[]};function IX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}IX.isMDXComponent=!0;const WX={toc:[]};function EX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}EX.isMDXComponent=!0;const BX={toc:[]};function FX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}FX.isMDXComponent=!0;const OX={toc:[]};function GX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}GX.isMDXComponent=!0;const jX={toc:[]};function UX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}UX.isMDXComponent=!0;const qX={toc:[]};function VX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}VX.isMDXComponent=!0;const HX={toc:[]};function $X(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}$X.isMDXComponent=!0;const QX={toc:[]};function JX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}JX.isMDXComponent=!0;const YX={toc:[]};function KX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}KX.isMDXComponent=!0;const tx={toc:[]};function ex(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}ex.isMDXComponent=!0;const nx={toc:[]};function ox(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}ox.isMDXComponent=!0;const rx={toc:[]};function sx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}sx.isMDXComponent=!0;const px={toc:[]};function ix(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},px,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ix.isMDXComponent=!0;const cx={toc:[]};function ax(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}ax.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}dx.isMDXComponent=!0;const hx={toc:[]};function fx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}fx.isMDXComponent=!0;const yx={toc:[]};function kx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}kx.isMDXComponent=!0;const wx={toc:[]};function Mx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Mx.isMDXComponent=!0;const Dx={toc:[]};function _x(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Dx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_x.isMDXComponent=!0;const gx={toc:[]};function Xx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Xx.isMDXComponent=!0;const xx={toc:[]};function Cx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}Cx.isMDXComponent=!0;const Tx={toc:[]};function vx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Tx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}vx.isMDXComponent=!0;const bx={toc:[]};function Lx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Lx.isMDXComponent=!0;const Zx={toc:[]};function Nx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Zx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Nx.isMDXComponent=!0;const Sx={toc:[]};function Rx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Sx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Rx.isMDXComponent=!0;const zx={toc:[]};function Px(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Px.isMDXComponent=!0;const Ax={toc:[]};function Ix(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ax,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}Ix.isMDXComponent=!0;const Wx={toc:[]};function Ex(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Wx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}Ex.isMDXComponent=!0;const Bx={toc:[]};function Fx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Bx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}Fx.isMDXComponent=!0;const Ox={toc:[]};function Gx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ox,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Gx.isMDXComponent=!0;const jx={toc:[]};function Ux(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Ux.isMDXComponent=!0;const qx={toc:[]};function Vx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Vx.isMDXComponent=!0;const Hx={toc:[]};function $x(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Hx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}$x.isMDXComponent=!0;const Qx={toc:[]};function Jx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Qx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}Jx.isMDXComponent=!0;const Yx={toc:[]};function Kx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Yx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Kx.isMDXComponent=!0;const tC={toc:[]};function eC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}eC.isMDXComponent=!0;const nC={toc:[]};function oC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}oC.isMDXComponent=!0;const rC={toc:[]};function sC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}sC.isMDXComponent=!0;const pC={toc:[]};function iC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}iC.isMDXComponent=!0;const cC={toc:[]};function aC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}aC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}dC.isMDXComponent=!0;const hC={toc:[]};function fC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}fC.isMDXComponent=!0;const yC={toc:[]};function kC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}kC.isMDXComponent=!0;const wC={toc:[]};function MC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}MC.isMDXComponent=!0;const DC={toc:[]};function _C(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}_C.isMDXComponent=!0;const gC={toc:[]};function XC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}XC.isMDXComponent=!0;const xC={toc:[]};function CC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Defining a cubic B\xe9zier curve using ",(0,p.kt)("inlineCode",{parentName:"p"},"points")," property."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  <CubicBezier\n    lineWidth={4}\n    stroke={'lightseagreen'}\n    p0={[-200, -200]}\n    p1={[100, -200]}\n    p2={[-100, 200]}\n    p3={[200, 200]}\n    end={0}\n  />\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}CC.isMDXComponent=!0;const TC={toc:[]};function vC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node for drawing a cubic B\xe9zier curve."))}vC.isMDXComponent=!0;const bC={toc:[]};function LC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}LC.isMDXComponent=!0;const ZC={toc:[]};function NC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}NC.isMDXComponent=!0;const SC={toc:[]};function RC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}RC.isMDXComponent=!0;const zC={toc:[]};function PC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}PC.isMDXComponent=!0;const AC={toc:[]};function IC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}IC.isMDXComponent=!0;const WC={toc:[]};function EC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}EC.isMDXComponent=!0;const BC={toc:[]};function FC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}FC.isMDXComponent=!0;const OC={toc:[]};function GC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}GC.isMDXComponent=!0;const jC={toc:[]};function UC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}UC.isMDXComponent=!0;const qC={toc:[]};function VC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}VC.isMDXComponent=!0;const HC={toc:[]};function $C(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}$C.isMDXComponent=!0;const QC={toc:[]};function JC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}JC.isMDXComponent=!0;const YC={toc:[]};function KC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}KC.isMDXComponent=!0;const tT={toc:[]};function eT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}eT.isMDXComponent=!0;const nT={toc:[]};function oT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}oT.isMDXComponent=!0;const rT={toc:[]};function sT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}sT.isMDXComponent=!0;const pT={toc:[]};function iT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}iT.isMDXComponent=!0;const cT={toc:[]};function aT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}aT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}dT.isMDXComponent=!0;const hT={toc:[]};function fT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}fT.isMDXComponent=!0;const yT={toc:[]};function kT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}kT.isMDXComponent=!0;const wT={toc:[]};function MT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}MT.isMDXComponent=!0;const DT={toc:[]};function _T(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}_T.isMDXComponent=!0;const gT={toc:[]};function XT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}XT.isMDXComponent=!0;const xT={toc:[]};function CT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}CT.isMDXComponent=!0;const TT={toc:[]};function vT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start point of the B\xe9zier curve."))}vT.isMDXComponent=!0;const bT={toc:[]};function LT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The first control point of the B\xe9zier curve."))}LT.isMDXComponent=!0;const ZT={toc:[]};function NT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The second control point of the B\xe9zier curve."))}NT.isMDXComponent=!0;const ST={toc:[]};function RT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ST,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end point of the B\xe9zier curve."))}RT.isMDXComponent=!0;const zT={toc:[]};function PT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}PT.isMDXComponent=!0;const AT={toc:[]};function IT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}IT.isMDXComponent=!0;const WT={toc:[]};function ET(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}ET.isMDXComponent=!0;const BT={toc:[]};function FT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}FT.isMDXComponent=!0;const OT={toc:[]};function GT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}GT.isMDXComponent=!0;const jT={toc:[]};function UT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}UT.isMDXComponent=!0;const qT={toc:[]};function VT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}VT.isMDXComponent=!0;const HT={toc:[]};function $T(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}$T.isMDXComponent=!0;const QT={toc:[]};function JT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}JT.isMDXComponent=!0;const YT={toc:[]};function KT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}KT.isMDXComponent=!0;const tv={toc:[]};function ev(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}ev.isMDXComponent=!0;const nv={toc:[]};function ov(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}ov.isMDXComponent=!0;const rv={toc:[]};function sv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}sv.isMDXComponent=!0;const pv={toc:[]};function iv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}iv.isMDXComponent=!0;const cv={toc:[]};function av(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}av.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}dv.isMDXComponent=!0;const hv={toc:[]};function fv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}fv.isMDXComponent=!0;const yv={toc:[]};function kv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}kv.isMDXComponent=!0;const wv={toc:[]};function Mv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Mv.isMDXComponent=!0;const Dv={toc:[]};function _v(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Dv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}_v.isMDXComponent=!0;const gv={toc:[]};function Xv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Xv.isMDXComponent=!0;const xv={toc:[]};function Cv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}Cv.isMDXComponent=!0;const Tv={toc:[]};function vv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Tv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}vv.isMDXComponent=!0;const bv={toc:[]};function Lv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}Lv.isMDXComponent=!0;const Zv={toc:[]};function Nv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Zv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}Nv.isMDXComponent=!0;const Sv={toc:[]};function Rv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Sv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Rv.isMDXComponent=!0;const zv={toc:[]};function Pv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}Pv.isMDXComponent=!0;const Av={toc:[]};function Iv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Av,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This arc length accounts for both the offset and the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Iv.isMDXComponent=!0;const Wv={toc:[]};function Ev(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Wv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The visible arc length of this curve."))}Ev.isMDXComponent=!0;const Bv={toc:[]};function Fv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Bv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Fv.isMDXComponent=!0;const Ov={toc:[]};function Gv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ov,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The base arc length of this curve."))}Gv.isMDXComponent=!0;const jv={toc:[]};function Uv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Uv.isMDXComponent=!0;const qv={toc:[]};function Vv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Vv.isMDXComponent=!0;const Hv={toc:[]};function $v(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Hv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}$v.isMDXComponent=!0;const Qv={toc:[]};function Jv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Qv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Jv.isMDXComponent=!0;const Yv={toc:[]};function Kv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Yv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Kv.isMDXComponent=!0;const tb={toc:[]};function eb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}eb.isMDXComponent=!0;const nb={toc:[]};function ob(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage of the curve that's currently visible."))}ob.isMDXComponent=!0;const rb={toc:[]};function sb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}sb.isMDXComponent=!0;const pb={toc:[]};function ib(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}ib.isMDXComponent=!0;const cb={toc:[]};function ab(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}ab.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a distance along the curve to a percentage."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance along the curve."))}db.isMDXComponent=!0;const hb={toc:[]};function fb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}fb.isMDXComponent=!0;const yb={toc:[]};function kb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kb.isMDXComponent=!0;const wb={toc:[]};function Mb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Mb.isMDXComponent=!0;const Db={toc:[]};function _b(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Db,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}_b.isMDXComponent=!0;const gb={toc:[]};function Xb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Xb.isMDXComponent=!0;const xb={toc:[]};function Cb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Cb.isMDXComponent=!0;const Tb={toc:[]};function vb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Tb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}vb.isMDXComponent=!0;const bb={toc:[]};function Lb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}Lb.isMDXComponent=!0;const Zb={toc:[]};function Nb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Zb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Nb.isMDXComponent=!0;const Sb={toc:[]};function Rb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Sb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Rb.isMDXComponent=!0;const zb={toc:[]};function Pb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Pb.isMDXComponent=!0;const Ab={toc:[]};function Ib(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ab,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}Ib.isMDXComponent=!0;const Wb={toc:[]};function Eb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Wb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Eb.isMDXComponent=!0;const Bb={toc:[]};function Fb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Bb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Fb.isMDXComponent=!0;const Ob={toc:[]};function Gb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ob,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}Gb.isMDXComponent=!0;const jb={toc:[]};function Ub(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Ub.isMDXComponent=!0;const qb={toc:[]};function Vb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}Vb.isMDXComponent=!0;const Hb={toc:[]};function $b(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Hb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}$b.isMDXComponent=!0;const Qb={toc:[]};function Jb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Qb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Jb.isMDXComponent=!0;const Yb={toc:[]};function Kb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Yb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Kb.isMDXComponent=!0;const tL={toc:[]};function eL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}eL.isMDXComponent=!0;const nL={toc:[]};function oL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}oL.isMDXComponent=!0;const rL={toc:[]};function sL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}sL.isMDXComponent=!0;const pL={toc:[]};function iL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}iL.isMDXComponent=!0;const cL={toc:[]};function aL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}aL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}dL.isMDXComponent=!0;const hL={toc:[]};function fL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}fL.isMDXComponent=!0;const yL={toc:[]};function kL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}kL.isMDXComponent=!0;const wL={toc:[]};function ML(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}ML.isMDXComponent=!0;const DL={toc:[]};function _L(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}_L.isMDXComponent=!0;const gL={toc:[]};function XL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}XL.isMDXComponent=!0;const xL={toc:[]};function CL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}CL.isMDXComponent=!0;const TL={toc:[]};function vL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}vL.isMDXComponent=!0;const bL={toc:[]};function LL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}LL.isMDXComponent=!0;const ZL={toc:[]};function NL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}NL.isMDXComponent=!0;const SL={toc:[]};function RL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}RL.isMDXComponent=!0;const zL={toc:[]};function PL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}PL.isMDXComponent=!0;const AL={toc:[]};function IL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}IL.isMDXComponent=!0;const WL={toc:[]};function EL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the length of the curve that accounts for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}EL.isMDXComponent=!0;const BL={toc:[]};function FL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset arc length of this curve."))}FL.isMDXComponent=!0;const OL={toc:[]};function GL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}GL.isMDXComponent=!0;const jL={toc:[]};function UL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a percentage along the curve to a distance."))}UL.isMDXComponent=!0;const qL={toc:[]};function VL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage along the curve."))}VL.isMDXComponent=!0;const HL={toc:[]};function $L(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}$L.isMDXComponent=!0;const QL={toc:[]};function JL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}JL.isMDXComponent=!0;const YL={toc:[]};function KL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}KL.isMDXComponent=!0;const tZ={toc:[]};function eZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}eZ.isMDXComponent=!0;const nZ={toc:[]};function oZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}oZ.isMDXComponent=!0;const rZ={toc:[]};function sZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}sZ.isMDXComponent=!0;const pZ={toc:[]};function iZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}iZ.isMDXComponent=!0;const cZ={toc:[]};function aZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}aZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function fZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}fZ.isMDXComponent=!0;const yZ={toc:[]};function kZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}kZ.isMDXComponent=!0;const wZ={toc:[]};function MZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}MZ.isMDXComponent=!0;const DZ={toc:[]};function _Z(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}_Z.isMDXComponent=!0;const gZ={toc:[]};function XZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}XZ.isMDXComponent=!0;const xZ={toc:[]};function CZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}CZ.isMDXComponent=!0;const TZ={toc:[]};function vZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}vZ.isMDXComponent=!0;const bZ={toc:[]};function LZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}LZ.isMDXComponent=!0;const ZZ={toc:[]};function NZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}NZ.isMDXComponent=!0;const SZ={toc:[]};function RZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}RZ.isMDXComponent=!0;const zZ={toc:[]};function PZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}PZ.isMDXComponent=!0;const AZ={toc:[]};function IZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}IZ.isMDXComponent=!0;const WZ={toc:[]};function EZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}EZ.isMDXComponent=!0;const BZ={toc:[]};function FZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}FZ.isMDXComponent=!0;const OZ={toc:[]};function GZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}GZ.isMDXComponent=!0;const jZ={toc:[]};function UZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}UZ.isMDXComponent=!0;const qZ={toc:[]};function VZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}VZ.isMDXComponent=!0;const HZ={toc:[]};function $Z(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}$Z.isMDXComponent=!0;const QZ={toc:[]};function JZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}JZ.isMDXComponent=!0;const YZ={toc:[]};function KZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}KZ.isMDXComponent=!0;const tN={toc:[]};function eN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}eN.isMDXComponent=!0;const nN={toc:[]};function oN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}oN.isMDXComponent=!0;const rN={toc:[]};function sN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}sN.isMDXComponent=!0;const pN={toc:[]};function iN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}iN.isMDXComponent=!0;const cN={toc:[]};function aN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}aN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}dN.isMDXComponent=!0;const hN={toc:[]};function fN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}fN.isMDXComponent=!0;const yN={toc:[]};function kN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}kN.isMDXComponent=!0;const wN={toc:[]};function MN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}MN.isMDXComponent=!0;const DN={toc:[]};function _N(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}_N.isMDXComponent=!0;const gN={toc:[]};function XN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}XN.isMDXComponent=!0;const xN={toc:[]};function CN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}CN.isMDXComponent=!0;const TN={toc:[]};function vN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}vN.isMDXComponent=!0;const bN={toc:[]};function LN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}LN.isMDXComponent=!0;const ZN={toc:[]};function NN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}NN.isMDXComponent=!0;const SN={toc:[]};function RN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}RN.isMDXComponent=!0;const zN={toc:[]};function PN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}PN.isMDXComponent=!0;const AN={toc:[]};function IN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}IN.isMDXComponent=!0;const WN={toc:[]};function EN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}EN.isMDXComponent=!0;const BN={toc:[]};function FN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}FN.isMDXComponent=!0;const ON={toc:[]};function GN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ON,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}GN.isMDXComponent=!0;const jN={toc:[]};function UN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}UN.isMDXComponent=!0;const qN={toc:[]};function VN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}VN.isMDXComponent=!0;const HN={toc:[]};function $N(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}$N.isMDXComponent=!0;const QN={toc:[]};function JN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}JN.isMDXComponent=!0;const YN={toc:[]};function KN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}KN.isMDXComponent=!0;const tS={toc:[]};function eS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}eS.isMDXComponent=!0;const nS={toc:[]};function oS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}oS.isMDXComponent=!0;const rS={toc:[]};function sS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}sS.isMDXComponent=!0;const pS={toc:[]};function iS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}iS.isMDXComponent=!0;const cS={toc:[]};function aS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}aS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}dS.isMDXComponent=!0;const hS={toc:[]};function fS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}fS.isMDXComponent=!0;const yS={toc:[]};function kS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}kS.isMDXComponent=!0;const wS={toc:[]};function MS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}MS.isMDXComponent=!0;const DS={toc:[]};function _S(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}_S.isMDXComponent=!0;const gS={toc:[]};function XS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}XS.isMDXComponent=!0;const xS={toc:[]};function CS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}CS.isMDXComponent=!0;const TS={toc:[]};function vS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}vS.isMDXComponent=!0;const bS={toc:[]};function LS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}LS.isMDXComponent=!0;const ZS={toc:[]};function NS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}NS.isMDXComponent=!0;const SS={toc:[]};function RS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}RS.isMDXComponent=!0;const zS={toc:[]};function PS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}PS.isMDXComponent=!0;const AS={toc:[]};function IS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}IS.isMDXComponent=!0;const WS={toc:[]};function ES(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}ES.isMDXComponent=!0;const BS={toc:[]};function FS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}FS.isMDXComponent=!0;const OS={toc:[]};function GS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}GS.isMDXComponent=!0;const jS={toc:[]};function US(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}US.isMDXComponent=!0;const qS={toc:[]};function VS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}VS.isMDXComponent=!0;const HS={toc:[]};function $S(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}$S.isMDXComponent=!0;const QS={toc:[]};function JS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}JS.isMDXComponent=!0;const YS={toc:[]};function KS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}KS.isMDXComponent=!0;const tR={toc:[]};function eR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}eR.isMDXComponent=!0;const nR={toc:[]};function oR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}oR.isMDXComponent=!0;const rR={toc:[]};function sR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}sR.isMDXComponent=!0;const pR={toc:[]};function iR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}iR.isMDXComponent=!0;const cR={toc:[]};function aR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}aR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This arc length accounts for both the offset and the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}dR.isMDXComponent=!0;const hR={toc:[]};function fR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The visible arc length of this curve."))}fR.isMDXComponent=!0;const yR={toc:[]};function kR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}kR.isMDXComponent=!0;const wR={toc:[]};function MR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The base arc length of this curve."))}MR.isMDXComponent=!0;const DR={toc:[]};function _R(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}_R.isMDXComponent=!0;const gR={toc:[]};function XR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}XR.isMDXComponent=!0;const xR={toc:[]};function CR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}CR.isMDXComponent=!0;const TR={toc:[]};function vR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}vR.isMDXComponent=!0;const bR={toc:[]};function LR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}LR.isMDXComponent=!0;const ZR={toc:[]};function NR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}NR.isMDXComponent=!0;const SR={toc:[]};function RR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage of the curve that's currently visible."))}RR.isMDXComponent=!0;const zR={toc:[]};function PR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}PR.isMDXComponent=!0;const AR={toc:[]};function IR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}IR.isMDXComponent=!0;const WR={toc:[]};function ER(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}ER.isMDXComponent=!0;const BR={toc:[]};function FR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}FR.isMDXComponent=!0;const OR={toc:[]};function GR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}GR.isMDXComponent=!0;const jR={toc:[]};function UR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}UR.isMDXComponent=!0;const qR={toc:[]};function VR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}VR.isMDXComponent=!0;const HR={toc:[]};function $R(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a distance along the curve to a percentage."))}$R.isMDXComponent=!0;const QR={toc:[]};function JR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance along the curve."))}JR.isMDXComponent=!0;const YR={toc:[]};function KR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}KR.isMDXComponent=!0;const tz={toc:[]};function ez(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}ez.isMDXComponent=!0;const nz={toc:[]};function oz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}oz.isMDXComponent=!0;const rz={toc:[]};function sz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}sz.isMDXComponent=!0;const pz={toc:[]};function iz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}iz.isMDXComponent=!0;const cz={toc:[]};function az(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}az.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}dz.isMDXComponent=!0;const hz={toc:[]};function fz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}fz.isMDXComponent=!0;const yz={toc:[]};function kz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}kz.isMDXComponent=!0;const wz={toc:[]};function Mz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Mz.isMDXComponent=!0;const Dz={toc:[]};function _z(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Dz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}_z.isMDXComponent=!0;const gz={toc:[]};function Xz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}Xz.isMDXComponent=!0;const xz={toc:[]};function Cz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Cz.isMDXComponent=!0;const Tz={toc:[]};function vz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Tz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}vz.isMDXComponent=!0;const bz={toc:[]};function Lz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Lz.isMDXComponent=!0;const Zz={toc:[]};function Nz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Zz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Nz.isMDXComponent=!0;const Sz={toc:[]};function Rz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Sz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}Rz.isMDXComponent=!0;const zz={toc:[]};function Pz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}Pz.isMDXComponent=!0;const Az={toc:[]};function Iz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Az,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Iz.isMDXComponent=!0;const Wz={toc:[]};function Ez(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Wz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Ez.isMDXComponent=!0;const Bz={toc:[]};function Fz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Bz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Fz.isMDXComponent=!0;const Oz={toc:[]};function Gz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Oz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}Gz.isMDXComponent=!0;const jz={toc:[]};function Uz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Uz.isMDXComponent=!0;const qz={toc:[]};function Vz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}Vz.isMDXComponent=!0;const Hz={toc:[]};function $z(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Hz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}$z.isMDXComponent=!0;const Qz={toc:[]};function Jz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Qz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Jz.isMDXComponent=!0;const Yz={toc:[]};function Kz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Yz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}Kz.isMDXComponent=!0;const tP={toc:[]};function eP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}eP.isMDXComponent=!0;const nP={toc:[]};function oP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}oP.isMDXComponent=!0;const rP={toc:[]};function sP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}sP.isMDXComponent=!0;const pP={toc:[]};function iP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}iP.isMDXComponent=!0;const cP={toc:[]};function aP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}aP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}dP.isMDXComponent=!0;const hP={toc:[]};function fP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}fP.isMDXComponent=!0;const yP={toc:[]};function kP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}kP.isMDXComponent=!0;const wP={toc:[]};function MP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}MP.isMDXComponent=!0;const DP={toc:[]};function _P(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}_P.isMDXComponent=!0;const gP={toc:[]};function XP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}XP.isMDXComponent=!0;const xP={toc:[]};function CP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}CP.isMDXComponent=!0;const TP={toc:[]};function vP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}vP.isMDXComponent=!0;const bP={toc:[]};function LP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}LP.isMDXComponent=!0;const ZP={toc:[]};function NP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}NP.isMDXComponent=!0;const SP={toc:[]};function RP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}RP.isMDXComponent=!0;const zP={toc:[]};function PP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}PP.isMDXComponent=!0;const AP={toc:[]};function IP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}IP.isMDXComponent=!0;const WP={toc:[]};function EP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}EP.isMDXComponent=!0;const BP={toc:[]};function FP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}FP.isMDXComponent=!0;const OP={toc:[]};function GP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}GP.isMDXComponent=!0;const jP={toc:[]};function UP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}UP.isMDXComponent=!0;const qP={toc:[]};function VP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}VP.isMDXComponent=!0;const HP={toc:[]};function $P(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the length of the curve that accounts for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}$P.isMDXComponent=!0;const QP={toc:[]};function JP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset arc length of this curve."))}JP.isMDXComponent=!0;const YP={toc:[]};function KP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}KP.isMDXComponent=!0;const tA={toc:[]};function eA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a percentage along the curve to a distance."))}eA.isMDXComponent=!0;const nA={toc:[]};function oA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage along the curve."))}oA.isMDXComponent=!0;const rA={toc:[]};function sA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}sA.isMDXComponent=!0;const pA={toc:[]};function iA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}iA.isMDXComponent=!0;const cA={toc:[]};function aA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}aA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}dA.isMDXComponent=!0;const hA={toc:[]};function fA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}fA.isMDXComponent=!0;const yA={toc:[]};function kA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}kA.isMDXComponent=!0;const wA={toc:[]};function MA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}MA.isMDXComponent=!0;const DA={toc:[]};function _A(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}_A.isMDXComponent=!0;const gA={toc:[]};function XA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}XA.isMDXComponent=!0;const xA={toc:[]};function CA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}CA.isMDXComponent=!0;const TA={toc:[]};function vA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}vA.isMDXComponent=!0;const bA={toc:[]};function LA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}LA.isMDXComponent=!0;const ZA={toc:[]};function NA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}NA.isMDXComponent=!0;const SA={toc:[]};function RA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}RA.isMDXComponent=!0;const zA={toc:[]};function PA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}PA.isMDXComponent=!0;const AA={toc:[]};function IA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}IA.isMDXComponent=!0;const WA={toc:[]};function EA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}EA.isMDXComponent=!0;const BA={toc:[]};function FA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}FA.isMDXComponent=!0;const OA={toc:[]};function GA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}GA.isMDXComponent=!0;const jA={toc:[]};function UA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}UA.isMDXComponent=!0;const qA={toc:[]};function VA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}VA.isMDXComponent=!0;const HA={toc:[]};function $A(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}$A.isMDXComponent=!0;const QA={toc:[]};function JA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}JA.isMDXComponent=!0;const YA={toc:[]};function KA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}KA.isMDXComponent=!0;const tI={toc:[]};function eI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}eI.isMDXComponent=!0;const nI={toc:[]};function oI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}oI.isMDXComponent=!0;const rI={toc:[]};function sI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}sI.isMDXComponent=!0;const pI={toc:[]};function iI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}iI.isMDXComponent=!0;const cI={toc:[]};function aI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}aI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}dI.isMDXComponent=!0;const hI={toc:[]};function fI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}fI.isMDXComponent=!0;const yI={toc:[]};function kI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}kI.isMDXComponent=!0;const wI={toc:[]};function MI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}MI.isMDXComponent=!0;const DI={toc:[]};function _I(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}_I.isMDXComponent=!0;const gI={toc:[]};function XI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}XI.isMDXComponent=!0;const xI={toc:[]};function CI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}CI.isMDXComponent=!0;const TI={toc:[]};function vI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}vI.isMDXComponent=!0;const bI={toc:[]};function LI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}LI.isMDXComponent=!0;const ZI={toc:[]};function NI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}NI.isMDXComponent=!0;const SI={toc:[]};function RI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}RI.isMDXComponent=!0;const zI={toc:[]};function PI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}PI.isMDXComponent=!0;const AI={toc:[]};function II(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}II.isMDXComponent=!0;const WI={toc:[]};function EI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}EI.isMDXComponent=!0;const BI={toc:[]};function FI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}FI.isMDXComponent=!0;const OI={toc:[]};function GI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}GI.isMDXComponent=!0;const jI={toc:[]};function UI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}UI.isMDXComponent=!0;const qI={toc:[]};function VI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}VI.isMDXComponent=!0;const HI={toc:[]};function $I(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}$I.isMDXComponent=!0;const QI={toc:[]};function JI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}JI.isMDXComponent=!0;const YI={toc:[]};function KI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}KI.isMDXComponent=!0;const tW={toc:[]};function eW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}eW.isMDXComponent=!0;const nW={toc:[]};function oW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}oW.isMDXComponent=!0;const rW={toc:[]};function sW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}sW.isMDXComponent=!0;const pW={toc:[]};function iW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}iW.isMDXComponent=!0;const cW={toc:[]};function aW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}aW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}dW.isMDXComponent=!0;const hW={toc:[]};function fW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}fW.isMDXComponent=!0;const yW={toc:[]};function kW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}kW.isMDXComponent=!0;const wW={toc:[]};function MW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}MW.isMDXComponent=!0;const DW={toc:[]};function _W(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}_W.isMDXComponent=!0;const gW={toc:[]};function XW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}XW.isMDXComponent=!0;const xW={toc:[]};function CW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}CW.isMDXComponent=!0;const TW={toc:[]};function vW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}vW.isMDXComponent=!0;const bW={toc:[]};function LW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}LW.isMDXComponent=!0;const ZW={toc:[]};function NW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}NW.isMDXComponent=!0;const SW={toc:[]};function RW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}RW.isMDXComponent=!0;const zW={toc:[]};function PW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}PW.isMDXComponent=!0;const AW={toc:[]};function IW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}IW.isMDXComponent=!0;const WW={toc:[]};function EW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}EW.isMDXComponent=!0;const BW={toc:[]};function FW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}FW.isMDXComponent=!0;const OW={toc:[]};function GW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}GW.isMDXComponent=!0;const jW={toc:[]};function UW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}UW.isMDXComponent=!0;const qW={toc:[]};function VW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}VW.isMDXComponent=!0;const HW={toc:[]};function $W(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}$W.isMDXComponent=!0;const QW={toc:[]};function JW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}JW.isMDXComponent=!0;const YW={toc:[]};function KW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}KW.isMDXComponent=!0;const tE={toc:[]};function eE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}eE.isMDXComponent=!0;const nE={toc:[]};function oE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}oE.isMDXComponent=!0;const rE={toc:[]};function sE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}sE.isMDXComponent=!0;const pE={toc:[]};function iE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}iE.isMDXComponent=!0;const cE={toc:[]};function aE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}aE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}dE.isMDXComponent=!0;const hE={toc:[]};function fE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}fE.isMDXComponent=!0;const yE={toc:[]};function kE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}kE.isMDXComponent=!0;const wE={toc:[]};function ME(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ME.isMDXComponent=!0;const DE={toc:[]};function _E(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}_E.isMDXComponent=!0;const gE={toc:[]};function XE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}XE.isMDXComponent=!0;const xE={toc:[]};function CE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}CE.isMDXComponent=!0;const TE={toc:[]};function vE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}vE.isMDXComponent=!0;const bE={toc:[]};function LE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}LE.isMDXComponent=!0;const ZE={toc:[]};function NE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}NE.isMDXComponent=!0;const SE={toc:[]};function RE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}RE.isMDXComponent=!0;const zE={toc:[]};function PE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}PE.isMDXComponent=!0;const AE={toc:[]};function IE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}IE.isMDXComponent=!0;const WE={toc:[]};function EE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}EE.isMDXComponent=!0;const BE={toc:[]};function FE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}FE.isMDXComponent=!0;const OE={toc:[]};function GE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}GE.isMDXComponent=!0;const jE={toc:[]};function UE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}UE.isMDXComponent=!0;const qE={toc:[]};function VE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}VE.isMDXComponent=!0;const HE={toc:[]};function $E(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}$E.isMDXComponent=!0;const QE={toc:[]};function JE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}JE.isMDXComponent=!0;const YE={toc:[]};function KE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}KE.isMDXComponent=!0;const tB={toc:[]};function eB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}eB.isMDXComponent=!0;const nB={toc:[]};function oB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}oB.isMDXComponent=!0;const rB={toc:[]};function sB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}sB.isMDXComponent=!0;const pB={toc:[]};function iB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}iB.isMDXComponent=!0;const cB={toc:[]};function aB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}aB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}dB.isMDXComponent=!0;const hB={toc:[]};function fB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}fB.isMDXComponent=!0;const yB={toc:[]};function kB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}kB.isMDXComponent=!0;const wB={toc:[]};function MB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}MB.isMDXComponent=!0;const DB={toc:[]};function _B(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}_B.isMDXComponent=!0;const gB={toc:[]};function XB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}XB.isMDXComponent=!0;const xB={toc:[]};function CB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}CB.isMDXComponent=!0;const TB={toc:[]};function vB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}vB.isMDXComponent=!0;const bB={toc:[]};function LB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}LB.isMDXComponent=!0;const ZB={toc:[]};function NB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}NB.isMDXComponent=!0;const SB={toc:[]};function RB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}RB.isMDXComponent=!0;const zB={toc:[]};function PB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}PB.isMDXComponent=!0;const AB={toc:[]};function IB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}IB.isMDXComponent=!0;const WB={toc:[]};function EB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}EB.isMDXComponent=!0;const BB={toc:[]};function FB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}FB.isMDXComponent=!0;const OB={toc:[]};function GB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}GB.isMDXComponent=!0;const jB={toc:[]};function UB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}UB.isMDXComponent=!0;const qB={toc:[]};function VB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}VB.isMDXComponent=!0;const HB={toc:[]};function $B(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}$B.isMDXComponent=!0;const QB={toc:[]};function JB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}JB.isMDXComponent=!0;const YB={toc:[]};function KB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}KB.isMDXComponent=!0;const tF={toc:[]};function eF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}eF.isMDXComponent=!0;const nF={toc:[]};function oF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}oF.isMDXComponent=!0;const rF={toc:[]};function sF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}sF.isMDXComponent=!0;const pF={toc:[]};function iF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}iF.isMDXComponent=!0;const cF={toc:[]};function aF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}aF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}dF.isMDXComponent=!0;const hF={toc:[]};function fF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}fF.isMDXComponent=!0;const yF={toc:[]};function kF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}kF.isMDXComponent=!0;const wF={toc:[]};function MF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}MF.isMDXComponent=!0;const DF={toc:[]};function _F(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}_F.isMDXComponent=!0;const gF={toc:[]};function XF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}XF.isMDXComponent=!0;const xF={toc:[]};function CF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}CF.isMDXComponent=!0;const TF={toc:[]};function vF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}vF.isMDXComponent=!0;const bF={toc:[]};function LF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}LF.isMDXComponent=!0;const ZF={toc:[]};function NF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}NF.isMDXComponent=!0;const SF={toc:[]};function RF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}RF.isMDXComponent=!0;const zF={toc:[]};function PF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}PF.isMDXComponent=!0;const AF={toc:[]};function IF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}IF.isMDXComponent=!0;const WF={toc:[]};function EF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}EF.isMDXComponent=!0;const BF={toc:[]};function FF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}FF.isMDXComponent=!0;const OF={toc:[]};function GF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}GF.isMDXComponent=!0;const jF={toc:[]};function UF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}UF.isMDXComponent=!0;const qF={toc:[]};function VF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}VF.isMDXComponent=!0;const HF={toc:[]};function $F(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}$F.isMDXComponent=!0;const QF={toc:[]};function JF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}JF.isMDXComponent=!0;const YF={toc:[]};function KF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}KF.isMDXComponent=!0;const tO={toc:[]};function eO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}eO.isMDXComponent=!0;const nO={toc:[]};function oO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}oO.isMDXComponent=!0;const rO={toc:[]};function sO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}sO.isMDXComponent=!0;const pO={toc:[]};function iO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}iO.isMDXComponent=!0;const cO={toc:[]};function aO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}aO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}dO.isMDXComponent=!0;const hO={toc:[]};function fO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}fO.isMDXComponent=!0;const yO={toc:[]};function kO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}kO.isMDXComponent=!0;const wO={toc:[]};function MO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}MO.isMDXComponent=!0;const DO={toc:[]};function _O(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}_O.isMDXComponent=!0;const gO={toc:[]};function XO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}XO.isMDXComponent=!0;const xO={toc:[]};function CO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}CO.isMDXComponent=!0;const TO={toc:[]};function vO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An Icon Component that provides an easy access to over 150k icons.\nSee ",(0,p.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}vO.isMDXComponent=!0;const bO={toc:[]};function LO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}LO.isMDXComponent=!0;const ZO={toc:[]};function NO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}NO.isMDXComponent=!0;const SO={toc:[]};function RO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}RO.isMDXComponent=!0;const zO={toc:[]};function PO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}PO.isMDXComponent=!0;const AO={toc:[]};function IO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}IO.isMDXComponent=!0;const WO={toc:[]};function EO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}EO.isMDXComponent=!0;const BO={toc:[]};function FO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}FO.isMDXComponent=!0;const OO={toc:[]};function GO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The alpha value of this image."))}GO.isMDXComponent=!0;const jO={toc:[]};function UO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}UO.isMDXComponent=!0;const qO={toc:[]};function VO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}VO.isMDXComponent=!0;const HO={toc:[]};function $O(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}$O.isMDXComponent=!0;const QO={toc:[]};function JO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}JO.isMDXComponent=!0;const YO={toc:[]};function KO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}KO.isMDXComponent=!0;const tG={toc:[]};function eG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}eG.isMDXComponent=!0;const nG={toc:[]};function oG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide the color in one of the following formats:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"named color like ",(0,p.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,p.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,p.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,p.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,p.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,p.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,p.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,p.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,p.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}oG.isMDXComponent=!0;const rG={toc:[]};function sG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"'white'"))}sG.isMDXComponent=!0;const pG={toc:[]};function iG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The color of the icon"))}iG.isMDXComponent=!0;const cG={toc:[]};function aG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}aG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}dG.isMDXComponent=!0;const hG={toc:[]};function fG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"You can find identifiers on ",(0,p.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}fG.isMDXComponent=!0;const yG={toc:[]};function kG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The identifier of the icon."))}kG.isMDXComponent=!0;const wG={toc:[]};function MG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}MG.isMDXComponent=!0;const DG={toc:[]};function _G(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}_G.isMDXComponent=!0;const gG={toc:[]};function XG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}XG.isMDXComponent=!0;const xG={toc:[]};function CG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}CG.isMDXComponent=!0;const TG={toc:[]};function vG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}vG.isMDXComponent=!0;const bG={toc:[]};function LG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}LG.isMDXComponent=!0;const ZG={toc:[]};function NG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}NG.isMDXComponent=!0;const SG={toc:[]};function RG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}RG.isMDXComponent=!0;const zG={toc:[]};function PG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}PG.isMDXComponent=!0;const AG={toc:[]};function IG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}IG.isMDXComponent=!0;const WG={toc:[]};function EG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}EG.isMDXComponent=!0;const BG={toc:[]};function FG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}FG.isMDXComponent=!0;const OG={toc:[]};function GG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}GG.isMDXComponent=!0;const jG={toc:[]};function UG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}UG.isMDXComponent=!0;const qG={toc:[]};function VG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}VG.isMDXComponent=!0;const HG={toc:[]};function $G(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}$G.isMDXComponent=!0;const QG={toc:[]};function JG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}JG.isMDXComponent=!0;const YG={toc:[]};function KG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}KG.isMDXComponent=!0;const tj={toc:[]};function ej(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"true"))}ej.isMDXComponent=!0;const nj={toc:[]};function oj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the image should be smoothed."))}oj.isMDXComponent=!0;const rj={toc:[]};function sj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Using a local image:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,p.kt)("p",null,"Loading an image from the internet:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}sj.isMDXComponent=!0;const pj={toc:[]};function ij(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The source of this image."))}ij.isMDXComponent=!0;const cj={toc:[]};function aj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}aj.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}dj.isMDXComponent=!0;const hj={toc:[]};function fj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}fj.isMDXComponent=!0;const yj={toc:[]};function kj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}kj.isMDXComponent=!0;const wj={toc:[]};function Mj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Mj.isMDXComponent=!0;const Dj={toc:[]};function _j(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Dj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}_j.isMDXComponent=!0;const gj={toc:[]};function Xj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Xj.isMDXComponent=!0;const xj={toc:[]};function Cj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}Cj.isMDXComponent=!0;const Tj={toc:[]};function vj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Tj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}vj.isMDXComponent=!0;const bj={toc:[]};function Lj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Lj.isMDXComponent=!0;const Zj={toc:[]};function Nj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Zj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}Nj.isMDXComponent=!0;const Sj={toc:[]};function Rj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Sj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Rj.isMDXComponent=!0;const zj={toc:[]};function Pj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Pj.isMDXComponent=!0;const Aj={toc:[]};function Ij(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Aj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Ij.isMDXComponent=!0;const Wj={toc:[]};function Ej(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Wj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Ej.isMDXComponent=!0;const Bj={toc:[]};function Fj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Bj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Fj.isMDXComponent=!0;const Oj={toc:[]};function Gj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Oj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Gj.isMDXComponent=!0;const jj={toc:[]};function Uj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Uj.isMDXComponent=!0;const qj={toc:[]};function Vj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Vj.isMDXComponent=!0;const Hj={toc:[]};function $j(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Hj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}$j.isMDXComponent=!0;const Qj={toc:[]};function Jj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Qj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Jj.isMDXComponent=!0;const Yj={toc:[]};function Kj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Yj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}Kj.isMDXComponent=!0;const tU={toc:[]};function eU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}eU.isMDXComponent=!0;const nU={toc:[]};function oU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}oU.isMDXComponent=!0;const rU={toc:[]};function sU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}sU.isMDXComponent=!0;const pU={toc:[]};function iU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}iU.isMDXComponent=!0;const cU={toc:[]};function aU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}aU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}dU.isMDXComponent=!0;const hU={toc:[]};function fU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}fU.isMDXComponent=!0;const yU={toc:[]};function kU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kU.isMDXComponent=!0;const wU={toc:[]};function MU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}MU.isMDXComponent=!0;const DU={toc:[]};function _U(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}_U.isMDXComponent=!0;const gU={toc:[]};function XU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color of the image at the given position."))}XU.isMDXComponent=!0;const xU={toc:[]};function CU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position in local space at which to sample the color."))}CU.isMDXComponent=!0;const TU={toc:[]};function vU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color of the image at the given pixel."))}vU.isMDXComponent=!0;const bU={toc:[]};function LU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The pixel's position."))}LU.isMDXComponent=!0;const ZU={toc:[]};function NU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"overrides ",(0,p.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}NU.isMDXComponent=!0;const SU={toc:[]};function RU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}RU.isMDXComponent=!0;const zU={toc:[]};function PU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}PU.isMDXComponent=!0;const AU={toc:[]};function IU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}IU.isMDXComponent=!0;const WU={toc:[]};function EU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}EU.isMDXComponent=!0;const BU={toc:[]};function FU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}FU.isMDXComponent=!0;const OU={toc:[]};function GU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}GU.isMDXComponent=!0;const jU={toc:[]};function UU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}UU.isMDXComponent=!0;const qU={toc:[]};function VU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}VU.isMDXComponent=!0;const HU={toc:[]};function $U(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}$U.isMDXComponent=!0;const QU={toc:[]};function JU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}JU.isMDXComponent=!0;const YU={toc:[]};function KU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}KU.isMDXComponent=!0;const tq={toc:[]};function eq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}eq.isMDXComponent=!0;const nq={toc:[]};function oq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}oq.isMDXComponent=!0;const rq={toc:[]};function sq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}sq.isMDXComponent=!0;const pq={toc:[]};function iq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}iq.isMDXComponent=!0;const cq={toc:[]};function aq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}aq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dq.isMDXComponent=!0;const hq={toc:[]};function fq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}fq.isMDXComponent=!0;const yq={toc:[]};function kq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}kq.isMDXComponent=!0;const wq={toc:[]};function Mq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Mq.isMDXComponent=!0;const Dq={toc:[]};function _q(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Dq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}_q.isMDXComponent=!0;const gq={toc:[]};function Xq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}Xq.isMDXComponent=!0;const xq={toc:[]};function Cq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Cq.isMDXComponent=!0;const Tq={toc:[]};function vq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Tq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}vq.isMDXComponent=!0;const bq={toc:[]};function Lq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Lq.isMDXComponent=!0;const Zq={toc:[]};function Nq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Zq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}Nq.isMDXComponent=!0;const Sq={toc:[]};function Rq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Sq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Rq.isMDXComponent=!0;const zq={toc:[]};function Pq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Pq.isMDXComponent=!0;const Aq={toc:[]};function Iq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Aq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}Iq.isMDXComponent=!0;const Wq={toc:[]};function Eq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Wq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Eq.isMDXComponent=!0;const Bq={toc:[]};function Fq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Bq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Fq.isMDXComponent=!0;const Oq={toc:[]};function Gq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Oq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Gq.isMDXComponent=!0;const jq={toc:[]};function Uq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Uq.isMDXComponent=!0;const qq={toc:[]};function Vq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}Vq.isMDXComponent=!0;const Hq={toc:[]};function $q(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Hq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}$q.isMDXComponent=!0;const Qq={toc:[]};function Jq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Qq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Jq.isMDXComponent=!0;const Yq={toc:[]};function Kq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Yq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Kq.isMDXComponent=!0;const tV={toc:[]};function eV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}eV.isMDXComponent=!0;const nV={toc:[]};function oV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}oV.isMDXComponent=!0;const rV={toc:[]};function sV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}sV.isMDXComponent=!0;const pV={toc:[]};function iV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}iV.isMDXComponent=!0;const cV={toc:[]};function aV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The natural size of this image."))}aV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}dV.isMDXComponent=!0;const hV={toc:[]};function fV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}fV.isMDXComponent=!0;const yV={toc:[]};function kV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}kV.isMDXComponent=!0;const wV={toc:[]};function MV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}MV.isMDXComponent=!0;const DV={toc:[]};function _V(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}_V.isMDXComponent=!0;const gV={toc:[]};function XV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}XV.isMDXComponent=!0;const xV={toc:[]};function CV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}CV.isMDXComponent=!0;const TV={toc:[]};function vV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}vV.isMDXComponent=!0;const bV={toc:[]};function LV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}LV.isMDXComponent=!0;const ZV={toc:[]};function NV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}NV.isMDXComponent=!0;const SV={toc:[]};function RV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}RV.isMDXComponent=!0;const zV={toc:[]};function PV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}PV.isMDXComponent=!0;const AV={toc:[]};function IV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}IV.isMDXComponent=!0;const WV={toc:[]};function EV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}EV.isMDXComponent=!0;const BV={toc:[]};function FV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}FV.isMDXComponent=!0;const OV={toc:[]};function GV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}GV.isMDXComponent=!0;const jV={toc:[]};function UV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}UV.isMDXComponent=!0;const qV={toc:[]};function VV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}VV.isMDXComponent=!0;const HV={toc:[]};function $V(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}$V.isMDXComponent=!0;const QV={toc:[]};function JV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"overrides ",(0,p.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}JV.isMDXComponent=!0;const YV={toc:[]};function KV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}KV.isMDXComponent=!0;const tH={toc:[]};function eH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}eH.isMDXComponent=!0;const nH={toc:[]};function oH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}oH.isMDXComponent=!0;const rH={toc:[]};function sH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}sH.isMDXComponent=!0;const pH={toc:[]};function iH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}iH.isMDXComponent=!0;const cH={toc:[]};function aH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}aH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Address to Iconify API for the requested Icon."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create the URL that will be used as the Image source"))}dH.isMDXComponent=!0;const hH={toc:[]};function fH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}fH.isMDXComponent=!0;const yH={toc:[]};function kH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}kH.isMDXComponent=!0;const wH={toc:[]};function MH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}MH.isMDXComponent=!0;const DH={toc:[]};function _H(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}_H.isMDXComponent=!0;const gH={toc:[]};function XH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}XH.isMDXComponent=!0;const xH={toc:[]};function CH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}CH.isMDXComponent=!0;const TH={toc:[]};function vH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}vH.isMDXComponent=!0;const bH={toc:[]};function LH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}LH.isMDXComponent=!0;const ZH={toc:[]};function NH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}NH.isMDXComponent=!0;const SH={toc:[]};function RH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}RH.isMDXComponent=!0;const zH={toc:[]};function PH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}PH.isMDXComponent=!0;const AH={toc:[]};function IH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node for displaying images."))}IH.isMDXComponent=!0;const WH={toc:[]};function EH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}EH.isMDXComponent=!0;const BH={toc:[]};function FH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}FH.isMDXComponent=!0;const OH={toc:[]};function GH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}GH.isMDXComponent=!0;const jH={toc:[]};function UH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}UH.isMDXComponent=!0;const qH={toc:[]};function VH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}VH.isMDXComponent=!0;const HH={toc:[]};function $H(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}$H.isMDXComponent=!0;const QH={toc:[]};function JH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}JH.isMDXComponent=!0;const YH={toc:[]};function KH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The alpha value of this image."))}KH.isMDXComponent=!0;const t$={toc:[]};function e$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},t$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}e$.isMDXComponent=!0;const n$={toc:[]};function o$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},n$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}o$.isMDXComponent=!0;const r$={toc:[]};function s$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},r$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}s$.isMDXComponent=!0;const p$={toc:[]};function i$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},p$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}i$.isMDXComponent=!0;const c$={toc:[]};function a$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},c$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}a$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},l$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},m$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}d$.isMDXComponent=!0;const h$={toc:[]};function f$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},h$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}f$.isMDXComponent=!0;const y$={toc:[]};function k$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},y$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}k$.isMDXComponent=!0;const w$={toc:[]};function M$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},w$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}M$.isMDXComponent=!0;const D$={toc:[]};function _$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},D$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}_$.isMDXComponent=!0;const g$={toc:[]};function X$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},g$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}X$.isMDXComponent=!0;const x$={toc:[]};function C$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},x$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}C$.isMDXComponent=!0;const T$={toc:[]};function v$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},T$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}v$.isMDXComponent=!0;const b$={toc:[]};function L$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},b$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}L$.isMDXComponent=!0;const Z$={toc:[]};function N$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Z$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}N$.isMDXComponent=!0;const S$={toc:[]};function R$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},S$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}R$.isMDXComponent=!0;const z$={toc:[]};function P$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},z$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}P$.isMDXComponent=!0;const A$={toc:[]};function I$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},A$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}I$.isMDXComponent=!0;const W$={toc:[]};function E$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},W$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}E$.isMDXComponent=!0;const B$={toc:[]};function F$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},B$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}F$.isMDXComponent=!0;const O$={toc:[]};function G$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},O$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}G$.isMDXComponent=!0;const j$={toc:[]};function U$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},j$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}U$.isMDXComponent=!0;const q$={toc:[]};function V$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},q$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}V$.isMDXComponent=!0;const H$={toc:[]};function $$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},H$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}$$.isMDXComponent=!0;const Q$={toc:[]};function J$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Q$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}J$.isMDXComponent=!0;const Y$={toc:[]};function K$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Y$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}K$.isMDXComponent=!0;const tQ={toc:[]};function eQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"true"))}eQ.isMDXComponent=!0;const nQ={toc:[]};function oQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the image should be smoothed."))}oQ.isMDXComponent=!0;const rQ={toc:[]};function sQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Using a local image:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,p.kt)("p",null,"Loading an image from the internet:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}sQ.isMDXComponent=!0;const pQ={toc:[]};function iQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The source of this image."))}iQ.isMDXComponent=!0;const cQ={toc:[]};function aQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}aQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function fQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}fQ.isMDXComponent=!0;const yQ={toc:[]};function kQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}kQ.isMDXComponent=!0;const wQ={toc:[]};function MQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}MQ.isMDXComponent=!0;const DQ={toc:[]};function _Q(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}_Q.isMDXComponent=!0;const gQ={toc:[]};function XQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}XQ.isMDXComponent=!0;const xQ={toc:[]};function CQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}CQ.isMDXComponent=!0;const TQ={toc:[]};function vQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}vQ.isMDXComponent=!0;const bQ={toc:[]};function LQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}LQ.isMDXComponent=!0;const ZQ={toc:[]};function NQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}NQ.isMDXComponent=!0;const SQ={toc:[]};function RQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}RQ.isMDXComponent=!0;const zQ={toc:[]};function PQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}PQ.isMDXComponent=!0;const AQ={toc:[]};function IQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}IQ.isMDXComponent=!0;const WQ={toc:[]};function EQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}EQ.isMDXComponent=!0;const BQ={toc:[]};function FQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}FQ.isMDXComponent=!0;const OQ={toc:[]};function GQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}GQ.isMDXComponent=!0;const jQ={toc:[]};function UQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}UQ.isMDXComponent=!0;const qQ={toc:[]};function VQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}VQ.isMDXComponent=!0;const HQ={toc:[]};function $Q(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}$Q.isMDXComponent=!0;const QQ={toc:[]};function JQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}JQ.isMDXComponent=!0;const YQ={toc:[]};function KQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}KQ.isMDXComponent=!0;const tJ={toc:[]};function eJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}eJ.isMDXComponent=!0;const nJ={toc:[]};function oJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}oJ.isMDXComponent=!0;const rJ={toc:[]};function sJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}sJ.isMDXComponent=!0;const pJ={toc:[]};function iJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}iJ.isMDXComponent=!0;const cJ={toc:[]};function aJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}aJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function fJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}fJ.isMDXComponent=!0;const yJ={toc:[]};function kJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kJ.isMDXComponent=!0;const wJ={toc:[]};function MJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}MJ.isMDXComponent=!0;const DJ={toc:[]};function _J(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}_J.isMDXComponent=!0;const gJ={toc:[]};function XJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color of the image at the given position."))}XJ.isMDXComponent=!0;const xJ={toc:[]};function CJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position in local space at which to sample the color."))}CJ.isMDXComponent=!0;const TJ={toc:[]};function vJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color of the image at the given pixel."))}vJ.isMDXComponent=!0;const bJ={toc:[]};function LJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The pixel's position."))}LJ.isMDXComponent=!0;const ZJ={toc:[]};function NJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}NJ.isMDXComponent=!0;const SJ={toc:[]};function RJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}RJ.isMDXComponent=!0;const zJ={toc:[]};function PJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}PJ.isMDXComponent=!0;const AJ={toc:[]};function IJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}IJ.isMDXComponent=!0;const WJ={toc:[]};function EJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}EJ.isMDXComponent=!0;const BJ={toc:[]};function FJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}FJ.isMDXComponent=!0;const OJ={toc:[]};function GJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}GJ.isMDXComponent=!0;const jJ={toc:[]};function UJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}UJ.isMDXComponent=!0;const qJ={toc:[]};function VJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}VJ.isMDXComponent=!0;const HJ={toc:[]};function $J(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}$J.isMDXComponent=!0;const QJ={toc:[]};function JJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}JJ.isMDXComponent=!0;const YJ={toc:[]};function KJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}KJ.isMDXComponent=!0;const tY={toc:[]};function eY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}eY.isMDXComponent=!0;const nY={toc:[]};function oY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}oY.isMDXComponent=!0;const rY={toc:[]};function sY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}sY.isMDXComponent=!0;const pY={toc:[]};function iY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}iY.isMDXComponent=!0;const cY={toc:[]};function aY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}aY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}dY.isMDXComponent=!0;const hY={toc:[]};function fY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}fY.isMDXComponent=!0;const yY={toc:[]};function kY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}kY.isMDXComponent=!0;const wY={toc:[]};function MY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}MY.isMDXComponent=!0;const DY={toc:[]};function _Y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}_Y.isMDXComponent=!0;const gY={toc:[]};function XY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}XY.isMDXComponent=!0;const xY={toc:[]};function CY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}CY.isMDXComponent=!0;const TY={toc:[]};function vY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}vY.isMDXComponent=!0;const bY={toc:[]};function LY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}LY.isMDXComponent=!0;const ZY={toc:[]};function NY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}NY.isMDXComponent=!0;const SY={toc:[]};function RY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}RY.isMDXComponent=!0;const zY={toc:[]};function PY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}PY.isMDXComponent=!0;const AY={toc:[]};function IY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}IY.isMDXComponent=!0;const WY={toc:[]};function EY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}EY.isMDXComponent=!0;const BY={toc:[]};function FY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}FY.isMDXComponent=!0;const OY={toc:[]};function GY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}GY.isMDXComponent=!0;const jY={toc:[]};function UY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}UY.isMDXComponent=!0;const qY={toc:[]};function VY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}VY.isMDXComponent=!0;const HY={toc:[]};function $Y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}$Y.isMDXComponent=!0;const QY={toc:[]};function JY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}JY.isMDXComponent=!0;const YY={toc:[]};function KY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}KY.isMDXComponent=!0;const tK={toc:[]};function eK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}eK.isMDXComponent=!0;const nK={toc:[]};function oK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},nK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}oK.isMDXComponent=!0;const rK={toc:[]};function sK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}sK.isMDXComponent=!0;const pK={toc:[]};function iK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The natural size of this image."))}iK.isMDXComponent=!0;const cK={toc:[]};function aK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}aK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},lK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}dK.isMDXComponent=!0;const hK={toc:[]};function fK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},hK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}fK.isMDXComponent=!0;const yK={toc:[]};function kK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},yK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}kK.isMDXComponent=!0;const wK={toc:[]};function MK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}MK.isMDXComponent=!0;const DK={toc:[]};function _K(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},DK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}_K.isMDXComponent=!0;const gK={toc:[]};function XK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}XK.isMDXComponent=!0;const xK={toc:[]};function CK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}CK.isMDXComponent=!0;const TK={toc:[]};function vK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},TK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}vK.isMDXComponent=!0;const bK={toc:[]};function LK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},bK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}LK.isMDXComponent=!0;const ZK={toc:[]};function NK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ZK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}NK.isMDXComponent=!0;const SK={toc:[]};function RK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},SK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}RK.isMDXComponent=!0;const zK={toc:[]};function PK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},zK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}PK.isMDXComponent=!0;const AK={toc:[]};function IK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},AK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}IK.isMDXComponent=!0;const WK={toc:[]};function EK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},WK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}EK.isMDXComponent=!0;const BK={toc:[]};function FK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},BK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}FK.isMDXComponent=!0;const OK={toc:[]};function GK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},OK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}GK.isMDXComponent=!0;const jK={toc:[]};function UK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}UK.isMDXComponent=!0;const qK={toc:[]};function VK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}VK.isMDXComponent=!0;const HK={toc:[]};function $K(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},HK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}$K.isMDXComponent=!0;const QK={toc:[]};function JK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},QK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}JK.isMDXComponent=!0;const YK={toc:[]};function KK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},YK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}KK.isMDXComponent=!0;const t0={toc:[]};function e0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},t0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}e0.isMDXComponent=!0;const n0={toc:[]};function o0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},n0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}o0.isMDXComponent=!0;const r0={toc:[]};function s0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},r0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}s0.isMDXComponent=!0;const p0={toc:[]};function i0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},p0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}i0.isMDXComponent=!0;const c0={toc:[]};function a0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},c0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}a0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},l0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},m0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}d0.isMDXComponent=!0;const h0={toc:[]};function f0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},h0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}f0.isMDXComponent=!0;const y0={toc:[]};function k0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},y0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}k0.isMDXComponent=!0;const w0={toc:[]};function M0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},w0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}M0.isMDXComponent=!0;const D0={toc:[]};function _0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},D0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}_0.isMDXComponent=!0;const g0={toc:[]};function X0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},g0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}X0.isMDXComponent=!0;const x0={toc:[]};function C0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},x0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}C0.isMDXComponent=!0;const T0={toc:[]};function v0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},T0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node representing a knot of a ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,p.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}v0.isMDXComponent=!0;const b0={toc:[]};function L0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},b0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}L0.isMDXComponent=!0;const Z0={toc:[]};function N0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Z0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}N0.isMDXComponent=!0;const S0={toc:[]};function R0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},S0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}R0.isMDXComponent=!0;const z0={toc:[]};function P0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},z0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}P0.isMDXComponent=!0;const A0={toc:[]};function I0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},A0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}I0.isMDXComponent=!0;const W0={toc:[]};function E0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},W0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}E0.isMDXComponent=!0;const B0={toc:[]};function F0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},B0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}F0.isMDXComponent=!0;const O0={toc:[]};function G0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},O0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"0"))}G0.isMDXComponent=!0;const j0={toc:[]};function U0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},j0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}U0.isMDXComponent=!0;const q0={toc:[]};function V0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},q0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,p.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,p.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,p.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,p.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}V0.isMDXComponent=!0;const H0={toc:[]};function $0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},H0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Mirrored position of the startHandle."))}$0.isMDXComponent=!0;const Q0={toc:[]};function J0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Q0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}J0.isMDXComponent=!0;const Y0={toc:[]};function K0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Y0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}K0.isMDXComponent=!0;const t2={toc:[]};function e2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},t2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}e2.isMDXComponent=!0;const n2={toc:[]};function o2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},n2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}o2.isMDXComponent=!0;const r2={toc:[]};function s2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},r2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}s2.isMDXComponent=!0;const p2={toc:[]};function i2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},p2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}i2.isMDXComponent=!0;const c2={toc:[]};function a2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},c2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,p.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,p.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,p.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,p.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}a2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},l2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Mirrored position of the endHandle."))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},m2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}d2.isMDXComponent=!0;const h2={toc:[]};function f2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},h2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}f2.isMDXComponent=!0;const y2={toc:[]};function k2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},y2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}k2.isMDXComponent=!0;const w2={toc:[]};function M2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},w2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}M2.isMDXComponent=!0;const D2={toc:[]};function _2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},D2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}_2.isMDXComponent=!0;const g2={toc:[]};function X2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},g2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}X2.isMDXComponent=!0;const x2={toc:[]};function C2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},x2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}C2.isMDXComponent=!0;const T2={toc:[]};function v2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},T2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}v2.isMDXComponent=!0;const b2={toc:[]};function L2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},b2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}L2.isMDXComponent=!0;const Z2={toc:[]};function N2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Z2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}N2.isMDXComponent=!0;const S2={toc:[]};function R2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},S2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}R2.isMDXComponent=!0;const z2={toc:[]};function P2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},z2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}P2.isMDXComponent=!0;const A2={toc:[]};function I2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},A2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}I2.isMDXComponent=!0;const W2={toc:[]};function E2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},W2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}E2.isMDXComponent=!0;const B2={toc:[]};function F2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},B2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}F2.isMDXComponent=!0;const O2={toc:[]};function G2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},O2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}G2.isMDXComponent=!0;const j2={toc:[]};function U2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},j2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}U2.isMDXComponent=!0;const q2={toc:[]};function V2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},q2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}V2.isMDXComponent=!0;const H2={toc:[]};function $2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},H2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}$2.isMDXComponent=!0;const Q2={toc:[]};function J2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Q2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}J2.isMDXComponent=!0;const Y2={toc:[]};function K2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Y2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}K2.isMDXComponent=!0;const t1={toc:[]};function e1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},t1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}e1.isMDXComponent=!0;const n1={toc:[]};function o1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},n1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}o1.isMDXComponent=!0;const r1={toc:[]};function s1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},r1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}s1.isMDXComponent=!0;const p1={toc:[]};function i1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},p1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}i1.isMDXComponent=!0;const c1={toc:[]};function a1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},c1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}a1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},l1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},m1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}d1.isMDXComponent=!0;const h1={toc:[]};function f1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},h1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}f1.isMDXComponent=!0;const y1={toc:[]};function k1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},y1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}k1.isMDXComponent=!0;const w1={toc:[]};function M1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},w1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}M1.isMDXComponent=!0;const D1={toc:[]};function _1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},D1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}_1.isMDXComponent=!0;const g1={toc:[]};function X1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},g1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}X1.isMDXComponent=!0;const x1={toc:[]};function C1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},x1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}C1.isMDXComponent=!0;const T1={toc:[]};function v1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},T1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}v1.isMDXComponent=!0;const b1={toc:[]};function L1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},b1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}L1.isMDXComponent=!0;const Z1={toc:[]};function N1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Z1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}N1.isMDXComponent=!0;const S1={toc:[]};function R1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},S1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}R1.isMDXComponent=!0;const z1={toc:[]};function P1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},z1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}P1.isMDXComponent=!0;const A1={toc:[]};function I1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},A1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}I1.isMDXComponent=!0;const W1={toc:[]};function E1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},W1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}E1.isMDXComponent=!0;const B1={toc:[]};function F1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},B1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}F1.isMDXComponent=!0;const O1={toc:[]};function G1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},O1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}G1.isMDXComponent=!0;const j1={toc:[]};function U1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},j1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}U1.isMDXComponent=!0;const q1={toc:[]};function V1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},q1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}V1.isMDXComponent=!0;const H1={toc:[]};function $1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},H1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}$1.isMDXComponent=!0;const Q1={toc:[]};function J1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Q1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}J1.isMDXComponent=!0;const Y1={toc:[]};function K1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Y1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}K1.isMDXComponent=!0;const t3={toc:[]};function e3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},t3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}e3.isMDXComponent=!0;const n3={toc:[]};function o3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},n3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}o3.isMDXComponent=!0;const r3={toc:[]};function s3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},r3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}s3.isMDXComponent=!0;const p3={toc:[]};function i3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},p3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}i3.isMDXComponent=!0;const c3={toc:[]};function a3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},c3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}a3.isMDXComponent=!0;const l3={toc:[]};function u3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},l3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},m3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}d3.isMDXComponent=!0;const h3={toc:[]};function f3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},h3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}f3.isMDXComponent=!0;const y3={toc:[]};function k3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},y3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}k3.isMDXComponent=!0;const w3={toc:[]};function M3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},w3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}M3.isMDXComponent=!0;const D3={toc:[]};function _3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},D3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}_3.isMDXComponent=!0;const g3={toc:[]};function X3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},g3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}X3.isMDXComponent=!0;const x3={toc:[]};function C3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},x3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}C3.isMDXComponent=!0;const T3={toc:[]};function v3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},T3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}v3.isMDXComponent=!0;const b3={toc:[]};function L3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},b3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}L3.isMDXComponent=!0;const Z3={toc:[]};function N3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Z3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}N3.isMDXComponent=!0;const S3={toc:[]};function R3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},S3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}R3.isMDXComponent=!0;const z3={toc:[]};function P3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},z3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}P3.isMDXComponent=!0;const A3={toc:[]};function I3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},A3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}I3.isMDXComponent=!0;const W3={toc:[]};function E3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},W3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}E3.isMDXComponent=!0;const B3={toc:[]};function F3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},B3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}F3.isMDXComponent=!0;const O3={toc:[]};function G3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},O3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}G3.isMDXComponent=!0;const j3={toc:[]};function U3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},j3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}U3.isMDXComponent=!0;const q3={toc:[]};function V3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},q3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}V3.isMDXComponent=!0;const H3={toc:[]};function $3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},H3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}$3.isMDXComponent=!0;const Q3={toc:[]};function J3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Q3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}J3.isMDXComponent=!0;const Y3={toc:[]};function K3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Y3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}K3.isMDXComponent=!0;const t4={toc:[]};function e4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},t4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}e4.isMDXComponent=!0;const n4={toc:[]};function o4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},n4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}o4.isMDXComponent=!0;const r4={toc:[]};function s4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},r4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}s4.isMDXComponent=!0;const p4={toc:[]};function i4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},p4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}i4.isMDXComponent=!0;const c4={toc:[]};function a4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},c4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}a4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},l4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},m4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}d4.isMDXComponent=!0;const h4={toc:[]};function f4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},h4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}f4.isMDXComponent=!0;const y4={toc:[]};function k4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},y4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}k4.isMDXComponent=!0;const w4={toc:[]};function M4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},w4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}M4.isMDXComponent=!0;const D4={toc:[]};function _4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},D4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}_4.isMDXComponent=!0;const g4={toc:[]};function X4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},g4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}X4.isMDXComponent=!0;const x4={toc:[]};function C4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},x4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}C4.isMDXComponent=!0;const T4={toc:[]};function v4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},T4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}v4.isMDXComponent=!0;const b4={toc:[]};function L4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},b4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}L4.isMDXComponent=!0;const Z4={toc:[]};function N4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Z4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}N4.isMDXComponent=!0;const S4={toc:[]};function R4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},S4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}R4.isMDXComponent=!0;const z4={toc:[]};function P4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},z4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}P4.isMDXComponent=!0;const A4={toc:[]};function I4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},A4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}I4.isMDXComponent=!0;const W4={toc:[]};function E4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},W4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}E4.isMDXComponent=!0;const B4={toc:[]};function F4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},B4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}F4.isMDXComponent=!0;const O4={toc:[]};function G4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},O4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}G4.isMDXComponent=!0;const j4={toc:[]};function U4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},j4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}U4.isMDXComponent=!0;const q4={toc:[]};function V4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},q4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node for displaying images."))}V4.isMDXComponent=!0;const H4={toc:[]};function $4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},H4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}$4.isMDXComponent=!0;const Q4={toc:[]};function J4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Q4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}J4.isMDXComponent=!0;const Y4={toc:[]};function K4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Y4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}K4.isMDXComponent=!0;const t6={toc:[]};function e6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},t6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}e6.isMDXComponent=!0;const n6={toc:[]};function o6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},n6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}o6.isMDXComponent=!0;const r6={toc:[]};function s6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},r6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}s6.isMDXComponent=!0;const p6={toc:[]};function i6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},p6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}i6.isMDXComponent=!0;const c6={toc:[]};function a6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},c6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The alpha value of this image."))}a6.isMDXComponent=!0;const l6={toc:[]};function u6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},l6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}u6.isMDXComponent=!0;const m6={toc:[]};function d6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},m6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}d6.isMDXComponent=!0;const h6={toc:[]};function f6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},h6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}f6.isMDXComponent=!0;const y6={toc:[]};function k6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},y6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}k6.isMDXComponent=!0;const w6={toc:[]};function M6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},w6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}M6.isMDXComponent=!0;const D6={toc:[]};function _6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},D6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}_6.isMDXComponent=!0;const g6={toc:[]};function X6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},g6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}X6.isMDXComponent=!0;const x6={toc:[]};function C6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},x6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}C6.isMDXComponent=!0;const T6={toc:[]};function v6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},T6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}v6.isMDXComponent=!0;const b6={toc:[]};function L6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},b6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}L6.isMDXComponent=!0;const Z6={toc:[]};function N6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Z6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}N6.isMDXComponent=!0;const S6={toc:[]};function R6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},S6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}R6.isMDXComponent=!0;const z6={toc:[]};function P6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},z6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}P6.isMDXComponent=!0;const A6={toc:[]};function I6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},A6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}I6.isMDXComponent=!0;const W6={toc:[]};function E6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},W6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}E6.isMDXComponent=!0;const B6={toc:[]};function F6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},B6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}F6.isMDXComponent=!0;const O6={toc:[]};function G6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},O6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}G6.isMDXComponent=!0;const j6={toc:[]};function U6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},j6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}U6.isMDXComponent=!0;const q6={toc:[]};function V6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},q6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}V6.isMDXComponent=!0;const H6={toc:[]};function $6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},H6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}$6.isMDXComponent=!0;const Q6={toc:[]};function J6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Q6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}J6.isMDXComponent=!0;const Y6={toc:[]};function K6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Y6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}K6.isMDXComponent=!0;const t8={toc:[]};function e8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},t8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}e8.isMDXComponent=!0;const n8={toc:[]};function o8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},n8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}o8.isMDXComponent=!0;const r8={toc:[]};function s8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},r8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}s8.isMDXComponent=!0;const p8={toc:[]};function i8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},p8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}i8.isMDXComponent=!0;const c8={toc:[]};function a8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},c8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}a8.isMDXComponent=!0;const l8={toc:[]};function u8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},l8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"true"))}u8.isMDXComponent=!0;const m8={toc:[]};function d8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},m8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the image should be smoothed."))}d8.isMDXComponent=!0;const h8={toc:[]};function f8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},h8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Using a local image:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,p.kt)("p",null,"Loading an image from the internet:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}f8.isMDXComponent=!0;const y8={toc:[]};function k8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},y8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The source of this image."))}k8.isMDXComponent=!0;const w8={toc:[]};function M8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},w8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}M8.isMDXComponent=!0;const D8={toc:[]};function _8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},D8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}_8.isMDXComponent=!0;const g8={toc:[]};function X8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},g8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}X8.isMDXComponent=!0;const x8={toc:[]};function C8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},x8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}C8.isMDXComponent=!0;const T8={toc:[]};function v8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},T8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}v8.isMDXComponent=!0;const b8={toc:[]};function L8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},b8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}L8.isMDXComponent=!0;const Z8={toc:[]};function N8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Z8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}N8.isMDXComponent=!0;const S8={toc:[]};function R8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},S8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}R8.isMDXComponent=!0;const z8={toc:[]};function P8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},z8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}P8.isMDXComponent=!0;const A8={toc:[]};function I8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},A8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}I8.isMDXComponent=!0;const W8={toc:[]};function E8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},W8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}E8.isMDXComponent=!0;const B8={toc:[]};function F8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},B8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}F8.isMDXComponent=!0;const O8={toc:[]};function G8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},O8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}G8.isMDXComponent=!0;const j8={toc:[]};function U8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},j8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}U8.isMDXComponent=!0;const q8={toc:[]};function V8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},q8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}V8.isMDXComponent=!0;const H8={toc:[]};function $8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},H8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}$8.isMDXComponent=!0;const Q8={toc:[]};function J8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Q8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}J8.isMDXComponent=!0;const Y8={toc:[]};function K8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Y8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}K8.isMDXComponent=!0;const t5={toc:[]};function e5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},t5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}e5.isMDXComponent=!0;const n5={toc:[]};function o5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},n5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}o5.isMDXComponent=!0;const r5={toc:[]};function s5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},r5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}s5.isMDXComponent=!0;const p5={toc:[]};function i5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},p5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}i5.isMDXComponent=!0;const c5={toc:[]};function a5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},c5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}a5.isMDXComponent=!0;const l5={toc:[]};function u5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},l5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}u5.isMDXComponent=!0;const m5={toc:[]};function d5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},m5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}d5.isMDXComponent=!0;const h5={toc:[]};function f5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},h5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}f5.isMDXComponent=!0;const y5={toc:[]};function k5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},y5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}k5.isMDXComponent=!0;const w5={toc:[]};function M5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},w5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}M5.isMDXComponent=!0;const D5={toc:[]};function _5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},D5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}_5.isMDXComponent=!0;const g5={toc:[]};function X5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},g5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}X5.isMDXComponent=!0;const x5={toc:[]};function C5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},x5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}C5.isMDXComponent=!0;const T5={toc:[]};function v5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},T5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}v5.isMDXComponent=!0;const b5={toc:[]};function L5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},b5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}L5.isMDXComponent=!0;const Z5={toc:[]};function N5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Z5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}N5.isMDXComponent=!0;const S5={toc:[]};function R5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},S5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color of the image at the given position."))}R5.isMDXComponent=!0;const z5={toc:[]};function P5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},z5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position in local space at which to sample the color."))}P5.isMDXComponent=!0;const A5={toc:[]};function I5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},A5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color of the image at the given pixel."))}I5.isMDXComponent=!0;const W5={toc:[]};function E5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},W5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The pixel's position."))}E5.isMDXComponent=!0;const B5={toc:[]};function F5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},B5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}F5.isMDXComponent=!0;const O5={toc:[]};function G5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},O5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}G5.isMDXComponent=!0;const j5={toc:[]};function U5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},j5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}U5.isMDXComponent=!0;const q5={toc:[]};function V5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},q5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}V5.isMDXComponent=!0;const H5={toc:[]};function $5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},H5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}$5.isMDXComponent=!0;const Q5={toc:[]};function J5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Q5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}J5.isMDXComponent=!0;const Y5={toc:[]};function K5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Y5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}K5.isMDXComponent=!0;const t7={toc:[]};function e7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},t7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}e7.isMDXComponent=!0;const n7={toc:[]};function o7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},n7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}o7.isMDXComponent=!0;const r7={toc:[]};function s7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},r7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}s7.isMDXComponent=!0;const p7={toc:[]};function i7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},p7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}i7.isMDXComponent=!0;const c7={toc:[]};function a7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},c7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}a7.isMDXComponent=!0;const l7={toc:[]};function u7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},l7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}u7.isMDXComponent=!0;const m7={toc:[]};function d7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},m7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}d7.isMDXComponent=!0;const h7={toc:[]};function f7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},h7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}f7.isMDXComponent=!0;const y7={toc:[]};function k7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},y7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}k7.isMDXComponent=!0;const w7={toc:[]};function M7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},w7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}M7.isMDXComponent=!0;const D7={toc:[]};function _7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},D7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}_7.isMDXComponent=!0;const g7={toc:[]};function X7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},g7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}X7.isMDXComponent=!0;const x7={toc:[]};function C7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},x7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}C7.isMDXComponent=!0;const T7={toc:[]};function v7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},T7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}v7.isMDXComponent=!0;const b7={toc:[]};function L7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},b7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}L7.isMDXComponent=!0;const Z7={toc:[]};function N7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Z7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}N7.isMDXComponent=!0;const S7={toc:[]};function R7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},S7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}R7.isMDXComponent=!0;const z7={toc:[]};function P7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},z7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}P7.isMDXComponent=!0;const A7={toc:[]};function I7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},A7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}I7.isMDXComponent=!0;const W7={toc:[]};function E7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},W7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}E7.isMDXComponent=!0;const B7={toc:[]};function F7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},B7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}F7.isMDXComponent=!0;const O7={toc:[]};function G7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},O7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}G7.isMDXComponent=!0;const j7={toc:[]};function U7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},j7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}U7.isMDXComponent=!0;const q7={toc:[]};function V7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},q7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}V7.isMDXComponent=!0;const H7={toc:[]};function $7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},H7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}$7.isMDXComponent=!0;const Q7={toc:[]};function J7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Q7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}J7.isMDXComponent=!0;const Y7={toc:[]};function K7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Y7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}K7.isMDXComponent=!0;const t9={toc:[]};function e9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},t9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}e9.isMDXComponent=!0;const n9={toc:[]};function o9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},n9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}o9.isMDXComponent=!0;const r9={toc:[]};function s9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},r9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}s9.isMDXComponent=!0;const p9={toc:[]};function i9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},p9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}i9.isMDXComponent=!0;const c9={toc:[]};function a9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},c9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}a9.isMDXComponent=!0;const l9={toc:[]};function u9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},l9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}u9.isMDXComponent=!0;const m9={toc:[]};function d9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},m9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}d9.isMDXComponent=!0;const h9={toc:[]};function f9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},h9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}f9.isMDXComponent=!0;const y9={toc:[]};function k9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},y9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The natural size of this image."))}k9.isMDXComponent=!0;const w9={toc:[]};function M9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},w9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}M9.isMDXComponent=!0;const D9={toc:[]};function _9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},D9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}_9.isMDXComponent=!0;const g9={toc:[]};function X9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},g9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}X9.isMDXComponent=!0;const x9={toc:[]};function C9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},x9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}C9.isMDXComponent=!0;const T9={toc:[]};function v9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},T9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}v9.isMDXComponent=!0;const b9={toc:[]};function L9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},b9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}L9.isMDXComponent=!0;const Z9={toc:[]};function N9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Z9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}N9.isMDXComponent=!0;const S9={toc:[]};function R9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},S9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}R9.isMDXComponent=!0;const z9={toc:[]};function P9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},z9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}P9.isMDXComponent=!0;const A9={toc:[]};function I9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},A9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}I9.isMDXComponent=!0;const W9={toc:[]};function E9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},W9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}E9.isMDXComponent=!0;const B9={toc:[]};function F9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},B9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}F9.isMDXComponent=!0;const O9={toc:[]};function G9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},O9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}G9.isMDXComponent=!0;const j9={toc:[]};function U9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},j9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}U9.isMDXComponent=!0;const q9={toc:[]};function V9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},q9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}V9.isMDXComponent=!0;const H9={toc:[]};function $9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},H9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}$9.isMDXComponent=!0;const Q9={toc:[]};function J9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Q9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}J9.isMDXComponent=!0;const Y9={toc:[]};function K9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Y9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}K9.isMDXComponent=!0;const ttt={toc:[]};function ett(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ttt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}ett.isMDXComponent=!0;const ntt={toc:[]};function ott(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ntt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}ott.isMDXComponent=!0;const rtt={toc:[]};function stt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},rtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}stt.isMDXComponent=!0;const ptt={toc:[]};function itt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ptt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}itt.isMDXComponent=!0;const ctt={toc:[]};function att(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ctt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}att.isMDXComponent=!0;const ltt={toc:[]};function utt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ltt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}utt.isMDXComponent=!0;const mtt={toc:[]};function dtt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},mtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}dtt.isMDXComponent=!0;const htt={toc:[]};function ftt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},htt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}ftt.isMDXComponent=!0;const ytt={toc:[]};function ktt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ytt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ktt.isMDXComponent=!0;const wtt={toc:[]};function Mtt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},wtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Mtt.isMDXComponent=!0;const Dtt={toc:[]};function _tt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Dtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}_tt.isMDXComponent=!0;const gtt={toc:[]};function Xtt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},gtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Xtt.isMDXComponent=!0;const xtt={toc:[]};function Ctt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},xtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Ctt.isMDXComponent=!0;const Ttt={toc:[]};function vtt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ttt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}vtt.isMDXComponent=!0;const btt={toc:[]};function Ltt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},btt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Ltt.isMDXComponent=!0;const Ztt={toc:[]};function Ntt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ztt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}Ntt.isMDXComponent=!0;const Stt={toc:[]};function Rtt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Stt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Rtt.isMDXComponent=!0;const ztt={toc:[]};function Ptt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ztt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}Ptt.isMDXComponent=!0;const Att={toc:[]};function Itt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Att,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}Itt.isMDXComponent=!0;const Wtt={toc:[]};function Ett(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Wtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}Ett.isMDXComponent=!0;const Btt={toc:[]};function Ftt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Btt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Ftt.isMDXComponent=!0;const Ott={toc:[]};function Gtt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ott,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Gtt.isMDXComponent=!0;const jtt={toc:[]};function Utt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},jtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}Utt.isMDXComponent=!0;const qtt={toc:[]};function Vtt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},qtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}Vtt.isMDXComponent=!0;const Htt={toc:[]};function $tt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Htt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}$tt.isMDXComponent=!0;const Qtt={toc:[]};function Jtt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Qtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Jtt.isMDXComponent=!0;const Ytt={toc:[]};function Ktt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ytt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Ktt.isMDXComponent=!0;const tet={toc:[]};function eet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},tet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}eet.isMDXComponent=!0;const net={toc:[]};function oet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},net,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}oet.isMDXComponent=!0;const ret={toc:[]};function set(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ret,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}set.isMDXComponent=!0;const pet={toc:[]};function iet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},pet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}iet.isMDXComponent=!0;const cet={toc:[]};function aet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},cet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}aet.isMDXComponent=!0;const uet={toc:[]};function met(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}met.isMDXComponent=!0;const det={toc:[]};function het(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},det,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}het.isMDXComponent=!0;const fet={toc:[]};function yet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}yet.isMDXComponent=!0;const ket={toc:[]};function wet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ket,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}wet.isMDXComponent=!0;const Met={toc:[]};function Det(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Met,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Det.isMDXComponent=!0;const _et={toc:[]};function get(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_et,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}get.isMDXComponent=!0;const Xet={toc:[]};function xet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}xet.isMDXComponent=!0;const Cet={toc:[]};function Tet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Tet.isMDXComponent=!0;const vet={toc:[]};function bet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}bet.isMDXComponent=!0;const Let={toc:[]};function Zet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Let,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Zet.isMDXComponent=!0;const Net={toc:[]};function Set(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Net,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Set.isMDXComponent=!0;const Ret={toc:[]};function zet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ret,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}zet.isMDXComponent=!0;const Pet={toc:[]};function Aet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Aet.isMDXComponent=!0;const Iet={toc:[]};function Wet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Iet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}Wet.isMDXComponent=!0;const Eet={toc:[]};function Bet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Bet.isMDXComponent=!0;const Fet={toc:[]};function Oet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Oet.isMDXComponent=!0;const Get={toc:[]};function jet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Get,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}jet.isMDXComponent=!0;const Uet={toc:[]};function qet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}qet.isMDXComponent=!0;const Vet={toc:[]};function Het(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}Het.isMDXComponent=!0;const $et={toc:[]};function Qet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$et,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Qet.isMDXComponent=!0;const Jet={toc:[]};function Yet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}Yet.isMDXComponent=!0;const Ket={toc:[]};function tnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ket,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}tnt.isMDXComponent=!0;const ent={toc:[]};function nnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ent,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}nnt.isMDXComponent=!0;const ont={toc:[]};function rnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ont,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}rnt.isMDXComponent=!0;const snt={toc:[]};function pnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},snt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}pnt.isMDXComponent=!0;const int={toc:[]};function cnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},int,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}cnt.isMDXComponent=!0;const ant={toc:[]};function lnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ant,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}lnt.isMDXComponent=!0;const unt={toc:[]};function mnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},unt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}mnt.isMDXComponent=!0;const dnt={toc:[]};function hnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}hnt.isMDXComponent=!0;const fnt={toc:[]};function ynt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}ynt.isMDXComponent=!0;const knt={toc:[]};function wnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},knt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}wnt.isMDXComponent=!0;const Mnt={toc:[]};function Dnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Dnt.isMDXComponent=!0;const _nt={toc:[]};function gnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_nt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}gnt.isMDXComponent=!0;const Xnt={toc:[]};function xnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}xnt.isMDXComponent=!0;const Cnt={toc:[]};function Tnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}Tnt.isMDXComponent=!0;const vnt={toc:[]};function bnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}bnt.isMDXComponent=!0;const Lnt={toc:[]};function Znt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Znt.isMDXComponent=!0;const Nnt={toc:[]};function Snt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Snt.isMDXComponent=!0;const Rnt={toc:[]};function znt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}znt.isMDXComponent=!0;const Pnt={toc:[]};function Ant(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Ant.isMDXComponent=!0;const Int={toc:[]};function Wnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Int,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Wnt.isMDXComponent=!0;const Ent={toc:[]};function Bnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ent,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Bnt.isMDXComponent=!0;const Fnt={toc:[]};function Ont(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}Ont.isMDXComponent=!0;const Gnt={toc:[]};function jnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}jnt.isMDXComponent=!0;const Unt={toc:[]};function qnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Unt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}qnt.isMDXComponent=!0;const Vnt={toc:[]};function Hnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Hnt.isMDXComponent=!0;const $nt={toc:[]};function Qnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$nt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Qnt.isMDXComponent=!0;const Jnt={toc:[]};function Ynt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}Ynt.isMDXComponent=!0;const Knt={toc:[]};function tot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Knt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}tot.isMDXComponent=!0;const eot={toc:[]};function not(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}not.isMDXComponent=!0;const oot={toc:[]};function rot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}rot.isMDXComponent=!0;const sot={toc:[]};function pot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}pot.isMDXComponent=!0;const iot={toc:[]};function cot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}cot.isMDXComponent=!0;const aot={toc:[]};function lot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}lot.isMDXComponent=!0;const uot={toc:[]};function mot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}mot.isMDXComponent=!0;const dot={toc:[]};function hot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}hot.isMDXComponent=!0;const fot={toc:[]};function yot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}yot.isMDXComponent=!0;const kot={toc:[]};function wot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}wot.isMDXComponent=!0;const Mot={toc:[]};function Dot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Dot.isMDXComponent=!0;const _ot={toc:[]};function got(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_ot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}got.isMDXComponent=!0;const Xot={toc:[]};function xot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}xot.isMDXComponent=!0;const Cot={toc:[]};function Tot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Tot.isMDXComponent=!0;const vot={toc:[]};function bot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}bot.isMDXComponent=!0;const Lot={toc:[]};function Zot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Zot.isMDXComponent=!0;const Not={toc:[]};function Sot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Not,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}Sot.isMDXComponent=!0;const Rot={toc:[]};function zot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}zot.isMDXComponent=!0;const Pot={toc:[]};function Aot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Aot.isMDXComponent=!0;const Iot={toc:[]};function Wot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Iot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Wot.isMDXComponent=!0;const Eot={toc:[]};function Bot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}Bot.isMDXComponent=!0;const Fot={toc:[]};function Oot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Oot.isMDXComponent=!0;const Got={toc:[]};function jot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Got,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}jot.isMDXComponent=!0;const Uot={toc:[]};function qot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}qot.isMDXComponent=!0;const Vot={toc:[]};function Hot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}Hot.isMDXComponent=!0;const $ot={toc:[]};function Qot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$ot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Qot.isMDXComponent=!0;const Jot={toc:[]};function Yot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Yot.isMDXComponent=!0;const Kot={toc:[]};function trt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}trt.isMDXComponent=!0;const ert={toc:[]};function nrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ert,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}nrt.isMDXComponent=!0;const ort={toc:[]};function rrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ort,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}rrt.isMDXComponent=!0;const srt={toc:[]};function prt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},srt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}prt.isMDXComponent=!0;const irt={toc:[]};function crt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},irt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}crt.isMDXComponent=!0;const art={toc:[]};function lrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},art,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}lrt.isMDXComponent=!0;const urt={toc:[]};function mrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},urt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}mrt.isMDXComponent=!0;const drt={toc:[]};function hrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},drt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}hrt.isMDXComponent=!0;const frt={toc:[]};function yrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},frt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}yrt.isMDXComponent=!0;const krt={toc:[]};function wrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},krt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}wrt.isMDXComponent=!0;const Mrt={toc:[]};function Drt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mrt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Drt.isMDXComponent=!0;const _rt={toc:[]};function grt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_rt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}grt.isMDXComponent=!0;const Xrt={toc:[]};function xrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xrt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}xrt.isMDXComponent=!0;const Crt={toc:[]};function Trt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Crt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Trt.isMDXComponent=!0;const vrt={toc:[]};function brt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vrt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}brt.isMDXComponent=!0;const Lrt={toc:[]};function Zrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lrt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}Zrt.isMDXComponent=!0;const Nrt={toc:[]};function Srt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nrt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}Srt.isMDXComponent=!0;const Rrt={toc:[]};function zrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rrt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}zrt.isMDXComponent=!0;const Prt={toc:[]};function Art(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Prt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Art.isMDXComponent=!0;const Irt={toc:[]};function Wrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Irt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Wrt.isMDXComponent=!0;const Ert={toc:[]};function Brt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ert,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Brt.isMDXComponent=!0;const Frt={toc:[]};function Ort(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Frt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}Ort.isMDXComponent=!0;const Grt={toc:[]};function jrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Grt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}jrt.isMDXComponent=!0;const Urt={toc:[]};function qrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Urt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}qrt.isMDXComponent=!0;const Vrt={toc:[]};function Hrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vrt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Hrt.isMDXComponent=!0;const $rt={toc:[]};function Qrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$rt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Qrt.isMDXComponent=!0;const Jrt={toc:[]};function Yrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jrt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Yrt.isMDXComponent=!0;const Krt={toc:[]};function tst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Krt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}tst.isMDXComponent=!0;const est={toc:[]};function nst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},est,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}nst.isMDXComponent=!0;const ost={toc:[]};function rst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ost,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}rst.isMDXComponent=!0;const sst={toc:[]};function pst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}pst.isMDXComponent=!0;const ist={toc:[]};function cst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ist,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}cst.isMDXComponent=!0;const ast={toc:[]};function lst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ast,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}lst.isMDXComponent=!0;const ust={toc:[]};function mst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ust,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}mst.isMDXComponent=!0;const dst={toc:[]};function hst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}hst.isMDXComponent=!0;const fst={toc:[]};function yst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}yst.isMDXComponent=!0;const kst={toc:[]};function wst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}wst.isMDXComponent=!0;const Mst={toc:[]};function Dst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Dst.isMDXComponent=!0;const _st={toc:[]};function gst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_st,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}gst.isMDXComponent=!0;const Xst={toc:[]};function xst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}xst.isMDXComponent=!0;const Cst={toc:[]};function Tst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}Tst.isMDXComponent=!0;const vst={toc:[]};function bst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}bst.isMDXComponent=!0;const Lst={toc:[]};function Zst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Zst.isMDXComponent=!0;const Nst={toc:[]};function Sst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Sst.isMDXComponent=!0;const Rst={toc:[]};function zst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}zst.isMDXComponent=!0;const Pst={toc:[]};function Ast(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}Ast.isMDXComponent=!0;const Ist={toc:[]};function Wst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ist,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Wst.isMDXComponent=!0;const Est={toc:[]};function Bst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Est,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}Bst.isMDXComponent=!0;const Fst={toc:[]};function Ost(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}Ost.isMDXComponent=!0;const Gst={toc:[]};function jst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}jst.isMDXComponent=!0;const Ust={toc:[]};function qst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ust,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}qst.isMDXComponent=!0;const Vst={toc:[]};function Hst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Hst.isMDXComponent=!0;const $st={toc:[]};function Qst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$st,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}Qst.isMDXComponent=!0;const Jst={toc:[]};function Yst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}Yst.isMDXComponent=!0;const Kst={toc:[]};function tpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}tpt.isMDXComponent=!0;const ept={toc:[]};function npt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ept,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}npt.isMDXComponent=!0;const opt={toc:[]};function rpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},opt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}rpt.isMDXComponent=!0;const spt={toc:[]};function ppt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},spt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}ppt.isMDXComponent=!0;const ipt={toc:[]};function cpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ipt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}cpt.isMDXComponent=!0;const apt={toc:[]};function lpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},apt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}lpt.isMDXComponent=!0;const upt={toc:[]};function mpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},upt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}mpt.isMDXComponent=!0;const dpt={toc:[]};function hpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}hpt.isMDXComponent=!0;const fpt={toc:[]};function ypt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}ypt.isMDXComponent=!0;const kpt={toc:[]};function wpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}wpt.isMDXComponent=!0;const Mpt={toc:[]};function Dpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Dpt.isMDXComponent=!0;const _pt={toc:[]};function gpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_pt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}gpt.isMDXComponent=!0;const Xpt={toc:[]};function xpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xpt.isMDXComponent=!0;const Cpt={toc:[]};function Tpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Tpt.isMDXComponent=!0;const vpt={toc:[]};function bpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}bpt.isMDXComponent=!0;const Lpt={toc:[]};function Zpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}Zpt.isMDXComponent=!0;const Npt={toc:[]};function Spt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Npt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Spt.isMDXComponent=!0;const Rpt={toc:[]};function zpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}zpt.isMDXComponent=!0;const Ppt={toc:[]};function Apt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ppt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Apt.isMDXComponent=!0;const Ipt={toc:[]};function Wpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ipt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}Wpt.isMDXComponent=!0;const Ept={toc:[]};function Bpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ept,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Bpt.isMDXComponent=!0;const Fpt={toc:[]};function Opt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}Opt.isMDXComponent=!0;const Gpt={toc:[]};function jpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}jpt.isMDXComponent=!0;const Upt={toc:[]};function qpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Upt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}qpt.isMDXComponent=!0;const Vpt={toc:[]};function Hpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Hpt.isMDXComponent=!0;const $pt={toc:[]};function Qpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$pt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Qpt.isMDXComponent=!0;const Jpt={toc:[]};function Ypt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Ypt.isMDXComponent=!0;const Kpt={toc:[]};function tit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}tit.isMDXComponent=!0;const eit={toc:[]};function nit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}nit.isMDXComponent=!0;const oit={toc:[]};function rit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}rit.isMDXComponent=!0;const sit={toc:[]};function pit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}pit.isMDXComponent=!0;const iit={toc:[]};function cit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}cit.isMDXComponent=!0;const ait={toc:[]};function lit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ait,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lit.isMDXComponent=!0;const uit={toc:[]};function mit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}mit.isMDXComponent=!0;const dit={toc:[]};function hit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}hit.isMDXComponent=!0;const fit={toc:[]};function yit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}yit.isMDXComponent=!0;const kit={toc:[]};function wit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}wit.isMDXComponent=!0;const Mit={toc:[]};function Dit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}Dit.isMDXComponent=!0;const _it={toc:[]};function git(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_it,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}git.isMDXComponent=!0;const Xit={toc:[]};function xit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}xit.isMDXComponent=!0;const Cit={toc:[]};function Tit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Tit.isMDXComponent=!0;const vit={toc:[]};function bit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}bit.isMDXComponent=!0;const Lit={toc:[]};function Zit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}Zit.isMDXComponent=!0;const Nit={toc:[]};function Sit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Sit.isMDXComponent=!0;const Rit={toc:[]};function zit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}zit.isMDXComponent=!0;const Pit={toc:[]};function Ait(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}Ait.isMDXComponent=!0;const Iit={toc:[]};function Wit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Iit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Wit.isMDXComponent=!0;const Eit={toc:[]};function Bit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}Bit.isMDXComponent=!0;const Fit={toc:[]};function Oit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This arc length accounts for both the offset and the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Oit.isMDXComponent=!0;const Git={toc:[]};function jit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Git,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The visible arc length of this curve."))}jit.isMDXComponent=!0;const Uit={toc:[]};function qit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}qit.isMDXComponent=!0;const Vit={toc:[]};function Hit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The base arc length of this curve."))}Hit.isMDXComponent=!0;const $it={toc:[]};function Qit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$it,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Qit.isMDXComponent=!0;const Jit={toc:[]};function Yit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Yit.isMDXComponent=!0;const Kit={toc:[]};function tct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}tct.isMDXComponent=!0;const ect={toc:[]};function nct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ect,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}nct.isMDXComponent=!0;const oct={toc:[]};function rct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}rct.isMDXComponent=!0;const sct={toc:[]};function pct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}pct.isMDXComponent=!0;const ict={toc:[]};function cct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ict,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage of the curve that's currently visible."))}cct.isMDXComponent=!0;const act={toc:[]};function lct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},act,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}lct.isMDXComponent=!0;const uct={toc:[]};function mct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}mct.isMDXComponent=!0;const dct={toc:[]};function hct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}hct.isMDXComponent=!0;const fct={toc:[]};function yct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}yct.isMDXComponent=!0;const kct={toc:[]};function wct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}wct.isMDXComponent=!0;const Mct={toc:[]};function Dct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}Dct.isMDXComponent=!0;const _ct={toc:[]};function gct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_ct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}gct.isMDXComponent=!0;const Xct={toc:[]};function xct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a distance along the curve to a percentage."))}xct.isMDXComponent=!0;const Cct={toc:[]};function Tct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance along the curve."))}Tct.isMDXComponent=!0;const vct={toc:[]};function bct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}bct.isMDXComponent=!0;const Lct={toc:[]};function Zct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Zct.isMDXComponent=!0;const Nct={toc:[]};function Sct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Sct.isMDXComponent=!0;const Rct={toc:[]};function zct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}zct.isMDXComponent=!0;const Pct={toc:[]};function Act(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Act.isMDXComponent=!0;const Ict={toc:[]};function Wct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ict,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Wct.isMDXComponent=!0;const Ect={toc:[]};function Bct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ect,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Bct.isMDXComponent=!0;const Fct={toc:[]};function Oct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}Oct.isMDXComponent=!0;const Gct={toc:[]};function jct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}jct.isMDXComponent=!0;const Uct={toc:[]};function qct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}qct.isMDXComponent=!0;const Vct={toc:[]};function Hct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Hct.isMDXComponent=!0;const $ct={toc:[]};function Qct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$ct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Qct.isMDXComponent=!0;const Jct={toc:[]};function Yct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}Yct.isMDXComponent=!0;const Kct={toc:[]};function tat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}tat.isMDXComponent=!0;const eat={toc:[]};function nat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}nat.isMDXComponent=!0;const oat={toc:[]};function rat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}rat.isMDXComponent=!0;const sat={toc:[]};function pat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}pat.isMDXComponent=!0;const iat={toc:[]};function cat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}cat.isMDXComponent=!0;const aat={toc:[]};function lat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}lat.isMDXComponent=!0;const uat={toc:[]};function mat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}mat.isMDXComponent=!0;const dat={toc:[]};function hat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}hat.isMDXComponent=!0;const fat={toc:[]};function yat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}yat.isMDXComponent=!0;const kat={toc:[]};function wat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}wat.isMDXComponent=!0;const Mat={toc:[]};function Dat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Dat.isMDXComponent=!0;const _at={toc:[]};function gat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_at,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}gat.isMDXComponent=!0;const Xat={toc:[]};function xat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}xat.isMDXComponent=!0;const Cat={toc:[]};function Tat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Tat.isMDXComponent=!0;const vat={toc:[]};function bat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}bat.isMDXComponent=!0;const Lat={toc:[]};function Zat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Zat.isMDXComponent=!0;const Nat={toc:[]};function Sat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}Sat.isMDXComponent=!0;const Rat={toc:[]};function zat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}zat.isMDXComponent=!0;const Pat={toc:[]};function Aat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Aat.isMDXComponent=!0;const Iat={toc:[]};function Wat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Iat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Wat.isMDXComponent=!0;const Eat={toc:[]};function Bat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}Bat.isMDXComponent=!0;const Fat={toc:[]};function Oat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Oat.isMDXComponent=!0;const Gat={toc:[]};function jat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}jat.isMDXComponent=!0;const Uat={toc:[]};function qat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}qat.isMDXComponent=!0;const Vat={toc:[]};function Hat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}Hat.isMDXComponent=!0;const $at={toc:[]};function Qat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$at,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Qat.isMDXComponent=!0;const Jat={toc:[]};function Yat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Yat.isMDXComponent=!0;const Kat={toc:[]};function tlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}tlt.isMDXComponent=!0;const elt={toc:[]};function nlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},elt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}nlt.isMDXComponent=!0;const olt={toc:[]};function rlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},olt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}rlt.isMDXComponent=!0;const slt={toc:[]};function plt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},slt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}plt.isMDXComponent=!0;const ilt={toc:[]};function clt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ilt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}clt.isMDXComponent=!0;const alt={toc:[]};function llt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},alt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}llt.isMDXComponent=!0;const ult={toc:[]};function mlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ult,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}mlt.isMDXComponent=!0;const dlt={toc:[]};function hlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dlt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}hlt.isMDXComponent=!0;const flt={toc:[]};function ylt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},flt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}ylt.isMDXComponent=!0;const klt={toc:[]};function wlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},klt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}wlt.isMDXComponent=!0;const Mlt={toc:[]};function Dlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mlt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Dlt.isMDXComponent=!0;const _lt={toc:[]};function glt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_lt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}glt.isMDXComponent=!0;const Xlt={toc:[]};function xlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xlt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the length of the curve that accounts for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}xlt.isMDXComponent=!0;const Clt={toc:[]};function Tlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Clt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset arc length of this curve."))}Tlt.isMDXComponent=!0;const vlt={toc:[]};function blt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vlt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}blt.isMDXComponent=!0;const Llt={toc:[]};function Zlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Llt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a percentage along the curve to a distance."))}Zlt.isMDXComponent=!0;const Nlt={toc:[]};function Slt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nlt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage along the curve."))}Slt.isMDXComponent=!0;const Rlt={toc:[]};function zlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rlt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}zlt.isMDXComponent=!0;const Plt={toc:[]};function Alt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Plt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Alt.isMDXComponent=!0;const Ilt={toc:[]};function Wlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ilt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Wlt.isMDXComponent=!0;const Elt={toc:[]};function Blt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Elt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}Blt.isMDXComponent=!0;const Flt={toc:[]};function Olt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Flt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}Olt.isMDXComponent=!0;const Glt={toc:[]};function jlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Glt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}jlt.isMDXComponent=!0;const Ult={toc:[]};function qlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ult,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}qlt.isMDXComponent=!0;const Vlt={toc:[]};function Hlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vlt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Hlt.isMDXComponent=!0;const $lt={toc:[]};function Qlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$lt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Qlt.isMDXComponent=!0;const Jlt={toc:[]};function Ylt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jlt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}Ylt.isMDXComponent=!0;const Klt={toc:[]};function tut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Klt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}tut.isMDXComponent=!0;const eut={toc:[]};function nut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}nut.isMDXComponent=!0;const out={toc:[]};function rut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},out,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}rut.isMDXComponent=!0;const sut={toc:[]};function put(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}put.isMDXComponent=!0;const iut={toc:[]};function cut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cut.isMDXComponent=!0;const aut={toc:[]};function lut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}lut.isMDXComponent=!0;const uut={toc:[]};function mut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}mut.isMDXComponent=!0;const dut={toc:[]};function hut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}hut.isMDXComponent=!0;const fut={toc:[]};function yut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}yut.isMDXComponent=!0;const kut={toc:[]};function wut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}wut.isMDXComponent=!0;const Mut={toc:[]};function Dut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Dut.isMDXComponent=!0;const _ut={toc:[]};function gut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_ut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}gut.isMDXComponent=!0;const Xut={toc:[]};function xut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}xut.isMDXComponent=!0;const Cut={toc:[]};function Tut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Tut.isMDXComponent=!0;const vut={toc:[]};function but(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}but.isMDXComponent=!0;const Lut={toc:[]};function Zut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Zut.isMDXComponent=!0;const Nut={toc:[]};function Sut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Sut.isMDXComponent=!0;const Rut={toc:[]};function zut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}zut.isMDXComponent=!0;const Put={toc:[]};function Aut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Put,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}Aut.isMDXComponent=!0;const Iut={toc:[]};function Wut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Iut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Wut.isMDXComponent=!0;const Eut={toc:[]};function But(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}But.isMDXComponent=!0;const Fut={toc:[]};function Out(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Out.isMDXComponent=!0;const Gut={toc:[]};function jut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}jut.isMDXComponent=!0;const Uut={toc:[]};function qut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}qut.isMDXComponent=!0;const Vut={toc:[]};function Hut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Hut.isMDXComponent=!0;const $ut={toc:[]};function Qut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$ut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}Qut.isMDXComponent=!0;const Jut={toc:[]};function Yut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}Yut.isMDXComponent=!0;const Kut={toc:[]};function tmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}tmt.isMDXComponent=!0;const emt={toc:[]};function nmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},emt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}nmt.isMDXComponent=!0;const omt={toc:[]};function rmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},omt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}rmt.isMDXComponent=!0;const smt={toc:[]};function pmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},smt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}pmt.isMDXComponent=!0;const imt={toc:[]};function cmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},imt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}cmt.isMDXComponent=!0;const amt={toc:[]};function lmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},amt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lmt.isMDXComponent=!0;const umt={toc:[]};function mmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},umt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}mmt.isMDXComponent=!0;const dmt={toc:[]};function hmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}hmt.isMDXComponent=!0;const fmt={toc:[]};function ymt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}ymt.isMDXComponent=!0;const kmt={toc:[]};function wmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}wmt.isMDXComponent=!0;const Mmt={toc:[]};function Dmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}Dmt.isMDXComponent=!0;const _mt={toc:[]};function gmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_mt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}gmt.isMDXComponent=!0;const Xmt={toc:[]};function xmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}xmt.isMDXComponent=!0;const Cmt={toc:[]};function Tmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}Tmt.isMDXComponent=!0;const vmt={toc:[]};function bmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}bmt.isMDXComponent=!0;const Lmt={toc:[]};function Zmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}Zmt.isMDXComponent=!0;const Nmt={toc:[]};function Smt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Smt.isMDXComponent=!0;const Rmt={toc:[]};function zmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}zmt.isMDXComponent=!0;const Pmt={toc:[]};function Amt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Amt.isMDXComponent=!0;const Imt={toc:[]};function Wmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Imt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Wmt.isMDXComponent=!0;const Emt={toc:[]};function Bmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Emt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Bmt.isMDXComponent=!0;const Fmt={toc:[]};function Omt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Omt.isMDXComponent=!0;const Gmt={toc:[]};function jmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}jmt.isMDXComponent=!0;const Umt={toc:[]};function qmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Umt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}qmt.isMDXComponent=!0;const Vmt={toc:[]};function Hmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}Hmt.isMDXComponent=!0;const $mt={toc:[]};function Qmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$mt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Qmt.isMDXComponent=!0;const Jmt={toc:[]};function Ymt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Ymt.isMDXComponent=!0;const Kmt={toc:[]};function tdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}tdt.isMDXComponent=!0;const edt={toc:[]};function ndt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},edt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ndt.isMDXComponent=!0;const odt={toc:[]};function rdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},odt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}rdt.isMDXComponent=!0;const sdt={toc:[]};function pdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}pdt.isMDXComponent=!0;const idt={toc:[]};function cdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},idt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}cdt.isMDXComponent=!0;const adt={toc:[]};function ldt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},adt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}ldt.isMDXComponent=!0;const udt={toc:[]};function mdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},udt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}mdt.isMDXComponent=!0;const ddt={toc:[]};function hdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ddt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}hdt.isMDXComponent=!0;const fdt={toc:[]};function ydt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}ydt.isMDXComponent=!0;const kdt={toc:[]};function wdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}wdt.isMDXComponent=!0;const Mdt={toc:[]};function Ddt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}Ddt.isMDXComponent=!0;const _dt={toc:[]};function gdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_dt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}gdt.isMDXComponent=!0;const Xdt={toc:[]};function xdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}xdt.isMDXComponent=!0;const Cdt={toc:[]};function Tdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Tdt.isMDXComponent=!0;const vdt={toc:[]};function bdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}bdt.isMDXComponent=!0;const Ldt={toc:[]};function Zdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ldt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}Zdt.isMDXComponent=!0;const Ndt={toc:[]};function Sdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ndt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}Sdt.isMDXComponent=!0;const Rdt={toc:[]};function zdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}zdt.isMDXComponent=!0;const Pdt={toc:[]};function Adt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Adt.isMDXComponent=!0;const Idt={toc:[]};function Wdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Idt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Wdt.isMDXComponent=!0;const Edt={toc:[]};function Bdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Edt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}Bdt.isMDXComponent=!0;const Fdt={toc:[]};function Odt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Odt.isMDXComponent=!0;const Gdt={toc:[]};function jdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}jdt.isMDXComponent=!0;const Udt={toc:[]};function qdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Udt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}qdt.isMDXComponent=!0;const Vdt={toc:[]};function Hdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Hdt.isMDXComponent=!0;const $dt={toc:[]};function Qdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$dt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}Qdt.isMDXComponent=!0;const Jdt={toc:[]};function Ydt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}Ydt.isMDXComponent=!0;const Kdt={toc:[]};function tht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}tht.isMDXComponent=!0;const eht={toc:[]};function nht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}nht.isMDXComponent=!0;const oht={toc:[]};function rht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}rht.isMDXComponent=!0;const sht={toc:[]};function pht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}pht.isMDXComponent=!0;const iht={toc:[]};function cht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}cht.isMDXComponent=!0;const aht={toc:[]};function lht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}lht.isMDXComponent=!0;const uht={toc:[]};function mht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}mht.isMDXComponent=!0;const dht={toc:[]};function hht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}hht.isMDXComponent=!0;const fht={toc:[]};function yht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}yht.isMDXComponent=!0;const kht={toc:[]};function wht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}wht.isMDXComponent=!0;const Mht={toc:[]};function Dht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Dht.isMDXComponent=!0;const _ht={toc:[]};function ght(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_ht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}ght.isMDXComponent=!0;const Xht={toc:[]};function xht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}xht.isMDXComponent=!0;const Cht={toc:[]};function Tht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Tht.isMDXComponent=!0;const vht={toc:[]};function bht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}bht.isMDXComponent=!0;const Lht={toc:[]};function Zht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Zht.isMDXComponent=!0;const Nht={toc:[]};function Sht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}Sht.isMDXComponent=!0;const Rht={toc:[]};function zht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}zht.isMDXComponent=!0;const Pht={toc:[]};function Aht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}Aht.isMDXComponent=!0;const Iht={toc:[]};function Wht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Iht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Wht.isMDXComponent=!0;const Eht={toc:[]};function Bht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Bht.isMDXComponent=!0;const Fht={toc:[]};function Oht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Oht.isMDXComponent=!0;const Ght={toc:[]};function jht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ght,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}jht.isMDXComponent=!0;const Uht={toc:[]};function qht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}qht.isMDXComponent=!0;const Vht={toc:[]};function Hht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Hht.isMDXComponent=!0;const $ht={toc:[]};function Qht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$ht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Qht.isMDXComponent=!0;const Jht={toc:[]};function Yht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Yht.isMDXComponent=!0;const Kht={toc:[]};function tft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}tft.isMDXComponent=!0;const eft={toc:[]};function nft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}nft.isMDXComponent=!0;const oft={toc:[]};function rft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}rft.isMDXComponent=!0;const sft={toc:[]};function pft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pft.isMDXComponent=!0;const ift={toc:[]};function cft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ift,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cft.isMDXComponent=!0;const aft={toc:[]};function lft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}lft.isMDXComponent=!0;const uft={toc:[]};function mft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}mft.isMDXComponent=!0;const dft={toc:[]};function hft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}hft.isMDXComponent=!0;const fft={toc:[]};function yft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}yft.isMDXComponent=!0;const kft={toc:[]};function wft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}wft.isMDXComponent=!0;const Mft={toc:[]};function Dft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Dft.isMDXComponent=!0;const _ft={toc:[]};function gft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_ft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}gft.isMDXComponent=!0;const Xft={toc:[]};function xft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}xft.isMDXComponent=!0;const Cft={toc:[]};function Tft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Tft.isMDXComponent=!0;const vft={toc:[]};function bft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}bft.isMDXComponent=!0;const Lft={toc:[]};function Zft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Zft.isMDXComponent=!0;const Nft={toc:[]};function Sft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Sft.isMDXComponent=!0;const Rft={toc:[]};function zft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}zft.isMDXComponent=!0;const Pft={toc:[]};function Aft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Aft.isMDXComponent=!0;const Ift={toc:[]};function Wft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ift,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Wft.isMDXComponent=!0;const Eft={toc:[]};function Bft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Bft.isMDXComponent=!0;const Fft={toc:[]};function Oft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Oft.isMDXComponent=!0;const Gft={toc:[]};function jft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}jft.isMDXComponent=!0;const Uft={toc:[]};function qft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}qft.isMDXComponent=!0;const Vft={toc:[]};function Hft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}Hft.isMDXComponent=!0;const $ft={toc:[]};function Qft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$ft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,p.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,p.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticable if the number of sides is low, e.g. for a\ntriangle."))}Qft.isMDXComponent=!0;const Jft={toc:[]};function Yft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}Yft.isMDXComponent=!0;const Kft={toc:[]};function tyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node for drawing regular polygons."))}tyt.isMDXComponent=!0;const eyt={toc:[]};function nyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}nyt.isMDXComponent=!0;const oyt={toc:[]};function ryt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}ryt.isMDXComponent=!0;const syt={toc:[]};function pyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},syt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}pyt.isMDXComponent=!0;const iyt={toc:[]};function cyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}cyt.isMDXComponent=!0;const ayt={toc:[]};function lyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ayt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}lyt.isMDXComponent=!0;const uyt={toc:[]};function myt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}myt.isMDXComponent=!0;const dyt={toc:[]};function hyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}hyt.isMDXComponent=!0;const fyt={toc:[]};function yyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}yyt.isMDXComponent=!0;const kyt={toc:[]};function wyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}wyt.isMDXComponent=!0;const Myt={toc:[]};function Dyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Myt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Dyt.isMDXComponent=!0;const _yt={toc:[]};function gyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_yt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}gyt.isMDXComponent=!0;const Xyt={toc:[]};function xyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}xyt.isMDXComponent=!0;const Cyt={toc:[]};function Tyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Tyt.isMDXComponent=!0;const vyt={toc:[]};function byt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}byt.isMDXComponent=!0;const Lyt={toc:[]};function Zyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Zyt.isMDXComponent=!0;const Nyt={toc:[]};function Syt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}Syt.isMDXComponent=!0;const Ryt={toc:[]};function zyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ryt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}zyt.isMDXComponent=!0;const Pyt={toc:[]};function Ayt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}Ayt.isMDXComponent=!0;const Iyt={toc:[]};function Wyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Iyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Wyt.isMDXComponent=!0;const Eyt={toc:[]};function Byt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Byt.isMDXComponent=!0;const Fyt={toc:[]};function Oyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Oyt.isMDXComponent=!0;const Gyt={toc:[]};function jyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}jyt.isMDXComponent=!0;const Uyt={toc:[]};function qyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}qyt.isMDXComponent=!0;const Vyt={toc:[]};function Hyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"For example, a value of 6 creates a hexagon."))}Hyt.isMDXComponent=!0;const $yt={toc:[]};function Qyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$yt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}Qyt.isMDXComponent=!0;const Jyt={toc:[]};function Yyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Sets the number of sides of the polygon."))}Yyt.isMDXComponent=!0;const Kyt={toc:[]};function tkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}tkt.isMDXComponent=!0;const ekt={toc:[]};function nkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ekt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}nkt.isMDXComponent=!0;const okt={toc:[]};function rkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},okt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}rkt.isMDXComponent=!0;const skt={toc:[]};function pkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},skt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}pkt.isMDXComponent=!0;const ikt={toc:[]};function ckt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ikt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}ckt.isMDXComponent=!0;const akt={toc:[]};function lkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},akt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}lkt.isMDXComponent=!0;const ukt={toc:[]};function mkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ukt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}mkt.isMDXComponent=!0;const dkt={toc:[]};function hkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}hkt.isMDXComponent=!0;const fkt={toc:[]};function ykt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}ykt.isMDXComponent=!0;const kkt={toc:[]};function wkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}wkt.isMDXComponent=!0;const Mkt={toc:[]};function Dkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Dkt.isMDXComponent=!0;const _kt={toc:[]};function gkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_kt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}gkt.isMDXComponent=!0;const Xkt={toc:[]};function xkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}xkt.isMDXComponent=!0;const Ckt={toc:[]};function Tkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ckt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Tkt.isMDXComponent=!0;const vkt={toc:[]};function bkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}bkt.isMDXComponent=!0;const Lkt={toc:[]};function Zkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Zkt.isMDXComponent=!0;const Nkt={toc:[]};function Skt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Skt.isMDXComponent=!0;const Rkt={toc:[]};function zkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}zkt.isMDXComponent=!0;const Pkt={toc:[]};function Akt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Akt.isMDXComponent=!0;const Ikt={toc:[]};function Wkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ikt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Wkt.isMDXComponent=!0;const Ekt={toc:[]};function Bkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ekt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Bkt.isMDXComponent=!0;const Fkt={toc:[]};function Okt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Okt.isMDXComponent=!0;const Gkt={toc:[]};function jkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}jkt.isMDXComponent=!0;const Ukt={toc:[]};function qkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ukt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}qkt.isMDXComponent=!0;const Vkt={toc:[]};function Hkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Hkt.isMDXComponent=!0;const $kt={toc:[]};function Qkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$kt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}Qkt.isMDXComponent=!0;const Jkt={toc:[]};function Ykt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Ykt.isMDXComponent=!0;const Kkt={toc:[]};function twt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}twt.isMDXComponent=!0;const ewt={toc:[]};function nwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ewt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}nwt.isMDXComponent=!0;const owt={toc:[]};function rwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},owt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}rwt.isMDXComponent=!0;const swt={toc:[]};function pwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},swt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}pwt.isMDXComponent=!0;const iwt={toc:[]};function cwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}cwt.isMDXComponent=!0;const awt={toc:[]};function lwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},awt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}lwt.isMDXComponent=!0;const uwt={toc:[]};function mwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}mwt.isMDXComponent=!0;const dwt={toc:[]};function hwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}hwt.isMDXComponent=!0;const fwt={toc:[]};function ywt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}ywt.isMDXComponent=!0;const kwt={toc:[]};function wwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}wwt.isMDXComponent=!0;const Mwt={toc:[]};function Dwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Dwt.isMDXComponent=!0;const _wt={toc:[]};function gwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_wt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}gwt.isMDXComponent=!0;const Xwt={toc:[]};function xwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}xwt.isMDXComponent=!0;const Cwt={toc:[]};function Twt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Twt.isMDXComponent=!0;const vwt={toc:[]};function bwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}bwt.isMDXComponent=!0;const Lwt={toc:[]};function Zwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Zwt.isMDXComponent=!0;const Nwt={toc:[]};function Swt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}Swt.isMDXComponent=!0;const Rwt={toc:[]};function zwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}zwt.isMDXComponent=!0;const Pwt={toc:[]};function Awt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Awt.isMDXComponent=!0;const Iwt={toc:[]};function Wwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Iwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Wwt.isMDXComponent=!0;const Ewt={toc:[]};function Bwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ewt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Bwt.isMDXComponent=!0;const Fwt={toc:[]};function Owt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}Owt.isMDXComponent=!0;const Gwt={toc:[]};function jwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}jwt.isMDXComponent=!0;const Uwt={toc:[]};function qwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}qwt.isMDXComponent=!0;const Vwt={toc:[]};function Hwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Hwt.isMDXComponent=!0;const $wt={toc:[]};function Qwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$wt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Qwt.isMDXComponent=!0;const Jwt={toc:[]};function Ywt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}Ywt.isMDXComponent=!0;const Kwt={toc:[]};function tMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}tMt.isMDXComponent=!0;const eMt={toc:[]};function nMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}nMt.isMDXComponent=!0;const oMt={toc:[]};function rMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}rMt.isMDXComponent=!0;const sMt={toc:[]};function pMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}pMt.isMDXComponent=!0;const iMt={toc:[]};function cMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}cMt.isMDXComponent=!0;const aMt={toc:[]};function lMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}lMt.isMDXComponent=!0;const uMt={toc:[]};function mMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}mMt.isMDXComponent=!0;const dMt={toc:[]};function hMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}hMt.isMDXComponent=!0;const fMt={toc:[]};function yMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}yMt.isMDXComponent=!0;const kMt={toc:[]};function wMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}wMt.isMDXComponent=!0;const MMt={toc:[]};function DMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}DMt.isMDXComponent=!0;const _Mt={toc:[]};function gMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Mt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}gMt.isMDXComponent=!0;const XMt={toc:[]};function xMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}xMt.isMDXComponent=!0;const CMt={toc:[]};function TMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}TMt.isMDXComponent=!0;const vMt={toc:[]};function bMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}bMt.isMDXComponent=!0;const LMt={toc:[]};function ZMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}ZMt.isMDXComponent=!0;const NMt={toc:[]};function SMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}SMt.isMDXComponent=!0;const RMt={toc:[]};function zMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}zMt.isMDXComponent=!0;const PMt={toc:[]};function AMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}AMt.isMDXComponent=!0;const IMt={toc:[]};function WMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}WMt.isMDXComponent=!0;const EMt={toc:[]};function BMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}BMt.isMDXComponent=!0;const FMt={toc:[]};function OMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}OMt.isMDXComponent=!0;const GMt={toc:[]};function jMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}jMt.isMDXComponent=!0;const UMt={toc:[]};function qMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}qMt.isMDXComponent=!0;const VMt={toc:[]};function HMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}HMt.isMDXComponent=!0;const $Mt={toc:[]};function QMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Mt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}QMt.isMDXComponent=!0;const JMt={toc:[]};function YMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}YMt.isMDXComponent=!0;const KMt={toc:[]};function tDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}tDt.isMDXComponent=!0;const eDt={toc:[]};function nDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}nDt.isMDXComponent=!0;const oDt={toc:[]};function rDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}rDt.isMDXComponent=!0;const sDt={toc:[]};function pDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}pDt.isMDXComponent=!0;const iDt={toc:[]};function cDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}cDt.isMDXComponent=!0;const aDt={toc:[]};function lDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}lDt.isMDXComponent=!0;const uDt={toc:[]};function mDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}mDt.isMDXComponent=!0;const dDt={toc:[]};function hDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}hDt.isMDXComponent=!0;const fDt={toc:[]};function yDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}yDt.isMDXComponent=!0;const kDt={toc:[]};function wDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}wDt.isMDXComponent=!0;const MDt={toc:[]};function DDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}DDt.isMDXComponent=!0;const _Dt={toc:[]};function gDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Dt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}gDt.isMDXComponent=!0;const XDt={toc:[]};function xDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}xDt.isMDXComponent=!0;const CDt={toc:[]};function TDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}TDt.isMDXComponent=!0;const vDt={toc:[]};function bDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}bDt.isMDXComponent=!0;const LDt={toc:[]};function ZDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}ZDt.isMDXComponent=!0;const NDt={toc:[]};function SDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}SDt.isMDXComponent=!0;const RDt={toc:[]};function zDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}zDt.isMDXComponent=!0;const PDt={toc:[]};function ADt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}ADt.isMDXComponent=!0;const IDt={toc:[]};function WDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}WDt.isMDXComponent=!0;const EDt={toc:[]};function BDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}BDt.isMDXComponent=!0;const FDt={toc:[]};function ODt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}ODt.isMDXComponent=!0;const GDt={toc:[]};function jDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}jDt.isMDXComponent=!0;const UDt={toc:[]};function qDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}qDt.isMDXComponent=!0;const VDt={toc:[]};function HDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}HDt.isMDXComponent=!0;const $Dt={toc:[]};function QDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Dt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}QDt.isMDXComponent=!0;const JDt={toc:[]};function YDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}YDt.isMDXComponent=!0;const KDt={toc:[]};function t_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}t_t.isMDXComponent=!0;const e_t={toc:[]};function n_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},e_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}n_t.isMDXComponent=!0;const o_t={toc:[]};function r_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},o_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}r_t.isMDXComponent=!0;const s_t={toc:[]};function p_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},s_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}p_t.isMDXComponent=!0;const i_t={toc:[]};function c_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},i_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}c_t.isMDXComponent=!0;const a_t={toc:[]};function l_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},a_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}l_t.isMDXComponent=!0;const u_t={toc:[]};function m_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},u_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}m_t.isMDXComponent=!0;const d_t={toc:[]};function h_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},d_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}h_t.isMDXComponent=!0;const f_t={toc:[]};function y_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},f_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}y_t.isMDXComponent=!0;const k_t={toc:[]};function w_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},k_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}w_t.isMDXComponent=!0;const M_t={toc:[]};function D_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},M_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}D_t.isMDXComponent=!0;const __t={toc:[]};function g_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},__t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}g_t.isMDXComponent=!0;const X_t={toc:[]};function x_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},X_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}x_t.isMDXComponent=!0;const C_t={toc:[]};function T_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},C_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}T_t.isMDXComponent=!0;const v_t={toc:[]};function b_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},v_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}b_t.isMDXComponent=!0;const L_t={toc:[]};function Z_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},L_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}Z_t.isMDXComponent=!0;const N_t={toc:[]};function S_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},N_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}S_t.isMDXComponent=!0;const R_t={toc:[]};function z_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},R_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}z_t.isMDXComponent=!0;const P_t={toc:[]};function A_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},P_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}A_t.isMDXComponent=!0;const I_t={toc:[]};function W_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},I_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}W_t.isMDXComponent=!0;const E_t={toc:[]};function B_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},E_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}B_t.isMDXComponent=!0;const F_t={toc:[]};function O_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},F_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}O_t.isMDXComponent=!0;const G_t={toc:[]};function j_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},G_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}j_t.isMDXComponent=!0;const U_t={toc:[]};function q_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},U_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}q_t.isMDXComponent=!0;const V_t={toc:[]};function H_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},V_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}H_t.isMDXComponent=!0;const $_t={toc:[]};function Q_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Q_t.isMDXComponent=!0;const J_t={toc:[]};function Y_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},J_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Y_t.isMDXComponent=!0;const K_t={toc:[]};function tgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},K_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}tgt.isMDXComponent=!0;const egt={toc:[]};function ngt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},egt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}ngt.isMDXComponent=!0;const ogt={toc:[]};function rgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ogt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}rgt.isMDXComponent=!0;const sgt={toc:[]};function pgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}pgt.isMDXComponent=!0;const igt={toc:[]};function cgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},igt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}cgt.isMDXComponent=!0;const agt={toc:[]};function lgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},agt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}lgt.isMDXComponent=!0;const ugt={toc:[]};function mgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ugt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}mgt.isMDXComponent=!0;const dgt={toc:[]};function hgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start point of the B\xe9zier curve."))}hgt.isMDXComponent=!0;const fgt={toc:[]};function ygt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The control point of the B\xe9zier curve."))}ygt.isMDXComponent=!0;const kgt={toc:[]};function wgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end point of the B\xe9zier curve."))}wgt.isMDXComponent=!0;const Mgt={toc:[]};function Dgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Dgt.isMDXComponent=!0;const _gt={toc:[]};function ggt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_gt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}ggt.isMDXComponent=!0;const Xgt={toc:[]};function xgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}xgt.isMDXComponent=!0;const Cgt={toc:[]};function Tgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Tgt.isMDXComponent=!0;const vgt={toc:[]};function bgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}bgt.isMDXComponent=!0;const Lgt={toc:[]};function Zgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Zgt.isMDXComponent=!0;const Ngt={toc:[]};function Sgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ngt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Sgt.isMDXComponent=!0;const Rgt={toc:[]};function zgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}zgt.isMDXComponent=!0;const Pgt={toc:[]};function Agt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Agt.isMDXComponent=!0;const Igt={toc:[]};function Wgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Igt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}Wgt.isMDXComponent=!0;const Egt={toc:[]};function Bgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Egt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Bgt.isMDXComponent=!0;const Fgt={toc:[]};function Ogt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Ogt.isMDXComponent=!0;const Ggt={toc:[]};function jgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ggt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}jgt.isMDXComponent=!0;const Ugt={toc:[]};function qgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ugt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}qgt.isMDXComponent=!0;const Vgt={toc:[]};function Hgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Hgt.isMDXComponent=!0;const $gt={toc:[]};function Qgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$gt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}Qgt.isMDXComponent=!0;const Jgt={toc:[]};function Ygt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Ygt.isMDXComponent=!0;const Kgt={toc:[]};function tXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}tXt.isMDXComponent=!0;const eXt={toc:[]};function nXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}nXt.isMDXComponent=!0;const oXt={toc:[]};function rXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}rXt.isMDXComponent=!0;const sXt={toc:[]};function pXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}pXt.isMDXComponent=!0;const iXt={toc:[]};function cXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}cXt.isMDXComponent=!0;const aXt={toc:[]};function lXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}lXt.isMDXComponent=!0;const uXt={toc:[]};function mXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}mXt.isMDXComponent=!0;const dXt={toc:[]};function hXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}hXt.isMDXComponent=!0;const fXt={toc:[]};function yXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}yXt.isMDXComponent=!0;const kXt={toc:[]};function wXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}wXt.isMDXComponent=!0;const MXt={toc:[]};function DXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}DXt.isMDXComponent=!0;const _Xt={toc:[]};function gXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Xt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This arc length accounts for both the offset and the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}gXt.isMDXComponent=!0;const XXt={toc:[]};function xXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The visible arc length of this curve."))}xXt.isMDXComponent=!0;const CXt={toc:[]};function TXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}TXt.isMDXComponent=!0;const vXt={toc:[]};function bXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The base arc length of this curve."))}bXt.isMDXComponent=!0;const LXt={toc:[]};function ZXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}ZXt.isMDXComponent=!0;const NXt={toc:[]};function SXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}SXt.isMDXComponent=!0;const RXt={toc:[]};function zXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}zXt.isMDXComponent=!0;const PXt={toc:[]};function AXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}AXt.isMDXComponent=!0;const IXt={toc:[]};function WXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}WXt.isMDXComponent=!0;const EXt={toc:[]};function BXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}BXt.isMDXComponent=!0;const FXt={toc:[]};function OXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage of the curve that's currently visible."))}OXt.isMDXComponent=!0;const GXt={toc:[]};function jXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}jXt.isMDXComponent=!0;const UXt={toc:[]};function qXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}qXt.isMDXComponent=!0;const VXt={toc:[]};function HXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}HXt.isMDXComponent=!0;const $Xt={toc:[]};function QXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Xt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a distance along the curve to a percentage."))}QXt.isMDXComponent=!0;const JXt={toc:[]};function YXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance along the curve."))}YXt.isMDXComponent=!0;const KXt={toc:[]};function txt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}txt.isMDXComponent=!0;const ext={toc:[]};function nxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ext,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}nxt.isMDXComponent=!0;const oxt={toc:[]};function rxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}rxt.isMDXComponent=!0;const sxt={toc:[]};function pxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}pxt.isMDXComponent=!0;const ixt={toc:[]};function cxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ixt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}cxt.isMDXComponent=!0;const axt={toc:[]};function lxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},axt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}lxt.isMDXComponent=!0;const uxt={toc:[]};function mxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}mxt.isMDXComponent=!0;const dxt={toc:[]};function hxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}hxt.isMDXComponent=!0;const fxt={toc:[]};function yxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}yxt.isMDXComponent=!0;const kxt={toc:[]};function wxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}wxt.isMDXComponent=!0;const Mxt={toc:[]};function Dxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Dxt.isMDXComponent=!0;const _xt={toc:[]};function gxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_xt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}gxt.isMDXComponent=!0;const Xxt={toc:[]};function xxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}xxt.isMDXComponent=!0;const Cxt={toc:[]};function Txt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Txt.isMDXComponent=!0;const vxt={toc:[]};function bxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}bxt.isMDXComponent=!0;const Lxt={toc:[]};function Zxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Zxt.isMDXComponent=!0;const Nxt={toc:[]};function Sxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}Sxt.isMDXComponent=!0;const Rxt={toc:[]};function zxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}zxt.isMDXComponent=!0;const Pxt={toc:[]};function Axt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Axt.isMDXComponent=!0;const Ixt={toc:[]};function Wxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ixt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Wxt.isMDXComponent=!0;const Ext={toc:[]};function Bxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ext,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}Bxt.isMDXComponent=!0;const Fxt={toc:[]};function Oxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Oxt.isMDXComponent=!0;const Gxt={toc:[]};function jxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}jxt.isMDXComponent=!0;const Uxt={toc:[]};function qxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}qxt.isMDXComponent=!0;const Vxt={toc:[]};function Hxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}Hxt.isMDXComponent=!0;const $xt={toc:[]};function Qxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$xt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Qxt.isMDXComponent=!0;const Jxt={toc:[]};function Yxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Yxt.isMDXComponent=!0;const Kxt={toc:[]};function tCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}tCt.isMDXComponent=!0;const eCt={toc:[]};function nCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}nCt.isMDXComponent=!0;const oCt={toc:[]};function rCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}rCt.isMDXComponent=!0;const sCt={toc:[]};function pCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}pCt.isMDXComponent=!0;const iCt={toc:[]};function cCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}cCt.isMDXComponent=!0;const aCt={toc:[]};function lCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}lCt.isMDXComponent=!0;const uCt={toc:[]};function mCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}mCt.isMDXComponent=!0;const dCt={toc:[]};function hCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}hCt.isMDXComponent=!0;const fCt={toc:[]};function yCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}yCt.isMDXComponent=!0;const kCt={toc:[]};function wCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}wCt.isMDXComponent=!0;const MCt={toc:[]};function DCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}DCt.isMDXComponent=!0;const _Ct={toc:[]};function gCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Ct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}gCt.isMDXComponent=!0;const XCt={toc:[]};function xCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the length of the curve that accounts for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}xCt.isMDXComponent=!0;const CCt={toc:[]};function TCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset arc length of this curve."))}TCt.isMDXComponent=!0;const vCt={toc:[]};function bCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}bCt.isMDXComponent=!0;const LCt={toc:[]};function ZCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a percentage along the curve to a distance."))}ZCt.isMDXComponent=!0;const NCt={toc:[]};function SCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage along the curve."))}SCt.isMDXComponent=!0;const RCt={toc:[]};function zCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}zCt.isMDXComponent=!0;const PCt={toc:[]};function ACt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}ACt.isMDXComponent=!0;const ICt={toc:[]};function WCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ICt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}WCt.isMDXComponent=!0;const ECt={toc:[]};function BCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ECt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}BCt.isMDXComponent=!0;const FCt={toc:[]};function OCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}OCt.isMDXComponent=!0;const GCt={toc:[]};function jCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}jCt.isMDXComponent=!0;const UCt={toc:[]};function qCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}qCt.isMDXComponent=!0;const VCt={toc:[]};function HCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}HCt.isMDXComponent=!0;const $Ct={toc:[]};function QCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Ct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}QCt.isMDXComponent=!0;const JCt={toc:[]};function YCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}YCt.isMDXComponent=!0;const KCt={toc:[]};function tTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}tTt.isMDXComponent=!0;const eTt={toc:[]};function nTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}nTt.isMDXComponent=!0;const oTt={toc:[]};function rTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}rTt.isMDXComponent=!0;const sTt={toc:[]};function pTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pTt.isMDXComponent=!0;const iTt={toc:[]};function cTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cTt.isMDXComponent=!0;const aTt={toc:[]};function lTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}lTt.isMDXComponent=!0;const uTt={toc:[]};function mTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}mTt.isMDXComponent=!0;const dTt={toc:[]};function hTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}hTt.isMDXComponent=!0;const fTt={toc:[]};function yTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}yTt.isMDXComponent=!0;const kTt={toc:[]};function wTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}wTt.isMDXComponent=!0;const MTt={toc:[]};function DTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}DTt.isMDXComponent=!0;const _Tt={toc:[]};function gTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Tt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}gTt.isMDXComponent=!0;const XTt={toc:[]};function xTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}xTt.isMDXComponent=!0;const CTt={toc:[]};function TTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}TTt.isMDXComponent=!0;const vTt={toc:[]};function bTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}bTt.isMDXComponent=!0;const LTt={toc:[]};function ZTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}ZTt.isMDXComponent=!0;const NTt={toc:[]};function STt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}STt.isMDXComponent=!0;const RTt={toc:[]};function zTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}zTt.isMDXComponent=!0;const PTt={toc:[]};function ATt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}ATt.isMDXComponent=!0;const ITt={toc:[]};function WTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ITt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}WTt.isMDXComponent=!0;const ETt={toc:[]};function BTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ETt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}BTt.isMDXComponent=!0;const FTt={toc:[]};function OTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}OTt.isMDXComponent=!0;const GTt={toc:[]};function jTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}jTt.isMDXComponent=!0;const UTt={toc:[]};function qTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}qTt.isMDXComponent=!0;const VTt={toc:[]};function HTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}HTt.isMDXComponent=!0;const $Tt={toc:[]};function QTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Tt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}QTt.isMDXComponent=!0;const JTt={toc:[]};function YTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@motion-canvas/2d';\nimport {Ray} from '@motion-canvas/2d/lib/components';\nimport {createRef} from '@motion-canvas/core/lib/utils';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}YTt.isMDXComponent=!0;const KTt={toc:[]};function tvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node for drawing an individual line segment."))}tvt.isMDXComponent=!0;const evt={toc:[]};function nvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},evt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}nvt.isMDXComponent=!0;const ovt={toc:[]};function rvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ovt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}rvt.isMDXComponent=!0;const svt={toc:[]};function pvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},svt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}pvt.isMDXComponent=!0;const ivt={toc:[]};function cvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ivt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}cvt.isMDXComponent=!0;const avt={toc:[]};function lvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},avt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}lvt.isMDXComponent=!0;const uvt={toc:[]};function mvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}mvt.isMDXComponent=!0;const dvt={toc:[]};function hvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}hvt.isMDXComponent=!0;const fvt={toc:[]};function yvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}yvt.isMDXComponent=!0;const kvt={toc:[]};function wvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}wvt.isMDXComponent=!0;const Mvt={toc:[]};function Dvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Dvt.isMDXComponent=!0;const _vt={toc:[]};function gvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_vt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}gvt.isMDXComponent=!0;const Xvt={toc:[]};function xvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}xvt.isMDXComponent=!0;const Cvt={toc:[]};function Tvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Tvt.isMDXComponent=!0;const vvt={toc:[]};function bvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}bvt.isMDXComponent=!0;const Lvt={toc:[]};function Zvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}Zvt.isMDXComponent=!0;const Nvt={toc:[]};function Svt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}Svt.isMDXComponent=!0;const Rvt={toc:[]};function zvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}zvt.isMDXComponent=!0;const Pvt={toc:[]};function Avt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Avt.isMDXComponent=!0;const Ivt={toc:[]};function Wvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ivt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Wvt.isMDXComponent=!0;const Evt={toc:[]};function Bvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Evt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Bvt.isMDXComponent=!0;const Fvt={toc:[]};function Ovt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Ovt.isMDXComponent=!0;const Gvt={toc:[]};function jvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}jvt.isMDXComponent=!0;const Uvt={toc:[]};function qvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The starting point of the ray."))}qvt.isMDXComponent=!0;const Vvt={toc:[]};function Hvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Hvt.isMDXComponent=!0;const $vt={toc:[]};function Qvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$vt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Qvt.isMDXComponent=!0;const Jvt={toc:[]};function Yvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Yvt.isMDXComponent=!0;const Kvt={toc:[]};function tbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}tbt.isMDXComponent=!0;const ebt={toc:[]};function nbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ebt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}nbt.isMDXComponent=!0;const obt={toc:[]};function rbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},obt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}rbt.isMDXComponent=!0;const sbt={toc:[]};function pbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}pbt.isMDXComponent=!0;const ibt={toc:[]};function cbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ibt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}cbt.isMDXComponent=!0;const abt={toc:[]};function lbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},abt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}lbt.isMDXComponent=!0;const ubt={toc:[]};function mbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ubt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}mbt.isMDXComponent=!0;const dbt={toc:[]};function hbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}hbt.isMDXComponent=!0;const fbt={toc:[]};function ybt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}ybt.isMDXComponent=!0;const kbt={toc:[]};function wbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}wbt.isMDXComponent=!0;const Mbt={toc:[]};function Dbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}Dbt.isMDXComponent=!0;const _bt={toc:[]};function gbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_bt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}gbt.isMDXComponent=!0;const Xbt={toc:[]};function xbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}xbt.isMDXComponent=!0;const Cbt={toc:[]};function Tbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Tbt.isMDXComponent=!0;const vbt={toc:[]};function bbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}bbt.isMDXComponent=!0;const Lbt={toc:[]};function Zbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Zbt.isMDXComponent=!0;const Nbt={toc:[]};function Sbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}Sbt.isMDXComponent=!0;const Rbt={toc:[]};function zbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ending point of the ray."))}zbt.isMDXComponent=!0;const Pbt={toc:[]};function Abt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Abt.isMDXComponent=!0;const Ibt={toc:[]};function Wbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ibt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}Wbt.isMDXComponent=!0;const Ebt={toc:[]};function Bbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ebt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Bbt.isMDXComponent=!0;const Fbt={toc:[]};function Obt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Obt.isMDXComponent=!0;const Gbt={toc:[]};function jbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}jbt.isMDXComponent=!0;const Ubt={toc:[]};function qbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ubt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}qbt.isMDXComponent=!0;const Vbt={toc:[]};function Hbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}Hbt.isMDXComponent=!0;const $bt={toc:[]};function Qbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$bt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Qbt.isMDXComponent=!0;const Jbt={toc:[]};function Ybt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}Ybt.isMDXComponent=!0;const Kbt={toc:[]};function tLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}tLt.isMDXComponent=!0;const eLt={toc:[]};function nLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}nLt.isMDXComponent=!0;const oLt={toc:[]};function rLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}rLt.isMDXComponent=!0;const sLt={toc:[]};function pLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This arc length accounts for both the offset and the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}pLt.isMDXComponent=!0;const iLt={toc:[]};function cLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The visible arc length of this curve."))}cLt.isMDXComponent=!0;const aLt={toc:[]};function lLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}lLt.isMDXComponent=!0;const uLt={toc:[]};function mLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The base arc length of this curve."))}mLt.isMDXComponent=!0;const dLt={toc:[]};function hLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}hLt.isMDXComponent=!0;const fLt={toc:[]};function yLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}yLt.isMDXComponent=!0;const kLt={toc:[]};function wLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}wLt.isMDXComponent=!0;const MLt={toc:[]};function DLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}DLt.isMDXComponent=!0;const _Lt={toc:[]};function gLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Lt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}gLt.isMDXComponent=!0;const XLt={toc:[]};function xLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}xLt.isMDXComponent=!0;const CLt={toc:[]};function TLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage of the curve that's currently visible."))}TLt.isMDXComponent=!0;const vLt={toc:[]};function bLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}bLt.isMDXComponent=!0;const LLt={toc:[]};function ZLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}ZLt.isMDXComponent=!0;const NLt={toc:[]};function SLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}SLt.isMDXComponent=!0;const RLt={toc:[]};function zLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}zLt.isMDXComponent=!0;const PLt={toc:[]};function ALt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}ALt.isMDXComponent=!0;const ILt={toc:[]};function WLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ILt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}WLt.isMDXComponent=!0;const ELt={toc:[]};function BLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ELt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}BLt.isMDXComponent=!0;const FLt={toc:[]};function OLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a distance along the curve to a percentage."))}OLt.isMDXComponent=!0;const GLt={toc:[]};function jLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance along the curve."))}jLt.isMDXComponent=!0;const ULt={toc:[]};function qLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ULt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}qLt.isMDXComponent=!0;const VLt={toc:[]};function HLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}HLt.isMDXComponent=!0;const $Lt={toc:[]};function QLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Lt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}QLt.isMDXComponent=!0;const JLt={toc:[]};function YLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}YLt.isMDXComponent=!0;const KLt={toc:[]};function tZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}tZt.isMDXComponent=!0;const eZt={toc:[]};function nZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}nZt.isMDXComponent=!0;const oZt={toc:[]};function rZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}rZt.isMDXComponent=!0;const sZt={toc:[]};function pZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}pZt.isMDXComponent=!0;const iZt={toc:[]};function cZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}cZt.isMDXComponent=!0;const aZt={toc:[]};function lZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}lZt.isMDXComponent=!0;const uZt={toc:[]};function mZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}mZt.isMDXComponent=!0;const dZt={toc:[]};function hZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}hZt.isMDXComponent=!0;const fZt={toc:[]};function yZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}yZt.isMDXComponent=!0;const kZt={toc:[]};function wZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}wZt.isMDXComponent=!0;const MZt={toc:[]};function DZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}DZt.isMDXComponent=!0;const _Zt={toc:[]};function gZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Zt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}gZt.isMDXComponent=!0;const XZt={toc:[]};function xZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}xZt.isMDXComponent=!0;const CZt={toc:[]};function TZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}TZt.isMDXComponent=!0;const vZt={toc:[]};function bZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}bZt.isMDXComponent=!0;const LZt={toc:[]};function ZZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}ZZt.isMDXComponent=!0;const NZt={toc:[]};function SZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}SZt.isMDXComponent=!0;const RZt={toc:[]};function zZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}zZt.isMDXComponent=!0;const PZt={toc:[]};function AZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}AZt.isMDXComponent=!0;const IZt={toc:[]};function WZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}WZt.isMDXComponent=!0;const EZt={toc:[]};function BZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}BZt.isMDXComponent=!0;const FZt={toc:[]};function OZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}OZt.isMDXComponent=!0;const GZt={toc:[]};function jZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}jZt.isMDXComponent=!0;const UZt={toc:[]};function qZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}qZt.isMDXComponent=!0;const VZt={toc:[]};function HZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}HZt.isMDXComponent=!0;const $Zt={toc:[]};function QZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Zt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}QZt.isMDXComponent=!0;const JZt={toc:[]};function YZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}YZt.isMDXComponent=!0;const KZt={toc:[]};function tNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}tNt.isMDXComponent=!0;const eNt={toc:[]};function nNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}nNt.isMDXComponent=!0;const oNt={toc:[]};function rNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}rNt.isMDXComponent=!0;const sNt={toc:[]};function pNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}pNt.isMDXComponent=!0;const iNt={toc:[]};function cNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}cNt.isMDXComponent=!0;const aNt={toc:[]};function lNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}lNt.isMDXComponent=!0;const uNt={toc:[]};function mNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}mNt.isMDXComponent=!0;const dNt={toc:[]};function hNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}hNt.isMDXComponent=!0;const fNt={toc:[]};function yNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}yNt.isMDXComponent=!0;const kNt={toc:[]};function wNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}wNt.isMDXComponent=!0;const MNt={toc:[]};function DNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}DNt.isMDXComponent=!0;const _Nt={toc:[]};function gNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Nt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}gNt.isMDXComponent=!0;const XNt={toc:[]};function xNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}xNt.isMDXComponent=!0;const CNt={toc:[]};function TNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}TNt.isMDXComponent=!0;const vNt={toc:[]};function bNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}bNt.isMDXComponent=!0;const LNt={toc:[]};function ZNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}ZNt.isMDXComponent=!0;const NNt={toc:[]};function SNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}SNt.isMDXComponent=!0;const RNt={toc:[]};function zNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}zNt.isMDXComponent=!0;const PNt={toc:[]};function ANt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}ANt.isMDXComponent=!0;const INt={toc:[]};function WNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},INt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}WNt.isMDXComponent=!0;const ENt={toc:[]};function BNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ENt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}BNt.isMDXComponent=!0;const FNt={toc:[]};function ONt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the length of the curve that accounts for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}ONt.isMDXComponent=!0;const GNt={toc:[]};function jNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset arc length of this curve."))}jNt.isMDXComponent=!0;const UNt={toc:[]};function qNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}qNt.isMDXComponent=!0;const VNt={toc:[]};function HNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a percentage along the curve to a distance."))}HNt.isMDXComponent=!0;const $Nt={toc:[]};function QNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Nt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage along the curve."))}QNt.isMDXComponent=!0;const JNt={toc:[]};function YNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}YNt.isMDXComponent=!0;const KNt={toc:[]};function tSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}tSt.isMDXComponent=!0;const eSt={toc:[]};function nSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}nSt.isMDXComponent=!0;const oSt={toc:[]};function rSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}rSt.isMDXComponent=!0;const sSt={toc:[]};function pSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}pSt.isMDXComponent=!0;const iSt={toc:[]};function cSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}cSt.isMDXComponent=!0;const aSt={toc:[]};function lSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}lSt.isMDXComponent=!0;const uSt={toc:[]};function mSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}mSt.isMDXComponent=!0;const dSt={toc:[]};function hSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}hSt.isMDXComponent=!0;const fSt={toc:[]};function ySt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}ySt.isMDXComponent=!0;const kSt={toc:[]};function wSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}wSt.isMDXComponent=!0;const MSt={toc:[]};function DSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}DSt.isMDXComponent=!0;const _St={toc:[]};function gSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_St,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}gSt.isMDXComponent=!0;const XSt={toc:[]};function xSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}xSt.isMDXComponent=!0;const CSt={toc:[]};function TSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}TSt.isMDXComponent=!0;const vSt={toc:[]};function bSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}bSt.isMDXComponent=!0;const LSt={toc:[]};function ZSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}ZSt.isMDXComponent=!0;const NSt={toc:[]};function SSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}SSt.isMDXComponent=!0;const RSt={toc:[]};function zSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}zSt.isMDXComponent=!0;const PSt={toc:[]};function ASt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}ASt.isMDXComponent=!0;const ISt={toc:[]};function WSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ISt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}WSt.isMDXComponent=!0;const ESt={toc:[]};function BSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ESt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}BSt.isMDXComponent=!0;const FSt={toc:[]};function OSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}OSt.isMDXComponent=!0;const GSt={toc:[]};function jSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}jSt.isMDXComponent=!0;const USt={toc:[]};function qSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},USt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}qSt.isMDXComponent=!0;const VSt={toc:[]};function HSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}HSt.isMDXComponent=!0;const $St={toc:[]};function QSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$St,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}QSt.isMDXComponent=!0;const JSt={toc:[]};function YSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}YSt.isMDXComponent=!0;const KSt={toc:[]};function tRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}tRt.isMDXComponent=!0;const eRt={toc:[]};function nRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}nRt.isMDXComponent=!0;const oRt={toc:[]};function rRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}rRt.isMDXComponent=!0;const sRt={toc:[]};function pRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}pRt.isMDXComponent=!0;const iRt={toc:[]};function cRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}cRt.isMDXComponent=!0;const aRt={toc:[]};function lRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}lRt.isMDXComponent=!0;const uRt={toc:[]};function mRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}mRt.isMDXComponent=!0;const dRt={toc:[]};function hRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}hRt.isMDXComponent=!0;const fRt={toc:[]};function yRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}yRt.isMDXComponent=!0;const kRt={toc:[]};function wRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}wRt.isMDXComponent=!0;const MRt={toc:[]};function DRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}DRt.isMDXComponent=!0;const _Rt={toc:[]};function gRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Rt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}gRt.isMDXComponent=!0;const XRt={toc:[]};function xRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}xRt.isMDXComponent=!0;const CRt={toc:[]};function TRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}TRt.isMDXComponent=!0;const vRt={toc:[]};function bRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}bRt.isMDXComponent=!0;const LRt={toc:[]};function ZRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}ZRt.isMDXComponent=!0;const NRt={toc:[]};function SRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}SRt.isMDXComponent=!0;const RRt={toc:[]};function zRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}zRt.isMDXComponent=!0;const PRt={toc:[]};function ARt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}ARt.isMDXComponent=!0;const IRt={toc:[]};function WRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}WRt.isMDXComponent=!0;const ERt={toc:[]};function BRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ERt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}BRt.isMDXComponent=!0;const FRt={toc:[]};function ORt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}ORt.isMDXComponent=!0;const GRt={toc:[]};function jRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}jRt.isMDXComponent=!0;const URt={toc:[]};function qRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},URt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}qRt.isMDXComponent=!0;const VRt={toc:[]};function HRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}HRt.isMDXComponent=!0;const $Rt={toc:[]};function QRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Rt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}QRt.isMDXComponent=!0;const JRt={toc:[]};function YRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}YRt.isMDXComponent=!0;const KRt={toc:[]};function tzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}tzt.isMDXComponent=!0;const ezt={toc:[]};function nzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ezt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}nzt.isMDXComponent=!0;const ozt={toc:[]};function rzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ozt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}rzt.isMDXComponent=!0;const szt={toc:[]};function pzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},szt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}pzt.isMDXComponent=!0;const izt={toc:[]};function czt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},izt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}czt.isMDXComponent=!0;const azt={toc:[]};function lzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},azt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}lzt.isMDXComponent=!0;const uzt={toc:[]};function mzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}mzt.isMDXComponent=!0;const dzt={toc:[]};function hzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}hzt.isMDXComponent=!0;const fzt={toc:[]};function yzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}yzt.isMDXComponent=!0;const kzt={toc:[]};function wzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}wzt.isMDXComponent=!0;const Mzt={toc:[]};function Dzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Dzt.isMDXComponent=!0;const _zt={toc:[]};function gzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_zt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}gzt.isMDXComponent=!0;const Xzt={toc:[]};function xzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}xzt.isMDXComponent=!0;const Czt={toc:[]};function Tzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Czt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Tzt.isMDXComponent=!0;const vzt={toc:[]};function bzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}bzt.isMDXComponent=!0;const Lzt={toc:[]};function Zzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Zzt.isMDXComponent=!0;const Nzt={toc:[]};function Szt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Szt.isMDXComponent=!0;const Rzt={toc:[]};function zzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}zzt.isMDXComponent=!0;const Pzt={toc:[]};function Azt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Azt.isMDXComponent=!0;const Izt={toc:[]};function Wzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Izt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}Wzt.isMDXComponent=!0;const Ezt={toc:[]};function Bzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ezt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Bzt.isMDXComponent=!0;const Fzt={toc:[]};function Ozt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}Ozt.isMDXComponent=!0;const Gzt={toc:[]};function jzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}jzt.isMDXComponent=!0;const Uzt={toc:[]};function qzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}qzt.isMDXComponent=!0;const Vzt={toc:[]};function Hzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}Hzt.isMDXComponent=!0;const $zt={toc:[]};function Qzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$zt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Qzt.isMDXComponent=!0;const Jzt={toc:[]};function Yzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Yzt.isMDXComponent=!0;const Kzt={toc:[]};function tPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}tPt.isMDXComponent=!0;const ePt={toc:[]};function nPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ePt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}nPt.isMDXComponent=!0;const oPt={toc:[]};function rPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}rPt.isMDXComponent=!0;const sPt={toc:[]};function pPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}pPt.isMDXComponent=!0;const iPt={toc:[]};function cPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}cPt.isMDXComponent=!0;const aPt={toc:[]};function lPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}lPt.isMDXComponent=!0;const uPt={toc:[]};function mPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}mPt.isMDXComponent=!0;const dPt={toc:[]};function hPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}hPt.isMDXComponent=!0;const fPt={toc:[]};function yPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}yPt.isMDXComponent=!0;const kPt={toc:[]};function wPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}wPt.isMDXComponent=!0;const MPt={toc:[]};function DPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}DPt.isMDXComponent=!0;const _Pt={toc:[]};function gPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Pt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}gPt.isMDXComponent=!0;const XPt={toc:[]};function xPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}xPt.isMDXComponent=!0;const CPt={toc:[]};function TPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}TPt.isMDXComponent=!0;const vPt={toc:[]};function bPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}bPt.isMDXComponent=!0;const LPt={toc:[]};function ZPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}ZPt.isMDXComponent=!0;const NPt={toc:[]};function SPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}SPt.isMDXComponent=!0;const RPt={toc:[]};function zPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}zPt.isMDXComponent=!0;const PPt={toc:[]};function APt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}APt.isMDXComponent=!0;const IPt={toc:[]};function WPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}WPt.isMDXComponent=!0;const EPt={toc:[]};function BPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}BPt.isMDXComponent=!0;const FPt={toc:[]};function OPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}OPt.isMDXComponent=!0;const GPt={toc:[]};function jPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}jPt.isMDXComponent=!0;const UPt={toc:[]};function qPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}qPt.isMDXComponent=!0;const VPt={toc:[]};function HPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}HPt.isMDXComponent=!0;const $Pt={toc:[]};function QPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Pt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}QPt.isMDXComponent=!0;const JPt={toc:[]};function YPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}YPt.isMDXComponent=!0;const KPt={toc:[]};function tAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}tAt.isMDXComponent=!0;const eAt={toc:[]};function nAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}nAt.isMDXComponent=!0;const oAt={toc:[]};function rAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}rAt.isMDXComponent=!0;const sAt={toc:[]};function pAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}pAt.isMDXComponent=!0;const iAt={toc:[]};function cAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}cAt.isMDXComponent=!0;const aAt={toc:[]};function lAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}lAt.isMDXComponent=!0;const uAt={toc:[]};function mAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}mAt.isMDXComponent=!0;const dAt={toc:[]};function hAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}hAt.isMDXComponent=!0;const fAt={toc:[]};function yAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}yAt.isMDXComponent=!0;const kAt={toc:[]};function wAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}wAt.isMDXComponent=!0;const MAt={toc:[]};function DAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}DAt.isMDXComponent=!0;const _At={toc:[]};function gAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_At,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}gAt.isMDXComponent=!0;const XAt={toc:[]};function xAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}xAt.isMDXComponent=!0;const CAt={toc:[]};function TAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}TAt.isMDXComponent=!0;const vAt={toc:[]};function bAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}bAt.isMDXComponent=!0;const LAt={toc:[]};function ZAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}ZAt.isMDXComponent=!0;const NAt={toc:[]};function SAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}SAt.isMDXComponent=!0;const RAt={toc:[]};function zAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}zAt.isMDXComponent=!0;const PAt={toc:[]};function AAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}AAt.isMDXComponent=!0;const IAt={toc:[]};function WAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}WAt.isMDXComponent=!0;const EAt={toc:[]};function BAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}BAt.isMDXComponent=!0;const FAt={toc:[]};function OAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}OAt.isMDXComponent=!0;const GAt={toc:[]};function jAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}jAt.isMDXComponent=!0;const UAt={toc:[]};function qAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}qAt.isMDXComponent=!0;const VAt={toc:[]};function HAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}HAt.isMDXComponent=!0;const $At={toc:[]};function QAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$At,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}QAt.isMDXComponent=!0;const JAt={toc:[]};function YAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}YAt.isMDXComponent=!0;const KAt={toc:[]};function tIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}tIt.isMDXComponent=!0;const eIt={toc:[]};function nIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}nIt.isMDXComponent=!0;const oIt={toc:[]};function rIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}rIt.isMDXComponent=!0;const sIt={toc:[]};function pIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}pIt.isMDXComponent=!0;const iIt={toc:[]};function cIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}cIt.isMDXComponent=!0;const aIt={toc:[]};function lIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}lIt.isMDXComponent=!0;const uIt={toc:[]};function mIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}mIt.isMDXComponent=!0;const dIt={toc:[]};function hIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}hIt.isMDXComponent=!0;const fIt={toc:[]};function yIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}yIt.isMDXComponent=!0;const kIt={toc:[]};function wIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}wIt.isMDXComponent=!0;const MIt={toc:[]};function DIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}DIt.isMDXComponent=!0;const _It={toc:[]};function gIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_It,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}gIt.isMDXComponent=!0;const XIt={toc:[]};function xIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}xIt.isMDXComponent=!0;const CIt={toc:[]};function TIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}TIt.isMDXComponent=!0;const vIt={toc:[]};function bIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}bIt.isMDXComponent=!0;const LIt={toc:[]};function ZIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}ZIt.isMDXComponent=!0;const NIt={toc:[]};function SIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}SIt.isMDXComponent=!0;const RIt={toc:[]};function zIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}zIt.isMDXComponent=!0;const PIt={toc:[]};function AIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}AIt.isMDXComponent=!0;const IIt={toc:[]};function WIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}WIt.isMDXComponent=!0;const EIt={toc:[]};function BIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}BIt.isMDXComponent=!0;const FIt={toc:[]};function OIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}OIt.isMDXComponent=!0;const GIt={toc:[]};function jIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}jIt.isMDXComponent=!0;const UIt={toc:[]};function qIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}qIt.isMDXComponent=!0;const VIt={toc:[]};function HIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}HIt.isMDXComponent=!0;const $It={toc:[]};function QIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$It,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}QIt.isMDXComponent=!0;const JIt={toc:[]};function YIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}YIt.isMDXComponent=!0;const KIt={toc:[]};function tWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}tWt.isMDXComponent=!0;const eWt={toc:[]};function nWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}nWt.isMDXComponent=!0;const oWt={toc:[]};function rWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}rWt.isMDXComponent=!0;const sWt={toc:[]};function pWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}pWt.isMDXComponent=!0;const iWt={toc:[]};function cWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}cWt.isMDXComponent=!0;const aWt={toc:[]};function lWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}lWt.isMDXComponent=!0;const uWt={toc:[]};function mWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}mWt.isMDXComponent=!0;const dWt={toc:[]};function hWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}hWt.isMDXComponent=!0;const fWt={toc:[]};function yWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}yWt.isMDXComponent=!0;const kWt={toc:[]};function wWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}wWt.isMDXComponent=!0;const MWt={toc:[]};function DWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}DWt.isMDXComponent=!0;const _Wt={toc:[]};function gWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Wt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}gWt.isMDXComponent=!0;const XWt={toc:[]};function xWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}xWt.isMDXComponent=!0;const CWt={toc:[]};function TWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}TWt.isMDXComponent=!0;const vWt={toc:[]};function bWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}bWt.isMDXComponent=!0;const LWt={toc:[]};function ZWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}ZWt.isMDXComponent=!0;const NWt={toc:[]};function SWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}SWt.isMDXComponent=!0;const RWt={toc:[]};function zWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}zWt.isMDXComponent=!0;const PWt={toc:[]};function AWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}AWt.isMDXComponent=!0;const IWt={toc:[]};function WWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}WWt.isMDXComponent=!0;const EWt={toc:[]};function BWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}BWt.isMDXComponent=!0;const FWt={toc:[]};function OWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}OWt.isMDXComponent=!0;const GWt={toc:[]};function jWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}jWt.isMDXComponent=!0;const UWt={toc:[]};function qWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}qWt.isMDXComponent=!0;const VWt={toc:[]};function HWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}HWt.isMDXComponent=!0;const $Wt={toc:[]};function QWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Wt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}QWt.isMDXComponent=!0;const JWt={toc:[]};function YWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}YWt.isMDXComponent=!0;const KWt={toc:[]};function tEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}tEt.isMDXComponent=!0;const eEt={toc:[]};function nEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}nEt.isMDXComponent=!0;const oEt={toc:[]};function rEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}rEt.isMDXComponent=!0;const sEt={toc:[]};function pEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}pEt.isMDXComponent=!0;const iEt={toc:[]};function cEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}cEt.isMDXComponent=!0;const aEt={toc:[]};function lEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lEt.isMDXComponent=!0;const uEt={toc:[]};function mEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}mEt.isMDXComponent=!0;const dEt={toc:[]};function hEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}hEt.isMDXComponent=!0;const fEt={toc:[]};function yEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}yEt.isMDXComponent=!0;const kEt={toc:[]};function wEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}wEt.isMDXComponent=!0;const MEt={toc:[]};function DEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}DEt.isMDXComponent=!0;const _Et={toc:[]};function gEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Et,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}gEt.isMDXComponent=!0;const XEt={toc:[]};function xEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}xEt.isMDXComponent=!0;const CEt={toc:[]};function TEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}TEt.isMDXComponent=!0;const vEt={toc:[]};function bEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}bEt.isMDXComponent=!0;const LEt={toc:[]};function ZEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}ZEt.isMDXComponent=!0;const NEt={toc:[]};function SEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}SEt.isMDXComponent=!0;const REt={toc:[]};function zEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},REt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}zEt.isMDXComponent=!0;const PEt={toc:[]};function AEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}AEt.isMDXComponent=!0;const IEt={toc:[]};function WEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}WEt.isMDXComponent=!0;const EEt={toc:[]};function BEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}BEt.isMDXComponent=!0;const FEt={toc:[]};function OEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}OEt.isMDXComponent=!0;const GEt={toc:[]};function jEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}jEt.isMDXComponent=!0;const UEt={toc:[]};function qEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}qEt.isMDXComponent=!0;const VEt={toc:[]};function HEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}HEt.isMDXComponent=!0;const $Et={toc:[]};function QEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Et,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}QEt.isMDXComponent=!0;const JEt={toc:[]};function YEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}YEt.isMDXComponent=!0;const KEt={toc:[]};function tBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}tBt.isMDXComponent=!0;const eBt={toc:[]};function nBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nBt.isMDXComponent=!0;const oBt={toc:[]};function rBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}rBt.isMDXComponent=!0;const sBt={toc:[]};function pBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}pBt.isMDXComponent=!0;const iBt={toc:[]};function cBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}cBt.isMDXComponent=!0;const aBt={toc:[]};function lBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}lBt.isMDXComponent=!0;const uBt={toc:[]};function mBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}mBt.isMDXComponent=!0;const dBt={toc:[]};function hBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}hBt.isMDXComponent=!0;const fBt={toc:[]};function yBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}yBt.isMDXComponent=!0;const kBt={toc:[]};function wBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}wBt.isMDXComponent=!0;const MBt={toc:[]};function DBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}DBt.isMDXComponent=!0;const _Bt={toc:[]};function gBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Bt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}gBt.isMDXComponent=!0;const XBt={toc:[]};function xBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}xBt.isMDXComponent=!0;const CBt={toc:[]};function TBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}TBt.isMDXComponent=!0;const vBt={toc:[]};function bBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}bBt.isMDXComponent=!0;const LBt={toc:[]};function ZBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}ZBt.isMDXComponent=!0;const NBt={toc:[]};function SBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}SBt.isMDXComponent=!0;const RBt={toc:[]};function zBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}zBt.isMDXComponent=!0;const PBt={toc:[]};function ABt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}ABt.isMDXComponent=!0;const IBt={toc:[]};function WBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}WBt.isMDXComponent=!0;const EBt={toc:[]};function BBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}BBt.isMDXComponent=!0;const FBt={toc:[]};function OBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}OBt.isMDXComponent=!0;const GBt={toc:[]};function jBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}jBt.isMDXComponent=!0;const UBt={toc:[]};function qBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}qBt.isMDXComponent=!0;const VBt={toc:[]};function HBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}HBt.isMDXComponent=!0;const $Bt={toc:[]};function QBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Bt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}QBt.isMDXComponent=!0;const JBt={toc:[]};function YBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}YBt.isMDXComponent=!0;const KBt={toc:[]};function tFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}tFt.isMDXComponent=!0;const eFt={toc:[]};function nFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}nFt.isMDXComponent=!0;const oFt={toc:[]};function rFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}rFt.isMDXComponent=!0;const sFt={toc:[]};function pFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}pFt.isMDXComponent=!0;const iFt={toc:[]};function cFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}cFt.isMDXComponent=!0;const aFt={toc:[]};function lFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}lFt.isMDXComponent=!0;const uFt={toc:[]};function mFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}mFt.isMDXComponent=!0;const dFt={toc:[]};function hFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}hFt.isMDXComponent=!0;const fFt={toc:[]};function yFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}yFt.isMDXComponent=!0;const kFt={toc:[]};function wFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wFt.isMDXComponent=!0;const MFt={toc:[]};function DFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}DFt.isMDXComponent=!0;const _Ft={toc:[]};function gFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Ft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}gFt.isMDXComponent=!0;const XFt={toc:[]};function xFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}xFt.isMDXComponent=!0;const CFt={toc:[]};function TFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}TFt.isMDXComponent=!0;const vFt={toc:[]};function bFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}bFt.isMDXComponent=!0;const LFt={toc:[]};function ZFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}ZFt.isMDXComponent=!0;const NFt={toc:[]};function SFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}SFt.isMDXComponent=!0;const RFt={toc:[]};function zFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}zFt.isMDXComponent=!0;const PFt={toc:[]};function AFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}AFt.isMDXComponent=!0;const IFt={toc:[]};function WFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}WFt.isMDXComponent=!0;const EFt={toc:[]};function BFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}BFt.isMDXComponent=!0;const FFt={toc:[]};function OFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}OFt.isMDXComponent=!0;const GFt={toc:[]};function jFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}jFt.isMDXComponent=!0;const UFt={toc:[]};function qFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qFt.isMDXComponent=!0;const VFt={toc:[]};function HFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}HFt.isMDXComponent=!0;const $Ft={toc:[]};function QFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Ft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}QFt.isMDXComponent=!0;const JFt={toc:[]};function YFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}YFt.isMDXComponent=!0;const KFt={toc:[]};function tOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}tOt.isMDXComponent=!0;const eOt={toc:[]};function nOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}nOt.isMDXComponent=!0;const oOt={toc:[]};function rOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}rOt.isMDXComponent=!0;const sOt={toc:[]};function pOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}pOt.isMDXComponent=!0;const iOt={toc:[]};function cOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}cOt.isMDXComponent=!0;const aOt={toc:[]};function lOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}lOt.isMDXComponent=!0;const uOt={toc:[]};function mOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}mOt.isMDXComponent=!0;const dOt={toc:[]};function hOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}hOt.isMDXComponent=!0;const fOt={toc:[]};function yOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}yOt.isMDXComponent=!0;const kOt={toc:[]};function wOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}wOt.isMDXComponent=!0;const MOt={toc:[]};function DOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}DOt.isMDXComponent=!0;const _Ot={toc:[]};function gOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Ot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}gOt.isMDXComponent=!0;const XOt={toc:[]};function xOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}xOt.isMDXComponent=!0;const COt={toc:[]};function TOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},COt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}TOt.isMDXComponent=!0;const vOt={toc:[]};function bOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}bOt.isMDXComponent=!0;const LOt={toc:[]};function ZOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}ZOt.isMDXComponent=!0;const NOt={toc:[]};function SOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}SOt.isMDXComponent=!0;const ROt={toc:[]};function zOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ROt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}zOt.isMDXComponent=!0;const POt={toc:[]};function AOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},POt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}AOt.isMDXComponent=!0;const IOt={toc:[]};function WOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}WOt.isMDXComponent=!0;const EOt={toc:[]};function BOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}BOt.isMDXComponent=!0;const FOt={toc:[]};function OOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}OOt.isMDXComponent=!0;const GOt={toc:[]};function jOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}jOt.isMDXComponent=!0;const UOt={toc:[]};function qOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qOt.isMDXComponent=!0;const VOt={toc:[]};function HOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}HOt.isMDXComponent=!0;const $Ot={toc:[]};function QOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Ot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}QOt.isMDXComponent=!0;const JOt={toc:[]};function YOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}YOt.isMDXComponent=!0;const KOt={toc:[]};function tGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}tGt.isMDXComponent=!0;const eGt={toc:[]};function nGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}nGt.isMDXComponent=!0;const oGt={toc:[]};function rGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}rGt.isMDXComponent=!0;const sGt={toc:[]};function pGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}pGt.isMDXComponent=!0;const iGt={toc:[]};function cGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}cGt.isMDXComponent=!0;const aGt={toc:[]};function lGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lGt.isMDXComponent=!0;const uGt={toc:[]};function mGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}mGt.isMDXComponent=!0;const dGt={toc:[]};function hGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}hGt.isMDXComponent=!0;const fGt={toc:[]};function yGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}yGt.isMDXComponent=!0;const kGt={toc:[]};function wGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}wGt.isMDXComponent=!0;const MGt={toc:[]};function DGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}DGt.isMDXComponent=!0;const _Gt={toc:[]};function gGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Gt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}gGt.isMDXComponent=!0;const XGt={toc:[]};function xGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}xGt.isMDXComponent=!0;const CGt={toc:[]};function TGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}TGt.isMDXComponent=!0;const vGt={toc:[]};function bGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}bGt.isMDXComponent=!0;const LGt={toc:[]};function ZGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}ZGt.isMDXComponent=!0;const NGt={toc:[]};function SGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}SGt.isMDXComponent=!0;const RGt={toc:[]};function zGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}zGt.isMDXComponent=!0;const PGt={toc:[]};function AGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}AGt.isMDXComponent=!0;const IGt={toc:[]};function WGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Defining knots using the ",(0,p.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,p.kt)("p",null,"Defining knots with ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,p.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}WGt.isMDXComponent=!0;const EGt={toc:[]};function BGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node for drawing a smooth line through a number of points."))}BGt.isMDXComponent=!0;const FGt={toc:[]};function OGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}OGt.isMDXComponent=!0;const GGt={toc:[]};function jGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}jGt.isMDXComponent=!0;const UGt={toc:[]};function qGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}qGt.isMDXComponent=!0;const VGt={toc:[]};function HGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}HGt.isMDXComponent=!0;const $Gt={toc:[]};function QGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Gt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}QGt.isMDXComponent=!0;const JGt={toc:[]};function YGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}YGt.isMDXComponent=!0;const KGt={toc:[]};function tjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}tjt.isMDXComponent=!0;const ejt={toc:[]};function njt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ejt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}njt.isMDXComponent=!0;const ojt={toc:[]};function rjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ojt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}rjt.isMDXComponent=!0;const sjt={toc:[]};function pjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}pjt.isMDXComponent=!0;const ijt={toc:[]};function cjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ijt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}cjt.isMDXComponent=!0;const ajt={toc:[]};function ljt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ajt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}ljt.isMDXComponent=!0;const ujt={toc:[]};function mjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ujt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}mjt.isMDXComponent=!0;const djt={toc:[]};function hjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},djt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}hjt.isMDXComponent=!0;const fjt={toc:[]};function yjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}yjt.isMDXComponent=!0;const kjt={toc:[]};function wjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}wjt.isMDXComponent=!0;const Mjt={toc:[]};function Djt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Djt.isMDXComponent=!0;const _jt={toc:[]};function gjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_jt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}gjt.isMDXComponent=!0;const Xjt={toc:[]};function xjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xjt.isMDXComponent=!0;const Cjt={toc:[]};function Tjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Tjt.isMDXComponent=!0;const vjt={toc:[]};function bjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}bjt.isMDXComponent=!0;const Ljt={toc:[]};function Zjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ljt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}Zjt.isMDXComponent=!0;const Njt={toc:[]};function Sjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Njt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Sjt.isMDXComponent=!0;const Rjt={toc:[]};function zjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}zjt.isMDXComponent=!0;const Pjt={toc:[]};function Ajt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Ajt.isMDXComponent=!0;const Ijt={toc:[]};function Wjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ijt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}Wjt.isMDXComponent=!0;const Ejt={toc:[]};function Bjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ejt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Bjt.isMDXComponent=!0;const Fjt={toc:[]};function Ojt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}Ojt.isMDXComponent=!0;const Gjt={toc:[]};function jjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}jjt.isMDXComponent=!0;const Ujt={toc:[]};function qjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ujt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}qjt.isMDXComponent=!0;const Vjt={toc:[]};function Hjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Hjt.isMDXComponent=!0;const $jt={toc:[]};function Qjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$jt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Qjt.isMDXComponent=!0;const Jjt={toc:[]};function Yjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Yjt.isMDXComponent=!0;const Kjt={toc:[]};function tUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}tUt.isMDXComponent=!0;const eUt={toc:[]};function nUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}nUt.isMDXComponent=!0;const oUt={toc:[]};function rUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}rUt.isMDXComponent=!0;const sUt={toc:[]};function pUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}pUt.isMDXComponent=!0;const iUt={toc:[]};function cUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"0.4"))}cUt.isMDXComponent=!0;const aUt={toc:[]};function lUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}lUt.isMDXComponent=!0;const uUt={toc:[]};function mUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}mUt.isMDXComponent=!0;const dUt={toc:[]};function hUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}hUt.isMDXComponent=!0;const fUt={toc:[]};function yUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}yUt.isMDXComponent=!0;const kUt={toc:[]};function wUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}wUt.isMDXComponent=!0;const MUt={toc:[]};function DUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}DUt.isMDXComponent=!0;const _Ut={toc:[]};function gUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Ut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}gUt.isMDXComponent=!0;const XUt={toc:[]};function xUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}xUt.isMDXComponent=!0;const CUt={toc:[]};function TUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}TUt.isMDXComponent=!0;const vUt={toc:[]};function bUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}bUt.isMDXComponent=!0;const LUt={toc:[]};function ZUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}ZUt.isMDXComponent=!0;const NUt={toc:[]};function SUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}SUt.isMDXComponent=!0;const RUt={toc:[]};function zUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}zUt.isMDXComponent=!0;const PUt={toc:[]};function AUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}AUt.isMDXComponent=!0;const IUt={toc:[]};function WUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}WUt.isMDXComponent=!0;const EUt={toc:[]};function BUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}BUt.isMDXComponent=!0;const FUt={toc:[]};function OUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}OUt.isMDXComponent=!0;const GUt={toc:[]};function jUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}jUt.isMDXComponent=!0;const UUt={toc:[]};function qUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}qUt.isMDXComponent=!0;const VUt={toc:[]};function HUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This arc length accounts for both the offset and the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}HUt.isMDXComponent=!0;const $Ut={toc:[]};function QUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Ut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The visible arc length of this curve."))}QUt.isMDXComponent=!0;const JUt={toc:[]};function YUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}YUt.isMDXComponent=!0;const KUt={toc:[]};function tqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The base arc length of this curve."))}tqt.isMDXComponent=!0;const eqt={toc:[]};function nqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}nqt.isMDXComponent=!0;const oqt={toc:[]};function rqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}rqt.isMDXComponent=!0;const sqt={toc:[]};function pqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}pqt.isMDXComponent=!0;const iqt={toc:[]};function cqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}cqt.isMDXComponent=!0;const aqt={toc:[]};function lqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}lqt.isMDXComponent=!0;const uqt={toc:[]};function mqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}mqt.isMDXComponent=!0;const dqt={toc:[]};function hqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage of the curve that's currently visible."))}hqt.isMDXComponent=!0;const fqt={toc:[]};function yqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}yqt.isMDXComponent=!0;const kqt={toc:[]};function wqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}wqt.isMDXComponent=!0;const Mqt={toc:[]};function Dqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Dqt.isMDXComponent=!0;const _qt={toc:[]};function gqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_qt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}gqt.isMDXComponent=!0;const Xqt={toc:[]};function xqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}xqt.isMDXComponent=!0;const Cqt={toc:[]};function Tqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}Tqt.isMDXComponent=!0;const vqt={toc:[]};function bqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}bqt.isMDXComponent=!0;const Lqt={toc:[]};function Zqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a distance along the curve to a percentage."))}Zqt.isMDXComponent=!0;const Nqt={toc:[]};function Sqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance along the curve."))}Sqt.isMDXComponent=!0;const Rqt={toc:[]};function zqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}zqt.isMDXComponent=!0;const Pqt={toc:[]};function Aqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Aqt.isMDXComponent=!0;const Iqt={toc:[]};function Wqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Iqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Wqt.isMDXComponent=!0;const Eqt={toc:[]};function Bqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Bqt.isMDXComponent=!0;const Fqt={toc:[]};function Oqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Oqt.isMDXComponent=!0;const Gqt={toc:[]};function jqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}jqt.isMDXComponent=!0;const Uqt={toc:[]};function qqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}qqt.isMDXComponent=!0;const Vqt={toc:[]};function Hqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}Hqt.isMDXComponent=!0;const $qt={toc:[]};function Qqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$qt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Qqt.isMDXComponent=!0;const Jqt={toc:[]};function Yqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}Yqt.isMDXComponent=!0;const Kqt={toc:[]};function tVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}tVt.isMDXComponent=!0;const eVt={toc:[]};function nVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}nVt.isMDXComponent=!0;const oVt={toc:[]};function rVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}rVt.isMDXComponent=!0;const sVt={toc:[]};function pVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}pVt.isMDXComponent=!0;const iVt={toc:[]};function cVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}cVt.isMDXComponent=!0;const aVt={toc:[]};function lVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}lVt.isMDXComponent=!0;const uVt={toc:[]};function mVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}mVt.isMDXComponent=!0;const dVt={toc:[]};function hVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}hVt.isMDXComponent=!0;const fVt={toc:[]};function yVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}yVt.isMDXComponent=!0;const kVt={toc:[]};function wVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}wVt.isMDXComponent=!0;const MVt={toc:[]};function DVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}DVt.isMDXComponent=!0;const _Vt={toc:[]};function gVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Vt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}gVt.isMDXComponent=!0;const XVt={toc:[]};function xVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}xVt.isMDXComponent=!0;const CVt={toc:[]};function TVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}TVt.isMDXComponent=!0;const vVt={toc:[]};function bVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}bVt.isMDXComponent=!0;const LVt={toc:[]};function ZVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}ZVt.isMDXComponent=!0;const NVt={toc:[]};function SVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}SVt.isMDXComponent=!0;const RVt={toc:[]};function zVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}zVt.isMDXComponent=!0;const PVt={toc:[]};function AVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}AVt.isMDXComponent=!0;const IVt={toc:[]};function WVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}WVt.isMDXComponent=!0;const EVt={toc:[]};function BVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}BVt.isMDXComponent=!0;const FVt={toc:[]};function OVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}OVt.isMDXComponent=!0;const GVt={toc:[]};function jVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}jVt.isMDXComponent=!0;const UVt={toc:[]};function qVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}qVt.isMDXComponent=!0;const VVt={toc:[]};function HVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}HVt.isMDXComponent=!0;const $Vt={toc:[]};function QVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Vt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}QVt.isMDXComponent=!0;const JVt={toc:[]};function YVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}YVt.isMDXComponent=!0;const KVt={toc:[]};function tHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}tHt.isMDXComponent=!0;const eHt={toc:[]};function nHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}nHt.isMDXComponent=!0;const oHt={toc:[]};function rHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}rHt.isMDXComponent=!0;const sHt={toc:[]};function pHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}pHt.isMDXComponent=!0;const iHt={toc:[]};function cHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}cHt.isMDXComponent=!0;const aHt={toc:[]};function lHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}lHt.isMDXComponent=!0;const uHt={toc:[]};function mHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}mHt.isMDXComponent=!0;const dHt={toc:[]};function hHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}hHt.isMDXComponent=!0;const fHt={toc:[]};function yHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}yHt.isMDXComponent=!0;const kHt={toc:[]};function wHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}wHt.isMDXComponent=!0;const MHt={toc:[]};function DHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}DHt.isMDXComponent=!0;const _Ht={toc:[]};function gHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Ht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}gHt.isMDXComponent=!0;const XHt={toc:[]};function xHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}xHt.isMDXComponent=!0;const CHt={toc:[]};function THt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}THt.isMDXComponent=!0;const vHt={toc:[]};function bHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}bHt.isMDXComponent=!0;const LHt={toc:[]};function ZHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the length of the curve that accounts for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}ZHt.isMDXComponent=!0;const NHt={toc:[]};function SHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset arc length of this curve."))}SHt.isMDXComponent=!0;const RHt={toc:[]};function zHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}zHt.isMDXComponent=!0;const PHt={toc:[]};function AHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a percentage along the curve to a distance."))}AHt.isMDXComponent=!0;const IHt={toc:[]};function WHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage along the curve."))}WHt.isMDXComponent=!0;const EHt={toc:[]};function BHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}BHt.isMDXComponent=!0;const FHt={toc:[]};function OHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}OHt.isMDXComponent=!0;const GHt={toc:[]};function jHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}jHt.isMDXComponent=!0;const UHt={toc:[]};function qHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}qHt.isMDXComponent=!0;const VHt={toc:[]};function HHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}HHt.isMDXComponent=!0;const $Ht={toc:[]};function QHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Ht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}QHt.isMDXComponent=!0;const JHt={toc:[]};function YHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}YHt.isMDXComponent=!0;const KHt={toc:[]};function t$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}t$t.isMDXComponent=!0;const e$t={toc:[]};function n$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},e$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}n$t.isMDXComponent=!0;const o$t={toc:[]};function r$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},o$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}r$t.isMDXComponent=!0;const s$t={toc:[]};function p$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},s$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}p$t.isMDXComponent=!0;const i$t={toc:[]};function c$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},i$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}c$t.isMDXComponent=!0;const a$t={toc:[]};function l$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},a$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}l$t.isMDXComponent=!0;const u$t={toc:[]};function m$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},u$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}m$t.isMDXComponent=!0;const d$t={toc:[]};function h$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},d$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}h$t.isMDXComponent=!0;const f$t={toc:[]};function y$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},f$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}y$t.isMDXComponent=!0;const k$t={toc:[]};function w$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},k$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}w$t.isMDXComponent=!0;const M$t={toc:[]};function D$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},M$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}D$t.isMDXComponent=!0;const _$t={toc:[]};function g$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}g$t.isMDXComponent=!0;const X$t={toc:[]};function x$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},X$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}x$t.isMDXComponent=!0;const C$t={toc:[]};function T$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},C$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}T$t.isMDXComponent=!0;const v$t={toc:[]};function b$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},v$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}b$t.isMDXComponent=!0;const L$t={toc:[]};function Z$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},L$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}Z$t.isMDXComponent=!0;const N$t={toc:[]};function S$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},N$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}S$t.isMDXComponent=!0;const R$t={toc:[]};function z$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},R$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}z$t.isMDXComponent=!0;const P$t={toc:[]};function A$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},P$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}A$t.isMDXComponent=!0;const I$t={toc:[]};function W$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},I$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}W$t.isMDXComponent=!0;const E$t={toc:[]};function B$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},E$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}B$t.isMDXComponent=!0;const F$t={toc:[]};function O$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},F$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}O$t.isMDXComponent=!0;const G$t={toc:[]};function j$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},G$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}j$t.isMDXComponent=!0;const U$t={toc:[]};function q$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},U$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}q$t.isMDXComponent=!0;const V$t={toc:[]};function H$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},V$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}H$t.isMDXComponent=!0;const $$t={toc:[]};function Q$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Q$t.isMDXComponent=!0;const J$t={toc:[]};function Y$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},J$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}Y$t.isMDXComponent=!0;const K$t={toc:[]};function tQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},K$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}tQt.isMDXComponent=!0;const eQt={toc:[]};function nQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}nQt.isMDXComponent=!0;const oQt={toc:[]};function rQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}rQt.isMDXComponent=!0;const sQt={toc:[]};function pQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}pQt.isMDXComponent=!0;const iQt={toc:[]};function cQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}cQt.isMDXComponent=!0;const aQt={toc:[]};function lQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}lQt.isMDXComponent=!0;const uQt={toc:[]};function mQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}mQt.isMDXComponent=!0;const dQt={toc:[]};function hQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}hQt.isMDXComponent=!0;const fQt={toc:[]};function yQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}yQt.isMDXComponent=!0;const kQt={toc:[]};function wQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}wQt.isMDXComponent=!0;const MQt={toc:[]};function DQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}DQt.isMDXComponent=!0;const _Qt={toc:[]};function gQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Qt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}gQt.isMDXComponent=!0;const XQt={toc:[]};function xQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}xQt.isMDXComponent=!0;const CQt={toc:[]};function TQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}TQt.isMDXComponent=!0;const vQt={toc:[]};function bQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}bQt.isMDXComponent=!0;const LQt={toc:[]};function ZQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}ZQt.isMDXComponent=!0;const NQt={toc:[]};function SQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}SQt.isMDXComponent=!0;const RQt={toc:[]};function zQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}zQt.isMDXComponent=!0;const PQt={toc:[]};function AQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}AQt.isMDXComponent=!0;const IQt={toc:[]};function WQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}WQt.isMDXComponent=!0;const EQt={toc:[]};function BQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}BQt.isMDXComponent=!0;const FQt={toc:[]};function OQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}OQt.isMDXComponent=!0;const GQt={toc:[]};function jQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}jQt.isMDXComponent=!0;const UQt={toc:[]};function qQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}qQt.isMDXComponent=!0;const VQt={toc:[]};function HQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}HQt.isMDXComponent=!0;const $Qt={toc:[]};function QQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Qt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}QQt.isMDXComponent=!0;const JQt={toc:[]};function YQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}YQt.isMDXComponent=!0;const KQt={toc:[]};function tJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}tJt.isMDXComponent=!0;const eJt={toc:[]};function nJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}nJt.isMDXComponent=!0;const oJt={toc:[]};function rJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}rJt.isMDXComponent=!0;const sJt={toc:[]};function pJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}pJt.isMDXComponent=!0;const iJt={toc:[]};function cJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}cJt.isMDXComponent=!0;const aJt={toc:[]};function lJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}lJt.isMDXComponent=!0;const uJt={toc:[]};function mJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}mJt.isMDXComponent=!0;const dJt={toc:[]};function hJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}hJt.isMDXComponent=!0;const fJt={toc:[]};function yJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}yJt.isMDXComponent=!0;const kJt={toc:[]};function wJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}wJt.isMDXComponent=!0;const MJt={toc:[]};function DJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}DJt.isMDXComponent=!0;const _Jt={toc:[]};function gJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Jt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}gJt.isMDXComponent=!0;const XJt={toc:[]};function xJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}xJt.isMDXComponent=!0;const CJt={toc:[]};function TJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}TJt.isMDXComponent=!0;const vJt={toc:[]};function bJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}bJt.isMDXComponent=!0;const LJt={toc:[]};function ZJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}ZJt.isMDXComponent=!0;const NJt={toc:[]};function SJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}SJt.isMDXComponent=!0;const RJt={toc:[]};function zJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}zJt.isMDXComponent=!0;const PJt={toc:[]};function AJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}AJt.isMDXComponent=!0;const IJt={toc:[]};function WJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}WJt.isMDXComponent=!0;const EJt={toc:[]};function BJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}BJt.isMDXComponent=!0;const FJt={toc:[]};function OJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}OJt.isMDXComponent=!0;const GJt={toc:[]};function jJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}jJt.isMDXComponent=!0;const UJt={toc:[]};function qJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}qJt.isMDXComponent=!0;const VJt={toc:[]};function HJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}HJt.isMDXComponent=!0;const $Jt={toc:[]};function QJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Jt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}QJt.isMDXComponent=!0;const JJt={toc:[]};function YJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}YJt.isMDXComponent=!0;const KJt={toc:[]};function tYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}tYt.isMDXComponent=!0;const eYt={toc:[]};function nYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}nYt.isMDXComponent=!0;const oYt={toc:[]};function rYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}rYt.isMDXComponent=!0;const sYt={toc:[]};function pYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}pYt.isMDXComponent=!0;const iYt={toc:[]};function cYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}cYt.isMDXComponent=!0;const aYt={toc:[]};function lYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}lYt.isMDXComponent=!0;const uYt={toc:[]};function mYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}mYt.isMDXComponent=!0;const dYt={toc:[]};function hYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}hYt.isMDXComponent=!0;const fYt={toc:[]};function yYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}yYt.isMDXComponent=!0;const kYt={toc:[]};function wYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}wYt.isMDXComponent=!0;const MYt={toc:[]};function DYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}DYt.isMDXComponent=!0;const _Yt={toc:[]};function gYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Yt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}gYt.isMDXComponent=!0;const XYt={toc:[]};function xYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}xYt.isMDXComponent=!0;const CYt={toc:[]};function TYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}TYt.isMDXComponent=!0;const vYt={toc:[]};function bYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}bYt.isMDXComponent=!0;const LYt={toc:[]};function ZYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}ZYt.isMDXComponent=!0;const NYt={toc:[]};function SYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}SYt.isMDXComponent=!0;const RYt={toc:[]};function zYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}zYt.isMDXComponent=!0;const PYt={toc:[]};function AYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}AYt.isMDXComponent=!0;const IYt={toc:[]};function WYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}WYt.isMDXComponent=!0;const EYt={toc:[]};function BYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}BYt.isMDXComponent=!0;const FYt={toc:[]};function OYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}OYt.isMDXComponent=!0;const GYt={toc:[]};function jYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}jYt.isMDXComponent=!0;const UYt={toc:[]};function qYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}qYt.isMDXComponent=!0;const VYt={toc:[]};function HYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}HYt.isMDXComponent=!0;const $Yt={toc:[]};function QYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Yt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}QYt.isMDXComponent=!0;const JYt={toc:[]};function YYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}YYt.isMDXComponent=!0;const KYt={toc:[]};function tKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}tKt.isMDXComponent=!0;const eKt={toc:[]};function nKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}nKt.isMDXComponent=!0;const oKt={toc:[]};function rKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}rKt.isMDXComponent=!0;const sKt={toc:[]};function pKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}pKt.isMDXComponent=!0;const iKt={toc:[]};function cKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}cKt.isMDXComponent=!0;const aKt={toc:[]};function lKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}lKt.isMDXComponent=!0;const uKt={toc:[]};function mKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}mKt.isMDXComponent=!0;const dKt={toc:[]};function hKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}hKt.isMDXComponent=!0;const fKt={toc:[]};function yKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}yKt.isMDXComponent=!0;const kKt={toc:[]};function wKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}wKt.isMDXComponent=!0;const MKt={toc:[]};function DKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}DKt.isMDXComponent=!0;const _Kt={toc:[]};function gKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Kt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}gKt.isMDXComponent=!0;const XKt={toc:[]};function xKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}xKt.isMDXComponent=!0;const CKt={toc:[]};function TKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}TKt.isMDXComponent=!0;const vKt={toc:[]};function bKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}bKt.isMDXComponent=!0;const LKt={toc:[]};function ZKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}ZKt.isMDXComponent=!0;const NKt={toc:[]};function SKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}SKt.isMDXComponent=!0;const RKt={toc:[]};function zKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}zKt.isMDXComponent=!0;const PKt={toc:[]};function AKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}AKt.isMDXComponent=!0;const IKt={toc:[]};function WKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}WKt.isMDXComponent=!0;const EKt={toc:[]};function BKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}BKt.isMDXComponent=!0;const FKt={toc:[]};function OKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}OKt.isMDXComponent=!0;const GKt={toc:[]};function jKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}jKt.isMDXComponent=!0;const UKt={toc:[]};function qKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}qKt.isMDXComponent=!0;const VKt={toc:[]};function HKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}HKt.isMDXComponent=!0;const $Kt={toc:[]};function QKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Kt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}QKt.isMDXComponent=!0;const JKt={toc:[]};function YKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}YKt.isMDXComponent=!0;const KKt={toc:[]};function t0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}t0t.isMDXComponent=!0;const e0t={toc:[]};function n0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},e0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}n0t.isMDXComponent=!0;const o0t={toc:[]};function r0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},o0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}r0t.isMDXComponent=!0;const s0t={toc:[]};function p0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},s0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}p0t.isMDXComponent=!0;const i0t={toc:[]};function c0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},i0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}c0t.isMDXComponent=!0;const a0t={toc:[]};function l0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},a0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}l0t.isMDXComponent=!0;const u0t={toc:[]};function m0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},u0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}m0t.isMDXComponent=!0;const d0t={toc:[]};function h0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},d0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}h0t.isMDXComponent=!0;const f0t={toc:[]};function y0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},f0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}y0t.isMDXComponent=!0;const k0t={toc:[]};function w0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},k0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}w0t.isMDXComponent=!0;const M0t={toc:[]};function D0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},M0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}D0t.isMDXComponent=!0;const _0t={toc:[]};function g0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}g0t.isMDXComponent=!0;const X0t={toc:[]};function x0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},X0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}x0t.isMDXComponent=!0;const C0t={toc:[]};function T0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},C0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}T0t.isMDXComponent=!0;const v0t={toc:[]};function b0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},v0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}b0t.isMDXComponent=!0;const L0t={toc:[]};function Z0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},L0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Z0t.isMDXComponent=!0;const N0t={toc:[]};function S0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},N0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}S0t.isMDXComponent=!0;const R0t={toc:[]};function z0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},R0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}z0t.isMDXComponent=!0;const P0t={toc:[]};function A0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},P0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}A0t.isMDXComponent=!0;const I0t={toc:[]};function W0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},I0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}W0t.isMDXComponent=!0;const E0t={toc:[]};function B0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},E0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}B0t.isMDXComponent=!0;const F0t={toc:[]};function O0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},F0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}O0t.isMDXComponent=!0;const G0t={toc:[]};function j0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},G0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}j0t.isMDXComponent=!0;const U0t={toc:[]};function q0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},U0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}q0t.isMDXComponent=!0;const V0t={toc:[]};function H0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},V0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}H0t.isMDXComponent=!0;const $0t={toc:[]};function Q0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Q0t.isMDXComponent=!0;const J0t={toc:[]};function Y0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},J0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Y0t.isMDXComponent=!0;const K0t={toc:[]};function t2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},K0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}t2t.isMDXComponent=!0;const e2t={toc:[]};function n2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},e2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}n2t.isMDXComponent=!0;const o2t={toc:[]};function r2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},o2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}r2t.isMDXComponent=!0;const s2t={toc:[]};function p2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},s2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}p2t.isMDXComponent=!0;const i2t={toc:[]};function c2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},i2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}c2t.isMDXComponent=!0;const a2t={toc:[]};function l2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},a2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}l2t.isMDXComponent=!0;const u2t={toc:[]};function m2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},u2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}m2t.isMDXComponent=!0;const d2t={toc:[]};function h2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},d2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}h2t.isMDXComponent=!0;const f2t={toc:[]};function y2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},f2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}y2t.isMDXComponent=!0;const k2t={toc:[]};function w2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},k2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}w2t.isMDXComponent=!0;const M2t={toc:[]};function D2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},M2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}D2t.isMDXComponent=!0;const _2t={toc:[]};function g2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The alpha value of this video."))}g2t.isMDXComponent=!0;const X2t={toc:[]};function x2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},X2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}x2t.isMDXComponent=!0;const C2t={toc:[]};function T2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},C2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}T2t.isMDXComponent=!0;const v2t={toc:[]};function b2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},v2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}b2t.isMDXComponent=!0;const L2t={toc:[]};function Z2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},L2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Z2t.isMDXComponent=!0;const N2t={toc:[]};function S2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},N2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}S2t.isMDXComponent=!0;const R2t={toc:[]};function z2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},R2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}z2t.isMDXComponent=!0;const P2t={toc:[]};function A2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},P2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}A2t.isMDXComponent=!0;const I2t={toc:[]};function W2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},I2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}W2t.isMDXComponent=!0;const E2t={toc:[]};function B2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},E2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}B2t.isMDXComponent=!0;const F2t={toc:[]};function O2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},F2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}O2t.isMDXComponent=!0;const G2t={toc:[]};function j2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},G2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}j2t.isMDXComponent=!0;const U2t={toc:[]};function q2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},U2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this video should loop upon reaching the end."))}q2t.isMDXComponent=!0;const V2t={toc:[]};function H2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},V2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}H2t.isMDXComponent=!0;const $2t={toc:[]};function Q2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}Q2t.isMDXComponent=!0;const J2t={toc:[]};function Y2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},J2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Y2t.isMDXComponent=!0;const K2t={toc:[]};function t1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},K2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}t1t.isMDXComponent=!0;const e1t={toc:[]};function n1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},e1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}n1t.isMDXComponent=!0;const o1t={toc:[]};function r1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},o1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}r1t.isMDXComponent=!0;const s1t={toc:[]};function p1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},s1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}p1t.isMDXComponent=!0;const i1t={toc:[]};function c1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},i1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}c1t.isMDXComponent=!0;const a1t={toc:[]};function l1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},a1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}l1t.isMDXComponent=!0;const u1t={toc:[]};function m1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},u1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}m1t.isMDXComponent=!0;const d1t={toc:[]};function h1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},d1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}h1t.isMDXComponent=!0;const f1t={toc:[]};function y1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},f1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}y1t.isMDXComponent=!0;const k1t={toc:[]};function w1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},k1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}w1t.isMDXComponent=!0;const M1t={toc:[]};function D1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},M1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}D1t.isMDXComponent=!0;const _1t={toc:[]};function g1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}g1t.isMDXComponent=!0;const X1t={toc:[]};function x1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},X1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}x1t.isMDXComponent=!0;const C1t={toc:[]};function T1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},C1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"true"))}T1t.isMDXComponent=!0;const v1t={toc:[]};function b1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},v1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the video should be smoothed."))}b1t.isMDXComponent=!0;const L1t={toc:[]};function Z1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},L1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Using a local video:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"import video from './example.mp4';\n// ...\nview.add(<Video src={video} />)\n")),(0,p.kt)("p",null,"Loading an image from the internet:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Video src="https://example.com/video.mp4" />)\n')))}Z1t.isMDXComponent=!0;const N1t={toc:[]};function S1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},N1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The source of this video."))}S1t.isMDXComponent=!0;const R1t={toc:[]};function z1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},R1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}z1t.isMDXComponent=!0;const P1t={toc:[]};function A1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},P1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}A1t.isMDXComponent=!0;const I1t={toc:[]};function W1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},I1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}W1t.isMDXComponent=!0;const E1t={toc:[]};function B1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},E1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}B1t.isMDXComponent=!0;const F1t={toc:[]};function O1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},F1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}O1t.isMDXComponent=!0;const G1t={toc:[]};function j1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},G1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}j1t.isMDXComponent=!0;const U1t={toc:[]};function q1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},U1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}q1t.isMDXComponent=!0;const V1t={toc:[]};function H1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},V1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}H1t.isMDXComponent=!0;const $1t={toc:[]};function Q1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}Q1t.isMDXComponent=!0;const J1t={toc:[]};function Y1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},J1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}Y1t.isMDXComponent=!0;const K1t={toc:[]};function t3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},K1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}t3t.isMDXComponent=!0;const e3t={toc:[]};function n3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},e3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}n3t.isMDXComponent=!0;const o3t={toc:[]};function r3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},o3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}r3t.isMDXComponent=!0;const s3t={toc:[]};function p3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},s3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}p3t.isMDXComponent=!0;const i3t={toc:[]};function c3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},i3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}c3t.isMDXComponent=!0;const a3t={toc:[]};function l3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},a3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}l3t.isMDXComponent=!0;const u3t={toc:[]};function m3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},u3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}m3t.isMDXComponent=!0;const d3t={toc:[]};function h3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},d3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}h3t.isMDXComponent=!0;const f3t={toc:[]};function y3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},f3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}y3t.isMDXComponent=!0;const k3t={toc:[]};function w3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},k3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}w3t.isMDXComponent=!0;const M3t={toc:[]};function D3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},M3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}D3t.isMDXComponent=!0;const _3t={toc:[]};function g3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}g3t.isMDXComponent=!0;const X3t={toc:[]};function x3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},X3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}x3t.isMDXComponent=!0;const C3t={toc:[]};function T3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},C3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}T3t.isMDXComponent=!0;const v3t={toc:[]};function b3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},v3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}b3t.isMDXComponent=!0;const L3t={toc:[]};function Z3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},L3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Z3t.isMDXComponent=!0;const N3t={toc:[]};function S3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},N3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}S3t.isMDXComponent=!0;const R3t={toc:[]};function z3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},R3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}z3t.isMDXComponent=!0;const P3t={toc:[]};function A3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},P3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}A3t.isMDXComponent=!0;const I3t={toc:[]};function W3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},I3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}W3t.isMDXComponent=!0;const E3t={toc:[]};function B3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},E3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}B3t.isMDXComponent=!0;const F3t={toc:[]};function O3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},F3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}O3t.isMDXComponent=!0;const G3t={toc:[]};function j3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},G3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}j3t.isMDXComponent=!0;const U3t={toc:[]};function q3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},U3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}q3t.isMDXComponent=!0;const V3t={toc:[]};function H3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},V3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}H3t.isMDXComponent=!0;const $3t={toc:[]};function Q3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}Q3t.isMDXComponent=!0;const J3t={toc:[]};function Y3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},J3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Y3t.isMDXComponent=!0;const K3t={toc:[]};function t4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},K3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}t4t.isMDXComponent=!0;const e4t={toc:[]};function n4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},e4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}n4t.isMDXComponent=!0;const o4t={toc:[]};function r4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},o4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}r4t.isMDXComponent=!0;const s4t={toc:[]};function p4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},s4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}p4t.isMDXComponent=!0;const i4t={toc:[]};function c4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},i4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}c4t.isMDXComponent=!0;const a4t={toc:[]};function l4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},a4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}l4t.isMDXComponent=!0;const u4t={toc:[]};function m4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},u4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}m4t.isMDXComponent=!0;const d4t={toc:[]};function h4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},d4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}h4t.isMDXComponent=!0;const f4t={toc:[]};function y4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},f4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}y4t.isMDXComponent=!0;const k4t={toc:[]};function w4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},k4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}w4t.isMDXComponent=!0;const M4t={toc:[]};function D4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},M4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}D4t.isMDXComponent=!0;const _4t={toc:[]};function g4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}g4t.isMDXComponent=!0;const X4t={toc:[]};function x4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},X4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}x4t.isMDXComponent=!0;const C4t={toc:[]};function T4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},C4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}T4t.isMDXComponent=!0;const v4t={toc:[]};function b4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},v4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}b4t.isMDXComponent=!0;const L4t={toc:[]};function Z4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},L4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}Z4t.isMDXComponent=!0;const N4t={toc:[]};function S4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},N4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}S4t.isMDXComponent=!0;const R4t={toc:[]};function z4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},R4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}z4t.isMDXComponent=!0;const P4t={toc:[]};function A4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},P4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}A4t.isMDXComponent=!0;const I4t={toc:[]};function W4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},I4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}W4t.isMDXComponent=!0;const E4t={toc:[]};function B4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},E4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}B4t.isMDXComponent=!0;const F4t={toc:[]};function O4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},F4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}O4t.isMDXComponent=!0;const G4t={toc:[]};function j4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},G4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}j4t.isMDXComponent=!0;const U4t={toc:[]};function q4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},U4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}q4t.isMDXComponent=!0;const V4t={toc:[]};function H4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},V4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}H4t.isMDXComponent=!0;const $4t={toc:[]};function Q4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Q4t.isMDXComponent=!0;const J4t={toc:[]};function Y4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},J4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}Y4t.isMDXComponent=!0;const K4t={toc:[]};function t6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},K4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}t6t.isMDXComponent=!0;const e6t={toc:[]};function n6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},e6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}n6t.isMDXComponent=!0;const o6t={toc:[]};function r6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},o6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}r6t.isMDXComponent=!0;const s6t={toc:[]};function p6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},s6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}p6t.isMDXComponent=!0;const i6t={toc:[]};function c6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},i6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}c6t.isMDXComponent=!0;const a6t={toc:[]};function l6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},a6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}l6t.isMDXComponent=!0;const u6t={toc:[]};function m6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},u6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}m6t.isMDXComponent=!0;const d6t={toc:[]};function h6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},d6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}h6t.isMDXComponent=!0;const f6t={toc:[]};function y6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},f6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}y6t.isMDXComponent=!0;const k6t={toc:[]};function w6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},k6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}w6t.isMDXComponent=!0;const M6t={toc:[]};function D6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},M6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}D6t.isMDXComponent=!0;const _6t={toc:[]};function g6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}g6t.isMDXComponent=!0;const X6t={toc:[]};function x6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},X6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}x6t.isMDXComponent=!0;const C6t={toc:[]};function T6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},C6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}T6t.isMDXComponent=!0;const v6t={toc:[]};function b6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},v6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}b6t.isMDXComponent=!0;const L6t={toc:[]};function Z6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},L6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}Z6t.isMDXComponent=!0;const N6t={toc:[]};function S6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},N6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}S6t.isMDXComponent=!0;const R6t={toc:[]};function z6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},R6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}z6t.isMDXComponent=!0;const P6t={toc:[]};function A6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},P6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}A6t.isMDXComponent=!0;const I6t={toc:[]};function W6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},I6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}W6t.isMDXComponent=!0;const E6t={toc:[]};function B6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},E6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}B6t.isMDXComponent=!0;const F6t={toc:[]};function O6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},F6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}O6t.isMDXComponent=!0;const G6t={toc:[]};function j6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},G6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}j6t.isMDXComponent=!0;const U6t={toc:[]};function q6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},U6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}q6t.isMDXComponent=!0;const V6t={toc:[]};function H6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},V6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}H6t.isMDXComponent=!0;const $6t={toc:[]};function Q6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Q6t.isMDXComponent=!0;const J6t={toc:[]};function Y6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},J6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}Y6t.isMDXComponent=!0;const K6t={toc:[]};function t8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},K6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}t8t.isMDXComponent=!0;const e8t={toc:[]};function n8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},e8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}n8t.isMDXComponent=!0;const o8t={toc:[]};function r8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},o8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}r8t.isMDXComponent=!0;const s8t={toc:[]};function p8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},s8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}p8t.isMDXComponent=!0;const i8t={toc:[]};function c8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},i8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}c8t.isMDXComponent=!0;const a8t={toc:[]};function l8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},a8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}l8t.isMDXComponent=!0;const u8t={toc:[]};function m8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},u8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}m8t.isMDXComponent=!0;const d8t={toc:[]};function h8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},d8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}h8t.isMDXComponent=!0;const f8t={toc:[]};function y8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},f8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}y8t.isMDXComponent=!0;const k8t={toc:[]};function w8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},k8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}w8t.isMDXComponent=!0;const M8t={toc:[]};function D8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},M8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}D8t.isMDXComponent=!0;const _8t={toc:[]};function g8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}g8t.isMDXComponent=!0;const X8t={toc:[]};function x8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},X8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}x8t.isMDXComponent=!0;const C8t={toc:[]};function T8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},C8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}T8t.isMDXComponent=!0;const v8t={toc:[]};function b8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},v8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}b8t.isMDXComponent=!0;const L8t={toc:[]};function Z8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},L8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Z8t.isMDXComponent=!0;const N8t={toc:[]};function S8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},N8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}S8t.isMDXComponent=!0;const R8t={toc:[]};function z8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},R8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}z8t.isMDXComponent=!0;const P8t={toc:[]};function A8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},P8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}A8t.isMDXComponent=!0;const I8t={toc:[]};function W8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},I8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}W8t.isMDXComponent=!0;const E8t={toc:[]};function B8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},E8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}B8t.isMDXComponent=!0;const F8t={toc:[]};function O8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},F8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}O8t.isMDXComponent=!0;const G8t={toc:[]};function j8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},G8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}j8t.isMDXComponent=!0;const U8t={toc:[]};function q8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},U8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}q8t.isMDXComponent=!0;const V8t={toc:[]};function H8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},V8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}H8t.isMDXComponent=!0;const $8t={toc:[]};function Q8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}Q8t.isMDXComponent=!0;const J8t={toc:[]};function Y8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},J8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Y8t.isMDXComponent=!0;const K8t={toc:[]};function t5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},K8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}t5t.isMDXComponent=!0;const e5t={toc:[]};function n5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},e5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}n5t.isMDXComponent=!0;const o5t={toc:[]};function r5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},o5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}r5t.isMDXComponent=!0;const s5t={toc:[]};function p5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},s5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}p5t.isMDXComponent=!0;const i5t={toc:[]};function c5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},i5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}c5t.isMDXComponent=!0;const a5t={toc:[]};function l5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},a5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}l5t.isMDXComponent=!0;const u5t={toc:[]};function m5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},u5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}m5t.isMDXComponent=!0;const d5t={toc:[]};function h5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},d5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}h5t.isMDXComponent=!0;const f5t={toc:[]};function y5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},f5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}y5t.isMDXComponent=!0;const k5t={toc:[]};function w5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},k5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}w5t.isMDXComponent=!0;const M5t={toc:[]};function D5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},M5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}D5t.isMDXComponent=!0;const _5t={toc:[]};function g5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}g5t.isMDXComponent=!0;const X5t={toc:[]};function x5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},X5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}x5t.isMDXComponent=!0;const C5t={toc:[]};function T5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},C5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}T5t.isMDXComponent=!0;const v5t={toc:[]};function b5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},v5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}b5t.isMDXComponent=!0;const L5t={toc:[]};function Z5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},L5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Z5t.isMDXComponent=!0;const N5t={toc:[]};function S5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},N5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}S5t.isMDXComponent=!0;const R5t={toc:[]};function z5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},R5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}z5t.isMDXComponent=!0;const P5t={toc:[]};function A5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},P5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}A5t.isMDXComponent=!0;const I5t={toc:[]};function W5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},I5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}W5t.isMDXComponent=!0;const E5t={toc:[]};function B5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},E5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}B5t.isMDXComponent=!0;const F5t={toc:[]};function O5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},F5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}O5t.isMDXComponent=!0;const G5t={toc:[]};function j5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},G5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}j5t.isMDXComponent=!0;const U5t={toc:[]};function q5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},U5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}q5t.isMDXComponent=!0;const V5t={toc:[]};function H5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},V5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}H5t.isMDXComponent=!0;const $5t={toc:[]};function Q5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Q5t.isMDXComponent=!0;const J5t={toc:[]};function Y5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},J5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}Y5t.isMDXComponent=!0;const K5t={toc:[]};function t7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},K5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}t7t.isMDXComponent=!0;const e7t={toc:[]};function n7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},e7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}n7t.isMDXComponent=!0;const o7t={toc:[]};function r7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},o7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}r7t.isMDXComponent=!0;const s7t={toc:[]};function p7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},s7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}p7t.isMDXComponent=!0;const i7t={toc:[]};function c7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},i7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}c7t.isMDXComponent=!0;const a7t={toc:[]};function l7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},a7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}l7t.isMDXComponent=!0;const u7t={toc:[]};function m7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},u7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}m7t.isMDXComponent=!0;const d7t={toc:[]};function h7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},d7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}h7t.isMDXComponent=!0;const f7t={toc:[]};function y7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},f7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}y7t.isMDXComponent=!0;const k7t={toc:[]};function w7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},k7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}w7t.isMDXComponent=!0;const M7t={toc:[]};function D7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},M7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}D7t.isMDXComponent=!0;const _7t={toc:[]};function g7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}g7t.isMDXComponent=!0;const X7t={toc:[]};function x7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},X7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}x7t.isMDXComponent=!0;const C7t={toc:[]};function T7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},C7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}T7t.isMDXComponent=!0;const v7t={toc:[]};function b7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},v7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}b7t.isMDXComponent=!0;const L7t={toc:[]};function Z7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},L7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Z7t.isMDXComponent=!0;const N7t={toc:[]};function S7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},N7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}S7t.isMDXComponent=!0;const R7t={toc:[]};function z7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},R7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}z7t.isMDXComponent=!0;const P7t={toc:[]};function A7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},P7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}A7t.isMDXComponent=!0;const I7t={toc:[]};function W7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},I7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}W7t.isMDXComponent=!0;const E7t={toc:[]};function B7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},E7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}B7t.isMDXComponent=!0;const F7t={toc:[]};function O7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},F7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}O7t.isMDXComponent=!0;const G7t={toc:[]};function j7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},G7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}j7t.isMDXComponent=!0;const U7t={toc:[]};function q7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},U7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}q7t.isMDXComponent=!0;const V7t={toc:[]};function H7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},V7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}H7t.isMDXComponent=!0;const $7t={toc:[]};function Q7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Q7t.isMDXComponent=!0;const J7t={toc:[]};function Y7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},J7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Y7t.isMDXComponent=!0;const K7t={toc:[]};function t9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},K7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}t9t.isMDXComponent=!0;const e9t={toc:[]};function n9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},e9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}n9t.isMDXComponent=!0;const o9t={toc:[]};function r9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},o9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}r9t.isMDXComponent=!0;const s9t={toc:[]};function p9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},s9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}p9t.isMDXComponent=!0;const i9t={toc:[]};function c9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},i9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}c9t.isMDXComponent=!0;const a9t={toc:[]};function l9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},a9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}l9t.isMDXComponent=!0;const u9t={toc:[]};function m9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},u9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}m9t.isMDXComponent=!0;const d9t={toc:[]};function h9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},d9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}h9t.isMDXComponent=!0;const f9t={toc:[]};function y9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},f9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}y9t.isMDXComponent=!0;const k9t={toc:[]};function w9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},k9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}w9t.isMDXComponent=!0;const M9t={toc:[]};function D9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},M9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}D9t.isMDXComponent=!0;const _9t={toc:[]};function g9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}g9t.isMDXComponent=!0;const X9t={toc:[]};function x9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},X9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}x9t.isMDXComponent=!0;const C9t={toc:[]};function T9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},C9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}T9t.isMDXComponent=!0;const v9t={toc:[]};function b9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},v9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}b9t.isMDXComponent=!0;const L9t={toc:[]};function Z9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},L9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Z9t.isMDXComponent=!0;const N9t={toc:[]};function S9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},N9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}S9t.isMDXComponent=!0;const R9t={toc:[]};function z9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},R9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}z9t.isMDXComponent=!0;const P9t={toc:[]};function A9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},P9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}A9t.isMDXComponent=!0;const I9t={toc:[]};function W9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},I9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}W9t.isMDXComponent=!0;const E9t={toc:[]};function B9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},E9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}B9t.isMDXComponent=!0;const F9t={toc:[]};function O9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},F9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}O9t.isMDXComponent=!0;const G9t={toc:[]};function j9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},G9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}j9t.isMDXComponent=!0;const U9t={toc:[]};function q9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},U9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}q9t.isMDXComponent=!0;const V9t={toc:[]};function H9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},V9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}H9t.isMDXComponent=!0;const $9t={toc:[]};function Q9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Q9t.isMDXComponent=!0;const J9t={toc:[]};function Y9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},J9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Y9t.isMDXComponent=!0;const K9t={toc:[]};function tte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},K9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}tte.isMDXComponent=!0;const ete={toc:[]};function nte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ete,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}nte.isMDXComponent=!0;const ote={toc:[]};function rte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ote,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}rte.isMDXComponent=!0;const ste={toc:[]};function pte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ste,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}pte.isMDXComponent=!0;const ite={toc:[]};function cte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ite,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}cte.isMDXComponent=!0;const ate={toc:[]};function lte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ate,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}lte.isMDXComponent=!0;const ute={toc:[]};function mte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ute,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}mte.isMDXComponent=!0;const dte={toc:[]};function hte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}hte.isMDXComponent=!0;const fte={toc:[]};function yte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}yte.isMDXComponent=!0;const kte={toc:[]};function wte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}wte.isMDXComponent=!0;const Mte={toc:[]};function Dte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Dte.isMDXComponent=!0;const _te={toc:[]};function gte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_te,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}gte.isMDXComponent=!0;const Xte={toc:[]};function xte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}xte.isMDXComponent=!0;const Cte={toc:[]};function Tte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Tte.isMDXComponent=!0;const vte={toc:[]};function bte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}bte.isMDXComponent=!0;const Lte={toc:[]};function Zte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Zte.isMDXComponent=!0;const Nte={toc:[]};function Ste(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}Ste.isMDXComponent=!0;const Rte={toc:[]};function zte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}zte.isMDXComponent=!0;const Pte={toc:[]};function Ate(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}Ate.isMDXComponent=!0;const Ite={toc:[]};function Wte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ite,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Wte.isMDXComponent=!0;const Ete={toc:[]};function Bte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ete,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Bte.isMDXComponent=!0;const Fte={toc:[]};function Ote(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Ote.isMDXComponent=!0;const Gte={toc:[]};function jte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}jte.isMDXComponent=!0;const Ute={toc:[]};function qte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ute,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}qte.isMDXComponent=!0;const Vte={toc:[]};function Hte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Hte.isMDXComponent=!0;const $te={toc:[]};function Qte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$te,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Qte.isMDXComponent=!0;const Jte={toc:[]};function Yte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Yte.isMDXComponent=!0;const Kte={toc:[]};function tee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}tee.isMDXComponent=!0;const eee={toc:[]};function nee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}nee.isMDXComponent=!0;const oee={toc:[]};function ree(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}ree.isMDXComponent=!0;const see={toc:[]};function pee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},see,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}pee.isMDXComponent=!0;const iee={toc:[]};function cee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}cee.isMDXComponent=!0;const aee={toc:[]};function lee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}lee.isMDXComponent=!0;const uee={toc:[]};function mee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}mee.isMDXComponent=!0;const dee={toc:[]};function hee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}hee.isMDXComponent=!0;const fee={toc:[]};function yee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}yee.isMDXComponent=!0;const kee={toc:[]};function wee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}wee.isMDXComponent=!0;const Mee={toc:[]};function Dee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Dee.isMDXComponent=!0;const _ee={toc:[]};function gee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_ee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}gee.isMDXComponent=!0;const Xee={toc:[]};function xee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}xee.isMDXComponent=!0;const Cee={toc:[]};function Tee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Tee.isMDXComponent=!0;const vee={toc:[]};function bee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}bee.isMDXComponent=!0;const Lee={toc:[]};function Zee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Zee.isMDXComponent=!0;const Nee={toc:[]};function See(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}See.isMDXComponent=!0;const Ree={toc:[]};function zee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ree,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}zee.isMDXComponent=!0;const Pee={toc:[]};function Aee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Aee.isMDXComponent=!0;const Iee={toc:[]};function Wee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Iee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Wee.isMDXComponent=!0;const Eee={toc:[]};function Bee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}Bee.isMDXComponent=!0;const Fee={toc:[]};function Oee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Oee.isMDXComponent=!0;const Gee={toc:[]};function jee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}jee.isMDXComponent=!0;const Uee={toc:[]};function qee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}qee.isMDXComponent=!0;const Vee={toc:[]};function Hee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Hee.isMDXComponent=!0;const $ee={toc:[]};function Qee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$ee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}Qee.isMDXComponent=!0;const Jee={toc:[]};function Yee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Yee.isMDXComponent=!0;const Kee={toc:[]};function tne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}tne.isMDXComponent=!0;const ene={toc:[]};function nne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ene,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nne.isMDXComponent=!0;const one={toc:[]};function rne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},one,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}rne.isMDXComponent=!0;const sne={toc:[]};function pne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pne.isMDXComponent=!0;const ine={toc:[]};function cne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ine,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}cne.isMDXComponent=!0;const ane={toc:[]};function lne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ane,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lne.isMDXComponent=!0;const une={toc:[]};function mne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},une,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}mne.isMDXComponent=!0;const dne={toc:[]};function hne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}hne.isMDXComponent=!0;const fne={toc:[]};function yne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the path of this circle should be closed."))}yne.isMDXComponent=!0;const kne={toc:[]};function wne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property can be used together with ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,p.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}wne.isMDXComponent=!0;const Mne={toc:[]};function Dne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ending angle in degrees for the circle sector."))}Dne.isMDXComponent=!0;const _ne={toc:[]};function gne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_ne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gne.isMDXComponent=!0;const Xne={toc:[]};function xne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}xne.isMDXComponent=!0;const Cne={toc:[]};function Tne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tne.isMDXComponent=!0;const vne={toc:[]};function bne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}bne.isMDXComponent=!0;const Lne={toc:[]};function Zne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property can be used together with ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,p.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Zne.isMDXComponent=!0;const Nne={toc:[]};function Sne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The starting angle in degrees for the circle sector."))}Sne.isMDXComponent=!0;const Rne={toc:[]};function zne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zne.isMDXComponent=!0;const Pne={toc:[]};function Ane(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}Ane.isMDXComponent=!0;const Ine={toc:[]};function Wne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ine,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wne.isMDXComponent=!0;const Ene={toc:[]};function Bne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ene,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Bne.isMDXComponent=!0;const Fne={toc:[]};function One(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}One.isMDXComponent=!0;const Gne={toc:[]};function jne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}jne.isMDXComponent=!0;const Une={toc:[]};function qne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Une,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}qne.isMDXComponent=!0;const Vne={toc:[]};function Hne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}Hne.isMDXComponent=!0;const $ne={toc:[]};function Qne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$ne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qne.isMDXComponent=!0;const Jne={toc:[]};function Yne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Yne.isMDXComponent=!0;const Kne={toc:[]};function toe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}toe.isMDXComponent=!0;const eoe={toc:[]};function noe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eoe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}noe.isMDXComponent=!0;const ooe={toc:[]};function roe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ooe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}roe.isMDXComponent=!0;const soe={toc:[]};function poe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},soe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}poe.isMDXComponent=!0;const ioe={toc:[]};function coe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ioe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}coe.isMDXComponent=!0;const aoe={toc:[]};function loe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aoe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}loe.isMDXComponent=!0;const uoe={toc:[]};function moe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uoe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}moe.isMDXComponent=!0;const doe={toc:[]};function hoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},doe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}hoe.isMDXComponent=!0;const foe={toc:[]};function yoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},foe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}yoe.isMDXComponent=!0;const koe={toc:[]};function woe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},koe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}woe.isMDXComponent=!0;const Moe={toc:[]};function Doe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Moe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Doe.isMDXComponent=!0;const _oe={toc:[]};function goe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_oe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}goe.isMDXComponent=!0;const Xoe={toc:[]};function xoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xoe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xoe.isMDXComponent=!0;const Coe={toc:[]};function Toe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Coe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Toe.isMDXComponent=!0;const voe={toc:[]};function boe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},voe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}boe.isMDXComponent=!0;const Loe={toc:[]};function Zoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Loe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Zoe.isMDXComponent=!0;const Noe={toc:[]};function Soe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Noe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Soe.isMDXComponent=!0;const Roe={toc:[]};function zoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Roe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}zoe.isMDXComponent=!0;const Poe={toc:[]};function Aoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Poe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Aoe.isMDXComponent=!0;const Ioe={toc:[]};function Woe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ioe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Woe.isMDXComponent=!0;const Eoe={toc:[]};function Boe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eoe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Boe.isMDXComponent=!0;const Foe={toc:[]};function Ooe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Foe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}Ooe.isMDXComponent=!0;const Goe={toc:[]};function joe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Goe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}joe.isMDXComponent=!0;const Uoe={toc:[]};function qoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uoe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}qoe.isMDXComponent=!0;const Voe={toc:[]};function Hoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Voe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hoe.isMDXComponent=!0;const $oe={toc:[]};function Qoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$oe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Qoe.isMDXComponent=!0;const Joe={toc:[]};function Yoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Joe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yoe.isMDXComponent=!0;const Koe={toc:[]};function tre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Koe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}tre.isMDXComponent=!0;const ere={toc:[]};function nre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ere,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}nre.isMDXComponent=!0;const ore={toc:[]};function rre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ore,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}rre.isMDXComponent=!0;const sre={toc:[]};function pre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pre.isMDXComponent=!0;const ire={toc:[]};function cre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ire,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}cre.isMDXComponent=!0;const are={toc:[]};function lre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},are,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lre.isMDXComponent=!0;const ure={toc:[]};function mre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ure,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}mre.isMDXComponent=!0;const dre={toc:[]};function hre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hre.isMDXComponent=!0;const fre={toc:[]};function yre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}yre.isMDXComponent=!0;const kre={toc:[]};function wre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}wre.isMDXComponent=!0;const Mre={toc:[]};function Dre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}Dre.isMDXComponent=!0;const _re={toc:[]};function gre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_re,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}gre.isMDXComponent=!0;const Xre={toc:[]};function xre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}xre.isMDXComponent=!0;const Cre={toc:[]};function Tre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Tre.isMDXComponent=!0;const vre={toc:[]};function bre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}bre.isMDXComponent=!0;const Lre={toc:[]};function Zre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Zre.isMDXComponent=!0;const Nre={toc:[]};function Sre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}Sre.isMDXComponent=!0;const Rre={toc:[]};function zre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zre.isMDXComponent=!0;const Pre={toc:[]};function Are(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Are.isMDXComponent=!0;const Ire={toc:[]};function Wre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ire,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wre.isMDXComponent=!0;const Ere={toc:[]};function Bre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ere,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Bre.isMDXComponent=!0;const Fre={toc:[]};function Ore(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Ore.isMDXComponent=!0;const Gre={toc:[]};function jre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}jre.isMDXComponent=!0;const Ure={toc:[]};function qre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ure,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qre.isMDXComponent=!0;const Vre={toc:[]};function Hre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Hre.isMDXComponent=!0;const $re={toc:[]};function Qre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$re,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Qre.isMDXComponent=!0;const Jre={toc:[]};function Yre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}Yre.isMDXComponent=!0;const Kre={toc:[]};function tse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tse.isMDXComponent=!0;const ese={toc:[]};function nse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ese,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}nse.isMDXComponent=!0;const ose={toc:[]};function rse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ose,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}rse.isMDXComponent=!0;const sse={toc:[]};function pse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}pse.isMDXComponent=!0;const ise={toc:[]};function cse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ise,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cse.isMDXComponent=!0;const ase={toc:[]};function lse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ase,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}lse.isMDXComponent=!0;const use={toc:[]};function mse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},use,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mse.isMDXComponent=!0;const dse={toc:[]};function hse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}hse.isMDXComponent=!0;const fse={toc:[]};function yse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}yse.isMDXComponent=!0;const kse={toc:[]};function wse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}wse.isMDXComponent=!0;const Mse={toc:[]};function Dse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Dse.isMDXComponent=!0;const _se={toc:[]};function gse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_se,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}gse.isMDXComponent=!0;const Xse={toc:[]};function xse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xse.isMDXComponent=!0;const Cse={toc:[]};function Tse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Tse.isMDXComponent=!0;const vse={toc:[]};function bse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bse.isMDXComponent=!0;const Lse={toc:[]};function Zse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Zse.isMDXComponent=!0;const Nse={toc:[]};function Sse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Sse.isMDXComponent=!0;const Rse={toc:[]};function zse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}zse.isMDXComponent=!0;const Pse={toc:[]};function Ase(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ase.isMDXComponent=!0;const Ise={toc:[]};function Wse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ise,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Wse.isMDXComponent=!0;const Ese={toc:[]};function Bse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ese,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bse.isMDXComponent=!0;const Fse={toc:[]};function Ose(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Ose.isMDXComponent=!0;const Gse={toc:[]};function jse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}jse.isMDXComponent=!0;const Use={toc:[]};function qse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Use,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The alpha value of this image."))}qse.isMDXComponent=!0;const Vse={toc:[]};function Hse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hse.isMDXComponent=!0;const $se={toc:[]};function Qse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$se,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Qse.isMDXComponent=!0;const Jse={toc:[]};function Yse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yse.isMDXComponent=!0;const Kse={toc:[]};function tpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}tpe.isMDXComponent=!0;const epe={toc:[]};function npe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},epe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}npe.isMDXComponent=!0;const ope={toc:[]};function rpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ope,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}rpe.isMDXComponent=!0;const spe={toc:[]};function ppe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},spe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide the color in one of the following formats:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"named color like ",(0,p.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,p.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,p.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,p.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,p.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,p.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,p.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,p.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,p.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}ppe.isMDXComponent=!0;const ipe={toc:[]};function cpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ipe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The color of the icon"))}cpe.isMDXComponent=!0;const ape={toc:[]};function lpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ape,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}lpe.isMDXComponent=!0;const upe={toc:[]};function mpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},upe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}mpe.isMDXComponent=!0;const dpe={toc:[]};function hpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"You can find identifiers on ",(0,p.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}hpe.isMDXComponent=!0;const fpe={toc:[]};function ype(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The identifier of the icon."))}ype.isMDXComponent=!0;const kpe={toc:[]};function wpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wpe.isMDXComponent=!0;const Mpe={toc:[]};function Dpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Dpe.isMDXComponent=!0;const _pe={toc:[]};function gpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_pe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gpe.isMDXComponent=!0;const Xpe={toc:[]};function xpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}xpe.isMDXComponent=!0;const Cpe={toc:[]};function Tpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Tpe.isMDXComponent=!0;const vpe={toc:[]};function bpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}bpe.isMDXComponent=!0;const Lpe={toc:[]};function Zpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Zpe.isMDXComponent=!0;const Npe={toc:[]};function Spe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Npe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the image should be smoothed."))}Spe.isMDXComponent=!0;const Rpe={toc:[]};function zpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The source of this image."))}zpe.isMDXComponent=!0;const Ppe={toc:[]};function Ape(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ppe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ape.isMDXComponent=!0;const Ipe={toc:[]};function Wpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ipe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}Wpe.isMDXComponent=!0;const Epe={toc:[]};function Bpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Epe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bpe.isMDXComponent=!0;const Fpe={toc:[]};function Ope(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Ope.isMDXComponent=!0;const Gpe={toc:[]};function jpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}jpe.isMDXComponent=!0;const Upe={toc:[]};function qpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Upe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}qpe.isMDXComponent=!0;const Vpe={toc:[]};function Hpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Hpe.isMDXComponent=!0;const $pe={toc:[]};function Qpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$pe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The alpha value of this image."))}Qpe.isMDXComponent=!0;const Jpe={toc:[]};function Ype(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ype.isMDXComponent=!0;const Kpe={toc:[]};function tie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}tie.isMDXComponent=!0;const eie={toc:[]};function nie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nie.isMDXComponent=!0;const oie={toc:[]};function rie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}rie.isMDXComponent=!0;const sie={toc:[]};function pie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pie.isMDXComponent=!0;const iie={toc:[]};function cie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}cie.isMDXComponent=!0;const aie={toc:[]};function lie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}lie.isMDXComponent=!0;const uie={toc:[]};function mie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}mie.isMDXComponent=!0;const die={toc:[]};function hie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},die,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hie.isMDXComponent=!0;const fie={toc:[]};function yie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}yie.isMDXComponent=!0;const kie={toc:[]};function wie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wie.isMDXComponent=!0;const Mie={toc:[]};function Die(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Die.isMDXComponent=!0;const _ie={toc:[]};function gie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_ie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}gie.isMDXComponent=!0;const Xie={toc:[]};function xie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}xie.isMDXComponent=!0;const Cie={toc:[]};function Tie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Tie.isMDXComponent=!0;const vie={toc:[]};function bie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the image should be smoothed."))}bie.isMDXComponent=!0;const Lie={toc:[]};function Zie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The source of this image."))}Zie.isMDXComponent=!0;const Nie={toc:[]};function Sie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Sie.isMDXComponent=!0;const Rie={toc:[]};function zie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}zie.isMDXComponent=!0;const Pie={toc:[]};function Aie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Aie.isMDXComponent=!0;const Iie={toc:[]};function Wie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Iie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Wie.isMDXComponent=!0;const Eie={toc:[]};function Bie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bie.isMDXComponent=!0;const Fie={toc:[]};function Oie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Oie.isMDXComponent=!0;const Gie={toc:[]};function jie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}jie.isMDXComponent=!0;const Uie={toc:[]};function qie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}qie.isMDXComponent=!0;const Vie={toc:[]};function Hie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,p.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,p.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,p.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,p.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Hie.isMDXComponent=!0;const $ie={toc:[]};function Qie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$ie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}Qie.isMDXComponent=!0;const Jie={toc:[]};function Yie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,p.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,p.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,p.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,p.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Yie.isMDXComponent=!0;const Kie={toc:[]};function tce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}tce.isMDXComponent=!0;const ece={toc:[]};function nce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ece,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}nce.isMDXComponent=!0;const oce={toc:[]};function rce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The alpha value of this image."))}rce.isMDXComponent=!0;const sce={toc:[]};function pce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pce.isMDXComponent=!0;const ice={toc:[]};function cce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ice,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}cce.isMDXComponent=!0;const ace={toc:[]};function lce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ace,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lce.isMDXComponent=!0;const uce={toc:[]};function mce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}mce.isMDXComponent=!0;const dce={toc:[]};function hce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hce.isMDXComponent=!0;const fce={toc:[]};function yce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}yce.isMDXComponent=!0;const kce={toc:[]};function wce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}wce.isMDXComponent=!0;const Mce={toc:[]};function Dce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}Dce.isMDXComponent=!0;const _ce={toc:[]};function gce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_ce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gce.isMDXComponent=!0;const Xce={toc:[]};function xce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}xce.isMDXComponent=!0;const Cce={toc:[]};function Tce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tce.isMDXComponent=!0;const vce={toc:[]};function bce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}bce.isMDXComponent=!0;const Lce={toc:[]};function Zce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Zce.isMDXComponent=!0;const Nce={toc:[]};function Sce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Sce.isMDXComponent=!0;const Rce={toc:[]};function zce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}zce.isMDXComponent=!0;const Pce={toc:[]};function Ace(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the image should be smoothed."))}Ace.isMDXComponent=!0;const Ice={toc:[]};function Wce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ice,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The source of this image."))}Wce.isMDXComponent=!0;const Ece={toc:[]};function Bce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ece,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bce.isMDXComponent=!0;const Fce={toc:[]};function Oce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}Oce.isMDXComponent=!0;const Gce={toc:[]};function jce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}jce.isMDXComponent=!0;const Uce={toc:[]};function qce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}qce.isMDXComponent=!0;const Vce={toc:[]};function Hce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hce.isMDXComponent=!0;const $ce={toc:[]};function Qce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$ce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Qce.isMDXComponent=!0;const Jce={toc:[]};function Yce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yce.isMDXComponent=!0;const Kce={toc:[]};function tae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}tae.isMDXComponent=!0;const eae={toc:[]};function nae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nae.isMDXComponent=!0;const oae={toc:[]};function rae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}rae.isMDXComponent=!0;const sae={toc:[]};function pae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pae.isMDXComponent=!0;const iae={toc:[]};function cae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}cae.isMDXComponent=!0;const aae={toc:[]};function lae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lae.isMDXComponent=!0;const uae={toc:[]};function mae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}mae.isMDXComponent=!0;const dae={toc:[]};function hae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hae.isMDXComponent=!0;const fae={toc:[]};function yae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}yae.isMDXComponent=!0;const kae={toc:[]};function wae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wae.isMDXComponent=!0;const Mae={toc:[]};function Dae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}Dae.isMDXComponent=!0;const _ae={toc:[]};function gae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_ae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gae.isMDXComponent=!0;const Xae={toc:[]};function xae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}xae.isMDXComponent=!0;const Cae={toc:[]};function Tae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tae.isMDXComponent=!0;const vae={toc:[]};function bae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}bae.isMDXComponent=!0;const Lae={toc:[]};function Zae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Zae.isMDXComponent=!0;const Nae={toc:[]};function Sae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}Sae.isMDXComponent=!0;const Rae={toc:[]};function zae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zae.isMDXComponent=!0;const Pae={toc:[]};function Aae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Aae.isMDXComponent=!0;const Iae={toc:[]};function Wae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Iae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wae.isMDXComponent=!0;const Eae={toc:[]};function Bae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Bae.isMDXComponent=!0;const Fae={toc:[]};function Oae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Oae.isMDXComponent=!0;const Gae={toc:[]};function jae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}jae.isMDXComponent=!0;const Uae={toc:[]};function qae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}qae.isMDXComponent=!0;const Vae={toc:[]};function Hae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}Hae.isMDXComponent=!0;const $ae={toc:[]};function Qae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$ae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Qae.isMDXComponent=!0;const Jae={toc:[]};function Yae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Yae.isMDXComponent=!0;const Kae={toc:[]};function tle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}tle.isMDXComponent=!0;const ele={toc:[]};function nle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ele,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}nle.isMDXComponent=!0;const ole={toc:[]};function rle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ole,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}rle.isMDXComponent=!0;const sle={toc:[]};function ple(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}ple.isMDXComponent=!0;const ile={toc:[]};function cle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ile,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cle.isMDXComponent=!0;const ale={toc:[]};function lle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ale,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}lle.isMDXComponent=!0;const ule={toc:[]};function mle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ule,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mle.isMDXComponent=!0;const dle={toc:[]};function hle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}hle.isMDXComponent=!0;const fle={toc:[]};function yle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}yle.isMDXComponent=!0;const kle={toc:[]};function wle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}wle.isMDXComponent=!0;const Mle={toc:[]};function Dle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Dle.isMDXComponent=!0;const _le={toc:[]};function gle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_le,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}gle.isMDXComponent=!0;const Xle={toc:[]};function xle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}xle.isMDXComponent=!0;const Cle={toc:[]};function Tle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}Tle.isMDXComponent=!0;const vle={toc:[]};function ble(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ble.isMDXComponent=!0;const Lle={toc:[]};function Zle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}Zle.isMDXComponent=!0;const Nle={toc:[]};function Sle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Sle.isMDXComponent=!0;const Rle={toc:[]};function zle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}zle.isMDXComponent=!0;const Ple={toc:[]};function Ale(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ple,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ale.isMDXComponent=!0;const Ile={toc:[]};function Wle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ile,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Wle.isMDXComponent=!0;const Ele={toc:[]};function Ble(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ele,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ble.isMDXComponent=!0;const Fle={toc:[]};function Ole(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Ole.isMDXComponent=!0;const Gle={toc:[]};function jle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}jle.isMDXComponent=!0;const Ule={toc:[]};function qle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ule,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}qle.isMDXComponent=!0;const Vle={toc:[]};function Hle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hle.isMDXComponent=!0;const $le={toc:[]};function Qle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$le,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Qle.isMDXComponent=!0;const Jle={toc:[]};function Yle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yle.isMDXComponent=!0;const Kle={toc:[]};function tue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}tue.isMDXComponent=!0;const eue={toc:[]};function nue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nue.isMDXComponent=!0;const oue={toc:[]};function rue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}rue.isMDXComponent=!0;const sue={toc:[]};function pue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"For example, a value of 6 creates a hexagon."))}pue.isMDXComponent=!0;const iue={toc:[]};function cue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Sets the number of sides of the polygon."))}cue.isMDXComponent=!0;const aue={toc:[]};function lue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lue.isMDXComponent=!0;const uue={toc:[]};function mue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}mue.isMDXComponent=!0;const due={toc:[]};function hue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},due,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hue.isMDXComponent=!0;const fue={toc:[]};function yue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}yue.isMDXComponent=!0;const kue={toc:[]};function wue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wue.isMDXComponent=!0;const Mue={toc:[]};function Due(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Due.isMDXComponent=!0;const _ue={toc:[]};function gue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_ue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}gue.isMDXComponent=!0;const Xue={toc:[]};function xue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}xue.isMDXComponent=!0;const Cue={toc:[]};function Tue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tue.isMDXComponent=!0;const vue={toc:[]};function bue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}bue.isMDXComponent=!0;const Lue={toc:[]};function Zue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Zue.isMDXComponent=!0;const Nue={toc:[]};function Sue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Sue.isMDXComponent=!0;const Rue={toc:[]};function zue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zue.isMDXComponent=!0;const Pue={toc:[]};function Aue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Aue.isMDXComponent=!0;const Iue={toc:[]};function Wue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Iue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}Wue.isMDXComponent=!0;const Eue={toc:[]};function Bue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}Bue.isMDXComponent=!0;const Fue={toc:[]};function Oue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Oue.isMDXComponent=!0;const Gue={toc:[]};function jue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}jue.isMDXComponent=!0;const Uue={toc:[]};function que(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}que.isMDXComponent=!0;const Vue={toc:[]};function Hue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Hue.isMDXComponent=!0;const $ue={toc:[]};function Que(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$ue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Que.isMDXComponent=!0;const Jue={toc:[]};function Yue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}Yue.isMDXComponent=!0;const Kue={toc:[]};function tme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tme.isMDXComponent=!0;const eme={toc:[]};function nme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}nme.isMDXComponent=!0;const ome={toc:[]};function rme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ome,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}rme.isMDXComponent=!0;const sme={toc:[]};function pme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}pme.isMDXComponent=!0;const ime={toc:[]};function cme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ime,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}cme.isMDXComponent=!0;const ame={toc:[]};function lme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ame,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}lme.isMDXComponent=!0;const ume={toc:[]};function mme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ume,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}mme.isMDXComponent=!0;const dme={toc:[]};function hme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}hme.isMDXComponent=!0;const fme={toc:[]};function yme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}yme.isMDXComponent=!0;const kme={toc:[]};function wme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}wme.isMDXComponent=!0;const Mme={toc:[]};function Dme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Dme.isMDXComponent=!0;const _me={toc:[]};function gme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_me,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}gme.isMDXComponent=!0;const Xme={toc:[]};function xme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xme.isMDXComponent=!0;const Cme={toc:[]};function Tme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Tme.isMDXComponent=!0;const vme={toc:[]};function bme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bme.isMDXComponent=!0;const Lme={toc:[]};function Zme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Zme.isMDXComponent=!0;const Nme={toc:[]};function Sme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Sme.isMDXComponent=!0;const Rme={toc:[]};function zme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}zme.isMDXComponent=!0;const Pme={toc:[]};function Ame(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ame.isMDXComponent=!0;const Ime={toc:[]};function Wme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ime,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Wme.isMDXComponent=!0;const Eme={toc:[]};function Bme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bme.isMDXComponent=!0;const Fme={toc:[]};function Ome(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Ome.isMDXComponent=!0;const Gme={toc:[]};function jme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}jme.isMDXComponent=!0;const Ume={toc:[]};function qme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ume,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}qme.isMDXComponent=!0;const Vme={toc:[]};function Hme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}Hme.isMDXComponent=!0;const $me={toc:[]};function Qme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$me,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}Qme.isMDXComponent=!0;const Jme={toc:[]};function Yme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Yme.isMDXComponent=!0;const Kme={toc:[]};function tde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}tde.isMDXComponent=!0;const ede={toc:[]};function nde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ede,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nde.isMDXComponent=!0;const ode={toc:[]};function rde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ode,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}rde.isMDXComponent=!0;const sde={toc:[]};function pde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}pde.isMDXComponent=!0;const ide={toc:[]};function cde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ide,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}cde.isMDXComponent=!0;const ade={toc:[]};function lde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ade,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The starting point of the ray."))}lde.isMDXComponent=!0;const ude={toc:[]};function mde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ude,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mde.isMDXComponent=!0;const dde={toc:[]};function hde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}hde.isMDXComponent=!0;const fde={toc:[]};function yde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}yde.isMDXComponent=!0;const kde={toc:[]};function wde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}wde.isMDXComponent=!0;const Mde={toc:[]};function Dde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Dde.isMDXComponent=!0;const _de={toc:[]};function gde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_de,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}gde.isMDXComponent=!0;const Xde={toc:[]};function xde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xde.isMDXComponent=!0;const Cde={toc:[]};function Tde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Tde.isMDXComponent=!0;const vde={toc:[]};function bde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}bde.isMDXComponent=!0;const Lde={toc:[]};function Zde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}Zde.isMDXComponent=!0;const Nde={toc:[]};function Sde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ending point of the ray."))}Sde.isMDXComponent=!0;const Rde={toc:[]};function zde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zde.isMDXComponent=!0;const Pde={toc:[]};function Ade(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}Ade.isMDXComponent=!0;const Ide={toc:[]};function Wde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ide,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wde.isMDXComponent=!0;const Ede={toc:[]};function Bde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ede,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Bde.isMDXComponent=!0;const Fde={toc:[]};function Ode(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ode.isMDXComponent=!0;const Gde={toc:[]};function jde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}jde.isMDXComponent=!0;const Ude={toc:[]};function qde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ude,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qde.isMDXComponent=!0;const Vde={toc:[]};function Hde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Hde.isMDXComponent=!0;const $de={toc:[]};function Qde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$de,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qde.isMDXComponent=!0;const Jde={toc:[]};function Yde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Yde.isMDXComponent=!0;const Kde={toc:[]};function the(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}the.isMDXComponent=!0;const ehe={toc:[]};function nhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ehe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}nhe.isMDXComponent=!0;const ohe={toc:[]};function rhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ohe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}rhe.isMDXComponent=!0;const she={toc:[]};function phe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},she,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}phe.isMDXComponent=!0;const ihe={toc:[]};function che(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ihe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}che.isMDXComponent=!0;const ahe={toc:[]};function lhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ahe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}lhe.isMDXComponent=!0;const uhe={toc:[]};function mhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mhe.isMDXComponent=!0;const dhe={toc:[]};function hhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}hhe.isMDXComponent=!0;const fhe={toc:[]};function yhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}yhe.isMDXComponent=!0;const khe={toc:[]};function whe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},khe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}whe.isMDXComponent=!0;const Mhe={toc:[]};function Dhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Dhe.isMDXComponent=!0;const _he={toc:[]};function ghe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_he,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}ghe.isMDXComponent=!0;const Xhe={toc:[]};function xhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xhe.isMDXComponent=!0;const Che={toc:[]};function The(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Che,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}The.isMDXComponent=!0;const vhe={toc:[]};function bhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bhe.isMDXComponent=!0;const Lhe={toc:[]};function Zhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Zhe.isMDXComponent=!0;const Nhe={toc:[]};function She(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}She.isMDXComponent=!0;const Rhe={toc:[]};function zhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}zhe.isMDXComponent=!0;const Phe={toc:[]};function Ahe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Phe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ahe.isMDXComponent=!0;const Ihe={toc:[]};function Whe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ihe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Whe.isMDXComponent=!0;const Ehe={toc:[]};function Bhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ehe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bhe.isMDXComponent=!0;const Fhe={toc:[]};function Ohe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Ohe.isMDXComponent=!0;const Ghe={toc:[]};function jhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ghe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}jhe.isMDXComponent=!0;const Uhe={toc:[]};function qhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}qhe.isMDXComponent=!0;const Vhe={toc:[]};function Hhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hhe.isMDXComponent=!0;const $he={toc:[]};function Qhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$he,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Qhe.isMDXComponent=!0;const Jhe={toc:[]};function Yhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yhe.isMDXComponent=!0;const Khe={toc:[]};function tfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Khe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}tfe.isMDXComponent=!0;const efe={toc:[]};function nfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},efe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nfe.isMDXComponent=!0;const ofe={toc:[]};function rfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ofe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}rfe.isMDXComponent=!0;const sfe={toc:[]};function pfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pfe.isMDXComponent=!0;const ife={toc:[]};function cfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ife,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}cfe.isMDXComponent=!0;const afe={toc:[]};function lfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},afe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}lfe.isMDXComponent=!0;const ufe={toc:[]};function mfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ufe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}mfe.isMDXComponent=!0;const dfe={toc:[]};function hfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hfe.isMDXComponent=!0;const ffe={toc:[]};function yfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ffe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}yfe.isMDXComponent=!0;const kfe={toc:[]};function wfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wfe.isMDXComponent=!0;const Mfe={toc:[]};function Dfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Dfe.isMDXComponent=!0;const _fe={toc:[]};function gfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_fe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gfe.isMDXComponent=!0;const Xfe={toc:[]};function xfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}xfe.isMDXComponent=!0;const Cfe={toc:[]};function Tfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}Tfe.isMDXComponent=!0;const vfe={toc:[]};function bfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}bfe.isMDXComponent=!0;const Lfe={toc:[]};function Zfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Zfe.isMDXComponent=!0;const Nfe={toc:[]};function Sfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Sfe.isMDXComponent=!0;const Rfe={toc:[]};function zfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}zfe.isMDXComponent=!0;const Pfe={toc:[]};function Afe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Afe.isMDXComponent=!0;const Ife={toc:[]};function Wfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ife,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Wfe.isMDXComponent=!0;const Efe={toc:[]};function Bfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Efe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}Bfe.isMDXComponent=!0;const Ffe={toc:[]};function Ofe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ffe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ofe.isMDXComponent=!0;const Gfe={toc:[]};function jfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}jfe.isMDXComponent=!0;const Ufe={toc:[]};function qfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ufe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Spline.points"))}qfe.isMDXComponent=!0;const Vfe={toc:[]};function Hfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hfe.isMDXComponent=!0;const $fe={toc:[]};function Qfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$fe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Qfe.isMDXComponent=!0;const Jfe={toc:[]};function Yfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}Yfe.isMDXComponent=!0;const Kfe={toc:[]};function tye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}tye.isMDXComponent=!0;const eye={toc:[]};function nye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}nye.isMDXComponent=!0;const oye={toc:[]};function rye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}rye.isMDXComponent=!0;const sye={toc:[]};function pye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pye.isMDXComponent=!0;const iye={toc:[]};function cye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}cye.isMDXComponent=!0;const aye={toc:[]};function lye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lye.isMDXComponent=!0;const uye={toc:[]};function mye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}mye.isMDXComponent=!0;const dye={toc:[]};function hye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hye.isMDXComponent=!0;const fye={toc:[]};function yye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}yye.isMDXComponent=!0;const kye={toc:[]};function wye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wye.isMDXComponent=!0;const Mye={toc:[]};function Dye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Dye.isMDXComponent=!0;const _ye={toc:[]};function gye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_ye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gye.isMDXComponent=!0;const Xye={toc:[]};function xye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}xye.isMDXComponent=!0;const Cye={toc:[]};function Tye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tye.isMDXComponent=!0;const vye={toc:[]};function bye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}bye.isMDXComponent=!0;const Lye={toc:[]};function Zye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Zye.isMDXComponent=!0;const Nye={toc:[]};function Sye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Sye.isMDXComponent=!0;const Rye={toc:[]};function zye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zye.isMDXComponent=!0;const Pye={toc:[]};function Aye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Aye.isMDXComponent=!0;const Iye={toc:[]};function Wye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Iye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wye.isMDXComponent=!0;const Eye={toc:[]};function Bye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Bye.isMDXComponent=!0;const Fye={toc:[]};function Oye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Oye.isMDXComponent=!0;const Gye={toc:[]};function jye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}jye.isMDXComponent=!0;const Uye={toc:[]};function qye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qye.isMDXComponent=!0;const Vye={toc:[]};function Hye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}Hye.isMDXComponent=!0;const $ye={toc:[]};function Qye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$ye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qye.isMDXComponent=!0;const Jye={toc:[]};function Yye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Yye.isMDXComponent=!0;const Kye={toc:[]};function tke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tke.isMDXComponent=!0;const eke={toc:[]};function nke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}nke.isMDXComponent=!0;const oke={toc:[]};function rke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}rke.isMDXComponent=!0;const ske={toc:[]};function pke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ske,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The alpha value of this video."))}pke.isMDXComponent=!0;const ike={toc:[]};function cke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ike,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cke.isMDXComponent=!0;const ake={toc:[]};function lke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ake,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}lke.isMDXComponent=!0;const uke={toc:[]};function mke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mke.isMDXComponent=!0;const dke={toc:[]};function hke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}hke.isMDXComponent=!0;const fke={toc:[]};function yke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}yke.isMDXComponent=!0;const kke={toc:[]};function wke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}wke.isMDXComponent=!0;const Mke={toc:[]};function Dke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Dke.isMDXComponent=!0;const _ke={toc:[]};function gke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_ke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}gke.isMDXComponent=!0;const Xke={toc:[]};function xke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xke.isMDXComponent=!0;const Cke={toc:[]};function Tke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Tke.isMDXComponent=!0;const vke={toc:[]};function bke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this video should loop upon reaching the end."))}bke.isMDXComponent=!0;const Lke={toc:[]};function Zke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Zke.isMDXComponent=!0;const Nke={toc:[]};function Ske(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Ske.isMDXComponent=!0;const Rke={toc:[]};function zke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}zke.isMDXComponent=!0;const Pke={toc:[]};function Ake(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Ake.isMDXComponent=!0;const Ike={toc:[]};function Wke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ike,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}Wke.isMDXComponent=!0;const Eke={toc:[]};function Bke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Eke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the video should be smoothed."))}Bke.isMDXComponent=!0;const Fke={toc:[]};function Oke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The source of this video."))}Oke.isMDXComponent=!0;const Gke={toc:[]};function jke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The starting time for this video in seconds."))}jke.isMDXComponent=!0;const Uke={toc:[]};function qke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qke.isMDXComponent=!0;const Vke={toc:[]};function Hke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}Hke.isMDXComponent=!0;const $ke={toc:[]};function Qke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$ke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qke.isMDXComponent=!0;const Jke={toc:[]};function Yke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Yke.isMDXComponent=!0;const Kke={toc:[]};function twe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}twe.isMDXComponent=!0;const ewe={toc:[]};function nwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ewe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}nwe.isMDXComponent=!0;const owe={toc:[]};function rwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},owe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}rwe.isMDXComponent=!0;const swe={toc:[]};function pwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},swe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}pwe.isMDXComponent=!0;const iwe={toc:[]};function cwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cwe.isMDXComponent=!0;const awe={toc:[]};function lwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},awe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}lwe.isMDXComponent=!0;const uwe={toc:[]};function mwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mwe.isMDXComponent=!0;const dwe={toc:[]};function hwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}hwe.isMDXComponent=!0;const fwe={toc:[]};function ywe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}ywe.isMDXComponent=!0;const kwe={toc:[]};function wwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}wwe.isMDXComponent=!0;const Mwe={toc:[]};function Dwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Dwe.isMDXComponent=!0;const _we={toc:[]};function gwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_we,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}gwe.isMDXComponent=!0;const Xwe={toc:[]};function xwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xwe.isMDXComponent=!0;const Cwe={toc:[]};function Twe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Twe.isMDXComponent=!0;const vwe={toc:[]};function bwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}bwe.isMDXComponent=!0;const Lwe={toc:[]};function Zwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Zwe.isMDXComponent=!0;const Nwe={toc:[]};function Swe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Swe.isMDXComponent=!0;const Rwe={toc:[]};function zwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}zwe.isMDXComponent=!0;const Pwe={toc:[]};function Awe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Awe.isMDXComponent=!0;const Iwe={toc:[]};function Wwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Iwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Wwe.isMDXComponent=!0;const Ewe={toc:[]};function Bwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ewe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bwe.isMDXComponent=!0;const Fwe={toc:[]};function Owe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Owe.isMDXComponent=!0;const Gwe={toc:[]};function jwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}jwe.isMDXComponent=!0;const Uwe={toc:[]};function qwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Evaluate the polynomial at the given t value."))}qwe.isMDXComponent=!0;const Vwe={toc:[]};function Hwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The t value at which to evaluate the curve."))}Hwe.isMDXComponent=!0;const $we={toc:[]};function Qwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$we,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}Qwe.isMDXComponent=!0;const Jwe={toc:[]};function Ywe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The t value at which to evaluate the curve."))}Ywe.isMDXComponent=!0;const Kwe={toc:[]};function tMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,p.kt)("p",null,"Source code liberally taken from:\n",(0,p.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}tMe.isMDXComponent=!0;const eMe={toc:[]};function nMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constant coefficient"))}nMe.isMDXComponent=!0;const oMe={toc:[]};function rMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constant coefficient"))}rMe.isMDXComponent=!0;const sMe={toc:[]};function pMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The linear coefficient"))}pMe.isMDXComponent=!0;const iMe={toc:[]};function cMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constant coefficient"))}cMe.isMDXComponent=!0;const aMe={toc:[]};function lMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The linear coefficient"))}lMe.isMDXComponent=!0;const uMe={toc:[]};function mMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The quadratic coefficient"))}mMe.isMDXComponent=!0;const dMe={toc:[]};function hMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constant coefficient"))}hMe.isMDXComponent=!0;const fMe={toc:[]};function yMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The linear coefficient"))}yMe.isMDXComponent=!0;const kMe={toc:[]};function wMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The quadratic coefficient"))}wMe.isMDXComponent=!0;const MMe={toc:[]};function DMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The cubic coefficient"))}DMe.isMDXComponent=!0;const _Me={toc:[]};function gMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Me,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The degree of the polynomial"))}gMe.isMDXComponent=!0;const XMe={toc:[]};function xMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the nth derivative of the polynomial."))}xMe.isMDXComponent=!0;const CMe={toc:[]};function TMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The number of times to differentiate the polynomial."))}TMe.isMDXComponent=!0;const vMe={toc:[]};function bMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Evaluate the polynomial at the given value t."))}bMe.isMDXComponent=!0;const LMe={toc:[]};function ZMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value to sample at"))}ZMe.isMDXComponent=!0;const NMe={toc:[]};function SMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}SMe.isMDXComponent=!0;const RMe={toc:[]};function zMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value to sample at"))}zMe.isMDXComponent=!0;const PMe={toc:[]};function AMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The derivative of the polynomial to sample from"))}AMe.isMDXComponent=!0;const IMe={toc:[]};function WMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the local extrema of the polynomial."))}WMe.isMDXComponent=!0;const EMe={toc:[]};function BMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}BMe.isMDXComponent=!0;const FMe={toc:[]};function OMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the output value range within the unit interval."))}OMe.isMDXComponent=!0;const GMe={toc:[]};function jMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}jMe.isMDXComponent=!0;const UMe={toc:[]};function qMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}qMe.isMDXComponent=!0;const VMe={toc:[]};function HMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}HMe.isMDXComponent=!0;const $Me={toc:[]};function QMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$Me,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The point at which to split the polynomial."))}QMe.isMDXComponent=!0;const JMe={toc:[]};function YMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Constructs a constant polynomial"))}YMe.isMDXComponent=!0;const KMe={toc:[]};function tDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constant coefficient"))}tDe.isMDXComponent=!0;const eDe={toc:[]};function nDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Constructs a cubic polynomial"))}nDe.isMDXComponent=!0;const oDe={toc:[]};function rDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constant coefficient"))}rDe.isMDXComponent=!0;const sDe={toc:[]};function pDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The linear coefficient"))}pDe.isMDXComponent=!0;const iDe={toc:[]};function cDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The quadratic coefficient"))}cDe.isMDXComponent=!0;const aDe={toc:[]};function lDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The cubic coefficient"))}lDe.isMDXComponent=!0;const uDe={toc:[]};function mDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Constructs a linear polynomial"))}mDe.isMDXComponent=!0;const dDe={toc:[]};function hDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constant coefficient"))}hDe.isMDXComponent=!0;const fDe={toc:[]};function yDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The linear coefficient"))}yDe.isMDXComponent=!0;const kDe={toc:[]};function wDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Constructs a quadratic polynomial"))}wDe.isMDXComponent=!0;const MDe={toc:[]};function DDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constant coefficient"))}DDe.isMDXComponent=!0;const _De={toc:[]};function gDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_De,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The linear coefficient"))}gDe.isMDXComponent=!0;const XDe={toc:[]};function xDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The quadratic coefficient"))}xDe.isMDXComponent=!0;const CDe={toc:[]};function TDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},CDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}TDe.isMDXComponent=!0;const vDe={toc:[]};function bDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}bDe.isMDXComponent=!0;const LDe={toc:[]};function ZDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},LDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Evaluate the polynomial at the given t value."))}ZDe.isMDXComponent=!0;const NDe={toc:[]};function SDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},NDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The t value at which to evaluate the curve."))}SDe.isMDXComponent=!0;const RDe={toc:[]};function zDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},RDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}zDe.isMDXComponent=!0;const PDe={toc:[]};function ADe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},PDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The t value at which to evaluate the curve."))}ADe.isMDXComponent=!0;const IDe={toc:[]};function WDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},IDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,p.kt)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}WDe.isMDXComponent=!0;const EDe={toc:[]};function BDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},EDe,n,{components:e,mdxType:"MDXLayout"}))}BDe.isMDXComponent=!0;const FDe={toc:[]};function ODe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},FDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}ODe.isMDXComponent=!0;const GDe={toc:[]};function jDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},GDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The knots defining the spline"))}jDe.isMDXComponent=!0;const UDe={toc:[]};function qDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},UDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the spline should be closed or not"))}qDe.isMDXComponent=!0;const VDe={toc:[]};function HDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},VDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}HDe.isMDXComponent=!0;const $De={toc:[]};function QDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$De,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}QDe.isMDXComponent=!0;const JDe={toc:[]};function YDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},JDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the signal is currently using its initial value."))}YDe.isMDXComponent=!0;const KDe={toc:[]};function t_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},KDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}t_e.isMDXComponent=!0;const e_e={toc:[]};function n_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},e_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}n_e.isMDXComponent=!0;const o_e={toc:[]};function r_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},o_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}r_e.isMDXComponent=!0;const s_e={toc:[]};function p_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},s_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}p_e.isMDXComponent=!0;const i_e={toc:[]};function c_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},i_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}c_e.isMDXComponent=!0;const a_e={toc:[]};function l_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},a_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}l_e.isMDXComponent=!0;const u_e={toc:[]};function m_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},u_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}m_e.isMDXComponent=!0;const d_e={toc:[]};function h_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},d_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}h_e.isMDXComponent=!0;const f_e={toc:[]};function y_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},f_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,p.kt)("p",null,"By default, any property is cloneable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}y_e.isMDXComponent=!0;const k_e={toc:[]};function w_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},k_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}w_e.isMDXComponent=!0;const M_e={toc:[]};function D_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},M_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a cloneable property decorator."))}D_e.isMDXComponent=!0;const __e={toc:[]};function g_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},__e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be cloneable."))}g_e.isMDXComponent=!0;const X_e={toc:[]};function x_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},X_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}x_e.isMDXComponent=!0;const C_e={toc:[]};function T_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},C_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}T_e.isMDXComponent=!0;const v_e={toc:[]};function b_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},v_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a compound property decorator."))}b_e.isMDXComponent=!0;const L_e={toc:[]};function Z_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},L_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}Z_e.isMDXComponent=!0;const N_e={toc:[]};function S_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},N_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,p.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,p.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}S_e.isMDXComponent=!0;const R_e={toc:[]};function z_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},R_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a computed method decorator."))}z_e.isMDXComponent=!0;const P_e={toc:[]};function A_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},P_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the initial value of a property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}A_e.isMDXComponent=!0;const I_e={toc:[]};function W_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},I_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}W_e.isMDXComponent=!0;const E_e={toc:[]};function B_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},E_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an initial signal value decorator."))}B_e.isMDXComponent=!0;const F_e={toc:[]};function O_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},F_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value of the property."))}O_e.isMDXComponent=!0;const G_e={toc:[]};function j_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},G_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,p.kt)("p",null,"By default, any property is inspectable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}j_e.isMDXComponent=!0;const U_e={toc:[]};function q_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},U_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}q_e.isMDXComponent=!0;const V_e={toc:[]};function H_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},V_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an inspectable property decorator."))}H_e.isMDXComponent=!0;const $_e={toc:[]};function Q_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be inspectable."))}Q_e.isMDXComponent=!0;const J_e={toc:[]};function Y_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},J_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Y_e.isMDXComponent=!0;const K_e={toc:[]};function tge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},K_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}tge.isMDXComponent=!0;const ege={toc:[]};function nge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ege,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal interpolation function decorator."))}nge.isMDXComponent=!0;const oge={toc:[]};function rge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interpolation function for the property."))}rge.isMDXComponent=!0;const sge={toc:[]};function pge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,p.kt)("p",null,"If the wrapper class has a method called ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}pge.isMDXComponent=!0;const ige={toc:[]};function cge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},ige,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}cge.isMDXComponent=!0;const age={toc:[]};function lge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},age,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal parser decorator."))}lge.isMDXComponent=!0;const uge={toc:[]};function mge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}mge.isMDXComponent=!0;const dge={toc:[]};function hge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given property into a signal."),(0,p.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}hge.isMDXComponent=!0;const fge={toc:[]};function yge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}yge.isMDXComponent=!0;const kge={toc:[]};function wge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal decorator."))}wge.isMDXComponent=!0;const Mge={toc:[]};function Dge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Mge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,p.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,p.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,p.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Dge.isMDXComponent=!0;const _ge={toc:[]};function gge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_ge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}gge.isMDXComponent=!0;const Xge={toc:[]};function xge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Xge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal wrapper decorator."))}xge.isMDXComponent=!0;const Cge={toc:[]};function Tge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Cge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}Tge.isMDXComponent=!0;const vge={toc:[]};function bge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},vge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A unified abstraction for all CSS filters."))}bge.isMDXComponent=!0;const Lge={toc:[]};function Zge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Lge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the desired length is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}Zge.isMDXComponent=!0;const Nge={toc:[]};function Sge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Nge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}Sge.isMDXComponent=!0;const Rge={toc:[]};function zge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Rge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value can be either:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'"))))}zge.isMDXComponent=!0;const Pge={toc:[]};function Age(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Pge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a length used by most layout properties."))}Age.isMDXComponent=!0;const Ige={toc:[]};function Wge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ige,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,p.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}Wge.isMDXComponent=!0;const Ege={toc:[]};function Bge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Ege,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,p.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}Bge.isMDXComponent=!0;const Fge={toc:[]};function Oge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Fge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter in pixels."))}Oge.isMDXComponent=!0;const Gge={toc:[]};function jge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Gge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,p.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}jge.isMDXComponent=!0;const Uge={toc:[]};function qge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Uge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}qge.isMDXComponent=!0;const Vge={toc:[]};function Hge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Vge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,p.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}Hge.isMDXComponent=!0;const $ge={toc:[]};function Qge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},$ge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}Qge.isMDXComponent=!0;const Jge={toc:[]};function Yge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Jge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,p.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}Yge.isMDXComponent=!0;const Kge={toc:[]};function tXe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},Kge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}tXe.isMDXComponent=!0;const eXe={toc:[]};function nXe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},eXe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,p.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}nXe.isMDXComponent=!0;const oXe={toc:[]};function rXe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},oXe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter in degrees."))}rXe.isMDXComponent=!0;const sXe={toc:[]};function pXe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},sXe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,p.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}pXe.isMDXComponent=!0;const iXe={toc:[]};function cXe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},iXe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}cXe.isMDXComponent=!0;const aXe={toc:[]};function lXe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},aXe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,p.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}lXe.isMDXComponent=!0;const uXe={toc:[]};function mXe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},uXe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}mXe.isMDXComponent=!0;const dXe={toc:[]};function hXe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},dXe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,p.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}hXe.isMDXComponent=!0;const fXe={toc:[]};function yXe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},fXe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}yXe.isMDXComponent=!0;const kXe={toc:[]};function wXe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},kXe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}wXe.isMDXComponent=!0;const MXe={toc:[]};function DXe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},MXe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoke the given callback in the context of this scene."))}DXe.isMDXComponent=!0;const _Xe={toc:[]};function gXe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},_Xe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to invoke."))}gXe.isMDXComponent=!0;const XXe={toc:[]};function xXe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,s.Z)({},XXe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}function CXe(t){let{id:e}=t;const n=o[e]??r.Fragment;return r.createElement(n,null)}xXe.isMDXComponent=!0},79322:(t,e,n)=>{"use strict";n.d(e,{Z:()=>m});var o=n(2784),r=n(30956),s=n(28698);const p="toggle_S_IX",i="collapsed_wdUB",c="collapse_TjTN",a="inverse_g6vW",l="clearFix_HQ1T";var u=n(6277);function m(t){let{comment:e,full:n=!0}=t;const s=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@remarks"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(r.Z,{id:null==e?void 0:e.summaryId}),o.createElement(r.Z,{id:null==s?void 0:s.contentId}),n&&o.createElement(d,{comment:e}))}function d(t){let{comment:e}=t;const[n,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@preview"===e}))}),[e]),h=(0,o.useMemo)((()=>{var t;return(null==e||null==(t=e.blockTags)?void 0:t.filter((t=>{let{tag:e}=t;return"@example"===e})))??[]}),[e]),f=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@defaultValue"===e}))}),[e]),y=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@deprecated"===e}))}),[e]),k=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@see"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(r.Z,{id:null==d?void 0:d.contentId}),h.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(p,n&&i),onClick:t=>{t.preventDefault(),m(!n)},href:"#"},"Examples")),o.createElement(s.z,{lazy:!0,as:"div",collapsed:n},o.createElement("div",{className:c},h.map((t=>o.createElement(r.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,a)})),f&&o.createElement(o.Fragment,null,"Default Value:"," ",o.createElement("code",null,f.content.map((t=>t.text)).join(""))),y&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(r.Z,{id:y.contentId})),k&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(r.Z,{id:k.contentId})))}},31930:(t,e,n)=>{"use strict";n.d(e,{Z:()=>Ot});var o=n(2784),r=n(37390),s=n(66835),p=n(80068),i=n(6277),c=n(68569);const a={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=n(7896);function u(t){let{width:e=24,height:n=24,...r}=t;return o.createElement("svg",(0,l.Z)({width:e,height:n,"aria-hidden":"true",viewBox:"0 0 24 24"},r),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:e,highlight:n,onClick:r,link:l}=t;const m=(0,s.F)(),d=(0,p.s2)();return o.createElement("div",{className:(0,i.Z)(c.Z.codeBlockContent,a.codeBlock,n&&a.highlight,r&&a.pointer)},o.createElement("pre",{onClick:r,onKeyDown:t=>{"Enter"===t.key&&(null==r||r())},tabIndex:0,ref:m.codeBlockRef,className:(0,i.Z)(c.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:c.Z.codeBlockLines,style:d},e)),l&&o.createElement("div",{className:c.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=n(39318);function h(t){let{children:e}=t;return o.createElement(d.Z,{as:"div",className:(0,i.Z)(a.codeBlockContainer,"language-typescript")},e)}var f=n(89817);function y(t){let{children:e,type:n,to:r,id:s,tooltip:i}=t;const c=(0,p.Ld)(n);return r?o.createElement(f.Z,(0,l.Z)({id:s,to:r,"data-tooltip":i},c),e):o.createElement("span",(0,l.Z)({id:s},c),e)}let k,w;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(k||(k={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(w||(w={}));const M={[k.None]:a.none,[k.Angle]:a.angle,[k.Curly]:a.curly,[k.Square]:a.square,[k.Parentheses]:a.parentheses};function D(t){let{children:e,type:n,separator:r=w.Comma}=t;return o.createElement("span",{className:(0,i.Z)(a.list,M[n??k.None])},o.createElement("span",{className:(0,i.Z)(a.elements,r!==w.Comma&&a.left)},(Array.isArray(e)?e:[e]).flatMap(((t,e)=>o.createElement("span",{"data-separator":r,key:e,className:a.element},t)))))}var _=n(88617);function g(t){var e;let{type:n}=t;const r=(0,_.RU)(n.project),s=null==r?void 0:r[n.id],p=n.externalUrl??(0,_.Gr)(s);return o.createElement(o.Fragment,null,o.createElement(y,{to:p,type:p?"class-name":"constant",tooltip:!0},n.name),!(null==(e=n.typeArguments)||!e.length)&&o.createElement(D,{type:k.Angle},n.typeArguments.map(((t,e)=>o.createElement(E,{key:e,type:t})))))}function X(t){let{type:e}=t;return o.createElement(y,{type:"keyword"},e.name)}function x(t){let{type:e}=t;return e.elements?o.createElement(D,{type:k.Square},e.elements.map(((t,e)=>o.createElement(E,{key:e,type:t})))):o.createElement(o.Fragment,null,"[]")}function C(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:e.elementType}),"[]")}function T(t){let{type:e}=t;return o.createElement(D,{type:k.Parentheses,separator:w.Pipe},e.types.map(((t,e)=>o.createElement(E,{key:e,type:t}))))}function v(t){let{type:e}=t;const[n,r]=(0,o.useMemo)((()=>{if(null===e.value)return["null","keyword"];switch(typeof e.value){case"object":return[(e.value.negative?"-":"")+e.value.value,"number"];case"boolean":return[e.value,"keyword"];case"number":return[e.value,"number"];case"string":return[`'${e.value}'`,"string"];default:return[e.value,"constant"]}}),[e.value]);return o.createElement(y,{type:r},n)}function b(t){let{type:e}=t;return e.asserts?o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"asserts "),o.createElement(y,null,e.name," ")):o.createElement(o.Fragment,null,o.createElement(y,null,e.name," "),o.createElement(y,{type:"keyword"},"is "),o.createElement(E,{type:e.targetType}))}function L(t){let{type:e}=t;const n=(0,_.in)();return o.createElement(Q,{reflection:n(e.declaration)})}function Z(t){let{type:e}=t;return o.createElement(D,{type:k.Parentheses,separator:w.Ampersand},e.types.map(((t,e)=>o.createElement(E,{key:e,type:t}))))}function N(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"string"},"`",e.head),e.tail.map(((t,e)=>{let[n,r]=t;return o.createElement(o.Fragment,null,"${",o.createElement(E,{key:e,type:n}),"}",o.createElement(y,{type:"string"},r))})),o.createElement(y,{type:"string"},"`"))}function S(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"typeof "),o.createElement(E,{type:e.queryType}))}function R(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:e.checkType}),o.createElement(y,{type:"keyword"}," extends "),o.createElement(E,{type:e.extendsType})," ? ",o.createElement(E,{type:e.trueType})," : ",o.createElement(E,{type:e.falseType}))}function z(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"infer "),o.createElement(y,{type:"constant"},e.name))}function P(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:e.objectType}),"[",o.createElement(E,{type:e.indexType}),"]")}function A(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},e.operator," "),o.createElement(E,{type:e.target}))}function I(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(D,{type:k.Curly},o.createElement(o.Fragment,null,"[",o.createElement(y,{type:"class"},e.parameter),o.createElement(y,{type:"keyword"}," in "),o.createElement(E,{type:e.parameterType}),"]: ",o.createElement(E,{type:e.templateType}))))}function W(t){let{type:e}=t;return o.createElement(o.Fragment,null,e.name,": ",o.createElement(E,{type:e.element}))}function E(t){const e=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return A;case"conditional":return R;case"reflection":return L;case"query":return S;case"named-tuple-member":return W;case"union":return T;case"intrinsic":return X;case"literal":return v;case"reference":return g;case"predicate":return b;case"tuple":return x;case"array":return C;case"intersection":return Z;case"inferred":return z;case"mapped":return I;case"template-literal":return N;case"indexedAccess":return P}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(e,t)}function B(t){let{flags:e,explicitAccessModifier:n}=t;const r=[];return null!=e&&e.isAbstract&&r.push("abstract"),null!=e&&e.isStatic&&r.push("static"),null!=e&&e.isConst&&r.push("const"),null!=e&&e.isReadonly&&r.push("readonly"),null!=e&&e.isPrivate&&r.push("private"),null!=e&&e.isProtected&&r.push("protected"),(null==e||!e.isPublic)&&(!n||null!=e&&e.isProtected||null!=e&&e.isPrivate)||r.push("public"),o.createElement(o.Fragment,null,r.map((t=>o.createElement(y,{key:t,type:"keyword"},t," "))))}function F(t){let{reflection:e}=t;const n="__namedParameters"===e.name?"{...}":e.name;return o.createElement(o.Fragment,null,o.createElement(B,{flags:e.flags}),e.flags.isRest&&"...",o.createElement(y,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"plain"},n),e.flags.isOptional&&"?",": ",e.type&&o.createElement(E,{type:e.type}),e.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(y,{type:"plain"},e.defaultValue)))}function O(t){let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(B,{flags:e.flags}),e.varianceModifier&&o.createElement(y,{type:"keyword"},e.varianceModifier," "),o.createElement(y,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"class-name"},e.name),e.type&&o.createElement(o.Fragment,null," extends ",o.createElement(E,{type:e.type})),e.default&&o.createElement(o.Fragment,null," = ",o.createElement(E,{type:e.default})))}function G(t){var e,n;let{reflection:s,flags:p}=t;const i=(0,_.in)(),c="__type"===s.name;return o.createElement(o.Fragment,null,o.createElement(B,{flags:p??s.flags,explicitAccessModifier:!c}),s.kind===r.W.GetSignature&&o.createElement(y,{type:"keyword"},"get "),s.kind===r.W.SetSignature&&o.createElement(y,{type:"keyword"},"set "),s.overwrites&&o.createElement(o.Fragment,null,o.createElement(y,{to:s.overwrites.externalUrl??(0,_.Gr)(i(s.overwrites.id)),type:"keyword"},"override")," "),s.kind===r.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(y,{to:"#",type:"keyword"},"new")," ",o.createElement(y,{type:"plain"},s.type.name)):c?"":o.createElement(y,{type:"function"},s.name),!(null==(e=s.typeParameter)||!e.length)&&o.createElement(D,{type:k.Angle},s.typeParameter.map((t=>o.createElement(O,{key:t.id,reflection:i(t)})))),null!=(n=s.parameters)&&n.length?o.createElement(D,{type:k.Parentheses},s.parameters.map((t=>o.createElement(F,{key:t,reflection:i(t)})))):"()",s.type&&o.createElement(o.Fragment,null,c?" => ":": ",o.createElement(E,{type:s.type})))}function j(t){let{reflection:e}=t;return o.createElement(F,{reflection:e})}const U={[r.W.Namespace]:"namespace",[r.W.Enum]:"enum",[r.W.Class]:"class",[r.W.Interface]:"interface"};function q(t){var e,n,r;let{reflection:s}=t;const p=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(B,{flags:s.flags}),o.createElement(y,{type:"keyword"},U[s.kind]," "),o.createElement(y,{type:"class-name"},s.name),!(null==(e=s.typeParameters)||!e.length)&&o.createElement(D,{type:k.Angle},s.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:p(t)}))))," ",!(null==(n=s.extendedTypes)||!n.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"extends "),o.createElement(D,null,s.extendedTypes.map(((t,e)=>o.createElement(E,{key:e,type:t}))))),!(null==(r=s.implementedTypes)||!r.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"implements "),o.createElement(D,null,s.implementedTypes.map(((t,e)=>o.createElement(E,{key:e,type:t}))))))}function V(t){let{reflection:e}=t;const n=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(B,{flags:e.flags}),o.createElement(y,{type:"keyword"},"type "),o.createElement(y,{type:"class-name"},e.name),e.typeParameters&&o.createElement(D,{type:k.Angle},e.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:n(t)}))))," = ",o.createElement(E,{type:e.type}))}function H(t){let{reflection:e}=t;const n=(0,_.in)();return e.signatures?o.createElement(G,{reflection:e.signatures[0]}):e.children?o.createElement(D,{type:k.Curly},e.children.map((t=>o.createElement(Q,{key:t.id,reflection:n(t)})))):o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"unknown"))}function $(t){var e;let{reflection:n}=t;const r=(null==(e=n.signatures)?void 0:e[0])??n.getSignature??n.setSignature??n.indexSignature;return o.createElement(G,{reflection:r})}function Q(t){let{reflection:e}=t;const n=(0,o.useMemo)((()=>{switch(e.kind){case r.W.Project:case r.W.Module:case r.W.EnumMember:case r.W.Variable:case r.W.Function:break;case r.W.Namespace:case r.W.Enum:case r.W.Class:case r.W.Interface:return q;case r.W.Constructor:return G;case r.W.Property:return j;case r.W.Method:return $;case r.W.CallSignature:case r.W.IndexSignature:case r.W.ConstructorSignature:case r.W.Parameter:break;case r.W.TypeLiteral:return H;case r.W.TypeParameter:return O;case r.W.Accessor:case r.W.GetSignature:case r.W.SetSignature:case r.W.ObjectLiteral:break;case r.W.TypeAlias:return V;case r.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.id]);return o.createElement(n,{reflection:e})}function J(t){let{children:e}=t;const n=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!n.current)return;const t=n.current.closest("pre");if(t.scrollWidth>t.clientWidth){const e=Array.from(n.current.querySelectorAll(`.${a.elements}`)).sort(((t,e)=>function(t,e){return t>e?1:t<e?-1:0}(e.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&e.length>0;)e.shift().classList.add(a.wrap)}})),o.createElement(o.Fragment,null,e&&o.createElement("span",{ref:n,className:(0,i.Z)(a.line,"token-line")},e),o.createElement("br",null))}var Y=n(79322),K=n(30956);function tt(t){let{parameters:e}=t;const n=(0,_.in)(),r=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=r&&r.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,r.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(O,{reflection:t})),o.createElement(K.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{parameters:e}=t;const n=(0,_.in)(),r=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=r&&r.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,r.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(F,{reflection:t})),o.createElement(K.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{signatures:e,flags:n,source:r}=t;const s=(0,_.in)(),p=(0,o.useMemo)((()=>e.map(s)),[e]),[i,c]=(0,o.useState)(p[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,p.map((t=>o.createElement(m,{link:null==r?void 0:r.url,key:t.id,highlight:e.length>1&&t.id===i.id,onClick:e.length>1?()=>c(t):void 0},o.createElement(J,null,o.createElement(G,{reflection:t,flags:n})))))),o.createElement(Y.Z,{comment:i.comment}),o.createElement(tt,{parameters:i.typeParameter}),o.createElement(et,{parameters:i.parameters}))}var ot=n(57708);function rt(t){let{width:e=24,height:n=24,...r}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},r),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const st="header_nSmr",pt="filters_z1iC",it="icon_ROIU";function ct(){const t=(0,o.useRef)(null),[e,n]=(0,o.useState)(!1),[r,s]=(0,ot.mN)();return(0,o.useEffect)((()=>{const e=e=>{t.current&&!t.current.contains(e.target)&&n(!1)};return document.addEventListener("mousedown",e),document.addEventListener("touchstart",e),()=>{document.removeEventListener("mousedown",e),document.removeEventListener("touchstart",e)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,i.Z)("dropdown dropdown--right margin-bottom--md",e&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),n(!e)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),n(!e))}},"Filters",o.createElement(rt,{className:it})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,i.Z)("dropdown__link",r.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:r.private,onChange:t=>{s({...r,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&n(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,i.Z)("dropdown__link",r.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:r.inherited,onChange:t=>{s({...r,inherited:t.target.checked})}}),"Inherited members")))))}function at(t){let{children:e,kind:n}=t;return n===r.W.Class||n===r.W.Interface?o.createElement("div",{className:(0,i.Z)("row",st)},o.createElement("div",{className:(0,i.Z)("col",pt)},o.createElement(ct,null)),o.createElement("div",{className:"col"},e)):o.createElement(o.Fragment,null,e)}var lt=n(53181),ut=n(83851),mt=n(24126),dt=n(32424),ht=n(42244),ft=n(24155);function yt(t){return function(t){var e;return(null==(e=o.Children.map(t,(t=>{if(!t||(0,o.isValidElement)(t)&&function(t){const{props:e}=t;return!!e&&"object"==typeof e&&"value"in e}(t))return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:e.filter(Boolean))??[]}(t).map((t=>{let{props:{value:e,label:n,attributes:o,default:r}}=t;return{value:e,label:n,attributes:o,default:r}}))}function kt(t){const{values:e,children:n}=t;return(0,o.useMemo)((()=>{const t=e??yt(n);return function(t){const e=(0,ht.l)(t,((t,e)=>t.value===e.value));if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[e,n])}function wt(t){let{value:e,tabValues:n}=t;return n.some((t=>t.value===e))}function Mt(t){let{queryString:e=!1,groupId:n}=t;const r=(0,lt.k6)(),s=function(t){let{queryString:e=!1,groupId:n}=t;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,dt._X)(s),(0,o.useCallback)((t=>{if(!s)return;const e=new URLSearchParams(r.location.search);e.set(s,t),r.replace({...r.location,search:e.toString()})}),[s,r])]}function Dt(t){const{defaultValue:e,queryString:n=!1,groupId:r}=t,s=kt(t),[p,i]=(0,o.useState)((()=>function(t){let{defaultValue:e,tabValues:n}=t;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!wt({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const o=n.find((t=>t.default))??n[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:e,tabValues:s}))),[c,a]=Mt({queryString:n,groupId:r}),[l,u]=function(t){let{groupId:e}=t;const n=function(t){return t?`docusaurus.tab.${t}`:null}(e),[r,s]=(0,ft.Nk)(n);return[r,(0,o.useCallback)((t=>{n&&s.set(t)}),[n,s])]}({groupId:r}),m=(()=>{const t=c??l;return wt({value:t,tabValues:s})?t:null})();(0,o.useLayoutEffect)((()=>{m&&i(m)}),[m]);return{selectedValue:p,selectValue:(0,o.useCallback)((t=>{if(!wt({value:t,tabValues:s}))throw new Error(`Can't select invalid tab value=${t}`);i(t),a(t),u(t)}),[a,u,s]),tabValues:s}}var _t=n(89741);const gt="tabList_M0Dn",Xt="tabItem_ysIP";function xt(t){let{className:e,block:n,selectedValue:r,selectValue:s,tabValues:p}=t;const c=[],{blockElementScrollPositionUntilNextRender:a}=(0,mt.o5)(),u=t=>{const e=t.currentTarget,n=c.indexOf(e),o=p[n].value;o!==r&&(a(e),s(o))},m=t=>{var e;let n=null;switch(t.key){case"Enter":u(t);break;case"ArrowRight":{const e=c.indexOf(t.currentTarget)+1;n=c[e]??c[0];break}case"ArrowLeft":{const e=c.indexOf(t.currentTarget)-1;n=c[e]??c[c.length-1];break}}null==(e=n)||e.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},e)},p.map((t=>{let{value:e,label:n,attributes:s}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:r===e?0:-1,"aria-selected":r===e,key:e,ref:t=>c.push(t),onKeyDown:m,onClick:u},s,{className:(0,i.Z)("tabs__item",Xt,null==s?void 0:s.className,{"tabs__item--active":r===e})}),n??e)})))}function Ct(t){let{lazy:e,children:n,selectedValue:r}=t;const s=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const t=s.find((t=>t.props.value===r));return t?(0,o.cloneElement)(t,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},s.map(((t,e)=>(0,o.cloneElement)(t,{key:e,hidden:t.props.value!==r}))))}function Tt(t){const e=Dt(t);return o.createElement("div",{className:(0,i.Z)("tabs-container",gt)},o.createElement(xt,(0,l.Z)({},t,e)),o.createElement(Ct,(0,l.Z)({},t,e)))}function vt(t){const e=(0,_t.Z)();return o.createElement(Tt,(0,l.Z)({key:String(e)},t))}const bt="tabItem_OMyP";function Lt(t){let{children:e,hidden:n,className:r}=t;return o.createElement("div",{role:"tabpanel",className:(0,i.Z)(bt,r),hidden:n},e)}function Zt(t){let{group:e}=t;return"Constructors"===e.title&&0===e.external.length&&1===e.nested.length?o.createElement(Ot,{reflection:e.nested[0]}):o.createElement(o.Fragment,null,e.external.length>0&&o.createElement("ul",null,e.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(g,{type:t})))))),e.nested.length>0&&e.nested.map(((t,e)=>o.createElement(o.Fragment,{key:t.id},e>0&&o.createElement("hr",null),o.createElement(Ot,{reflection:t})))))}function Nt(t){let{group:e,project:n}=t;const r=(0,lt.TH)(),s=(0,_.RU)(n),p=r.hash.split("-")[0].slice(1),[i]=(0,ot.mN)(),c=(0,o.useMemo)((()=>(e.categories??[e]).map((t=>function(t,e,n){const o=[],r=[],s=[];for(const p of t.children){const t=e[p];t&&(0,ot.It)(n,t)&&(s.push(t.anchor),t.hasOwnPage?o.push(t):r.push(t))}if(o.length>0||r.length>0)return{title:t.title,external:o,nested:r,anchors:s}}(t,s,i))).filter((t=>!!t))),[e,s,i]);return(0,o.useEffect)((()=>{if(1===c.length)return;const t=r.hash.split("-")[0].slice(1);for(const e of c)if(e.anchors.includes(t))return}),[r.hash,c]),0===c.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h2",id:e.title},e.title),c.length>1?o.createElement(vt,{groupId:e.title},c.map((t=>o.createElement(Lt,{default:t.anchors.includes(p),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(Zt,{group:t}))))):o.createElement(Zt,{group:c[0]}))}function St(t){var e,n,r,s,p;let{reflection:i}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(e=i.sources)||null==(n=e[0])?void 0:n.url},o.createElement(J,null,o.createElement(Q,{reflection:i})))),o.createElement(at,{kind:i.kind},o.createElement(Y.Z,{comment:i.comment})),o.createElement(tt,{parameters:i.typeParameters}),(null==(r=i.implementedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,i.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(g,{type:t}))))))),(null==(s=i.extendedBy)?void 0:s.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,i.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(g,{type:t}))))))),i.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:i.signatures})),null==(p=i.groups)?void 0:p.map((t=>o.createElement(Nt,{group:t,key:t.title,project:i.project}))))}function Rt(t){var e;let{reflection:n,headless:r}=t;const s=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!r&&(n.hasOwnPage?o.createElement("h1",null,n.name):o.createElement(ut.Z,{as:"h3",id:n.anchor},o.createElement("code",null,n.name))),o.createElement(nt,{signatures:s,flags:n.flags,source:null==(e=n.sources)?void 0:e[0]}),n.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(g,{type:n.inheritedFrom}))),n.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(g,{type:n.overwrites}))))}function zt(t){var e,n;let{reflection:r,headless:s}=t;return o.createElement(o.Fragment,null,!s&&(r.hasOwnPage?o.createElement("h1",null,r.name):o.createElement(ut.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name))),o.createElement(h,null,o.createElement(m,{link:null==(e=r.sources)||null==(n=e[0])?void 0:n.url},o.createElement(J,null,o.createElement(j,{reflection:r})))),o.createElement(Y.Z,{comment:r.comment}),r.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(g,{type:r.inheritedFrom}))))}function Pt(t){var e,n,r;let{reflection:s}=t;const p=(0,_.RU)(s.project);return o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h3",id:s.anchor},o.createElement("code",null,s.name)),o.createElement(h,null,o.createElement(m,{link:null==(e=s.sources)||null==(n=e[0])?void 0:n.url},o.createElement(J,null,o.createElement(Q,{reflection:s})))),o.createElement(Y.Z,{comment:s.comment}),o.createElement(tt,{parameters:s.typeParameters}),s.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:s.signatures})),null==(r=s.groups)?void 0:r.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>p[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Ot,{key:t.id,reflection:t})))))))}var At=n(78128);function It(t){var e;let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(At.Z,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),o.createElement(at,{kind:n.kind},o.createElement(Y.Z,{comment:n.comment})),null==(e=n.groups)?void 0:e.map((t=>o.createElement(Nt,{group:t,key:t.title,project:n.project}))))}const Wt="cardContainer_ybwo",Et="cardTitle_Ehd1",Bt="cardDescription_b6wr";function Ft(t){let{reflection:e}=t;const n=(0,_.RU)(e.project),r=e.groups[0].children.map((t=>n[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,i.Z)("row")},r.map((t=>{var e;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(f.Z,{href:t.href,className:(0,i.Z)("card padding--lg",Wt)},o.createElement("h2",{className:(0,i.Z)("text--truncate",Et)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,i.Z)("text--truncate",Bt)},(null==(e=t.comment)?void 0:e.summaryText)??"\xa0")))}))))}function Ot(t){let{reflection:e,headless:n=!1}=t;const s=(0,o.useMemo)((()=>{switch(e.kind){case r.W.Project:return Ft;case r.W.Module:return It;case r.W.Namespace:case r.W.Enum:case r.W.Class:case r.W.Interface:return St;case r.W.Function:case r.W.Accessor:case r.W.Constructor:case r.W.Method:return Rt;case r.W.Variable:case r.W.Property:case r.W.EnumMember:return zt;case r.W.CallSignature:case r.W.IndexSignature:case r.W.ConstructorSignature:case r.W.Parameter:case r.W.TypeLiteral:case r.W.TypeParameter:case r.W.GetSignature:case r.W.SetSignature:case r.W.ObjectLiteral:break;case r.W.TypeAlias:return Pt;case r.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.kind]);return o.createElement(s,{reflection:e,headless:n})}},37390:(t,e,n)=>{"use strict";let o;n.d(e,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},26773:(t,e,n)=>{"use strict";n.d(e,{Z:()=>Ct});var o=n(2784),r=n(18888),s=n(35565),p=n(1727),i=n(99387),c=n(77120),a=n(53947),l=n(86253);const u=c.Qf.define([{tag:l.pJ.comment,color:"var(--hl-comment)"},{tag:l.pJ.docComment,color:"var(--hl-comment)"},{tag:l.pJ.blockComment,color:"var(--hl-comment)"},{tag:l.pJ.keyword,color:"var(--hl-keyword)"},{tag:l.pJ.number,color:"var(--hl-number)"},{tag:l.pJ.inserted,color:"var(--hl-number)"},{tag:l.pJ.constant(l.pJ.propertyName),color:"var(--hl-constant)"},{tag:l.pJ.attributeName,color:"var(--hl-variable)"},{tag:l.pJ.variableName,color:"var(--hl-variable)"},{tag:l.pJ.propertyName,color:"var(--hl-variable)"},{tag:l.pJ.deleted,color:"var(--hl-string)"},{tag:l.pJ.string,color:"var(--hl-string)"},{tag:l.pJ.attributeValue,color:"var(--hl-string)"},{tag:l.pJ.tagName,color:"var(--hl-tag)"},{tag:l.pJ.typeName,color:"var(--hl-tag)"},{tag:l.pJ.punctuation,color:"var(--hl-punctuation)"},{tag:l.pJ.operator,color:"var(--hl-punctuation)"},{tag:l.pJ.function(l.pJ.variableName),color:"var(--hl-function)"},{tag:l.pJ.function(l.pJ.propertyName),color:"var(--hl-function)"},{tag:l.pJ.className,color:"var(--hl-class)"},{tag:l.pJ.character,color:"var(--hl-char)"}]),m=s.tk.theme({"&":{fontSize:"var(--ifm-code-font-size)",lineHeight:"21.04px",fontFamily:"var(--ifm-font-family-monospace)",color:"var(--hl-color)",backgroundColor:"var(--hl-background)"},"&.cm-focused .cm-cursor":{borderLeftColor:"var(--hl-color)"},"&.cm-focused":{outline:"none"},".cm-gutters":{backgroundColor:"var(--hl-background)",color:"var(--ifm-color-secondary-darkest)",borderRight:"1px solid var(--ifm-background-color)"},"& .cm-lineNumbers .cm-gutterElement":{paddingLeft:"var(--ifm-pre-padding)"},".cm-activeLineGutter":{backgroundColor:"var(--ifm-code-active-color)"},".cm-scroller":{fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",paddingTop:"var(--ifm-pre-padding)",paddingBottom:"var(--ifm-pre-padding)"},".cm-content":{padding:"0"},"& .cm-line":{paddingRight:"var(--ifm-pre-padding)"},"& .cm-selectionBackground, &.cm-focused .cm-selectionBackground, ::selection":{backgroundColor:"var(--ifm-code-selection-color)"},".cm-activeLine":{backgroundColor:"var(--ifm-code-active-color)"},".cm-selectionMatch":{backgroundColor:"var(--ifm-code-selection-color)"},".cm-foldPlaceholder":{backgroundColor:"var(--ifm-code-selection-color)",borderColor:"var(--ifm-color-emphasis-300)"},".cm-tooltip":{backgroundColor:"var(--ifm-background-surface-color)"}});var d=n(78128);function h(t){const[e,n]=(0,o.useState)(null==t?void 0:t.current);return(0,o.useEffect)((()=>t&&t.subscribe(n)),[t]),e}function f(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M6 6h2v12H6zm3.5 6l8.5 6V6z"}))}function y(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"}))}function k(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M8 5v14l11-7z"}))}function w(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M6 19h4V5H6v14zm8-14v14h4V5h-4z"}))}var M=n(48015),D=n(10700),_=n(69573),g=n(74391);const X=Object.entries(g.Z).map((t=>{let[e,n]=t;return{label:e,type:"function"==typeof n?(o=n,o.prototype&&o.prototype.constructor.name?"class":"function"):"variable"};var o}));var x,C=n(96881);!function(t){t.Error="error",t.Warn="warn",t.Info="info",t.Http="http",t.Verbose="verbose",t.Debug="debug",t.Silly="silly"}(x||(x={}));class T{constructor(){this.logged=new C.p,this.history=[],this.profilers={}}get onLogged(){return this.logged.subscribable}log(t){this.logged.dispatch(t),this.history.push(t)}error(t){this.logLevel(x.Error,t)}warn(t){this.logLevel(x.Warn,t)}info(t){this.logLevel(x.Info,t)}http(t){this.logLevel(x.Http,t)}verbose(t){this.logLevel(x.Verbose,t)}debug(t){this.logLevel(x.Debug,t)}silly(t){this.logLevel(x.Silly,t)}logLevel(t,e){const n="string"==typeof e?{message:e}:e;n.level=t,this.log(n)}profile(t,e){const n=performance.now();if(this.profilers[t]){const o=this.profilers[t];delete this.profilers[t];const r=e??{message:t};return r.level??(r.level=x.Debug),r.durationMs=n-o,void this.log(r)}this.profilers[t]=n}}var v=n(82344),b=n(92673),L=n(30204);class Z extends v.C{constructor(){super(...arguments),this.type=L.I.symbol}parse(t){return null===t?null:new L.I(t)}serialize(){var t;return(null==(t=this.value.current)?void 0:t.serialize())??null}}var N=n(57292),S=n(13170);class R extends v.C{constructor(){super(...arguments),this.type=R.symbol}parse(t){return this.parseRange(1/0,t[0],t[1]??1/0)}update(t,e,n,o){this.value.current=this.parseRange(n/o-N.I,t/o-N.I,e/o-N.I)}parseRange(t,e,n){return void 0===e&&(e=this.value.current[0]),void 0===n&&(n=this.value.current[1]),(e=(0,S.uZ)(0,t,e))>(n=(0,S.uZ)(0,t,n??1/0))&&([e,n]=[n,e]),n>=t&&(n=1/0),[e,n]}}R.symbol=Symbol.for("@motion-canvas/core/meta/RangeMetaField");var z=n(29797);class P extends v.C{constructor(){super(...arguments),this.type=z.F.symbol}parse(t){return new z.F(t)}serialize(){return this.value.current.serialize()}}class A extends v.C{constructor(){super(...arguments),this.type=Number,this.presets=[]}parse(t){let e=parseFloat(t);return void 0!==this.min&&e<this.min&&(e=this.min),void 0!==this.max&&e>this.max&&(e=this.max),e}getPresets(){return this.presets}setPresets(t){return this.presets=t,this}setRange(t,e){return this.min=t,this.max=e,this}}class I extends v.C{constructor(t,e,n){void 0===n&&(n=e[0].value),super(t,n),this.options=e,this.type=I.symbol}set(t){super.set(this.getOption(t).value)}parse(t){return this.getOption(t).value}getOption(t){return this.options.find((e=>e.value===t))??this.options[0]}}I.symbol=Symbol.for("@motion-canvas/core/meta/EnumMetaField");var W=n(1323);class E extends v.C{get onFieldsChanged(){return this.fields.subscribable}get options(){return this.optionFields[this.current]}get exporter(){return this.exporters[this.current]}constructor(t,e,n){void 0===n&&(n=0);const o=e.map((t=>t.meta())),r=new I("exporter",e.map((t=>({value:t.name,text:t.name}))),e[n].name);super(t,{name:r.get(),options:o[n].get()}),this.exporters=e,this.current=n,this.type=Object,this.handleChange=()=>{const t=this.exporterField.get(),e=Math.max(this.exporters.findIndex((e=>e.name===t)),0);this.current!==e&&(this.options.onChanged.unsubscribe(this.handleChange),this.current=e,this.options.onChanged.subscribe(this.handleChange,!1),this.fields.current=[this.exporterField,this.options]),this.value.current={name:this.exporterField.get(),options:this.options.get()}},this.exporterField=r,this.exporterField.onChanged.subscribe(this.handleChange,!1),this.exporterField.disable(o.length<2).space(),this.optionFields=o,this.optionFields[n].onChanged.subscribe(this.handleChange,!1),this.fields=new W.G([this.exporterField,this.options])}set(t){this.exporterField.set(t.name),this.options.set(t.options)}serialize(){return{name:this.exporterField.serialize(),options:this.options.serialize()}}clone(){return new this.constructor(this.name,this.exporters,this.current)}}const B=[{value:.25,text:"0.25x (Quarter)"},{value:.5,text:"0.5x (Half)"},{value:1,text:"1.0x (Full)"},{value:2,text:"2.0x (Double)"}],F=[{value:"srgb",text:"sRGB"},{value:"display-p3",text:"DCI-P3"}],O=[{value:"image/png",text:"png"},{value:"image/jpeg",text:"jpeg"},{value:"image/webp",text:"webp"}],G=[{value:30,text:"30 FPS"},{value:60,text:"60 FPS"}];class j extends b.v{constructor(t){super("project",function(t){const e={version:new v.C("version",1),shared:new b.v("General",{background:new Z("background",null),range:new R("range",[0,1/0]),size:new P("resolution",new z.F(1920,1080)),audioOffset:new A("audio offset",0)}),preview:new b.v("Preview",{fps:new A("frame rate",30).setPresets(G),resolutionScale:new I("scale",B,1)}),rendering:new b.v("Rendering",{fps:new A("frame rate",60).setPresets(G),resolutionScale:new I("scale",B,1),colorSpace:new I("color space",F),exporter:new E("exporter",t.plugins.flatMap((e=>(null==e.exporters?void 0:e.exporters(t))??[])))})};return e.shared.audioOffset.disable(!t.audio),e}(t))}getFullPreviewSettings(){return{...this.shared.get(),...this.preview.get()}}getFullRenderingSettings(){return{...this.shared.get(),...this.rendering.get()}}}var U=n(2672),q=n(9989),V=n(15914);class H extends v.C{constructor(){super(...arguments),this.type=Boolean}parse(t){return!!t}}class ${constructor(t){this.logger=t,this.name="image sequence",this.frameLookup=new Map,this.frameCounter=0,this.projectName="unknown",this.quality=1,this.fileType="image/png",this.groupByScene=!1}meta(){const t=new b.v(this.name,{fileType:new I("file type",O),quality:new A("quality",100).setRange(0,100),groupByScene:new H("group by scene",!1)});return t.fileType.onChanged.subscribe((e=>{t.quality.disable("image/png"===e)})),t}async configure(t){const e=t.exporter.options;this.projectName=t.name,this.quality=(0,S.uZ)(0,1,e.quality/100),this.fileType=e.fileType,this.groupByScene=e.groupByScene}async start(){this.frameLookup.clear()}async handleFrame(t,e,n,o,r){this.frameLookup.has(e)&&this.logger.warn(`Frame no. ${e} is already being exported.`)}async stop(){for(;this.frameCounter>0;)await new Promise((t=>setTimeout(t,1e3)))}}const Q={name:"mc-default-plugin",exporters:t=>[new $(t.logger)]};let J=null,Y=null,K=null,tt=null,et=null,nt=null,ot=1;function rt(t,e,n){var o;if(t!==et)return J||(window.mc={...g.Z,makeScene2D:t=>(Y.config=t,Y.onReplaced.current=Y,Y)},Y=(0,V.r)((function*(){yield})),Y.onReplaced=new W.G(Y),J={name:"fiddle",logger:new T,plugins:[Q],scenes:[Y]},J.meta=new j(J),J.meta.shared.size.set(960),K=new U.J(J,{size:J.meta.shared.size.get()}),tt=new q.H,tt.configure({size:J.meta.shared.size.get()}),K.onRender.subscribe((async()=>{await tt.render(K.playback.currentScene,K.playback.previousScene)})),K.onRecalculated.subscribe((()=>{var t;tt.finalBuffer.parentElement!==nt&&(null==(t=nt)||t.append(tt.finalBuffer),et(K))}))),null==(o=nt)||o.removeChild(tt.finalBuffer),null==et||et(null),et=t,nt=e,ot!==n&&(J.meta.shared.size.set([960,Math.floor(960/n)]),Y.onReplaced.current={...Y.onReplaced.current,size:J.meta.shared.size.get()},tt.configure({size:J.meta.shared.size.get()}),ot=n),K.activate(),K.requestReset(),K}const st="root_icgl",pt="layoutControl_X__N",it="icon_brRG",ct="active_qxTr",at="progress_HsLC",lt="controls_R4ai",ut="previewOnly_FFUw",mt="section_UscS",dt="error_N64d",ht="editor_xQGp",ft="source_Dq6N",yt="preview_C9cZ",kt="button_ESGX",wt="picker_Whdf",Mt="codeOnly_lee0";var Dt=n(53487);const _t=/ *\/\/ ?(\S+) ?(.*)/,gt=["highlight-next-line","highlight-start","highlight-end"];var Xt=n(6277);function xt(t){var e;let{options:n,value:r,className:s,onChange:p}=t;const i=(0,o.useRef)(),c=(0,o.useRef)(),[a,l]=(0,o.useState)(!1);return(0,o.useEffect)((()=>{const t=t=>{i.current&&!i.current.contains(t.target)&&l(!1)};return document.addEventListener("mousedown",t),document.addEventListener("touchstart",t),()=>{document.removeEventListener("mousedown",t),document.removeEventListener("touchstart",t)}}),[i]),o.createElement("div",{ref:i,className:(0,Xt.Z)("dropdown dropdown--right",a&&"dropdown--show",s)},o.createElement("a",{ref:c,className:"navbar__link",href:"#",onClick:t=>{t.preventDefault(),l(!a)}},(null==(e=n.find((t=>t.value===r)))?void 0:e.name)??r),o.createElement("ul",{className:"dropdown__menu"},n.map(((t,e)=>o.createElement("li",{key:t.value},o.createElement("a",{href:"#",className:(0,Xt.Z)("dropdown__link",r===t.value&&"dropdown__link--active"),onClick:e=>{e.preventDefault(),p(t.value),l(!1),c.current.focus()},onKeyDown:t=>{e!==n.length-1||"Tab"!==t.key||t.shiftKey||(t.preventDefault(),l(!1),c.current.focus())}},t.name))))))}function Ct(t){let{children:e,className:n,mode:l="editor",ratio:g="4"}=t;const[x,C]=(0,o.useState)(null),T=(0,o.useRef)(null),v=(0,o.useRef)(),b=(0,o.useRef)(),[L,Z]=(0,o.useState)(l),[N,S]=(0,o.useState)(null),R=h(null==x?void 0:x.onDurationChanged),z=h(null==x?void 0:x.onFrameChanged),P=h(null==x?void 0:x.onStateChanged),[A,I]=(0,o.useState)(null),[W,E]=(0,o.useState)(null),B=(0,o.useMemo)((()=>{if(g.includes("/")){const t=g.split("/"),e=parseFloat(t[0])/parseFloat(t[1]);if(!isNaN(e))return e}const t=parseFloat(g);return isNaN(t)?4:t}),[g]),F=function(t,e){void 0===e&&(e=!0),rt(C,b.current,B);const n=(0,Dt.v)(t.sliceString(0));var o;S(n),n||(E(t),!e||null!=W&&W.eq(t)||b.current.animate((void 0===o&&(o=4),[{boxShadow:"0 0 0px 0 #ccc inset",easing:"cubic-bezier(0.33, 1, 0.68, 1)"},{boxShadow:`0 0 0px ${o}px #ccc inset`,easing:"cubic-bezier(0.32, 0, 0.67, 0)"},{boxShadow:"0 0 0px 0 #ccc inset"}]),{duration:300}))},[O,G]=(0,o.useState)(0),j=(0,o.useMemo)((()=>function(t){let e={name:"Default",lines:[]};const n=[e];for(const o of t.split("\n")){const t=_t.exec(o);if(!t){e.lines.push(o);continue}const[,r,s]=t;gt.includes(r)||("snippet"===r?e.lines.length>0?(e={name:s,lines:[]},n.push(e)):e.name=s:e.lines.push(o))}return n}(e).map((t=>({name:t.name,state:p.yy.create({doc:p.xv.of(t.lines),extensions:[r.Xy,s.$f.of([a.oc,{key:"Mod-s",preventDefault:!0,run:t=>(F(t.state.doc),!0)}]),s.tk.updateListener.of((t=>{I(t.state.doc),S(null)})),i.Lz.data.of({autocomplete:t=>{if("String"===(0,c.qz)(t.state).resolveInner(t.pos,-1).name)return;const e=t.matchBefore(/\w*/);return e.from!=e.to||t.explicit?{from:e.from,options:X}:null}}),(0,i.eJ)({jsx:!0,typescript:!0}),(0,c.nF)(u),m]})})))),[e]);(0,o.useEffect)((()=>{T.current=new s.tk({parent:v.current,state:j[O].state});const t=function(t,e,n){return et?null:rt(t,e,n)}(C,b.current,B);return t&&(F(j[O].state.doc,!1),"code"!==L&&t.togglePlayback(!0)),()=>{et===C&&J&&(K.deactivate(),et=null,nt=null,tt.finalBuffer.remove()),T.current.destroy()}}),[]);const U=W&&A&&!A.eq(W),q=A&&!A.eq(j[O].state.doc)||U;return o.createElement("div",{className:(0,Xt.Z)(st,n,{[Mt]:"code"===L,[ut]:"preview"===L})},o.createElement("div",{className:pt},o.createElement("button",{className:(0,Xt.Z)(it,"code"===L&&ct),onClick:()=>{Z("code"),null==x||x.togglePlayback(!1)},title:"Source code"},o.createElement(M.Z,null)),o.createElement("button",{className:(0,Xt.Z)(it,"editor"===L&&ct),onClick:()=>Z("editor"),title:"Editor with preview"},o.createElement(D.Z,null)),o.createElement("button",{className:(0,Xt.Z)(it,"preview"===L&&ct),onClick:()=>Z("preview"),title:"Preview"},o.createElement(_.Z,null))),o.createElement("div",{className:yt,style:{aspectRatio:g},ref:b},!x&&o.createElement("div",null,"Press play to preview the animation")),R>0&&o.createElement("div",{className:at,style:{width:x?z/R*100+"%":0}}),o.createElement("div",{className:lt},o.createElement("div",{className:mt},U&&o.createElement("button",{onClick:()=>F(T.current.state.doc),className:kt},o.createElement("kbd",null,"CTRL"),o.createElement("kbd",null,"S"),o.createElement("small",null,"Update preview"))),o.createElement("div",{className:mt},o.createElement("button",{className:it,onClick:()=>null==x?void 0:x.requestPreviousFrame()},o.createElement(f,null)),o.createElement("button",{className:it,onClick:()=>{if(x)W||F(T.current.state.doc),x.togglePlayback();else{const t=rt(C,b.current,B);F(T.current.state.doc),t.togglePlayback(!0)}}},!x||((null==P?void 0:P.paused)??1)?o.createElement(k,null):o.createElement(w,null)),o.createElement("button",{className:it,onClick:()=>null==x?void 0:x.requestNextFrame()},o.createElement(y,null))),o.createElement("div",{className:mt},0===j.length&&q&&o.createElement("button",{className:kt,onClick:()=>{T.current.setState(j[O].state),F(j[O].state.doc),I(j[O].state.doc)}},o.createElement("small",null,"Reset example")),j.length>1&&o.createElement(xt,{className:wt,value:q?-1:O,onChange:t=>{G(t),T.current.setState(j[t].state),F(j[t].state.doc)},options:j.map(((t,e)=>({value:e,name:t.name}))).concat(q?{value:-1,name:"Custom"}:[])}))),N&&o.createElement("pre",{className:dt},N.message),o.createElement("div",{className:ht,ref:v},o.createElement(d.Z,{className:ft,language:"tsx"},j[0].state.doc.toString()+("code"===L?"":"\n"))))}},74391:(t,e,n)=>{"use strict";n.d(e,{Z:()=>$e});var o={};n.r(o),n.d(o,{Circle:()=>k,CubicBezier:()=>W,Curve:()=>z,Grid:()=>Y,Icon:()=>Q,Img:()=>V,Knot:()=>nt,Latex:()=>mt,Layout:()=>dt.A,Line:()=>wt,Node:()=>K.N,Polygon:()=>gt,QuadBezier:()=>Tt,Ray:()=>Dt,Rect:()=>B.U,Shape:()=>d.b,Spline:()=>St,Txt:()=>Pt,Video:()=>Et,View2D:()=>Rt.h});var r={};n.r(r),n.d(r,{all:()=>Bt.$,any:()=>jt,chain:()=>qt,delay:()=>Ht,every:()=>Qt,loop:()=>Jt,loopFor:()=>Yt,loopUntil:()=>te,noop:()=>ee,run:()=>ne.K,sequence:()=>oe,waitFor:()=>Vt.X,waitUntil:()=>Vt.A});var s={};n.r(s),n.d(s,{DEG2RAD:()=>f.q,DetailedError:()=>ae.t,RAD2DEG:()=>f.I,Semaphore:()=>de.L,beginSlide:()=>re,capitalize:()=>se.k,createRef:()=>ye,debug:()=>ie,deprecate:()=>ce,endPlayback:()=>$t.Mh,endScene:()=>O.ug,endThread:()=>At.kw,errorToLog:()=>le.d,finishScene:()=>O.vl,getContext:()=>ue.f,isProxyEnabled:()=>j,makeRef:()=>ke,makeRefs:()=>we,range:()=>me.w,startPlayback:()=>$t.wA,startScene:()=>O.DO,startThread:()=>At.h$,useContext:()=>De,useContextAfter:()=>_e,useDuration:()=>Kt.Y,useLogger:()=>O.wL,usePlayback:()=>$t.te,useRandom:()=>fe,useScene:()=>O.$r,useThread:()=>At.nn,useTime:()=>Me,viaProxy:()=>G});var p={};n.r(p),n.d(p,{CompoundSignalContext:()=>ge.N,ComputedContext:()=>Xe.h,DEFAULT:()=>be.T,DependencyContext:()=>F.k,SignalContext:()=>ve.V,createComputed:()=>xe.D,createComputedAsync:()=>Te,createSignal:()=>Ce.g,isReactive:()=>ht.PG,modify:()=>ht.Pj,unwrap:()=>ht.Wg});var i={};n.r(i),n.d(i,{BBox:()=>x.b,Center:()=>Se.M5,Color:()=>E.I,Direction:()=>Se.Nm,EPSILON:()=>Ze.I,Matrix2D:()=>Ne,Origin:()=>Se.aP,Spacing:()=>Re.K,Vector2:()=>w.F,flipOrigin:()=>Se.lk,isType:()=>Ze.P,originToOffset:()=>Se.WS,transformAngle:()=>Le.$,transformScalar:()=>Le.X});var c={};n.r(c),n.d(c,{BeatSpring:()=>We,BounceSpring:()=>Be,JumpSpring:()=>Oe,PlopSpring:()=>Ee,SmoothSpring:()=>je,StrikeSpring:()=>Ge,SwingSpring:()=>Fe,arcLerp:()=>_.Vz,clamp:()=>_.uZ,clampRemap:()=>_.vl,cos:()=>ze.mC,createEaseInBack:()=>ze.j$,createEaseInBounce:()=>ze.jv,createEaseInElastic:()=>ze.qS,createEaseInOutBack:()=>ze.Bl,createEaseInOutBounce:()=>ze.Ij,createEaseInOutElastic:()=>ze.du,createEaseOutBack:()=>ze.lj,createEaseOutBounce:()=>ze.zk,createEaseOutElastic:()=>ze.Kx,deepLerp:()=>_.o0,easeInBack:()=>ze.Yw,easeInBounce:()=>ze.SJ,easeInCirc:()=>ze.Mg,easeInCubic:()=>ze.Q9,easeInElastic:()=>ze.eE,easeInExpo:()=>ze.e_,easeInOutBack:()=>ze.BH,easeInOutBounce:()=>ze.en,easeInOutCirc:()=>ze.Ge,easeInOutCubic:()=>ze.qb,easeInOutElastic:()=>ze.cv,easeInOutExpo:()=>ze.hN,easeInOutQuad:()=>ze.to,easeInOutQuart:()=>ze.J7,easeInOutQuint:()=>ze.rz,easeInOutSine:()=>ze.Fs,easeInQuad:()=>ze.FG,easeInQuart:()=>ze.g4,easeInQuint:()=>ze.n5,easeInSine:()=>ze.N1,easeOutBack:()=>ze.UE,easeOutBounce:()=>ze.C6,easeOutCirc:()=>ze.ei,easeOutCubic:()=>ze.w2,easeOutElastic:()=>ze.sK,easeOutExpo:()=>ze.ad,easeOutQuad:()=>ze.hl,easeOutQuart:()=>ze.Y3,easeOutQuint:()=>ze.pl,easeOutSine:()=>ze.vh,linear:()=>ze.GE,makeSpring:()=>Ie,map:()=>_.UI,remap:()=>_.a2,sin:()=>ze.O$,spring:()=>Ae,textLerp:()=>_.JC,tween:()=>Pe.i});var a={};n.r(a),n.d(a,{Thread:()=>Ve.j,cancel:()=>Ue,getTaskName:()=>qe.z,isPromisable:()=>Ut.x,isPromise:()=>He.t,isThreadGenerator:()=>Ut.R,join:()=>Ft.v,setTaskName:()=>qe.i,threads:()=>He.C});var l=n(15914);const u=Symbol.for("@motion-canvas/2d/fragment");function m(t,e){const{ref:n,children:o,...r}=e,s=Array.isArray(o)?o.flat():o;if(t===u)return s;if(null!=(p=t.prototype)&&p.isClass){const e=new t({...r,children:s});return null==n||n(e),e}return t({...r,ref:n,children:s});var p}var d=n(13730),h=n(93091),f=n(48733),y=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class k extends d.b{constructor(t){super(t)}getPath(){return this.createPath()}getRipplePath(){return this.createPath(this.rippleSize())}createPath(t){void 0===t&&(t=0);const e=new Path2D,n=this.startAngle()*f.q,o=this.endAngle()*f.q,r=this.size().scale(.5),s=this.closed();return s&&e.moveTo(0,0),e.ellipse(0,0,r.x+t,r.y+t,0,n,o),s&&e.closePath(),e}}y([(0,h.nn)(0),(0,h.td)()],k.prototype,"startAngle",void 0),y([(0,h.nn)(360),(0,h.td)()],k.prototype,"endAngle",void 0),y([(0,h.nn)(!1),(0,h.td)()],k.prototype,"closed",void 0);var w=n(29797),M=n(11258);class D{}var _=n(13170);class g{constructor(t,e){void 0===e&&(e=20),this.curve=t,this.sampledDistances=[],this.resample(e)}resample(t){this.sampledDistances=[0];let e=0,n=this.curve.eval(0).position;for(let o=1;o<t;o++){const r=o/(t-1),s=this.curve.eval(r);e+=n.sub(s.position).magnitude,this.sampledDistances.push(e),n=s.position}this.sampledDistances[this.sampledDistances.length-1]=this.curve.arcLength}pointAtDistance(t){return this.curve.eval(this.distanceToT(t))}distanceToT(t){const e=this.sampledDistances.length;t=(0,_.uZ)(0,this.curve.arcLength,t);for(let n=0;n<e;n++){const o=this.sampledDistances[n],r=this.sampledDistances[n+1];if(t>=o&&t<=r)return(0,_.a2)(o,r,n/(e-1),(n+1)/(e-1),t)}return 1}}class X extends D{get arcLength(){return this.length}constructor(t,e){super(),this.curve=t,this.length=e,this.pointSampler=new g(this)}getBBox(){return this.curve.getBounds()}eval(t){const e=this.tangent(t);return{position:this.curve.eval(t),tangent:e,normal:e.perpendicular}}getPoint(t){const e=this.pointSampler.pointAtDistance(this.arcLength*t);return{position:e.position,tangent:e.tangent,normal:e.tangent.perpendicular}}transformPoints(t){return this.points.map((e=>e.transformAsPoint(t)))}tangent(t){return this.curve.evalDerivative(t).normalized}draw(t,e,n,o){void 0===e&&(e=0),void 0===n&&(n=1),void 0===o&&(o=!0);let r=null,s=e,p=n,i=this.points;if(0!==e||1!==n){const t=this.length*e,o=this.length*n;s=this.pointSampler.distanceToT(t),p=this.pointSampler.distanceToT(o);const c=(p-s)/(1-s),[,a]=this.split(s);[r]=a.split(c),i=r.points}o&&(0,M.Ao)(t,i[0]),(r??this).doDraw(t);const c=this.tangent(s),a=this.tangent(p);return[{position:i[0],tangent:c,normal:c.perpendicular},{position:i.at(-1),tangent:a,normal:a.perpendicular}]}}var x=n(23357);class C{static constant(t){return new C(t)}static linear(t,e){return new C(t,e)}static quadratic(t,e,n){return new C(t,e,n)}static cubic(t,e,n,o){return new C(t,e,n,o)}get degree(){return 0!==this.c3?3:0!==this.c2?2:0!==this.c1?1:0}constructor(t,e,n,o){this.c0=t,this.c1=e??0,this.c2=n??0,this.c3=o??0}differentiate(t){switch(void 0===t&&(t=1),t){case 0:return this;case 1:return new C(this.c1,2*this.c2,3*this.c3,0);case 2:return new C(2*this.c2,6*this.c3,0,0);case 3:return new C(6*this.c3,0,0,0);default:throw new Error("Unsupported derivative")}}eval(t,e){return void 0===e&&(e=0),0!==e?this.differentiate(e).eval(t):this.c3*(t*t*t)+this.c2*(t*t)+this.c1*t+this.c0}split(t){const e=1-t;return[new C(this.c0,this.c1*t,this.c2*t*t,this.c3*t*t*t),new C(this.eval(0),e*this.differentiate(1).eval(t),e*e/2*this.differentiate(2).eval(t),e*e*e/6*this.differentiate(3).eval(t))]}roots(){switch(this.degree){case 3:return this.solveCubicRoots();case 2:return this.solveQuadraticRoots();case 1:return this.solveLinearRoot();case 0:return[];default:throw new Error(`Unsupported polynomial degree: ${this.degree}`)}}localExtrema(){return this.differentiate().roots()}localExtrema01(){const t=this.localExtrema(),e=[];for(let n=0;n<t.length;n++){const o=t[n];o>=0&&o<=1&&e.push(t[n])}return e}outputRange01(){let t=[this.eval(0),this.eval(1)];return this.localExtrema01().forEach((e=>{return n=this.eval(e),void(t=t[1]>t[0]?[Math.min(t[0],n),Math.max(t[1],n)]:[Math.min(t[1],n),Math.max(t[0],n)]);var n})),t}solveCubicRoots(){const t=this.c0,e=this.c1,n=this.c2,o=this.c3,r=t*t,s=t*n,p=e*e,i=(3*s-p)/(3*r),c=(2*p*e-9*s*e+27*r*o)/(27*r*t),a=this.solveDepressedCubicRoots(i,c),l=n=>n-e/(3*t);switch(a.length){case 1:return[l(a[0])];case 2:return[l(a[0]),l(a[1])];case 3:return[l(a[0]),l(a[1]),l(a[2])];default:return[]}}solveDepressedCubicRoots(t,e){if(this.almostZero(t))return[Math.cbrt(-e)];const n=2*Math.PI,o=4*t*t*t+27*e*e;if(o<1e-5){const o=2*Math.sqrt(-t/3),r=3*e/(2*t)*Math.sqrt(-3/t),s=t=>o*Math.cos(1/3*Math.acos((0,_.uZ)(-1,1,r))-n/3*t);return r>=.9999?[s(0),s(2)]:r<=-.9999?[s(1),s(2)]:[s(0),s(1),s(2)]}if(o>0&&t<0){const n=1/3*Math.acosh(-3*Math.abs(e)/(2*t)*Math.sqrt(-3/t));return[-2*Math.sign(e)*Math.sqrt(-t/3)*Math.cosh(n)]}if(t>0){const n=1/3*Math.asinh(3*e/(2*t)*Math.sqrt(3/t));return[-2*Math.sqrt(t/3)*Math.sinh(n)]}return[]}solveQuadraticRoots(){const t=this.c2,e=this.c1,n=e*e-4*t*this.c0;if(this.almostZero(n))return[-e/(2*t)];if(n>=0){const o=Math.sqrt(n),r=(-e-o)/(2*t),s=(-e+o)/(2*t);return[Math.min(r,s),Math.max(r,s)]}return[]}solveLinearRoot(){return[-this.c0/this.c1]}almostZero(t){return Math.abs(0-t)<=Number.EPSILON}}class T{constructor(t,e,n,o){this.c0=t,this.c1=e,this.c2=n,this.c3=o,t instanceof C?(this.x=t,this.y=e):void 0!==o?(this.x=new C(t.x,e.x,n.x,o.x),this.y=new C(t.y,e.y,n.y,o.y)):(this.x=new C(t.x,e.x,n.x),this.y=new C(t.y,e.y,n.y))}eval(t,e){return void 0===e&&(e=0),new w.F(this.x.differentiate(e).eval(t),this.y.differentiate(e).eval(t))}split(t){const[e,n]=this.x.split(t),[o,r]=this.y.split(t);return[new T(e,o),new T(n,r)]}differentiate(t){return void 0===t&&(t=1),new T(this.x.differentiate(t),this.y.differentiate(t))}evalDerivative(t){return this.differentiate().eval(t)}getBounds(){const t=this.x.outputRange01(),e=this.y.outputRange01();return x.b.fromPoints(new w.F(Math.min(...t),Math.max(...e)),new w.F(Math.max(...t),Math.min(...e)))}}var v=n(79116),b=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class L extends X{get points(){return[this.p0,this.p1,this.p2,this.p3]}constructor(t,e,n,o){super(new T(t,t.flipped.add(e).scale(3),t.scale(3).sub(e.scale(6)).add(n.scale(3)),t.flipped.add(e.scale(3)).sub(n.scale(3)).add(o)),L.getLength(t,e,n,o)),this.p0=t,this.p1=e,this.p2=n,this.p3=o}split(t){const e=new w.F(this.p0.x+(this.p1.x-this.p0.x)*t,this.p0.y+(this.p1.y-this.p0.y)*t),n=new w.F(this.p1.x+(this.p2.x-this.p1.x)*t,this.p1.y+(this.p2.y-this.p1.y)*t),o=new w.F(this.p2.x+(this.p3.x-this.p2.x)*t,this.p2.y+(this.p3.y-this.p2.y)*t),r=new w.F(e.x+(n.x-e.x)*t,e.y+(n.y-e.y)*t),s=new w.F(n.x+(o.x-n.x)*t,n.y+(o.y-n.y)*t),p=new w.F(r.x+(s.x-r.x)*t,r.y+(s.y-r.y)*t);return[new L(this.p0,e,r,p),new L(p,s,o,this.p3)]}doDraw(t){(0,M.JQ)(t,this.p1,this.p2,this.p3)}static getLength(t,e,n,o){return L.el.setAttribute("d",`M ${t.x} ${t.y} C ${e.x} ${e.y} ${n.x} ${n.y} ${o.x} ${o.y}`),L.el.getTotalLength()}}b([(0,v.V)((()=>document.createElementNS("http://www.w3.org/2000/svg","path")))],L,"el",void 0);var Z=n(88104),N=n(46350);function S(t,e){const n=(0,_.uZ)(0,t.arcLength,e);let o=0;for(const r of t.segments){const t=o;if(o+=r.arcLength,o>=n){const e=(n-t)/r.arcLength;return r.getPoint((0,_.uZ)(0,1,e))}}return{position:w.F.zero,tangent:w.F.up,normal:w.F.up}}var R=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class z extends d.b{desiredSize(){return this.childrenBBox().size}constructor(t){super(t)}percentageToDistance(t){return(0,_.uZ)(0,this.baseArcLength(),this.startOffset()+this.offsetArcLength()*t)}distanceToPercentage(t){return(t-this.startOffset())/this.offsetArcLength()}baseArcLength(){return this.profile().arcLength}offsetArcLength(){const t=this.startOffset(),e=this.endOffset(),n=this.baseArcLength();return(0,_.uZ)(0,n,n-t-e)}arcLength(){return this.offsetArcLength()*Math.abs(this.start()-this.end())}completion(){return Math.abs(this.start()-this.end())}curveDrawingInfo(){const t=new Path2D,e=this.profile();let n=this.percentageToDistance(this.start()),o=this.percentageToDistance(this.end());n>o&&([n,o]=[o,n]);const r=o-n,s=Math.min(r/2,this.arrowSize());this.startArrow()&&(n+=s/2),this.endArrow()&&(o-=s/2);let p=0,i=null,c=null,a=null,l=null;for(const u of e.segments){const e=p;if(p+=u.arcLength,p<n)continue;const r=(n-e)/u.arcLength,s=(o-e)/u.arcLength,m=(0,_.uZ)(0,1,r),d=(0,_.uZ)(0,1,s),[h,f]=u.draw(t,m,d,null===i);if(null===i&&(i=h.position,c=h.normal.flipped.perpendicular),a=f.position,l=f.normal.flipped.perpendicular,p>o)break}return 1===this.end()&&this.closed()&&t.closePath(),{startPoint:i??w.F.zero,startTangent:c??w.F.right,endPoint:a??w.F.zero,endTangent:l??w.F.right,arrowSize:s,path:t,startOffset:n}}getPointAtDistance(t){return S(this.profile(),t+this.startOffset())}getPointAtPercentage(t){return S(this.profile(),this.percentageToDistance(t))}applyStyle(t){super.applyStyle(t);const{arcLength:e}=this.profile();t.lineDashOffset-=e/2}getComputedLayout(){return this.offsetComputedLayout(super.getComputedLayout())}offsetComputedLayout(t){return t.position=t.position.sub(this.childrenBBox().center),t}getPath(){return this.curveDrawingInfo().path}getCacheBBox(){const t=this.childrenBBox(),e=this.arrowSize(),n=this.lineWidth(),o=this.lineWidthCoefficient();return t.expand(Math.max(0,e,n*o))}lineWidthCoefficient(){return"square"===this.lineCap()?.70715:.5}drawShape(t){super.drawShape(t);const{startPoint:e,startTangent:n,endPoint:o,endTangent:r,arrowSize:s}=this.curveDrawingInfo();s<.001||(t.save(),t.beginPath(),this.endArrow()&&this.drawArrow(t,o,r.flipped,s),this.startArrow()&&this.drawArrow(t,e,n,s),t.fillStyle=(0,M.ho)(this.stroke(),t),t.closePath(),t.fill(),t.restore())}drawArrow(t,e,n,o){const r=n.perpendicular,s=e.add(n.scale(-o/2));(0,M.Ao)(t,s),(0,M.kZ)(t,s.add(n.add(r).scale(o))),(0,M.kZ)(t,s.add(n.sub(r).scale(o))),(0,M.kZ)(t,s),t.closePath()}}R([(0,h.nn)(!1),(0,h.td)()],z.prototype,"closed",void 0),R([(0,h.nn)(0),(0,h.td)()],z.prototype,"start",void 0),R([(0,h.nn)(0),(0,h.td)()],z.prototype,"startOffset",void 0),R([(0,h.nn)(!1),(0,h.td)()],z.prototype,"startArrow",void 0),R([(0,h.nn)(1),(0,h.td)()],z.prototype,"end",void 0),R([(0,h.nn)(0),(0,h.td)()],z.prototype,"endOffset",void 0),R([(0,h.nn)(!1),(0,h.td)()],z.prototype,"endArrow",void 0),R([(0,h.nn)(24),(0,h.td)()],z.prototype,"arrowSize",void 0),R([(0,N.F)()],z.prototype,"arcLength",null),R([(0,N.F)()],z.prototype,"curveDrawingInfo",null);var P=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class A extends z{profile(){const t=this.segment();return{segments:[t],arcLength:t.arcLength,minSin:0}}childrenBBox(){return x.b.fromPoints(...this.segment().points)}desiredSize(){return this.segment().getBBox().size}offsetComputedLayout(t){return t.position=t.position.sub(this.segment().getBBox().center),t}drawOverlay(t,e){const n=this.computedSize(),o=this.childrenBBox().transformCorners(e),r=n.mul(this.offset()).scale(.5).transformAsPoint(e),s=this.overlayInfo(e);t.lineWidth=1,t.strokeStyle="white",t.fillStyle="white",t.stroke(s.curve),t.fillStyle="white",t.globalAlpha=.5,t.beginPath(),t.stroke(s.handleLines),t.globalAlpha=1,t.lineWidth=2;for(const p of[s.startPoint,s.endPoint])(0,M.Ao)(t,p),t.beginPath(),(0,M.Nb)(t,p,4),t.closePath(),t.stroke(),t.fill();t.fillStyle="black";for(const p of s.controlPoints)(0,M.Ao)(t,p),t.beginPath(),(0,M.Nb)(t,p,4),t.closePath(),t.fill(),t.stroke();t.lineWidth=1,t.beginPath(),(0,M.wp)(t,r),t.stroke(),t.beginPath(),(0,M.pS)(t,o),t.closePath(),t.stroke()}}P([(0,N.F)()],A.prototype,"childrenBBox",null);var I=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class W extends A{constructor(t){super(t)}segment(){return new L(this.p0(),this.p1(),this.p2(),this.p3())}overlayInfo(t){const[e,n,o,r]=this.segment().transformPoints(t),s=new Path2D;(0,M.Ao)(s,e),(0,M.JQ)(s,n,o,r);const p=new Path2D;return(0,M.Ao)(p,e),(0,M.kZ)(p,n),(0,M.Ao)(p,o),(0,M.kZ)(p,r),{curve:s,startPoint:e,endPoint:r,controlPoints:[n,o],handleLines:p}}}I([(0,Z.y)("p0")],W.prototype,"p0",void 0),I([(0,Z.y)("p1")],W.prototype,"p1",void 0),I([(0,Z.y)("p2")],W.prototype,"p2",void 0),I([(0,Z.y)("p3")],W.prototype,"p3",void 0),I([(0,N.F)()],W.prototype,"segment",null);var E=n(30204),B=n(15498),F=n(76062),O=n(3163);function G(t){if(!j())return t;if(t.startsWith("/cors-proxy/"))return t;const e=new URL(window.location.toString());try{const n=new URL(t,e);if(!n.protocol.startsWith("http"))return t;if(e.host===n.host)return t;if(!function(t){const e=function(){if("true"!==(void 0).VITEST&&U)return[...U];const t=(j(),[]);return U=t,[...U]}();if(0===e.length)return!0;for(const n of e)if(n.toLowerCase().trim()===t)return!0;return!1}(n.host))return t}catch(n){return t}return`/cors-proxy/${encodeURIComponent(t)}`}function j(){return!1}let U;var q=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class V extends B.U{constructor(t){super(t)}desiredSize(){const t=super.desiredSize();if(null===t.x&&null===t.y){const t=this.image();return{x:t.naturalWidth,y:t.naturalHeight}}return t}image(){const t=G(this.src()),e=this.view().assetHash();let n=V.pool[t];return n||(n=document.createElement("img"),n.crossOrigin="anonymous",n.src=`${t}?${e}`,V.pool[t]=n),n.complete||F.k.collectPromise(new Promise(((t,e)=>{n.addEventListener("load",t),n.addEventListener("error",e)}))),n}imageCanvas(){const t=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});if(!t)throw new Error("Could not create an image canvas");return t}filledImageCanvas(){const t=this.imageCanvas(),e=this.image();return t.canvas.width=e.naturalWidth,t.canvas.height=e.naturalHeight,t.imageSmoothingEnabled=this.smoothing(),t.drawImage(e,0,0),t}draw(t){this.drawShape(t),this.clip()&&t.clip(this.getPath());const e=this.alpha();if(e>0){const n=x.b.fromSizeCentered(this.computedSize());t.save(),e<1&&(t.globalAlpha*=e),t.imageSmoothingEnabled=this.smoothing(),(0,M.AE)(t,this.image(),n),t.restore()}this.drawChildren(t)}applyFlex(){super.applyFlex();const t=this.image();this.element.style.aspectRatio=(this.ratio()??t.naturalWidth/t.naturalHeight).toString()}getColorAtPoint(t){const e=this.computedSize(),n=this.naturalSize(),o=new w.F(t).add(this.computedSize().scale(.5)).mul(n.div(e).safe);return this.getPixelColor(o)}naturalSize(){const t=this.image();return new w.F(t.naturalWidth,t.naturalHeight)}getPixelColor(t){const e=this.filledImageCanvas(),n=new w.F(t),o=e.getImageData(n.x,n.y,1,1).data;return new E.I({r:o[0],g:o[1],b:o[2],a:o[3]/255})}collectAsyncResources(){super.collectAsyncResources(),this.image()}}V.pool={},q([(0,h.td)()],V.prototype,"src",void 0),q([(0,h.nn)(1),(0,h.td)()],V.prototype,"alpha",void 0),q([(0,h.nn)(!0),(0,h.td)()],V.prototype,"smoothing",void 0),q([(0,N.F)()],V.prototype,"image",null),q([(0,N.F)()],V.prototype,"imageCanvas",null),q([(0,N.F)()],V.prototype,"filledImageCanvas",null),q([(0,N.F)()],V.prototype,"naturalSize",null);var H=n(43595),$=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class Q extends V{constructor(t){super(t)}svgUrl(){return`https://api.iconify.design/${this.icon().replace(":","/")}.svg?color=${encodeURIComponent(this.color().hex())}`}getSrc(){return this.svgUrl()}setSrc(){(0,O.wL)().warn("The Icon Component does not accept setting the `src`. If you need access to `src`, use '<Img/>` instead.")}}$([(0,h.td)()],Q.prototype,"icon",void 0),$([(0,h.nn)("white"),(0,H.j)()],Q.prototype,"color",void 0),$([(0,N.F)()],Q.prototype,"svgUrl",null);var J=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class Y extends d.b{constructor(t){super(t)}drawShape(t){t.save(),this.applyStyle(t),this.drawRipple(t);const e=this.spacing(),n=this.computedSize().scale(.5),o=n.div(e).floored;for(let r=-o.x;r<=o.x;r++)t.beginPath(),t.moveTo(e.x*r,-n.height),t.lineTo(e.x*r,n.height),t.stroke();for(let r=-o.y;r<=o.y;r++)t.beginPath(),t.moveTo(-n.width,e.y*r),t.lineTo(n.width,e.y*r),t.stroke();t.restore()}}J([(0,h.nn)(80),(0,Z.y)("spacing")],Y.prototype,"spacing",void 0);var K=n(20092),tt=n(37060),et=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class nt extends K.N{get startHandleAuto(){return this.auto.startHandle}get endHandleAuto(){return this.auto.endHandle}constructor(t){super(void 0===t.startHandle&&void 0===t.endHandle?{auto:1,...t}:t)}points(){const t=!this.startHandle.isInitial()||!this.endHandle.isInitial(),e=t?this.startHandle():w.F.zero,n=t?this.endHandle():w.F.zero;return{position:this.position(),startHandle:e.transformAsPoint(this.localToParent()),endHandle:n.transformAsPoint(this.localToParent()),auto:{start:this.startHandleAuto(),end:this.endHandleAuto()}}}getDefaultEndHandle(){return this.startHandle().flipped}getDefaultStartHandle(){return this.endHandle().flipped}}et([(0,h.YS)(w.F),(0,h.td)()],nt.prototype,"startHandle",void 0),et([(0,h.YS)(w.F),(0,h.td)()],nt.prototype,"endHandle",void 0),et([(0,h.r_)(!1),(0,h.nn)((()=>({startHandle:0,endHandle:0}))),(0,h.E2)((t=>"object"!=typeof t||Array.isArray(t)?("number"==typeof t&&(t=[t,t]),{startHandle:t[0],endHandle:t[1]}):t)),(0,tt.I)({startHandle:"startHandleAuto",endHandle:"endHandleAuto"})],nt.prototype,"auto",void 0),et([(0,N.F)()],nt.prototype,"points",null);var ot=n(98911),rt=n(2322),st=n(64238),pt=n(81962),it=n(86226),ct=n(50099),at=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};const lt=(0,it.liteAdaptor)();(0,ct.Q)(lt);const ut=ot.mathjax.document("",{InputJax:new rt.TeX({packages:pt.b}),OutputJax:new st.SVG({fontCache:"local"})});class mt extends V{constructor(t){super(t),this.imageElement=document.createElement("img")}image(){const t=`${this.tex()}::${JSON.stringify(this.options())}`;if(mt.svgContentsPool[t])return this.imageElement.src=mt.svgContentsPool[t],this.imageElement.complete||F.k.collectPromise(new Promise(((t,e)=>{this.imageElement.addEventListener("load",t),this.imageElement.addEventListener("error",e)}))),this.imageElement;const e=this.tex(),n=lt.innerHTML(ut.convert(e,this.options()));if(n.includes("data-mjx-error")){const t=n.match(/data-mjx-error="(.*?)"/);t&&t.length>0&&(0,O.wL)().error(`Invalid MathJax: ${t[1]}`)}const o=`data:image/svg+xml;base64,${btoa(`<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n${n}`)}`;mt.svgContentsPool[t]=o;const r=document.createElement("img");return r.src=o,r.src=o,r.complete||F.k.collectPromise(new Promise(((t,e)=>{r.addEventListener("load",t),r.addEventListener("error",e)}))),r}}mt.svgContentsPool={},at([(0,h.nn)({}),(0,h.td)()],mt.prototype,"options",void 0),at([(0,h.td)()],mt.prototype,"tex",void 0);var dt=n(70989),ht=n(68003);class ft extends D{constructor(t,e){super(),this.from=t,this.to=e,this.vector=e.sub(t),this.length=this.vector.magnitude,this.normal=this.vector.perpendicular.normalized.safe}get arcLength(){return this.length}draw(t,e,n,o){void 0===e&&(e=0),void 0===n&&(n=1),void 0===o&&(o=!1);const r=this.from.add(this.vector.scale(e)),s=this.from.add(this.vector.scale(n));return o&&(0,M.Ao)(t,r),(0,M.kZ)(t,s),[{position:r,tangent:this.normal.flipped,normal:this.normal},{position:s,tangent:this.normal,normal:this.normal}]}getPoint(t){return{position:this.from.add(this.vector.scale(t)),tangent:this.normal.flipped,normal:this.normal}}}class yt extends D{constructor(t,e,n,o,r){super(),this.center=t,this.radius=e,this.from=n,this.to=o,this.counter=r,this.angle=Math.acos((0,_.uZ)(-1,1,n.dot(o))),this.length=Math.abs(this.angle*e)}get arcLength(){return this.length}draw(t,e,n){const o=this.counter?-1:1,r=this.from.radians+e*this.angle*o,s=this.to.radians-(1-n)*this.angle*o;Math.abs(this.angle)>1e-4&&t.arc(this.center.x,this.center.y,this.radius,r,s,this.counter);const p=w.F.fromRadians(r),i=w.F.fromRadians(s);return[{position:this.center.add(p.scale(this.radius)),tangent:this.counter?p:p.flipped,normal:this.counter?p:p.flipped},{position:this.center.add(i.scale(this.radius)),tangent:this.counter?i.flipped:i,normal:this.counter?i.flipped:i}]}getPoint(t){const e=this.counter?-1:1,n=this.from.radians+t*this.angle*e,o=w.F.fromRadians(n);return{position:this.center.add(o.scale(this.radius)),tangent:this.counter?o:o.flipped,normal:this.counter?o:o.flipped}}}var kt=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class wt extends z{constructor(t){super(t),void 0===t.children&&void 0===t.points&&(0,O.wL)().warn({message:"No points specified for the line",remarks:'<p>The line won&#39;t be visible unless you specify at least two points:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span>\n  stroke=<span class="hljs-string">&quot;#fff&quot;</span>\n  lineWidth={<span class="hljs-number">8</span>}\n  points={[\n    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],\n  ]}\n/&gt;\n</code></pre>\n<p>Alternatively, you can define the points using the children:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>\n&lt;/<span class="hljs-title class_">Line</span>&gt;\n</code></pre>\n<p>If you did this intentionally, and want to disable this message, set the\n<code>points</code> property to <code>null</code>:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>} points={<span class="hljs-literal">null</span>} /&gt;\n</code></pre>\n',inspect:this.key})}childrenBBox(){const t=this.points(),e=t?t.map((t=>new w.F((0,ht.Wg)(t)))):this.children().filter((t=>!(t instanceof dt.A)||t.isLayoutRoot())).map((t=>t.position()));return x.b.fromPoints(...e)}parsedPoints(){const t=this.points();return t?t.map((t=>new w.F((0,ht.Wg)(t)))):this.children().map((t=>t.position()))}profile(){return function(t,e,n){const o={arcLength:0,segments:[],minSin:1};if(0===t.length)return o;if(n){const e=t[0].add(t[t.length-1]).scale(.5);t.unshift(e),t.push(e)}let r=t[0];for(let p=2;p<t.length;p++){const n=t[p-2],s=t[p-1],i=t[p],c=n.sub(s),a=i.sub(s),l=c.normalized.safe,u=a.normalized.safe,m=Math.acos((0,_.uZ)(-1,1,l.dot(u))),d=Math.tan(m/2),h=Math.sin(m/2),f=Math.min(e,d*c.magnitude*(2===p?1:.5),d*a.magnitude*(p===t.length-1?1:.5)),y=0===h?0:f/h,k=0===d?0:f/d,w=l.add(u).scale(.5).normalized.safe.scale(y).add(s),M=l.perpendicular.dot(u)<0,D=new ft(r,s.add(l.scale(k))),g=new yt(w,f,l.perpendicular.scale(M?1:-1),u.perpendicular.scale(M?-1:1),M);o.segments.push(D),o.segments.push(g),o.arcLength+=D.arcLength,o.arcLength+=g.arcLength,o.minSin=Math.min(o.minSin,Math.abs(h)),r=s.add(u.scale(k))}const s=new ft(r,t[t.length-1]);return o.segments.push(s),o.arcLength+=s.arcLength,o}(this.parsedPoints(),this.radius(),this.closed())}lineWidthCoefficient(){const t=this.radius(),e=this.lineJoin();let n=super.lineWidthCoefficient();if(0===t&&"miter"===e){const{minSin:t}=this.profile();t>0&&(n=Math.max(n,.5/t))}return n}drawOverlay(t,e){const n=this.childrenBBox().transformCorners(e),o=this.computedSize().mul(this.offset()).scale(.5).transformAsPoint(e);t.fillStyle="white",t.strokeStyle="black",t.lineWidth=1;const r=new Path2D,s=this.parsedPoints().map((t=>t.transformAsPoint(e)));if(s.length>0){(0,M.Ao)(r,s[0]);for(const e of s)(0,M.kZ)(r,e),t.beginPath(),(0,M.Nb)(t,e,4),t.closePath(),t.fill(),t.stroke()}t.strokeStyle="white",t.stroke(r),t.beginPath(),(0,M.wp)(t,o),t.stroke(),t.beginPath(),(0,M.pS)(t,n),t.closePath(),t.stroke()}}kt([(0,h.nn)(0),(0,h.td)()],wt.prototype,"radius",void 0),kt([(0,h.nn)(null),(0,h.td)()],wt.prototype,"points",void 0),kt([(0,N.F)()],wt.prototype,"childrenBBox",null),kt([(0,N.F)()],wt.prototype,"parsedPoints",null),kt([(0,N.F)()],wt.prototype,"profile",null);var Mt=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class Dt extends z{constructor(t){super(t)}childrenBBox(){return x.b.fromPoints(this.from(),this.to())}profile(){const t=new ft(this.from(),this.to());return{arcLength:t.arcLength,minSin:1,segments:[t]}}drawOverlay(t,e){const n=this.childrenBBox().transformCorners(e),o=this.computedSize().mul(this.offset()).scale(.5).transformAsPoint(e),r=this.from().transformAsPoint(e),s=this.to().transformAsPoint(e);t.fillStyle="white",t.strokeStyle="black",t.lineWidth=1,t.beginPath(),(0,M.Nb)(t,r,4),t.fill(),t.stroke(),t.beginPath(),(0,M.Nb)(t,s,4),t.fill(),t.stroke(),t.strokeStyle="white",t.beginPath(),(0,M.pS)(t,[r,s]),t.stroke(),t.beginPath(),(0,M.wp)(t,o),t.stroke(),t.beginPath(),(0,M.pS)(t,n),t.closePath(),t.stroke()}}Mt([(0,Z.y)("from")],Dt.prototype,"from",void 0),Mt([(0,Z.y)("to")],Dt.prototype,"to",void 0);var _t=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class gt extends d.b{constructor(t){super(t)}getPath(){const t=new Path2D,e=this.sides(),n=x.b.fromSizeCentered(this.size());return(0,M.is)(t,n,e),t}getRipplePath(){const t=new Path2D,e=this.sides(),n=this.rippleSize(),o=x.b.fromSizeCentered(this.size()).expand(n);return(0,M.is)(t,o,e),t}}_t([(0,h.nn)(6),(0,h.td)()],gt.prototype,"sides",void 0);var Xt=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class xt extends X{get points(){return[this.p0,this.p1,this.p2]}constructor(t,e,n){super(new T(t,t.flipped.add(e).scale(2),t.sub(e.scale(2)).add(n)),xt.getLength(t,e,n)),this.p0=t,this.p1=e,this.p2=n}split(t){const e=new w.F(this.p0.x+(this.p1.x-this.p0.x)*t,this.p0.y+(this.p1.y-this.p0.y)*t),n=new w.F(this.p1.x+(this.p2.x-this.p1.x)*t,this.p1.y+(this.p2.y-this.p1.y)*t),o=new w.F(e.x+(n.x-e.x)*t,e.y+(n.y-e.y)*t);return[new xt(this.p0,e,o),new xt(o,n,this.p2)]}static getLength(t,e,n){return xt.el.setAttribute("d",`M ${t.x} ${t.y} Q ${e.x} ${e.y} ${n.x} ${n.y}`),xt.el.getTotalLength()}doDraw(t){(0,M.pt)(t,this.p1,this.p2)}}Xt([(0,v.V)((()=>document.createElementNS("http://www.w3.org/2000/svg","path")))],xt,"el",void 0);var Ct=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class Tt extends A{constructor(t){super(t)}segment(){return new xt(this.p0(),this.p1(),this.p2())}overlayInfo(t){const[e,n,o]=this.segment().transformPoints(t),r=new Path2D;(0,M.Ao)(r,e),(0,M.pt)(r,n,o);const s=new Path2D;return(0,M.Ao)(s,e),(0,M.kZ)(s,n),(0,M.kZ)(s,o),{curve:r,startPoint:e,endPoint:o,controlPoints:[n],handleLines:s}}}function vt(t){return t instanceof L}function bt(t,e,n,o){if(0===t.auto.start&&0===t.auto.end)return;const r=t.position.sub(e.position).magnitude,s=o*r/(r+n.position.sub(t.position).magnitude),p=o-s,i=new w.F(t.position.x-s*(n.position.x-e.position.x),t.position.y-s*(n.position.y-e.position.y)),c=new w.F(t.position.x+p*(n.position.x-e.position.x),t.position.y+p*(n.position.y-e.position.y));t.startHandle=t.startHandle.lerp(i,t.auto.start),t.endHandle=t.endHandle.lerp(c,t.auto.end)}function Lt(t,e,n,o,r){const s=void 0!==r?new L(e,n,o,r):new xt(e,n,o);t.segments.push(s),t.arcLength+=s.arcLength}function Zt(t,e,n){const o={segments:[],arcLength:0,minSin:1},r=t.length;for(let a=0;a<r;a++){const e=(a-1+r)%r,o=(a+1)%r;bt(t[a],t[e],t[o],n)}const s=t[0],p=t[1];e||1!==s.auto.start||1!==s.auto.end?Lt(o,s.position,s.endHandle,p.startHandle,p.position):Lt(o,s.position,p.startHandle,p.position);for(let a=1;a<r-2;a++){const e=t[a],n=t[a+1];Lt(o,e.position,e.endHandle,n.startHandle,n.position)}const i=t.at(-1),c=t.at(-2);return t.length>2&&(e||1!==i.auto.start||1!==i.auto.end?Lt(o,c.position,c.endHandle,i.startHandle,i.position):Lt(o,c.position,c.endHandle,i.position)),e&&Lt(o,i.position,i.endHandle,s.startHandle,s.position),function(t){for(let e=0;e<t.segments.length;e++){const n=t.segments[e],o=t.segments[(e+1)%t.segments.length];if(!vt(n)||!vt(o))continue;const r=n.p2.sub(n.p3).normalized.safe,s=o.p1.sub(o.p0).normalized.safe,p=r.dot(s);if(!(1-Math.abs(p)>1e-4))continue;const i=Math.acos((0,_.uZ)(-1,1,p)),c=Math.sin(i/2);t.minSin=Math.min(t.minSin,Math.abs(c))}}(o),o}Ct([(0,Z.y)("p0")],Tt.prototype,"p0",void 0),Ct([(0,Z.y)("p1")],Tt.prototype,"p1",void 0),Ct([(0,Z.y)("p2")],Tt.prototype,"p2",void 0),Ct([(0,N.F)()],Tt.prototype,"segment",null);var Nt=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class St extends z{constructor(t){super(t),(void 0===t.children||t.children.length<2)&&(void 0===t.points||t.points.length<2)&&void 0===t.spawner&&(0,O.wL)().warn({message:"Insufficient number of knots specified for spline. A spline needs at least two knots.",remarks:'<p>The spline won&#39;t be visible unless you specify at least two knots:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Spline</span>\n  stroke=<span class="hljs-string">&quot;#fff&quot;</span>\n  lineWidth={<span class="hljs-number">8</span>}\n  points={[\n    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],\n  ]}\n/&gt;\n</code></pre>\n<p>For more control over the knot handles, you can alternatively provide the knots\nas children to the spline using the <code>Knot</code> component:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Spline</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Knot</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> <span class="hljs-attr">endHandle</span>=<span class="hljs-string">{[-50,</span> <span class="hljs-attr">0</span>]} /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Knot</span> /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Knot</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> <span class="hljs-attr">startHandle</span>=<span class="hljs-string">{[-100,</span> <span class="hljs-attr">50</span>]} /&gt;</span></span>\n&lt;/<span class="hljs-title class_">Spline</span>&gt;\n</code></pre>\n',inspect:this.key})}profile(){return Zt(this.knots(),this.closed(),this.smoothness())}knots(){const t=this.points();return t?t.map((t=>{const e=new w.F((0,ht.Wg)(t));return{position:e,startHandle:e,endHandle:e,auto:{start:1,end:1}}})):this.children().filter(this.isKnot).map((t=>t.points()))}childrenBBox(){const t=this.profile().segments.flatMap((t=>t.points));return x.b.fromPoints(...t)}lineWidthCoefficient(){const t=this.lineJoin();let e=super.lineWidthCoefficient();if("miter"!==t)return e;const{minSin:n}=this.profile();return n>0&&(e=Math.max(e,.5/n)),e}desiredSize(){return this.getTightBBox().size}offsetComputedLayout(t){return t.position=t.position.sub(this.getTightBBox().center),t}getTightBBox(){const t=this.profile().segments.map((t=>t.getBBox()));return x.b.fromBBoxes(...t)}drawOverlay(t,e){const n=this.computedSize(),o=this.childrenBBox().transformCorners(e),r=n.mul(this.offset()).scale(.5).transformAsPoint(e),s=this.profile().segments;t.lineWidth=1,t.strokeStyle="white",t.fillStyle="white";const p=new Path2D;for(let i=0;i<s.length;i++){const t=s[i],[n,o,r,c]=t.transformPoints(e);(0,M.Ao)(p,n),t instanceof L?(0,M.JQ)(p,o,r,c):(0,M.pt)(p,o,r)}t.stroke(p);for(let i=0;i<s.length;i++){const n=s[i];t.fillStyle="white";const[o,r,p,c]=n.transformPoints(e),a=new Path2D;t.globalAlpha=.5,(0,M.Ao)(a,o),(0,M.kZ)(a,r),n instanceof L?((0,M.Ao)(a,p),(0,M.kZ)(a,c),t.beginPath(),t.stroke(a)):((0,M.kZ)(a,p),t.beginPath(),t.stroke(a)),t.globalAlpha=1,t.lineWidth=2,(0,M.Ao)(t,o),t.beginPath(),(0,M.Nb)(t,o,4),t.closePath(),t.stroke(),t.fill(),i===s.length-1&&void 0!==c&&((0,M.Ao)(t,c),t.beginPath(),(0,M.Nb)(t,c,4),t.closePath(),t.stroke(),t.fill()),t.fillStyle="black";for(const e of[r,p])e.magnitude>0&&((0,M.Ao)(t,e),t.beginPath(),(0,M.Nb)(t,e,4),t.closePath(),t.fill(),t.stroke())}t.lineWidth=1,t.beginPath(),(0,M.wp)(t,r),t.stroke(),t.beginPath(),(0,M.pS)(t,o),t.closePath(),t.stroke()}isKnot(t){return t instanceof nt}}Nt([(0,h.nn)(.4),(0,h.td)()],St.prototype,"smoothness",void 0),Nt([(0,h.nn)(null),(0,h.td)()],St.prototype,"points",void 0),Nt([(0,N.F)()],St.prototype,"profile",null),Nt([(0,N.F)()],St.prototype,"knots",null),Nt([(0,N.F)()],St.prototype,"childrenBBox",null),Nt([(0,N.F)()],St.prototype,"getTightBBox",null);var Rt=n(70419),zt=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class Pt extends d.b{constructor(t){let{children:e,...n}=t;super(n),e&&this.text(e)}draw(t){this.requestFontUpdate(),this.applyStyle(t),this.applyText(t),t.font=this.styles.font,"letterSpacing"in t&&(t.letterSpacing=`${this.letterSpacing()}px`);const e=this.element.getBoundingClientRect(),{width:n,height:o}=this.size(),r=document.createRange();let s="";const p=new x.b;for(const i of this.element.childNodes){if(!i.textContent)continue;r.selectNodeContents(i);const c=r.getBoundingClientRect(),a=n/-2+c.left-e.left,l=o/-2+c.top-e.top;p.y===l?(p.width+=c.width,s+=i.textContent):(this.drawText(t,s,p),p.x=a,p.y=l,p.width=c.width,p.height=c.height,s=i.textContent)}this.drawText(t,s,p)}drawText(t,e,n){const o=n.y+n.height/2;t.save(),t.textBaseline="middle",this.lineWidth()<=0?t.fillText(e,n.x,o):this.strokeFirst()?(t.strokeText(e,n.x,o),t.fillText(e,n.x,o)):(t.fillText(e,n.x,o),t.strokeText(e,n.x,o)),t.restore()}formattedText(){return Pt.formatter.innerText=this.text(),Pt.formatter.innerText}updateLayout(){this.applyFont(),this.applyFlex(),this.justifyContent.isInitial()&&(this.element.style.justifyContent=this.styles.getPropertyValue("text-align"));if("nowrap"!==this.styles.whiteSpace&&"pre"!==this.styles.whiteSpace)if(this.element.innerText="",Pt.segmenter)for(const t of Pt.segmenter.segment(this.formattedText()))this.element.appendChild(document.createTextNode(t.segment));else for(const t of this.formattedText().split(""))this.element.appendChild(document.createTextNode(t));else if("pre"===this.styles.whiteSpace){this.element.innerText="";for(const t of this.text().split("\n"))this.element.appendChild(document.createTextNode(t+"\n"))}else this.element.innerText=this.formattedText()}}zt([(0,h.nn)(""),(0,h.JI)(_.JC),(0,h.td)()],Pt.prototype,"text",void 0),zt([(0,N.F)()],Pt.prototype,"formattedText",null),zt([(0,v.V)((()=>{const t=document.createElement("div");return Rt.h.shadowRoot.append(t),t}))],Pt,"formatter",void 0),zt([(0,v.V)((()=>{try{return new Intl.Segmenter(void 0,{granularity:"grapheme"})}catch(t){return null}}))],Pt,"segmenter",void 0);var At=n(56632),It=n(88733),Wt=function(t,e,n,o){var r,s=arguments.length,p=s<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(r=t[i])&&(p=(s<3?r(p):s>3?r(e,n,p):r(e,n))||p);return s>3&&p&&Object.defineProperty(e,n,p),p};class Et extends B.U{constructor(t){let{play:e,...n}=t;super(n),this.lastTime=-1,e&&this.play()}isPlaying(){return this.playing()}getCurrentTime(){return this.clampTime(this.time())}getDuration(){return this.video().duration}desiredSize(){const t=super.desiredSize();if(null===t.x&&null===t.y){const t=this.video();return{x:t.videoWidth,y:t.videoHeight}}return t}completion(){return this.clampTime(this.time())/this.video().duration}video(){const t=this.src(),e=`${this.key}/${t}`;let n=Et.pool[e];return n||(n=document.createElement("video"),n.src=t,Et.pool[e]=n),n.readyState<2&&F.k.collectPromise(new Promise((t=>{const e=()=>{t(),n.removeEventListener("canplay",e)};n.addEventListener("canplay",e)}))),n}seekedVideo(){const t=this.video(),e=this.clampTime(this.time());return t.paused||t.pause(),this.lastTime===e||this.setCurrentTime(e),t}fastSeekedVideo(){const t=this.video(),e=this.clampTime(this.time());if(this.lastTime===e)return t;const n=this.playing()&&e<t.duration;return n?t.paused&&F.k.collectPromise(t.play()):t.paused||t.pause(),Math.abs(t.currentTime-e)>.2?this.setCurrentTime(e):n||(t.currentTime=e),t}draw(t){this.drawShape(t),this.clip()&&t.clip(this.getPath());const e=this.alpha();if(e>0){const n=this.view().playbackState(),o=n===It.q.Playing||n===It.q.Presenting?this.fastSeekedVideo():this.seekedVideo(),r=x.b.fromSizeCentered(this.computedSize());t.save(),e<1&&(t.globalAlpha*=e),t.imageSmoothingEnabled=this.smoothing(),(0,M.AE)(t,o,r),t.restore()}this.drawChildren(t)}applyFlex(){super.applyFlex();const t=this.video();this.element.style.aspectRatio=(this.ratio()??t.videoWidth/t.videoHeight).toString()}setCurrentTime(t){const e=this.video();e.readyState<2||(e.currentTime=t,this.lastTime=t,e.seeking&&F.k.collectPromise(new Promise((t=>{const n=()=>{t(),e.removeEventListener("seeked",n)};e.addEventListener("seeked",n)}))))}play(){const t=(0,At.nn)().time,e=t()-this.time();this.playing(!0),this.time((()=>this.clampTime(t()-e)))}pause(){this.playing(!1),this.time.save(),this.video().pause()}seek(t){const e=this.playing();this.time(this.clampTime(t)),e?this.play():this.pause()}clampTime(t){const e=this.video().duration;return this.loop()&&(t%=e),(0,_.uZ)(0,e,t)}collectAsyncResources(){super.collectAsyncResources(),this.seekedVideo()}}Et.pool={},Wt([(0,h.td)()],Et.prototype,"src",void 0),Wt([(0,h.nn)(1),(0,h.td)()],Et.prototype,"alpha",void 0),Wt([(0,h.nn)(!0),(0,h.td)()],Et.prototype,"smoothing",void 0),Wt([(0,h.nn)(!1),(0,h.td)()],Et.prototype,"loop",void 0),Wt([(0,h.nn)(0),(0,h.td)()],Et.prototype,"time",void 0),Wt([(0,h.nn)(!1),(0,h.td)()],Et.prototype,"playing",void 0),Wt([(0,N.F)()],Et.prototype,"completion",null),Wt([(0,N.F)()],Et.prototype,"video",null),Wt([(0,N.F)()],Et.prototype,"seekedVideo",null),Wt([(0,N.F)()],Et.prototype,"fastSeekedVideo",null);var Bt=n(5376),Ft=n(51284),Ot=n(42075),Gt=n(67292);function*jt(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];for(const o of e)yield o;yield*(0,Ft.v)(!1,...e)}(0,Ot.G)(jt,(0,Gt.C)());var Ut=n(80638);function*qt(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];for(const o of e)(0,Ut.R)(o)?yield*o:o()}(0,Ot.G)(qt,(0,Gt.C)());var Vt=n(84266);function*Ht(t,e){yield*(0,Vt.X)(t),(0,Ut.R)(e)?yield*e:e()}(0,Ot.G)(Ht,(0,Gt.C)());var $t=n(97715);function Qt(t,e){let n=!1;function*o(){const o=(0,$t.te)();let r=0,s=0;for(e(s),n=!0;;)r>=o.secondsToFrames(t)?(r=0,s++,e(s),n=!0):n=!1,r++,yield}return(0,Ot.G)(o,(0,Gt.C)("every")),{runner:o(),setInterval(e){t=e,n=!1},setCallback(t){e=t,n=!1},*sync(){for(;!n;)yield}}}function*Jt(t,e){for(let n=0;n<t;n++){const t=e(n);t?yield*t:yield}}function*Yt(t,e){const n=(0,At.nn)(),o=(0,$t.te)().framesToSeconds(1),r=n.time()+t;let s=0;for(;r-o>n.fixed;){const t=e(s);t?yield*t:yield,s+=1}n.time(r)}(0,Ot.G)(Jt,(0,Gt.C)()),(0,Ot.G)(Yt,(0,Gt.C)());var Kt=n(30092);function*te(t,e){yield*Yt((0,Kt.Y)(t),e)}function*ee(){}(0,Ot.G)(te,(0,Gt.C)()),(0,Ot.G)(ee,(0,Gt.C)());var ne=n(77396);function*oe(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),o=1;o<e;o++)n[o-1]=arguments[o];for(const r of n)yield r,yield*(0,Vt.X)(t);yield*(0,Ft.v)(...n)}function*re(t){const{slides:e}=(0,O.$r)(),n=(0,At.nn)();for(e.register(t,n.fixed),yield;e.shouldWait(t);)yield}(0,Ot.G)(oe,(0,Gt.C)());var se=n(15688);function pe(t){switch(typeof t){case"string":return t;case"undefined":return"undefined";default:return Number.isNaN(t)?"NaN":JSON.stringify(t)}}function ie(t){const e={message:pe(t)};t&&"object"==typeof t&&(e.object=t),(0,O.wL)().debug(e)}function ce(t,e,n){return function(){(0,O.wL)().warn({message:e,remarks:n,stack:(new Error).stack});for(var o=arguments.length,r=new Array(o),s=0;s<o;s++)r[s]=arguments[s];return t.apply(this,r)}}var ae=n(49111),le=n(90031),ue=n(1119),me=n(37762),de=n(15649),he=n(11726);function fe(t,e){return void 0===e&&(e=!0),"number"==typeof t?new he.k(e?t:t+(0,O.$r)().meta.seed.get()):(0,O.$r)().random}function ye(){let t;return e=>{if(void 0===e)return t;t=e}}function ke(t,e){return n=>{t[e]=n}}function we(){return{}}function Me(){return(0,At.nn)().time()}function De(t){return(0,O.$r)().lifecycleEvents.onBeginRender.subscribe(t)}function _e(t){return(0,O.$r)().lifecycleEvents.onFinishRender.subscribe(t)}var ge=n(46096),Xe=n(81865),xe=n(73662),Ce=n(97140);function Te(t,e){let n;void 0===e&&(e=null);const o=(0,Ce.g)(t);return(0,xe.D)((()=>{const t=o();var r;n&&n.promise===t||(n=Xe.h.collectPromise(t,(null==(r=n)?void 0:r.value)??e));return n.value}))}var ve=n(16249),be=n(60771),Le=n(74741),Ze=n(57292);class Ne{static fromRotation(t){return Ne.identity.rotate(t)}static fromTranslation(t){return Ne.identity.translate(new w.F(t))}static fromScaling(t){return Ne.identity.scale(new w.F(t))}get x(){return new w.F(this.values[0],this.values[1])}get y(){return new w.F(this.values[2],this.values[3])}get scaleX(){return this.values[0]}set scaleX(t){this.values[0]=this.x.normalized.scale(t).x}set scaleY(t){this.values[3]=this.y.normalized.scale(t).y}get scaleY(){return this.values[3]}set translateX(t){this.values[4]=t}get translateX(){return this.values[4]}set translateY(t){this.values[5]=t}get translateY(){return this.values[5]}set rotation(t){const e=this.rotate(t-this.rotation);this.values[0]=e.values[0],this.values[1]=e.values[1],this.values[2]=e.values[2],this.values[3]=e.values[3]}get rotation(){return w.F.degrees(this.values[0],this.values[1])}set translation(t){const e=new w.F(t);this.values[4]=e.x,this.values[5]=e.y}get translation(){return new w.F(this.values[4],this.values[5])}set scaling(t){const e=new w.F(t),n=new w.F(this.values[0],this.values[1]).normalized,o=new w.F(this.values[2],this.values[3]).normalized;this.values[0]=n.x*e.x,this.values[1]=n.y*e.y,this.values[2]=o.x*e.x,this.values[3]=o.y*e.y}get scaling(){return new w.F(this.values[0],this.values[3])}get inverse(){const t=this.values[0],e=this.values[1],n=this.values[2],o=this.values[3],r=this.values[4],s=this.values[5];let p=t*o-e*n;return p?(p=1/p,new Ne(o*p,-e*p,-n*p,t*p,(n*s-o*r)*p,(e*r-t*s)*p)):null}get determinant(){return this.values[0]*this.values[3]-this.values[1]*this.values[2]}get domMatrix(){return new DOMMatrix([this.values[0],this.values[1],this.values[2],this.values[3],this.values[4],this.values[5]])}constructor(t,e,n,o,r,s){if(this.values=new Float32Array(6),0===arguments.length)return void(this.values=new Float32Array([1,0,0,1,0,0]));if(6===arguments.length)return this.values[0]=t,this.values[1]=e,this.values[2]=n,this.values[3]=o,this.values[4]=r,void(this.values[5]=s);if(t instanceof Ne)return void(this.values=t.values);if(Array.isArray(t)){if(2===t.length)return this.values[0]=t[0],this.values[1]=t[1],this.values[2]=e[0],this.values[3]=e[1],this.values[4]=n[0],void(this.values[5]=n[1]);if(3===t.length){const e=new w.F(t[0]),n=new w.F(t[1]),o=new w.F(t[2]);return this.values[0]=e.x,this.values[1]=e.y,this.values[2]=n.x,this.values[3]=n.y,this.values[4]=o.x,void(this.values[5]=o.y)}return this.values[0]=t[0],this.values[1]=t[1],this.values[2]=t[2],this.values[3]=t[3],this.values[4]=t[4],void(this.values[5]=t[5])}const p=new w.F(t),i=new w.F(e),c=new w.F(n);this.values[0]=p.x,this.values[1]=p.y,this.values[2]=i.x,this.values[3]=i.y,this.values[4]=c.x,this.values[5]=c.y}column(t){return new w.F(this.values[2*t],this.values[2*t+1])}row(t){return[this.values[t],this.values[t+2],this.values[t+4]]}mul(t){const e=this.values[0],n=this.values[1],o=this.values[2],r=this.values[3],s=this.values[4],p=this.values[5],i=t.values[0],c=t.values[1],a=t.values[2],l=t.values[3],u=t.values[4],m=t.values[5];return new Ne(e*i+o*c,n*i+r*c,e*a+o*l,n*a+r*l,e*u+o*m+s,n*u+r*m+p)}rotate(t,e){void 0===e&&(e=!0),e&&(t*=f.q);const n=this.values[0],o=this.values[1],r=this.values[2],s=this.values[3],p=this.values[4],i=this.values[5],c=Math.sin(t),a=Math.cos(t);return new Ne(n*a+r*c,o*a+s*c,n*-c+r*a,o*-c+s*a,p,i)}scale(t){const e=new w.F(t);return new Ne(this.values[0]*e.x,this.values[1]*e.x,this.values[2]*e.y,this.values[3]*e.y,this.values[4],this.values[5])}mulScalar(t){return new Ne(this.values[0]*t,this.values[1]*t,this.values[2]*t,this.values[3]*t,this.values[4]*t,this.values[5]*t)}translate(t){const e=new w.F(t);return new Ne(this.values[0],this.values[1],this.values[2],this.values[3],this.values[0]*e.x+this.values[2]*e.y+this.values[4],this.values[1]*e.x+this.values[3]*e.y+this.values[5])}add(t){return new Ne(this.values[0]+t.values[0],this.values[1]+t.values[1],this.values[2]+t.values[2],this.values[3]+t.values[3],this.values[4]+t.values[4],this.values[5]+t.values[5])}sub(t){return new Ne(this.values[0]-t.values[0],this.values[1]-t.values[1],this.values[2]-t.values[2],this.values[3]-t.values[3],this.values[4]-t.values[4],this.values[5]-t.values[5])}toSymbol(){return Ne.symbol}equals(t,e){return void 0===e&&(e=Ze.I),Math.abs(this.values[0]-t.values[0])<=e+Number.EPSILON&&Math.abs(this.values[1]-t.values[1])<=e+Number.EPSILON&&Math.abs(this.values[2]-t.values[2])<=e+Number.EPSILON&&Math.abs(this.values[3]-t.values[3])<=e+Number.EPSILON&&Math.abs(this.values[4]-t.values[4])<=e+Number.EPSILON&&Math.abs(this.values[5]-t.values[5])<=e+Number.EPSILON}exactlyEquals(t){return this.values[0]===t.values[0]&&this.values[1]===t.values[1]&&this.values[2]===t.values[2]&&this.values[3]===t.values[3]&&this.values[4]===t.values[4]&&this.values[5]===t.values[5]}}Ne.symbol=Symbol.for("@motion-canvas/core/types/Matrix2D"),Ne.identity=new Ne(1,0,0,1,0,0),Ne.zero=new Ne(0,0,0,0,0,0);var Se=n(98378),Re=n(43188),ze=n(97074),Pe=n(74534);function*Ae(t,e,n,o,r,s){const p="number"==typeof o?o:.001;s="number"==typeof o?s:r;const i=(t,e)=>{"function"==typeof o?o(t,e):"function"==typeof r&&r(t,e)};if((t=t??{mass:.05,stiffness:10,damping:.5}).mass<=0)return void(0,O.wL)().error(new Error("Spring mass must be greater than 0."));if(t.stiffness<0)return void(0,O.wL)().error(new Error("Spring stiffness must be greater or equal to 0."));if(t.damping<0)return void(0,O.wL)().error(new Error("Spring damping must be greater or equal to 0."));const c=(0,At.nn)();let a=e,l=t.initialVelocity??0;const u=e=>{if(null===t)return;const o=a-n,r=-t.stiffness*o-t.damping*l;l+=r/t.mass*e,a+=l*e},m=1/120;i(e,0);const d=c.time();let h=d,f=!1;for(;!f;){for(;h<c.fixed;){const t=c.fixed-h;if(m>t?(u(t),h=c.fixed):(u(m),h+=m),Math.abs(n-a)<p&&Math.abs(l)<p){c.time(h),f=!0;break}}f||(i(a,c.fixed-d),yield)}i(n,c.fixed-d),null==s||s(n,c.fixed-d)}function Ie(t,e,n,o){return{mass:t,stiffness:e,damping:n,initialVelocity:o}}(0,Ot.G)(Ae,(0,Gt.C)());const We=Ie(.13,5.7,1.2,10),Ee=Ie(.2,20,.68,0),Be=Ie(.08,4.75,.05,0),Fe=Ie(.39,19.85,2.82,0),Oe=Ie(.04,10,.7,8),Ge=Ie(.03,20,.9,4.8),je=Ie(.16,15.35,1.88,0);function Ue(){const t=(0,At.nn)();for(var e=arguments.length,n=new Array(e),o=0;o<e;o++)n[o]=arguments[o];for(const r of n){const e=t.children.find((t=>t.runner===r));e&&!e.canceled&&(e.cancel(),e.time(t.time()))}}var qe=n(75168),Ve=n(50580),He=n(5881);const $e={...o,...r,...s,...p,...i,...c,...a,_Fragment:u,_jsx:m,_jsxs:m,makeScene2D:l.r}},53487:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{v:()=>transform});var _babel_standalone__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(87243),_babel_standalone__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(_babel_standalone__WEBPACK_IMPORTED_MODULE_0__),_site_src_components_Fiddle_runtime__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(74391);function transform(code){try{const result=_babel_standalone__WEBPACK_IMPORTED_MODULE_0__.transform(code,{filename:"fiddle.tsx",presets:["typescript",["react",{runtime:"automatic",importSource:"@motion-canvas/2d/lib"}]],plugins:["mc"]});eval(result.code)}catch(e){return e}return null}_babel_standalone__WEBPACK_IMPORTED_MODULE_0__.registerPlugin("mc",(t=>{let{types:e}=t;return{visitor:{Program(t){t.node.body.unshift(e.variableDeclaration("const",[e.variableDeclarator(e.objectPattern(Object.keys(_site_src_components_Fiddle_runtime__WEBPACK_IMPORTED_MODULE_1__.Z).map((t=>e.objectProperty(e.identifier(t),e.identifier(t),!1,!0)))),e.memberExpression(e.identifier("window"),e.identifier("mc")))]))},ImportDeclaration(t){t.remove()},ExportDefaultDeclaration(t){t.replaceWith(t.node.declaration)}}}}))},70532:(t,e,n)=>{"use strict";n.d(e,{Z:()=>l});var o=n(2784),r=n(89741);const s="tooltip_lI6R",p="active_DOSD";var i=n(6277),c=n(88617),a=n(79322);function l(t){let{children:e}=t;const n=(0,r.Z)(),l=(0,c.rG)(),[u,m]=(0,o.useState)(!1),[d,h]=(0,o.useState)(null),f=(0,o.useRef)(),y=(0,o.useRef)(),k=(0,o.useRef)(),w=(0,o.useCallback)((()=>{if(!y.current||!k.current)return;const t=y.current.getBoundingClientRect();let e=window.innerWidth-t.left-496;e<0&&(e=0),k.current.style.right=`${e}px`,k.current.style.top=`${t.bottom}px`}),[]);return(0,o.useEffect)((()=>{if(!n)return;const t=t=>{var e,n,o;if(!t.target.href||null==(e=f.current)||!e.contains(t.target)||null!=(n=k.current)&&n.contains(t.target))return;const r=new URL(t.target.href,document.baseURI);if(r.pathname===window.location.pathname)return;const s=l(r.pathname+r.hash);null!=s&&null!=(o=s.comment)&&o.summary&&(y.current=t.target,m(!0),h(s.comment),w())},e=t=>{t.target===y.current&&m(!1)};return document.addEventListener("mouseenter",t,!0),document.addEventListener("focus",t,!0),document.addEventListener("mouseleave",e,!0),document.addEventListener("blur",e,!0),document.addEventListener("scroll",w),()=>{document.removeEventListener("mouseenter",t,!0),document.removeEventListener("focus",t,!0),document.removeEventListener("mouseleave",e,!0),document.removeEventListener("blur",e,!0),document.removeEventListener("scroll",w)}}),[n]),(0,o.useEffect)((()=>{w()})),o.createElement("div",{ref:f},e,o.createElement("div",{ref:k,className:(0,i.Z)(s,"padding--md margin-horiz--md",u&&p)},d&&o.createElement(a.Z,{comment:d,full:!1})))}},88617:(t,e,n)=>{"use strict";n.d(e,{Gr:()=>a,RU:()=>p,gs:()=>s,in:()=>i,rG:()=>c});var o=n(2784);const r=o.createContext({lookup:{},urlLookup:{}});function s(t){let{children:e,lookup:n,urlLookup:s}=t;return o.createElement(r.Provider,{value:{lookup:n,urlLookup:s}},e)}function p(t){const{lookup:e}=(0,o.useContext)(r);return e[t]}function i(){const{lookup:t}=(0,o.useContext)(r);return e=>{if("number"==typeof(null==e?void 0:e.project))return t[e.project][e.id]}}function c(){const{urlLookup:t,lookup:e}=(0,o.useContext)(r);return n=>{var o;const r=t[n];return r?(null==(o=e[r.projectId])?void 0:o[r.id])??null:null}}function a(t){if(t)return t.href}},80068:(t,e,n)=>{"use strict";n.d(e,{Ld:()=>i,Y0:()=>p,s2:()=>c});var o=n(2784),r=n(50822);const s=o.createContext(null);function p(t){let{children:e}=t;const n=(0,r.p)(),p=(0,o.useMemo)((()=>function(t,e){const{plain:n}=t,o=Object.create(null),r=t.styles.reduce(((t,n)=>{const{languages:o,style:r}=n;return o&&!o.includes(e)||n.types.forEach((e=>{t[e]={...t[e],...r}})),t}),o);return r.root=n,r.plain={...n,backgroundColor:null},r}(n,"typescript")),[n]);return o.createElement(s.Provider,{value:p},e)}function i(t){void 0===t&&(t="plain");const e=(0,o.useContext)(s);return{className:`token ${t}`,style:e[t]??e.plain}}function c(t){void 0===t&&(t="plain");const e=(0,o.useContext)(s);return e[t]??e.plain}},57708:(t,e,n)=>{"use strict";n.d(e,{It:()=>m,Wy:()=>l,mN:()=>u});var o=n(2784),r=n(31263),s=n(89741);const p="api-filters",i=r.Z.canUseDOM?localStorage.getItem(p):null,c=i?JSON.parse(i):{inherited:!0,private:!1},a=o.createContext([c,()=>{}]);function l(t){let{children:e}=t;const[n,r]=(0,o.useState)(c),i=(0,s.Z)();return o.createElement(a.Provider,{value:[n,t=>{i&&localStorage.setItem(p,JSON.stringify(t)),r(t)}]},e)}function u(){return(0,o.useContext)(a)}function m(t,e){var n,o;const r=(null==(n=e.flags)?void 0:n.isPrivate)||(null==(o=e.flags)?void 0:o.isProtected);if(!t.private&&r)return!1;const s=!!e.inheritedFrom;return!(!t.inherited&&s)}},26047:(t,e,n)=>{"use strict";n.d(e,{Z:()=>u});var o=n(7896),r=n(2784),s=n(59055);const p="icon_Fw4I";function i(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"}))}function c(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"}))}function a(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"}))}function l(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"}))}function u(t){const e=(0,r.useMemo)((()=>{switch(t.type){case"tip":return l;case"caution":return c;case"danger":return a;default:return i}}),[t.type]);return r.createElement(r.Fragment,null,r.createElement(s.Z,(0,o.Z)({icon:r.createElement(e,{className:p})},t)))}},94141:(t,e,n)=>{"use strict";n.d(e,{Z:()=>i});var o=n(7896),r=n(2784),s=n(6277);const p="iconEdit_N_05";function i(t){let{className:e,...n}=t;return r.createElement("svg",(0,o.Z)({fill:"currentColor",width:"24px",height:"24px",viewBox:"0 0 24 24",className:(0,s.Z)(p,e),"aria-hidden":"true"},n),r.createElement("path",{d:"M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"}))}},44648:(t,e,n)=>{"use strict";n.d(e,{Z:()=>s});var o=n(7896),r=n(2784);function s(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",style:{width:16,height:16,marginTop:"0.1rem"}},t),r.createElement("path",{d:"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z",fill:"currentColor"}))}},29459:(t,e,n)=>{"use strict";n.d(e,{Z:()=>i});var o=n(2784),r=n(52203),s=n(26773),p=n(78128);const i={...r.Z,pre:function(t){var e,n;return(0,o.isValidElement)(t.children)&&null!=(e=t.children.props)&&e.editor?o.createElement(s.Z,t.children.props):o.createElement(p.Z,(0,o.isValidElement)(t.children)&&"code"===(null==(n=t.children.props)?void 0:n.originalType)?t.children.props:{...t})}}},47733:(t,e,n)=>{"use strict";n.d(e,{Z:()=>i});var o=n(7896),r=n(2784),s=n(77287);const p="root_ZAv1";function i(t){const e=r.Children.toArray(t.children),n=e.find((t=>{var e;return r.isValidElement(t)&&"summary"===(null==(e=t.props)?void 0:e.mdxType)})),i=r.createElement(r.Fragment,null,e.filter((t=>t!==n)));return r.createElement(r.Fragment,null,r.createElement(s.P,(0,o.Z)({},t,{summary:n,className:p}),i))}},46155:(t,e,n)=>{var o={"./locale":99394,"./locale.js":99394};function r(t){var e=s(t);return n(e)}function s(t){if(!n.o(o,t)){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}return o[t]}r.keys=function(){return Object.keys(o)},r.resolve=s,t.exports=r,r.id=46155}}]);
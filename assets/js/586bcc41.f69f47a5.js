(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[3239],{61532:t=>{function e(t){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}e.keys=()=>[],e.resolve=e,e.id=61532,t.exports=e},70989:(t,e,n)=>{"use strict";n.d(e,{A:()=>w});var o=n(93091),s=n(88104),r=n(15688);function i(t,e){return void 0===e&&(e=t=>t),(n,o)=>{n[`getDefault${(0,r.k)(o)}`]=function(){this.requestLayoutUpdate();const n=this.element.style[t];this.element.style[t]="";const o=e.call(this,this.styles.getPropertyValue(t));return this.element.style[t]=n,o}}}var a=n(46350),p=n(29797),c=n(23357),l=n(98378),u=n(74534),m=n(67292),d=n(20092),h=n(11258),y=n(53693),f=n(97140),k=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class w extends d.N{get columnGap(){return this.gap.x}get rowGap(){return this.gap.y}getX(){return this.isLayoutRoot()?this.customX():this.computedPosition().x}setX(t){this.customX(t)}getY(){return this.isLayoutRoot()?this.customY():this.computedPosition().y}setY(t){this.customY(t)}getWidth(){return this.computedSize().width}setWidth(t){this.customWidth(t)}*tweenWidth(t,e,n,o){const s=this.desiredSize().x,r="number"!=typeof s||"number"!=typeof t;let i,a;i=r?this.size.x():s,r?(this.size.x(t),a=this.size.x()):a=t,this.size.x(i),r&&this.lockSize(),yield*(0,u.i)(e,(t=>this.size.x(o(i,a,n(t))))),this.size.x(t),r&&this.releaseSize()}getHeight(){return this.computedSize().height}setHeight(t){this.customHeight(t)}*tweenHeight(t,e,n,o){const s=this.desiredSize().y,r="number"!=typeof s||"number"!=typeof t;let i,a;i=r?this.size.y():s,r?(this.size.y(t),a=this.size.y()):a=t,this.size.y(i),r&&this.lockSize(),yield*(0,u.i)(e,(t=>this.size.y(o(i,a,n(t))))),this.size.y(t),r&&this.releaseSize()}get width(){return this.size.x}get height(){return this.size.y}desiredSize(){return{x:this.customWidth(),y:this.customHeight()}}*tweenSize(t,e,n,o){const s=this.desiredSize();let r,i;r="number"!=typeof s.x||"number"!=typeof s.y?this.size():new p.F(s),"object"==typeof t&&"number"==typeof t.x&&"number"==typeof t.y?i=new p.F(t):(this.size(t),i=this.size()),this.size(r),this.lockSize(),yield*(0,u.i)(e,(t=>this.size(o(r,i,n(t))))),this.releaseSize(),this.size(t)}constructor(t){let{tagName:e="div",...n}=t;super(n),this.sizeLockCounter=(0,f.g)(0),this.element=document.createElement(e),this.element.style.display="flex",this.element.style.boxSizing="border-box",this.styles=getComputedStyle(this.element)}lockSize(){this.sizeLockCounter(this.sizeLockCounter()+1)}releaseSize(){this.sizeLockCounter(this.sizeLockCounter()-1)}parentTransform(){let t=this.parent();for(;t;){if(t instanceof w)return t;t=t.parent()}return null}anchorPosition(){const t=this.computedSize(),e=this.offset();return t.scale(.5).mul(e)}layoutEnabled(){var t;return this.layout()??(null==(t=this.parentTransform())?void 0:t.layoutEnabled())??!1}isLayoutRoot(){var t;return!this.layoutEnabled()||!(null!=(t=this.parentTransform())&&t.layoutEnabled())}localToParent(){const t=new DOMMatrix,e=this.size().mul(this.offset()).scale(-.5);return t.translateSelf(this.position.x(),this.position.y()),t.rotateSelf(0,0,this.rotation()),t.scaleSelf(this.scale.x(),this.scale.y()),t.translateSelf(e.x,e.y),t}getComputedLayout(){return new c.b(this.element.getBoundingClientRect())}computedPosition(){this.requestLayoutUpdate();const t=this.getComputedLayout(),e=new p.F(t.x+t.width/2*this.offset.x(),t.y+t.height/2*this.offset.y()),n=this.parentTransform();if(n){const o=n.getComputedLayout();e.x-=o.x+(o.width-t.width)/2,e.y-=o.y+(o.height-t.height)/2}return e}computedSize(){return this.requestLayoutUpdate(),this.getComputedLayout().size}requestLayoutUpdate(){const t=this.parentTransform();this.appendedToView()?(null==t||t.requestFontUpdate(),this.updateLayout()):t.requestLayoutUpdate()}appendedToView(){const t=this.isLayoutRoot();return t&&this.view().element.append(this.element),t}updateLayout(){if(this.applyFont(),this.applyFlex(),this.layoutEnabled()){const t=this.layoutChildren();for(const e of t)e.updateLayout()}}layoutChildren(){const t=[...this.children()],e=[],n=[];for(;t.length;){const o=t.shift();o instanceof w?(e.push(o),n.push(o.element)):o&&t.unshift(...o.children())}return this.element.replaceChildren(...n),e}requestFontUpdate(){var t;null==(t=this.parentTransform())||t.requestFontUpdate(),this.applyFont()}getCacheBBox(){return c.b.fromSizeCentered(this.computedSize())}draw(t){if(this.clip()){const e=this.computedSize();if(0===e.width||0===e.height)return;t.beginPath(),t.rect(e.width/-2,e.height/-2,e.width,e.height),t.closePath(),t.clip()}this.drawChildren(t)}drawOverlay(t,e){const n=this.computedSize(),o=n.mul(this.offset()).scale(.5).transformAsPoint(e),s=c.b.fromSizeCentered(n),r=s.transformCorners(e),i=s.addSpacing(this.padding().scale(-1)).transformCorners(e),a=s.addSpacing(this.margin()).transformCorners(e);t.beginPath(),(0,h.pS)(t,a),(0,h.pS)(t,r),t.closePath(),t.fillStyle="rgba(255,193,125,0.6)",t.fill("evenodd"),t.beginPath(),(0,h.pS)(t,r),(0,h.pS)(t,i),t.closePath(),t.fillStyle="rgba(180,255,147,0.6)",t.fill("evenodd"),t.beginPath(),(0,h.pS)(t,r),t.closePath(),t.lineWidth=1,t.strokeStyle="white",t.stroke();t.beginPath(),(0,h.kZ)(t,o.addY(-8)),(0,h.kZ)(t,o.addY(8)),(0,h.kZ)(t,o),(0,h.kZ)(t,o.addX(-8)),t.arc(o.x,o.y,8,0,2*Math.PI),t.stroke()}getOriginDelta(t){const e=this.computedSize().scale(.5),n=this.offset().mul(e);if(t===l.aP.Middle)return n.flipped;return(0,l.WS)(t).mul(e).sub(n)}moveOffset(t){const e=this.computedSize().scale(.5),n=this.offset().mul(e),o=t.mul(e);this.offset(t),this.position(this.position().add(o).sub(n))}parsePixels(t){return null===t?"":`${t}px`}parseLength(t){return null===t?"":"string"==typeof t?t:`${t}px`}applyFlex(){this.element.style.position=this.isLayoutRoot()?"absolute":"relative";const t=this.desiredSize();this.element.style.width=this.parseLength(t.x),this.element.style.height=this.parseLength(t.y),this.element.style.maxWidth=this.parseLength(this.maxWidth()),this.element.style.minWidth=this.parseLength(this.minWidth()),this.element.style.maxHeight=this.parseLength(this.maxHeight()),this.element.style.minHeight=this.parseLength(this.minHeight()),this.element.style.aspectRatio=null===this.ratio()?"":this.ratio().toString(),this.element.style.marginTop=this.parsePixels(this.margin.top()),this.element.style.marginBottom=this.parsePixels(this.margin.bottom()),this.element.style.marginLeft=this.parsePixels(this.margin.left()),this.element.style.marginRight=this.parsePixels(this.margin.right()),this.element.style.paddingTop=this.parsePixels(this.padding.top()),this.element.style.paddingBottom=this.parsePixels(this.padding.bottom()),this.element.style.paddingLeft=this.parsePixels(this.padding.left()),this.element.style.paddingRight=this.parsePixels(this.padding.right()),this.element.style.flexDirection=this.direction(),this.element.style.flexBasis=this.parseLength(this.basis()),this.element.style.flexWrap=this.wrap(),this.element.style.justifyContent=this.justifyContent(),this.element.style.alignContent=this.alignContent(),this.element.style.alignItems=this.alignItems(),this.element.style.alignSelf=this.alignSelf(),this.element.style.columnGap=this.parseLength(this.gap.x()),this.element.style.rowGap=this.parseLength(this.gap.y()),this.sizeLockCounter()>0?(this.element.style.flexGrow="0",this.element.style.flexShrink="0"):(this.element.style.flexGrow=this.grow().toString(),this.element.style.flexShrink=this.shrink().toString())}applyFont(){if(this.element.style.fontFamily=this.fontFamily.isInitial()?"":this.fontFamily(),this.element.style.fontSize=this.fontSize.isInitial()?"":`${this.fontSize()}px`,this.element.style.fontStyle=this.fontStyle.isInitial()?"":this.fontStyle(),this.lineHeight.isInitial())this.element.style.lineHeight="";else{const t=this.lineHeight();this.element.style.lineHeight="string"==typeof t?(parseFloat(t)/100).toString():`${t}px`}if(this.element.style.fontWeight=this.fontWeight.isInitial()?"":this.fontWeight().toString(),this.element.style.letterSpacing=this.letterSpacing.isInitial()?"":`${this.letterSpacing()}px`,this.element.style.textAlign=this.textAlign.isInitial()?"":this.textAlign(),this.textWrap.isInitial())this.element.style.whiteSpace="";else{const t=this.textWrap();this.element.style.whiteSpace="boolean"==typeof t?t?"normal":"nowrap":t}}dispose(){var t;super.dispose(),null==(t=this.sizeLockCounter)||t.context.dispose(),this.element&&(this.element.remove(),this.element.innerHTML=""),this.element=null,this.styles=null}hit(t){const e=t.transformAsPoint(this.localToParent().inverse());return this.cacheBBox().includes(e)?super.hit(t)??this:null}}k([(0,o.nn)(null),(0,o.td)()],w.prototype,"layout",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"maxWidth",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"maxHeight",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"minWidth",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"minHeight",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"ratio",void 0),k([(0,y.g)("margin")],w.prototype,"margin",void 0),k([(0,y.g)("padding")],w.prototype,"padding",void 0),k([(0,o.nn)("row"),(0,o.td)()],w.prototype,"direction",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"basis",void 0),k([(0,o.nn)(0),(0,o.td)()],w.prototype,"grow",void 0),k([(0,o.nn)(1),(0,o.td)()],w.prototype,"shrink",void 0),k([(0,o.nn)("nowrap"),(0,o.td)()],w.prototype,"wrap",void 0),k([(0,o.nn)("start"),(0,o.td)()],w.prototype,"justifyContent",void 0),k([(0,o.nn)("normal"),(0,o.td)()],w.prototype,"alignContent",void 0),k([(0,o.nn)("stretch"),(0,o.td)()],w.prototype,"alignItems",void 0),k([(0,o.nn)("auto"),(0,o.td)()],w.prototype,"alignSelf",void 0),k([(0,o.nn)(0),(0,s.y)({x:"columnGap",y:"rowGap"})],w.prototype,"gap",void 0),k([i("font-family"),(0,o.td)()],w.prototype,"fontFamily",void 0),k([i("font-size",parseFloat),(0,o.td)()],w.prototype,"fontSize",void 0),k([i("font-style"),(0,o.td)()],w.prototype,"fontStyle",void 0),k([i("font-weight",parseInt),(0,o.td)()],w.prototype,"fontWeight",void 0),k([i("line-height",parseFloat),(0,o.td)()],w.prototype,"lineHeight",void 0),k([i("letter-spacing",(t=>"normal"===t?0:parseFloat(t))),(0,o.td)()],w.prototype,"letterSpacing",void 0),k([i("white-space",(t=>"pre"===t?"pre":"normal"===t)),(0,o.td)()],w.prototype,"textWrap",void 0),k([(0,o.nn)("inherit"),(0,o.td)()],w.prototype,"textDirection",void 0),k([i("text-align"),(0,o.td)()],w.prototype,"textAlign",void 0),k([(0,o.r_)(!1),(0,o.Oq)(!1),(0,o.td)()],w.prototype,"customX",void 0),k([(0,o.r_)(!1),(0,o.Oq)(!1),(0,o.td)()],w.prototype,"customY",void 0),k([(0,o.Oq)(!1),(0,o.nn)(null),(0,o.td)()],w.prototype,"customWidth",void 0),k([(0,m.C)()],w.prototype,"tweenWidth",null),k([(0,o.Oq)(!1),(0,o.nn)(null),(0,o.td)()],w.prototype,"customHeight",void 0),k([(0,m.C)()],w.prototype,"tweenHeight",null),k([(0,o.r_)(!1),(0,o.nn)({x:null,y:null}),(0,s.y)({x:"width",y:"height"})],w.prototype,"size",void 0),k([(0,a.F)()],w.prototype,"desiredSize",null),k([(0,m.C)()],w.prototype,"tweenSize",null),k([(0,s.y)("offset")],w.prototype,"offset",void 0),k([(0,o.nn)(!1),(0,o.td)()],w.prototype,"clip",void 0),k([(0,a.F)()],w.prototype,"parentTransform",null),k([(0,a.F)()],w.prototype,"anchorPosition",null),k([(0,a.F)()],w.prototype,"layoutEnabled",null),k([(0,a.F)()],w.prototype,"isLayoutRoot",null),k([(0,a.F)()],w.prototype,"computedPosition",null),k([(0,a.F)()],w.prototype,"computedSize",null),k([(0,a.F)()],w.prototype,"requestLayoutUpdate",null),k([(0,a.F)()],w.prototype,"appendedToView",null),k([(0,a.F)()],w.prototype,"updateLayout",null),k([(0,a.F)()],w.prototype,"layoutChildren",null),k([(0,a.F)()],w.prototype,"requestFontUpdate",null),k([(0,a.F)()],w.prototype,"applyFlex",null),k([(0,a.F)()],w.prototype,"applyFont",null)},20092:(t,e,n)=>{"use strict";n.d(e,{N:()=>T});var o=n(93091),s=n(88104),r=n(46350),i=n(43595),a=n(29797),p=n(74741),c=n(23357),l=n(49111),u=n(3163);var m=n(97074),d=n(74534),h=n(13170),y=n(67292),f=n(11258),k=n(97140);const w={invert:{name:"invert"},sepia:{name:"sepia"},grayscale:{name:"grayscale"},brightness:{name:"brightness",default:1},contrast:{name:"contrast",default:1},saturate:{name:"saturate",default:1},hue:{name:"hue-rotate",unit:"deg",scale:1},blur:{name:"blur",transform:!0,unit:"px",scale:1}};class g{get name(){return this.props.name}get default(){return this.props.default}constructor(t){this.props={name:"invert",default:0,unit:"%",scale:100,transform:!1,...t,value:t.value??t.default??0},this.value=(0,k.g)(this.props.value,h.UI,this)}isActive(){return this.value()!==this.props.default}serialize(t){let e=this.value();return this.props.transform&&(e=(0,p.X6)(e,t)),`${this.props.name}(${e*this.props.scale}${this.props.unit})`}}var M=n(5376),D=n(5788),_=n(16249),X=n(93214);class x extends _.V{constructor(t,e){var n;super(t,h.o0,e),n=this;for(const o in w){const t=w[o];Object.defineProperty(this.invokable,o,{value:function(e,o,s){var r,i,a;if(void 0===s&&(s=m.qb),void 0===e)return(null==(i=n.get())||null==(a=i.find((e=>e.name===t.name)))?void 0:a.value())??t.default??0;let p=null==(r=n.get())?void 0:r.find((e=>e.name===t.name));return p||(p=new g(t),n.set([...n.get(),p])),void 0===o?(p.value(e),n.owner):p.value(e,o,s)}})}}*doTween(t,e,n){const o=this.get(),s=(0,X.P)(t)?t():t;if(function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n].name!==e[n].name)return!1;return!0}(o,s))return yield*(0,M.$)(...o.map(((t,o)=>t.value(s[o].value(),e,n)))),void this.set(s);for(const a of s)a.value(a.default);const r=s.map((t=>t.value.context.raw())),i=o.length>0&&s.length>0?e/2:e;o.length>0&&(yield*(0,M.$)(...o.map((t=>t.value(t.default,i,n))))),this.set(s),s.length>0&&(yield*(0,M.$)(...s.map(((t,e)=>t.value(r[e],i,n)))))}}var v=n(76062),C=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class T{getAbsolutePosition(){const t=this.localToWorld();return new a.F(t.m41,t.m42)}setAbsolutePosition(t){(0,X.P)(t)?this.position((()=>t().transformAsPoint(this.worldToParent()))):this.position(t.transformAsPoint(this.worldToParent()))}getAbsoluteRotation(){const t=this.localToWorld();return 180*Math.atan2(t.m12,t.m11)/Math.PI}setAbsoluteRotation(t){(0,X.P)(t)?this.rotation((()=>(0,p.$H)(t(),this.worldToParent()))):this.rotation((0,p.$H)(t,this.worldToParent()))}getAbsoluteScale(){const t=this.localToWorld();return new a.F(a.F.magnitude(t.m11,t.m12),a.F.magnitude(t.m21,t.m22))}setAbsoluteScale(t){(0,X.P)(t)?this.scale((()=>this.getRelativeScale(t()))):this.scale(this.getRelativeScale(t))}getRelativeScale(t){var e;const n=(null==(e=this.parent())?void 0:e.absoluteScale())??a.F.one;return t.div(n)}*tweenCompositeOperation(t,e,n){const o=(0,X.P)(t)?t():t;"source-over"===o?(yield*this.compositeOverride(1,e,n),this.compositeOverride(0),this.compositeOperation(o)):(this.compositeOperation(o),this.compositeOverride(1),yield*this.compositeOverride(0,e,n))}absoluteOpacity(){var t;return((null==(t=this.parent())?void 0:t.absoluteOpacity())??1)*this.opacity()}hasFilters(){return!!this.filters().find((t=>t.isActive()))}hasShadow(){return!!this.shadowColor()&&(this.shadowBlur()>0||0!==this.shadowOffset.x()||0!==this.shadowOffset.y())}filterString(){let t="";const e=this.compositeToWorld();for(const n of this.filters())n.isActive()&&(t+=" "+n.serialize(e));return t}setChildren(t){this.spawner(t)}getChildren(){return this.spawnChildren(),this.realChildren}spawnChildren(){const t=this.spawner();if((0,X.P)(this.spawner.context.raw())){const e=new Set;for(const n of t){const t=n.parent.context.raw();if(t&&t!==this)throw new l.t("The spawner returned a node that already has a parent","A spawner should either create entirely new nodes or reuse nodes from a pool.");n.parent(this),e.add(n.key)}for(const t of this.realChildren)e.has(t.key)||t.parent(null);this.realChildren=t}else this.realChildren=t}sortedChildren(){return[...this.children()].sort(((t,e)=>Math.sign(t.zIndex()-e.zIndex())))}constructor(t){let{children:e,spawner:n,key:s,...r}=t;this.compositeOverride=(0,k.g)(0),this.stateStack=[],this.realChildren=[],this.parent=(0,k.g)(null),this.properties=(0,o.RG)(this);const i=(0,u.$r)();this.key=i.registerNode(this,s),this.view2D=i.getView(),this.creationStack=(new Error).stack,(0,o.Xd)(this,r),this.add(e),n&&this.children(n)}localToWorld(){const t=this.parent();return t?t.localToWorld().multiply(this.localToParent()):this.localToParent()}worldToLocal(){return this.localToWorld().inverse()}worldToParent(){var t;return(null==(t=this.parent())?void 0:t.worldToLocal())??new DOMMatrix}localToParent(){const t=new DOMMatrix;return t.translateSelf(this.position.x(),this.position.y()),t.rotateSelf(0,0,this.rotation()),t.scaleSelf(this.scale.x(),this.scale.y()),t}compositeToWorld(){var t;return(null==(t=this.compositeRoot())?void 0:t.localToWorld())??new DOMMatrix}compositeRoot(){var t;return this.composite()?this:(null==(t=this.parent())?void 0:t.compositeRoot())??null}compositeToLocal(){const t=this.compositeRoot();if(t){const e=this.worldToLocal();return e.m44=1,t.localToWorld().multiply(e)}return new DOMMatrix}view(){return this.view2D}add(t){return this.insert(t,1/0)}insert(t,e){void 0===e&&(e=0);const n=Array.isArray(t)?t:[t];if(0===n.length)return this;const o=this.children(),s=o.slice(0,e);for(const r of n)r instanceof T&&(s.push(r),r.remove(),r.parent(this));return s.push(...o.slice(e)),this.children(s),this}remove(){const t=this.parent();return null===t||(t.children(t.children().filter((t=>t!==this))),this.parent(null)),this}move(t){void 0===t&&(t=1);const e=this.parent();if(0===t||!e)return this;const n=e.children(),o=[];if(t>0)for(let s=0;s<n.length;s++){const e=n[s];if(e===this){const e=s+t;for(;s<e&&s+1<n.length;s++)o[s]=n[s+1]}o[s]=e}else for(let s=n.length-1;s>=0;s--){const e=n[s];if(e===this){const e=s+t;for(;s>e&&s>0;s--)o[s]=n[s-1]}o[s]=e}return e.children(o),this}moveUp(){return this.move(1)}moveDown(){return this.move(-1)}moveToTop(){return this.move(1/0)}moveToBottom(){return this.move(-1/0)}moveTo(t){const e=this.parent();if(!e)return this;const n=t-e.children().indexOf(this);return this.move(n)}moveBelow(t,e){void 0===e&&(e=!1);const n=this.parent();if(!n)return this;if(t.parent()!==n)return(0,u.wL)().error("Cannot position nodes relative to each other if they don't belong to the same parent."),this;const o=n.children(),s=o.indexOf(this),r=o.indexOf(t);if(!e&&s<r)return this;const i=r-s-1;return this.move(i)}moveAbove(t,e){void 0===e&&(e=!1);const n=this.parent();if(!n)return this;if(t.parent()!==n)return(0,u.wL)().error("Cannot position nodes relative to each other if they don't belong to the same parent."),this;const o=n.children(),s=o.indexOf(this),r=o.indexOf(t);if(!e&&s>r)return this;const i=r-s+1;return this.move(i)}reparent(t){const e=this.absolutePosition(),n=this.absoluteRotation(),o=this.absoluteScale();t.add(this),this.absolutePosition(e),this.absoluteRotation(n),this.absoluteScale(o)}removeChildren(){for(const t of this.children())t.remove()}dispose(){this.stateStack=[];for(const{signal:t}of this)null==t||t.context.dispose()}clone(t){void 0===t&&(t={});const e={...t};(0,X.P)(this.spawner.context.raw())?e.spawner=this.spawner.context.raw():this.children().length>0&&(e.children??(e.children=this.children().map((t=>t.clone()))));for(const{key:n,meta:o,signal:s}of this)if(o.cloneable&&!(n in e))if(o.compound)for(const[t,r]of o.compoundEntries)r in e||(e[r]=s[t].context.raw());else e[n]=s.context.raw();return this.instantiate(e)}snapshotClone(t){void 0===t&&(t={});const e={...this.getState(),...t};return this.children().length>0&&(e.children??(e.children=this.children().map((t=>t.snapshotClone())))),this.instantiate(e)}reactiveClone(t){void 0===t&&(t={});const e={...t};this.children().length>0&&(e.children??(e.children=this.children().map((t=>t.reactiveClone()))));for(const{key:n,meta:o,signal:s}of this)o.cloneable&&!(n in e)&&(e[n]=()=>s());return this.instantiate(e)}instantiate(t){return void 0===t&&(t={}),new this.constructor(t)}requiresCache(){return this.cache()||this.opacity()<1||"source-over"!==this.compositeOperation()||this.hasFilters()||this.hasShadow()}cacheCanvas(){const t=document.createElement("canvas").getContext("2d");if(!t)throw new Error("Could not create a cache canvas");return t}cachedCanvas(){const t=this.cacheCanvas(),e=this.worldSpaceCacheBBox(),n=this.localToWorld();return t.canvas.width=e.width,t.canvas.height=e.height,t.setTransform(n.a,n.b,n.c,n.d,n.e-e.x,n.f-e.y),this.draw(t),t}getCacheBBox(){return new c.b}cacheBBox(){const t=this.getCacheBBox(),e=this.children();if(0===e.length)return t;const n=t.corners;for(const o of e){const t=o.fullCacheBBox(),e=o.localToParent();n.push(...t.corners.map((t=>t.transformAsPoint(e))))}return c.b.fromPoints(...n)}fullCacheBBox(){const t=this.compositeToLocal(),e=this.shadowOffset().transform(t),n=(0,p.X6)(this.shadowBlur(),t),o=this.cacheBBox().expand(2*this.filters.blur()+n);return e.x<0?(o.x+=e.x,o.width-=e.x):o.width+=e.x,e.y<0?(o.y+=e.y,o.height-=e.y):o.height+=e.y,o}worldSpaceCacheBBox(){const t=c.b.fromSizeCentered(this.view().size()),e=c.b.fromPoints(...t.transformCorners(this.view().localToWorld())),n=c.b.fromPoints(...this.cacheBBox().transformCorners(this.localToWorld()));return e.intersection(n).pixelPerfect}setupDrawFromCache(t){if(t.globalCompositeOperation=this.compositeOperation(),t.globalAlpha*=this.opacity(),this.hasFilters()&&(t.filter=this.filterString()),this.hasShadow()){const e=this.compositeToWorld(),n=this.shadowOffset().transform(e),o=(0,p.X6)(this.shadowBlur(),e);t.shadowColor=this.shadowColor().serialize(),t.shadowBlur=o,t.shadowOffsetX=n.x,t.shadowOffsetY=n.y}}render(t){if(!(this.absoluteOpacity()<=0)){if(t.save(),this.transformContext(t),this.requiresCache()){const e=this.worldSpaceCacheBBox();if(0!==e.width&&0!==e.height){this.setupDrawFromCache(t);const n=this.cachedCanvas(),o=this.compositeOverride(),s=this.worldToLocal();t.transform(s.a,s.b,s.c,s.d,s.e,s.f),t.drawImage(n.canvas,e.position.x,e.position.y),o>0&&(t.save(),t.globalAlpha*=o,t.globalCompositeOperation="source-over",t.drawImage(n.canvas,e.position.x,e.position.y),t.restore())}}else this.draw(t);t.restore()}}draw(t){this.drawChildren(t)}drawChildren(t){for(const e of this.sortedChildren())e.render(t)}drawOverlay(t,e){const n=this.cacheBBox().transformCorners(e),o=this.getCacheBBox().transformCorners(e);t.strokeStyle="white",t.lineWidth=1,t.beginPath(),(0,f.pS)(t,n),t.closePath(),t.stroke(),t.strokeStyle="blue",t.beginPath(),(0,f.pS)(t,o),t.closePath(),t.stroke()}transformContext(t){const e=this.localToParent();t.transform(e.a,e.b,e.c,e.d,e.e,e.f)}hit(t){let e=null;const n=t.transformAsPoint(this.localToParent().inverse());for(const o of this.children().reverse())if(e=o.hit(n),e)break;return e}collectAsyncResources(){for(const t of this.children())t.collectAsyncResources()}async toPromise(){let t=v.k.consumePromises();do{await Promise.all(t.map((t=>t.promise))),this.collectAsyncResources(),t=v.k.consumePromises()}while(t.length>0);return this}getState(){const t={};for(const{key:e,meta:n,signal:o}of this)n.cloneable&&!(e in t)&&(t[e]=o());return t}applyState(t){for(const e in t){const n=this.signalByKey(e);n&&n(t[e])}}save(){this.stateStack.push(this.getState())}restore(t,e){void 0===e&&(e=m.qb);const n=this.stateStack.pop();if(void 0===n)return;const o=this.getState();for(const s in n)o[s]===n[s]&&delete n[s];return(0,d.i)(t,(t=>{const s=e(t),r=Object.keys(n).reduce(((t,e)=>(t[e]=(0,h.o0)(o[e],n[e],s),t)),{});this.applyState(r)}))}*[Symbol.iterator](){for(const t in this.properties){const e=this.properties[t],n=this.signalByKey(t);yield{meta:e,signal:n,key:t}}}signalByKey(t){return this[t]}}C([(0,s.y)()],T.prototype,"position",void 0),C([(0,o.YS)(a.F),(0,o.r_)(!1),(0,o.td)()],T.prototype,"absolutePosition",void 0),C([(0,o.nn)(0),(0,o.td)()],T.prototype,"rotation",void 0),C([(0,o.r_)(!1),(0,o.td)()],T.prototype,"absoluteRotation",void 0),C([(0,o.nn)(a.F.one),(0,s.y)("scale")],T.prototype,"scale",void 0),C([(0,o.YS)(a.F),(0,o.r_)(!1),(0,o.td)()],T.prototype,"absoluteScale",void 0),C([(0,o.nn)(0),(0,o.td)()],T.prototype,"zIndex",void 0),C([(0,o.nn)(!1),(0,o.td)()],T.prototype,"cache",void 0),C([(0,o.nn)(!1),(0,o.td)()],T.prototype,"composite",void 0),C([(0,o.nn)("source-over"),(0,o.td)()],T.prototype,"compositeOperation",void 0),C([(0,y.C)()],T.prototype,"tweenCompositeOperation",null),C([(0,o.nn)(1),(0,o.td)()],T.prototype,"opacity",void 0),C([(0,r.F)()],T.prototype,"absoluteOpacity",null),C([(t,e)=>{const n=(0,o.J)(t,e);(0,D.f)(t,(t=>{t[e]=new x(n.default??[],t).toSignal()}))}],T.prototype,"filters",void 0),C([(0,o.nn)("#0000"),(0,i.j)()],T.prototype,"shadowColor",void 0),C([(0,o.nn)(0),(0,o.td)()],T.prototype,"shadowBlur",void 0),C([(0,s.y)("shadowOffset")],T.prototype,"shadowOffset",void 0),C([(0,r.F)()],T.prototype,"hasFilters",null),C([(0,r.F)()],T.prototype,"hasShadow",null),C([(0,r.F)()],T.prototype,"filterString",null),C([(0,o.Oq)(!1),(0,o.r_)(!1),(0,o.nn)([]),(0,o.td)()],T.prototype,"spawner",void 0),C([(0,o.Oq)(!1),(0,o.r_)(!1),(0,o.td)()],T.prototype,"children",void 0),C([(0,r.F)()],T.prototype,"spawnChildren",null),C([(0,r.F)()],T.prototype,"sortedChildren",null),C([(0,r.F)()],T.prototype,"localToWorld",null),C([(0,r.F)()],T.prototype,"worldToLocal",null),C([(0,r.F)()],T.prototype,"worldToParent",null),C([(0,r.F)()],T.prototype,"localToParent",null),C([(0,r.F)()],T.prototype,"compositeToWorld",null),C([(0,r.F)()],T.prototype,"compositeRoot",null),C([(0,r.F)()],T.prototype,"compositeToLocal",null),C([(0,r.F)()],T.prototype,"cacheCanvas",null),C([(0,r.F)()],T.prototype,"cachedCanvas",null),C([(0,r.F)()],T.prototype,"cacheBBox",null),C([(0,r.F)()],T.prototype,"fullCacheBBox",null),C([(0,r.F)()],T.prototype,"worldSpaceCacheBBox",null),T.prototype.isClass=!0},15498:(t,e,n)=>{"use strict";n.d(e,{U:()=>c});var o=n(23357),s=n(13730),r=n(11258),i=n(93091),a=n(53693),p=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class c extends s.b{constructor(t){super(t)}getPath(){const t=new Path2D,e=this.radius(),n=this.smoothCorners(),s=this.cornerSharpness(),i=o.b.fromSizeCentered(this.size());return(0,r.Zy)(t,i,e,n,s),t}getCacheBBox(){return super.getCacheBBox().expand(this.rippleSize())}getRipplePath(){const t=new Path2D,e=this.rippleSize(),n=this.radius().addScalar(e),s=this.smoothCorners(),i=this.cornerSharpness(),a=o.b.fromSizeCentered(this.size()).expand(e);return(0,r.Zy)(t,a,n,s,i),t}}p([(0,a.g)("radius")],c.prototype,"radius",void 0),p([(0,i.nn)(!1),(0,i.td)()],c.prototype,"smoothCorners",void 0),p([(0,i.nn)(.6),(0,i.td)()],c.prototype,"cornerSharpness",void 0)},13730:(t,e,n)=>{"use strict";n.d(e,{b:()=>h});var o=n(93091),s=n(46350),r=n(70989),i=n(67292),a=n(97074),p=n(13170),c=n(11258),l=n(5392);function u(){return(t,e)=>{(0,o.td)()(t,e),(0,o.E2)(c.av)(t,e),(0,o.JI)(l.Color.lerp)(t,e),(0,o.nn)(null)(t,e)}}var m=n(97140),d=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class h extends r.A{rippleSize(){return(0,a.ad)(this.rippleStrength(),0,50)}constructor(t){super(t),this.rippleStrength=(0,m.g)(0)}applyText(t){t.direction=this.textDirection(),this.element.dir=this.textDirection()}applyStyle(t){t.fillStyle=(0,c.ho)(this.fill(),t),t.strokeStyle=(0,c.ho)(this.stroke(),t),t.lineWidth=this.lineWidth(),t.lineJoin=this.lineJoin(),t.lineCap=this.lineCap(),t.setLineDash(this.lineDash()),t.lineDashOffset=this.lineDashOffset(),this.antialiased()||(t.filter="url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxmaWx0ZXIgaWQ9ImZpbHRlciIgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj48ZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVGdW5jUiB0eXBlPSJpZGVudGl0eSIvPjxmZUZ1bmNHIHR5cGU9ImlkZW50aXR5Ii8+PGZlRnVuY0IgdHlwZT0iaWRlbnRpdHkiLz48ZmVGdW5jQSB0eXBlPSJkaXNjcmV0ZSIgdGFibGVWYWx1ZXM9IjAgMSIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj48L2ZpbHRlcj48L3N2Zz4=#filter)")}draw(t){this.drawShape(t),this.clip()&&t.clip(this.getPath()),this.drawChildren(t)}drawShape(t){const e=this.getPath(),n=this.lineWidth()>0&&null!==this.stroke(),o=null!==this.fill();t.save(),this.applyStyle(t),this.drawRipple(t),this.strokeFirst()?(n&&t.stroke(e),o&&t.fill(e)):(o&&t.fill(e),n&&t.stroke(e)),t.restore()}getCacheBBox(){return super.getCacheBBox().expand(this.lineWidth()/2)}getPath(){return new Path2D}getRipplePath(){return new Path2D}drawRipple(t){const e=this.rippleStrength();if(e>0){const n=this.getRipplePath();t.save(),t.globalAlpha*=(0,p.UI)(.54,0,e),t.fill(n),t.restore()}}*ripple(t){void 0===t&&(t=1),this.rippleStrength(0),yield*this.rippleStrength(1,t,a.GE),this.rippleStrength(0)}}d([u()],h.prototype,"fill",void 0),d([u()],h.prototype,"stroke",void 0),d([(0,o.nn)(!1),(0,o.td)()],h.prototype,"strokeFirst",void 0),d([(0,o.nn)(0),(0,o.td)()],h.prototype,"lineWidth",void 0),d([(0,o.nn)("miter"),(0,o.td)()],h.prototype,"lineJoin",void 0),d([(0,o.nn)("butt"),(0,o.td)()],h.prototype,"lineCap",void 0),d([(0,o.nn)([]),(0,o.td)()],h.prototype,"lineDash",void 0),d([(0,o.nn)(0),(0,o.td)()],h.prototype,"lineDashOffset",void 0),d([(0,o.nn)(!0),(0,o.td)()],h.prototype,"antialiased",void 0),d([(0,s.F)()],h.prototype,"rippleSize",null),d([(0,s.F)()],h.prototype,"getPath",null),d([(0,i.C)()],h.prototype,"ripple",null)},70419:(t,e,n)=>{"use strict";n.d(e,{h:()=>p});var o=n(15498),s=n(93091),r=n(88733),i=n(79116),a=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class p extends o.U{constructor(t){super({composite:!0,fontFamily:"Roboto",fontSize:48,lineHeight:"120%",textWrap:!1,fontStyle:"normal",...t}),this.view2D=this,p.shadowRoot.append(this.element),this.applyFlex()}transformContext(){}dispose(){this.removeChildren(),super.dispose()}render(t){this.computedSize(),this.computedPosition(),super.render(t)}requestLayoutUpdate(){this.updateLayout()}view(){return this}}a([(0,s.nn)(r.q.Paused),(0,s.td)()],p.prototype,"playbackState",void 0),a([(0,i.V)((()=>{const t="motion-canvas-2d-frame";let e=document.querySelector(`#${t}`);return e||(e=document.createElement("div"),e.id=t,e.style.position="absolute",e.style.pointerEvents="none",e.style.top="0",e.style.left="0",e.style.opacity="0",e.style.overflow="hidden",document.body.prepend(e)),e.shadowRoot??e.attachShadow({mode:"open"})}))],p,"shadowRoot",void 0)},43595:(t,e,n)=>{"use strict";n.d(e,{j:()=>r});var o=n(5392),s=n(93091);function r(){return(t,e)=>{(0,s.td)()(t,e),(0,s.YS)(o.Color)(t,e)}}},37060:(t,e,n)=>{"use strict";n.d(e,{I:()=>c});var o=n(3163),s=n(93091),r=n(5788),i=n(13170),a=n(46096),p=n(14455);function c(t){return(e,n)=>{const c=(0,s.J)(e,n);c.compound=!0,c.compoundEntries=Object.entries(t),(0,r.f)(e,(e=>{if(!c.parser)return void(0,o.wL)().error(`Missing parser decorator for "${n.toString()}"`);const s=new a.N(Object.keys(t),c.parser,c.default,c.interpolationFunction??i.o0,e);(0,p.I)(s,c.parser,e,n);const r=s.toSignal();for(const[t,n]of c.compoundEntries)(0,p.I)(r[t].context,void 0,e,n);e[n]=r}))}}},46350:(t,e,n)=>{"use strict";n.d(e,{F:()=>r});var o=n(5788),s=n(73662);function r(){return(t,e)=>{(0,o.f)(t,(t=>{const n=Object.getPrototypeOf(t)[e];t[e]=(0,s.D)(n.bind(t),t)}))}}},5788:(t,e,n)=>{"use strict";n.d(e,{f:()=>s,j:()=>r});const o=Symbol.for("@motion-canvas/2d/decorators/initializers");function s(t,e){if(t[o]){if(t[o]&&!Object.prototype.hasOwnProperty.call(t,o)){const e=Object.getPrototypeOf(t);t[o]=[...e[o]]}}else t[o]=[];t[o].push(e)}function r(t,e){if(t[o])try{t[o].forEach((n=>n(t,e)))}catch(n){throw n.inspect??(n.inspect=t.key),n}}},93091:(t,e,n)=>{"use strict";n.d(e,{E2:()=>k,J:()=>u,JI:()=>f,Oq:()=>M,RG:()=>m,Xd:()=>d,YS:()=>w,nn:()=>y,r_:()=>g,td:()=>h});var o=n(13170),s=n(5788),r=n(15688),i=n(3163),a=n(14455),p=n(16249);const c=Symbol.for("@motion-canvas/2d/decorators/properties");function l(t,e){var n;return(null==(n=t[c])?void 0:n[e])??null}function u(t,e){let n;return t[c]?t[c]&&!Object.prototype.hasOwnProperty.call(t,c)?t[c]=n=Object.fromEntries(Object.entries(t[c]).map((t=>{let[e,n]=t;return[e,{...n}]}))):n=t[c]:t[c]=n={},n[e]??(n[e]={cloneable:!0,inspectable:!0,compoundEntries:[]}),n[e]}function m(t){return t&&"object"==typeof t?t[c]??{}:{}}function d(t,e){(0,s.j)(t);for(const[n,o]of Object.entries(m(t))){const s=t[n];if(s.reset(),void 0!==e[n]&&s(e[n]),void 0!==o.compoundEntries)for(const[t,n]of o.compoundEntries)n in e&&s[t](e[n])}}function h(){return(t,e)=>{const n=u(t,e);(0,s.f)(t,(t=>{var s;const i=null==(s=t[`getDefault${(0,r.k)(e)}`])?void 0:s.bind(t),c=new p.V(i??n.default,n.interpolationFunction??o.o0,t);(0,a.I)(c,n.parser,t,e),t[e]=c.toSignal()}))}}function y(t){return(e,n)=>{const o=l(e,n);o?o.default=t:(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function f(t){return(e,n)=>{const o=l(e,n);o?o.interpolationFunction=t:(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function k(t){return(e,n)=>{const o=l(e,n);o?o.parser=t:(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function w(t){return(e,n)=>{const o=l(e,n);o?(o.parser=e=>new t(e),"lerp"in t&&(o.interpolationFunction??(o.interpolationFunction=t.lerp))):(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function g(t){return void 0===t&&(t=!0),(e,n)=>{const o=l(e,n);o?o.cloneable=t:(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function M(t){return void 0===t&&(t=!0),(e,n)=>{const o=l(e,n);o?o.inspectable=t:(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}},53693:(t,e,n)=>{"use strict";n.d(e,{g:()=>i});var o=n(43188),s=n(37060),r=n(93091);function i(t){return(e,n)=>{(0,s.I)({top:t?`${t}Top`:"top",right:t?`${t}Right`:"right",bottom:t?`${t}Bottom`:"bottom",left:t?`${t}Left`:"left"})(e,n),(0,r.YS)(o.K)(e,n)}}},88104:(t,e,n)=>{"use strict";n.d(e,{y:()=>i});var o=n(29797),s=n(37060),r=n(93091);function i(t){return(e,n)=>{(0,s.I)("object"==typeof t?t:{x:t?`${t}X`:"x",y:t?`${t}Y`:"y"})(e,n),(0,r.YS)(o.F)(e,n)}}},15914:(t,e,n)=>{"use strict";n.d(e,{r:()=>T});var o=n(92673),s=n(82344),r=n(11726);var i=n(80638),a=n(5881),p=n(97140);class c{constructor(t){this.scene=t,this.signals={},this.variables={},this.handleReset=()=>{this.signals={}},t.onReset.subscribe(this.handleReset)}get(t,e){var n;return(n=this.signals)[t]??(n[t]=(0,p.g)(this.variables[t]??e)),()=>this.signals[t]()}updateSignals(t){this.variables=t,Object.keys(t).map((e=>{e in this.signals&&this.signals[e](t[e])}))}}var l,u=n(1323),m=n(96881),d=n(42075),h=n(67292),y=n(3163),f=n(97715);!function(t){t[t.BeforeRender=0]="BeforeRender",t[t.BeginRender=1]="BeginRender",t[t.FinishRender=2]="FinishRender",t[t.AfterRender=3]="AfterRender"}(l||(l={}));class k{get onBeforeRender(){return this.beforeRender.subscribable}get onBeginRender(){return this.beginRender.subscribable}get onFinishRender(){return this.finishRender.subscribable}get onAfterRender(){return this.afterRender.subscribable}constructor(t){this.scene=t,this.beforeRender=new m.p,this.beginRender=new m.p,this.finishRender=new m.p,this.afterRender=new m.p,this.scene.onRenderLifecycle.subscribe((t=>{let[e,n]=t;switch(e){case l.BeforeRender:return this.beforeRender.dispatch(n);case l.BeginRender:return this.beginRender.dispatch(n);case l.FinishRender:return this.finishRender.dispatch(n);case l.AfterRender:return this.afterRender.dispatch(n)}})),this.scene.onReset.subscribe((()=>{this.beforeRender.clear(),this.beginRender.clear(),this.finishRender.clear(),this.afterRender.clear()}))}}var w,g=n(23357);!function(t){t[t.Initial=0]="Initial",t[t.AfterTransitionIn=1]="AfterTransitionIn",t[t.CanTransitionOut=2]="CanTransitionOut",t[t.Finished=3]="Finished"}(w||(w={}));var M=n(76062),D=n(88733);class _{get onChanged(){return this.slides.subscribable}constructor(t){this.scene=t,this.slides=new u.G([]),this.lookup=new Map,this.collisionLookup=new Set,this.current=null,this.canResume=!1,this.waitsForId=null,this.targetId=null,this.handleReload=()=>{this.lookup.clear(),this.collisionLookup.clear(),this.current=null,this.waitsForId=null,this.targetId=null},this.handleReset=()=>{this.collisionLookup.clear(),this.current=null,this.waitsForId=null},this.handleRecalculated=()=>{this.slides.current=[...this.lookup.values()]},this.scene.onReloaded.subscribe(this.handleReload),this.scene.onReset.subscribe(this.handleReset),this.scene.onRecalculated.subscribe(this.handleRecalculated)}setTarget(t){this.targetId=t}resume(){this.canResume=!0}isWaitingFor(t){return this.waitsForId===t}isWaiting(){return null!==this.waitsForId}didHappen(t){if(null===this.current)return!1;for(const n of this.lookup.keys()){var e;if(n===t)return!0;if(n===(null==(e=this.current)?void 0:e.id))return!1}return!1}getCurrent(){return this.current}register(t,e){if(null!==this.waitsForId)throw new Error(`The animation already waits for a slide: ${this.waitsForId}.`);const n=this.toId(t);this.scene.playback.state!==D.q.Presenting&&(this.lookup.has(n)||this.lookup.set(n,{id:n,name:t,time:e,scene:this.scene,stack:(new Error).stack}),this.collisionLookup.has(t)?this.scene.logger.warn({message:`A slide named "${t}" already exists.`,stack:(new Error).stack}):this.collisionLookup.add(t)),this.waitsForId=n,this.current=this.lookup.get(n)??null,this.canResume=!1}shouldWait(t){const e=this.toId(t);if(this.waitsForId!==e)throw new Error(`The animation waits for a different slide: ${this.waitsForId}.`);if(!this.lookup.get(e))throw new Error(`Could not find the "${t}" slide.`);let n=this.canResume;return this.scene.playback.state!==D.q.Presenting&&(n=e!==this.targetId),n&&(this.waitsForId=null),!n}toId(t){return`${this.scene.name}:${t}`}}class X{get firstFrame(){return this.cache.current.firstFrame}get lastFrame(){return this.firstFrame+this.cache.current.duration}get onCacheChanged(){return this.cache.subscribable}get onReloaded(){return this.reloaded.subscribable}get onRecalculated(){return this.recalculated.subscribable}get onThreadChanged(){return this.thread.subscribable}get onRenderLifecycle(){return this.renderLifecycle.subscribable}get onReset(){return this.afterReset.subscribable}get LifecycleEvents(){return this.logger.warn("LifecycleEvents is deprecated. Use lifecycleEvents instead."),this.lifecycleEvents}get previous(){return this.previousScene}constructor(t){this.cache=new u.G({firstFrame:0,transitionDuration:0,duration:0,lastFrame:0}),this.reloaded=new m.p,this.recalculated=new m.p,this.thread=new u.G(null),this.renderLifecycle=new m.p,this.afterReset=new m.p,this.lifecycleEvents=new k(this),this.previousScene=null,this.runner=null,this.state=w.Initial,this.cached=!1,this.counters={},this.name=t.name,this.size=t.size,this.resolutionScale=t.resolutionScale,this.logger=t.logger,this.playback=t.playback,this.meta=t.meta,this.runnerFactory=t.config,this.creationStack=t.stack,(0,d.G)(this.runnerFactory,(0,h.C)(this.name)),this.timeEvents=new t.timeEventsClass(this),this.variables=new c(this),this.slides=new _(this),this.random=new r.k(this.meta.seed.get())}update(){}async render(t){let e=M.k.consumePromises(),n=0;do{n++,await Promise.all(e.map((t=>t.promise))),t.save();const o=g.b.fromSizeCentered(this.getSize());t.clearRect(o.x,o.y,o.width,o.height),this.execute((()=>this.draw(t))),t.restore(),e=M.k.consumePromises()}while(e.length>0&&n<10);n>1&&this.logger.debug(`render iterations: ${n}`)}reload(t){let{config:e,size:n,stack:o,resolutionScale:s}=void 0===t?{}:t;e&&(this.runnerFactory=e),n&&(this.size=n),s&&(this.resolutionScale=s),o&&(this.creationStack=o),this.cached=!1,this.reloaded.dispatch()}async recalculate(t){const e=this.cache.current;if(e.firstFrame=this.playback.frame,e.lastFrame=e.firstFrame+e.duration,this.isCached())return t(e.lastFrame),void(this.cache.current={...e});for(e.transitionDuration=-1,await this.reset();!this.canTransitionOut();)e.transitionDuration<0&&this.state===w.AfterTransitionIn&&(e.transitionDuration=this.playback.frame-e.firstFrame),t(this.playback.frame+1),await this.next();-1===e.transitionDuration&&(e.transitionDuration=0),e.lastFrame=this.playback.frame,e.duration=e.lastFrame-e.firstFrame,await new Promise((t=>setTimeout(t,0))),this.cached=!0,this.cache.current={...e},this.recalculated.dispatch()}async next(){if(!this.runner)return;let t=this.execute((()=>this.runner.next()));for(this.update();t.value;){if((0,i.x)(t.value)){const e=await t.value.toPromise();t=this.execute((()=>this.runner.next(e)))}else if((0,a.t)(t.value)){const e=await t.value;t=this.execute((()=>this.runner.next(e)))}else this.logger.warn({message:"Invalid value yielded by the scene.",object:t.value}),t=this.execute((()=>this.runner.next(t.value)));this.update()}const e=M.k.consumePromises();var n;e.length>0&&(await Promise.all(e.map((t=>t.promise))),this.logger.error({message:"Tried to access an asynchronous property before the node was ready. Make sure to yield the node before accessing the property.",stack:e[0].stack,inspect:(null==(n=e[0].owner)?void 0:n.key)??void 0}));t.done&&(this.state=w.Finished)}async reset(t){void 0===t&&(t=null),this.counters={},this.previousScene=t,this.random=new r.k(this.meta.seed.get()),this.runner=(0,a.C)((()=>this.runnerFactory(this.getView())),(t=>{this.thread.current=t})),this.state=w.AfterTransitionIn,this.afterReset.dispatch(),await this.next()}getSize(){return this.size}isAfterTransitionIn(){return this.state===w.AfterTransitionIn}canTransitionOut(){return this.state===w.CanTransitionOut||this.state===w.Finished}isFinished(){return this.state===w.Finished}enterInitial(){this.state===w.AfterTransitionIn?this.state=w.Initial:this.logger.warn(`Scene ${this.name} entered initial in an unexpected state: ${this.state}`)}enterAfterTransitionIn(){this.state===w.Initial?this.state=w.AfterTransitionIn:this.logger.warn(`Scene ${this.name} transitioned in an unexpected state: ${this.state}`)}enterCanTransitionOut(){this.state===w.AfterTransitionIn||this.state===w.Initial?this.state=w.CanTransitionOut:this.logger.warn(`Scene ${this.name} was marked as finished in an unexpected state: ${this.state}`)}isCached(){return this.cached}execute(t){let e;(0,y.DO)(this),(0,f.wA)(this.playback);try{e=t()}finally{(0,f.Mh)(this.playback),(0,y.ug)(this)}return e}}var x=n(29797),v=n(70419);class C extends X{constructor(t){super(t),this.view=null,this.registeredNodes={},this.nodeCounters={},this.recreateView()}getView(){return this.view}next(){var t;return null==(t=this.getView())||t.playbackState(this.playback.state),super.next()}draw(t){t.save(),this.renderLifecycle.dispatch([l.BeforeRender,t]),t.save(),this.renderLifecycle.dispatch([l.BeginRender,t]),this.getView().playbackState(this.playback.state),this.getView().render(t),this.renderLifecycle.dispatch([l.FinishRender,t]),t.restore(),this.renderLifecycle.dispatch([l.AfterRender,t]),t.restore()}reset(t){for(const n in this.registeredNodes)try{this.registeredNodes[n].dispose()}catch(e){this.logger.error(e)}return this.registeredNodes={},this.nodeCounters={},this.recreateView(),super.reset(t)}inspectPosition(t,e){return this.execute((()=>{var n;return(null==(n=this.getView().hit(new x.F(t,e).scale(this.resolutionScale)))?void 0:n.key)??null}))}validateInspection(t){var e;return(null==(e=this.getNode(t))?void 0:e.key)??null}inspectAttributes(t){const e=this.getNode(t);if(!e)return null;const n={stack:e.creationStack,key:e.key};for(const{key:o,meta:s,signal:r}of e)s.inspectable&&(n[o]=r());return n}drawOverlay(t,e,n){const o=this.getNode(t);o&&o.drawOverlay(n,e.scale(1/this.resolutionScale,1/this.resolutionScale).multiplySelf(o.localToWorld()))}registerNode(t,e){var n,o;const s=(null==(n=t.constructor)?void 0:n.name)??"unknown";(o=this.nodeCounters)[s]??(o[s]=0);const r=this.nodeCounters[s]++;return e??(e=`${this.name}/${s}[${r}]`),this.registeredNodes[e]=t,e}getNode(t){return"string"!=typeof t?null:this.registeredNodes[t]??null}recreateView(){this.execute((()=>{const t=this.getSize();this.view=new v.h({position:t.scale(this.resolutionScale/2),scale:this.resolutionScale,size:t})}))}}function T(t){return{klass:C,config:t,stack:(new Error).stack,meta:new o.v("scene",{version:new s.C("version",1),timeEvents:new s.C("time events",[]),seed:new s.C("seed",r.k.createSeed())})}}},11258:(t,e,n)=>{"use strict";n.d(e,{Nb:()=>_,av:()=>d,AE:()=>w,pS:()=>D,is:()=>k,Zy:()=>y,kZ:()=>M,Ao:()=>g,ho:()=>h});var o=n(93091),s=n(88104),r=n(46350),i=n(5392),a=n(93214),p=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class c{constructor(t){(0,o.Xd)(this,t)}canvasGradient(t){let e;switch(this.type()){case"linear":e=t.createLinearGradient(this.from.x(),this.from.y(),this.to.x(),this.to.y());break;case"conic":e=t.createConicGradient(this.angle(),this.from.x(),this.from.y());break;case"radial":e=t.createRadialGradient(this.from.x(),this.from.y(),this.fromRadius(),this.to.x(),this.to.y(),this.toRadius())}for(const{offset:n,color:o}of this.stops())e.addColorStop((0,a.P)(n)?n():n,new i.Color((0,a.P)(o)?o():o).serialize());return e}}p([(0,o.nn)("linear"),(0,o.td)()],c.prototype,"type",void 0),p([(0,s.y)("from")],c.prototype,"from",void 0),p([(0,s.y)("to")],c.prototype,"to",void 0),p([(0,o.nn)(0),(0,o.td)()],c.prototype,"angle",void 0),p([(0,o.nn)(0),(0,o.td)()],c.prototype,"fromRadius",void 0),p([(0,o.nn)(0),(0,o.td)()],c.prototype,"toRadius",void 0),p([(0,o.nn)([]),(0,o.td)()],c.prototype,"stops",void 0),p([(0,r.F)()],c.prototype,"canvasGradient",null);var l=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class u{constructor(t){(0,o.Xd)(this,t)}canvasPattern(t){return t.createPattern(this.image(),this.repetition())}}l([(0,o.td)()],u.prototype,"image",void 0),l([(0,o.nn)(null),(0,o.td)()],u.prototype,"repetition",void 0),l([(0,r.F)()],u.prototype,"canvasPattern",null);var m=n(29797);function d(t){return null===t?null:t instanceof c||t instanceof u?t:new i.Color(t)}function h(t,e){return null===t?"":t instanceof i.Color?t.serialize():t instanceof c?t.canvasGradient(e):t instanceof u?t.canvasPattern(e)??"":""}function y(t,e,n,o,s){if(0===n.top&&0===n.right&&0===n.bottom&&0===n.left)return void function(t,e){t.rect(e.x,e.y,e.width,e.height)}(t,e);const r=f(n.top,n.right,n.left,e),i=f(n.right,n.top,n.bottom,e),a=f(n.bottom,n.left,n.right,e),p=f(n.left,n.bottom,n.top,e);if(o){const n=t=>t-t*s;return t.moveTo(e.left+r,e.top),t.lineTo(e.right-i,e.top),t.bezierCurveTo(e.right-n(i),e.top,e.right,e.top+n(i),e.right,e.top+i),t.lineTo(e.right,e.bottom-a),t.bezierCurveTo(e.right,e.bottom-n(a),e.right-n(a),e.bottom,e.right-a,e.bottom),t.lineTo(e.left+p,e.bottom),t.bezierCurveTo(e.left+n(p),e.bottom,e.left,e.bottom-n(p),e.left,e.bottom-p),t.lineTo(e.left,e.top+r),void t.bezierCurveTo(e.left,e.top+n(r),e.left+n(r),e.top,e.left+r,e.top)}t.moveTo(e.left+r,e.top),t.arcTo(e.right,e.top,e.right,e.bottom,i),t.arcTo(e.right,e.bottom,e.left,e.bottom,a),t.arcTo(e.left,e.bottom,e.left,e.top,p),t.arcTo(e.left,e.top,e.right,e.top,r)}function f(t,e,n,o){const s=t+e>o.width?o.width*(t/(t+e)):t,r=t+n>o.height?o.height*(t/(t+n)):t;return Math.min(s,r)}function k(t,e,n){const o=e.size.scale(.5);for(let s=0;s<=n;s++){const e=2*s*Math.PI/n,r=m.F.fromRadians(e).perpendicular.mul(o);0==s?g(t,r):M(t,r)}t.closePath()}function w(t,e,n,o){o?t.drawImage(e,n.x,n.y,n.width,n.height,o.x,o.y,o.width,o.height):t.drawImage(e,n.x,n.y,n.width,n.height)}function g(t,e){t.moveTo(e.x,e.y)}function M(t,e){t.lineTo(e.x,e.y)}function D(t,e){if(!(e.length<2)){g(t,e[0]);for(const n of e.slice(1))M(t,n)}}function _(t,e,n,o,s,r){void 0===o&&(o=0),void 0===s&&(s=2*Math.PI),void 0===r&&(r=!1),t.arc(e.x,e.y,n,o,s,r)}},14455:(t,e,n)=>{"use strict";n.d(e,{I:()=>s});var o=n(15688);function s(t,e,n,s){if(e&&t.setParser(e.bind(n)),s&&n){const e=null==n?void 0:n[`set${(0,o.k)(s)}`];e&&(t.set=function(){for(var t=arguments.length,o=new Array(t),s=0;s<t;s++)o[s]=arguments[s];return e.apply(n,o),n});const r=null==n?void 0:n[`get${(0,o.k)(s)}`];r&&(t.get=r.bind(n));const i=null==n?void 0:n[`tween${(0,o.k)(s)}`];i&&(t.doTween=i.bind(n))}}},88733:(t,e,n)=>{"use strict";n.d(e,{q:()=>o,r:()=>r});var o,s=n(1323);!function(t){t[t.Playing=0]="Playing",t[t.Rendering=1]="Rendering",t[t.Paused=2]="Paused",t[t.Presenting=3]="Presenting"}(o||(o={}));class r{constructor(){this.frame=0,this.speed=1,this.fps=30,this.duration=0,this.finished=!1,this.slides=[],this.previousScene=null,this.state=o.Paused,this.currentSceneReference=null,this.scenes=new s.G([])}get onSceneChanged(){if(null===this.currentSceneReference)throw new Error("PlaybackManager has not been properly initialized");return this.currentSceneReference.subscribable}get onScenesRecalculated(){return this.scenes.subscribable}get currentScene(){if(null===this.currentSceneReference)throw new Error("PlaybackManager has not been properly initialized");return this.currentSceneReference.current}set currentScene(t){if(!t)throw new Error("Invalid scene.");this.currentSceneReference??(this.currentSceneReference=new s.G(t)),this.currentSceneReference.current=t}setup(t){this.scenes.current=t,this.currentScene=t[0]}async progress(){return this.finished=await this.next(),this.finished}async seek(t){if(t<=this.frame||this.currentScene.isCached()&&this.currentScene.lastFrame<t){const e=this.findBestScene(t);e!==this.currentScene?(this.previousScene=null,this.currentScene=e,this.frame=this.currentScene.firstFrame,await this.currentScene.reset()):this.frame>=t&&(this.previousScene=null,this.frame=this.currentScene.firstFrame,await this.currentScene.reset())}for(this.finished=!1;this.frame<t&&!this.finished;)this.finished=await this.next();return this.finished}async goBack(){let t=this.currentScene.slides.getCurrent();if(t&&this.currentScene.slides.isWaiting()){const e=this.slides.indexOf(t);t=this.slides[e-1]}await this.seekSlide(t)}async goForward(){const t=this.currentScene.slides.getCurrent(),e=this.slides.indexOf(t);await this.seekSlide(this.slides[e+1])}async goTo(t){await this.seekSlide(this.slides.find((e=>e.id===t)))}async seekSlide(t){if(void 0===t&&(t=null),!t)return;const{id:e,scene:n}=t;for((this.currentScene!==n||this.currentScene.slides.didHappen(e))&&(this.previousScene=null,this.currentScene=n,this.frame=this.currentScene.firstFrame,this.currentScene.slides.setTarget(e),await this.currentScene.reset()),this.finished=!1,this.currentScene.slides.setTarget(e);!this.currentScene.slides.isWaitingFor(e)&&!this.finished;)this.finished=await this.next();return this.currentScene.slides.setTarget(null),this.finished}async reset(){this.previousScene=null,this.currentScene=this.scenes.current[0],this.frame=0,await this.currentScene.reset()}reload(t){this.scenes.current.forEach((e=>e.reload(t)))}async recalculate(){this.previousScene=null,this.slides=[];const t=this.speed;this.frame=0,this.speed=1;const e=[];try{for(const t of this.scenes.current)await t.recalculate((t=>{this.frame=t})),this.slides.push(...t.slides.onChanged.current),e.push(t)}finally{this.speed=t}this.scenes.current=e,this.duration=this.frame}async next(){if(this.previousScene&&(await this.previousScene.next(),this.currentScene.isFinished()&&(this.previousScene=null)),this.frame+=this.speed,this.currentScene.isFinished())return!0;if(await this.currentScene.next(),this.previousScene&&this.currentScene.isAfterTransitionIn()&&(this.previousScene=null),this.currentScene.canTransitionOut()){this.previousScene=this.currentScene;const t=this.getNextScene(this.previousScene);t&&(this.currentScene=t,await this.currentScene.reset(this.previousScene)),t&&!this.currentScene.isAfterTransitionIn()||(this.previousScene=null)}return this.currentScene.isFinished()}findBestScene(t){let e=this.scenes.current[0];for(const n of this.scenes.current){if(!n.isCached()||n.lastFrame>t)return n;e=n}return e}getNextScene(t){const e=this.scenes.current;if(!t)return e[0];const n=e.findIndex((e=>e===t));return n<0?null:e[n+1]??null}}},2672:(t,e,n)=>{"use strict";n.d(e,{J:()=>y});var o=n(88733),s=n(1323),r=n(3163);class i{get onDataChanged(){return this.data.subscribable}constructor(t){this.logger=t,this.data=new s.G(null),this.context=new AudioContext,this.audioElement=new Audio,this.source=null,this.error=!1,this.abortController=null,this.offset=0}getTime(){return this.toAbsoluteTime(this.audioElement.currentTime)}setTime(t){this.audioElement.currentTime=this.toRelativeTime(t)}setOffset(t){this.offset=t}setMuted(t){this.audioElement.muted=t}setSource(t){var e;this.source=t,this.audioElement.src=t,null==(e=this.abortController)||e.abort(),this.abortController=new AbortController,this.loadData(this.abortController.signal).catch((t=>{"AbortError"!==t.name&&this.logger.error(t)}))}isInRange(t){return t>=this.offset&&t<this.audioElement.duration}toRelativeTime(t){return Math.max(0,t-this.offset)}toAbsoluteTime(t){return t+this.offset}isReady(){return this.source&&!this.error}async setPaused(t){if(this.source&&this.audioElement.paused!==t)if(t)this.audioElement.pause();else try{return await this.audioElement.play(),this.error=!1,!0}catch(e){this.error||(0,r.wL)().error(e),this.error=!0}return!1}async loadData(t){if(this.data.current=null,!this.source)return;const e=await fetch(this.source,{signal:t}),n=await e.arrayBuffer();if(t.aborted)return;const o=await this.decodeAudioData(n);if(t.aborted)return;const s=256,r=~~(o.length/s),i=[];let a=0;for(let p=0;p<o.numberOfChannels;p++){const t=o.getChannelData(p);for(let e=0;e<r;e++){const n=~~(e*s),o=~~(n+s);let r=t[n],c=r;for(let e=n;e<o;e++){const n=t[e];n>c&&(c=n),n<r&&(r=n)}(0===p||c>i[2*e])&&(i[2*e]=c),(0===p||r<i[2*e+1])&&(i[2*e+1]=r),c>a&&(a=c),Math.abs(r)>a&&(a=Math.abs(r))}}this.data.current={peaks:i,absoluteMax:a,length:r,sampleRate:o.sampleRate/s*2}}decodeAudioData(t){return new Promise(((e,n)=>this.context.decodeAudioData(t,e,n)))}}var a=n(13170),p=n(11395);class c extends p.p{async dispatch(t){await Promise.all(this.notifySubscribers(t))}}var l=n(96881),u=n(29797);class m{constructor(t){this.playback=t}secondsToFrames(t){return Math.ceil(t*this.playback.fps)}framesToSeconds(t){return t/this.playback.fps}get time(){return this.framesToSeconds(this.playback.frame)}get frame(){return this.playback.frame}get speed(){return this.playback.speed}get fps(){return this.playback.fps}get state(){return this.playback.state}}var d=n(15649);class h{get onChanged(){return this.events.subscribable}constructor(t){this.scene=t,this.events=new s.G([]),this.registeredEvents={},this.lookup={},this.collisionLookup=new Set,this.previousReference=[],this.didEventsChange=!1,this.preserveTiming=!0,this.handleReload=()=>{this.registeredEvents={},this.collisionLookup.clear()},this.handleRecalculated=()=>{var t;this.preserveTiming=!0,this.events.current=Object.values(this.registeredEvents),(this.didEventsChange||((null==(t=this.previousReference)?void 0:t.length)??0)!==this.events.current.length)&&(this.didEventsChange=!1,this.previousReference=Object.values(this.registeredEvents).map((t=>({name:t.name,targetTime:t.targetTime}))),this.scene.meta.timeEvents.set(this.previousReference))},this.handleReset=()=>{this.collisionLookup.clear()},this.handleMetaChanged=t=>{t!==this.previousReference&&(this.previousReference=t,this.load(t),this.scene.reload())},this.previousReference=t.meta.timeEvents.get(),this.load(this.previousReference),t.onReloaded.subscribe(this.handleReload),t.onRecalculated.subscribe(this.handleRecalculated),t.onReset.subscribe(this.handleReset),t.meta.timeEvents.onChanged.subscribe(this.handleMetaChanged,!1)}set(t,e,n){void 0===n&&(n=!0),this.lookup[t]&&this.lookup[t].offset!==e&&(this.preserveTiming=n,this.lookup[t]={...this.lookup[t],targetTime:this.lookup[t].initialTime+e,offset:e},this.registeredEvents[t]=this.lookup[t],this.events.current=Object.values(this.registeredEvents),this.didEventsChange=!0,this.scene.reload())}register(t,e){if(this.collisionLookup.has(t))return this.scene.logger.error({message:`name "${t}" has already been used for another event name.`,stack:(new Error).stack}),0;if(this.collisionLookup.add(t),this.lookup[t]){let n=!1;const o={...this.lookup[t]},s=(new Error).stack;o.stack!==s&&(o.stack=s,n=!0),o.initialTime!==e&&(o.initialTime=e,n=!0);const r=Math.max(0,o.targetTime-o.initialTime);this.preserveTiming&&o.offset!==r&&(o.offset=r,n=!0);const i=o.initialTime+o.offset;this.preserveTiming||o.targetTime===i||(this.didEventsChange=!0,o.targetTime=i,n=!0),n&&(this.lookup[t]=o)}else this.didEventsChange=!0,this.lookup[t]={name:t,initialTime:e,targetTime:e,offset:0,stack:(new Error).stack};return this.registeredEvents[t]=this.lookup[t],this.lookup[t].offset}load(t){for(const e of t){const t=this.lookup[e.name]??{name:e.name,initialTime:0,offset:0};this.lookup[e.name]={...t,targetTime:e.targetTime}}}}class y{get onRender(){return this.render.subscribable}get onStateChanged(){return this.playerState.subscribable}get onFrameChanged(){return this.frame.subscribable}get onDurationChanged(){return this.duration.subscribable}get onRecalculated(){return this.recalculated.subscribable}get startFrame(){return Math.min(this.playback.duration,this.status.secondsToFrames(this.startTime))}get endFrame(){return Math.min(this.playback.duration,this.status.secondsToFrames(this.endTime))}get finished(){return this.playback.finished||this.playback.frame>=this.endFrame}constructor(t,e,n,r){var a,p;void 0===e&&(e={}),void 0===n&&(n={}),void 0===r&&(r=-1),this.project=t,this.settings=e,this.initialState=n,this.initialFrame=r,this.render=new c,this.frame=new s.G(0),this.duration=new s.G(0),this.recalculated=new l.p,this.lock=new d.L,this.startTime=0,this.endTime=1/0,this.requestId=null,this.renderTime=0,this.requestedSeek=-1,this.requestedRecalculation=!0,this.active=!1,this.playerState=new s.G({loop:!0,muted:!0,speed:1,...n,paused:!0}),this.requestedSeek=r,this.logger=this.project.logger,this.playback=new o.r,this.status=new m(this.playback),this.audio=new i(this.logger),this.size=e.size??new u.F(1920,1080),this.resolutionScale=e.resolutionScale??1,this.startTime=(null==(a=e.range)?void 0:a[0])??0,this.endTime=(null==(p=e.range)?void 0:p[1])??1/0,this.playback.fps=e.fps??60,this.audio.setOffset(e.audioOffset??0),t.audio&&this.audio.setSource(t.audio);const y=[];for(const o of t.scenes){var f;const e=new o.klass({...o,playback:this.status,logger:this.project.logger,size:this.size,resolutionScale:this.resolutionScale,timeEventsClass:h});null==(f=o.onReplaced)||f.subscribe((t=>{e.reload(t)}),!1),e.onReloaded.subscribe((()=>this.requestRecalculation())),e.variables.updateSignals(t.variables??{}),y.push(e)}this.playback.setup(y),this.activate()}async configure(t){await this.lock.acquire();let e=this.playback.frame,n=!1;if(this.startTime=t.range[0],this.endTime=t.range[1],this.playback.fps!==t.fps){const o=t.fps/this.playback.fps;this.playback.fps=t.fps,e=Math.floor(e*o),n=!0}t.size.exactlyEquals(this.size)&&t.resolutionScale===this.resolutionScale||(this.size=t.size,this.resolutionScale=t.resolutionScale,this.playback.reload({size:this.size,resolutionScale:this.resolutionScale})),void 0!==t.audioOffset&&this.audio.setOffset(t.audioOffset),this.lock.release(),n&&(this.playback.reload(),this.frame.current=e,this.requestRecalculation(),this.requestedSeek=e)}requestSeek(t){this.requestedSeek=this.clampRange(t)}requestPreviousFrame(){this.requestedSeek=this.frame.current-this.playback.speed}requestNextFrame(){this.requestedSeek=this.frame.current+this.playback.speed}requestReset(){this.requestedSeek=0}toggleLoop(t){void 0===t&&(t=!this.playerState.current.loop),t!==this.playerState.current.loop&&(this.playerState.current={...this.playerState.current,loop:t})}togglePlayback(t){void 0===t&&(t=this.playerState.current.paused),t===this.playerState.current.paused&&(this.playerState.current={...this.playerState.current,paused:!t},t&&!this.playerState.current.loop&&this.playback.frame===this.playback.duration&&this.requestReset())}toggleAudio(t){void 0===t&&(t=this.playerState.current.muted),t===this.playerState.current.muted&&(this.playerState.current={...this.playerState.current,muted:!t})}setSpeed(t){t!==this.playerState.current.speed&&(this.playback.speed=t,this.playback.reload(),this.playerState.current={...this.playerState.current,speed:t},this.requestRecalculation())}setVariables(t){for(const e of this.playback.onScenesRecalculated.current)e.variables.updateSignals(t)}activate(){this.active=!0,this.request()}deactivate(){this.active=!1,null!==this.requestId&&(cancelAnimationFrame(this.requestId),this.requestId=null)}requestRecalculation(){this.requestedRecalculation=!0,this.request()}async prepare(){const t={...this.playerState.current,seek:this.requestedSeek};if(this.requestedSeek=-1,this.requestedRecalculation){t.seek<0&&(t.seek=this.playback.frame);try{await this.playback.recalculate(),this.duration.current=this.playback.frame,this.recalculated.dispatch()}catch(n){throw this.requestSeek(t.seek),n}finally{this.requestedRecalculation=!1}}(!t.loop&&this.finished&&!t.paused&&t.seek<0||this.endFrame===this.startFrame)&&(this.togglePlayback(!1),t.paused=!0),t.loop&&(t.seek>this.endFrame||this.finished&&!t.paused)&&this.startFrame!==this.endTime&&(t.seek=this.startFrame);const e=t.paused||this.finished||!this.audio.isInRange(this.status.time);return await this.audio.setPaused(e)&&this.syncAudio(-3),this.audio.setMuted(t.muted),t}async run(){const t=await this.prepare(),e=this.playback.state;if(this.playback.state=t.paused?o.q.Paused:o.q.Playing,t.seek>=0||!this.isInRange(this.status.frame)){const e=t.seek<0?this.status.frame:t.seek,n=this.clampRange(e);this.logger.profile("seek time"),await this.playback.seek(n),this.logger.profile("seek time"),this.syncAudio(-3)}else{if(t.paused||1===t.speed&&this.audio.isReady()&&this.audio.isInRange(this.status.time)&&this.audio.getTime()<this.status.time)return t.paused&&e!==o.q.Paused&&await this.render.dispatch(),!t.paused&&this.status.time>this.audio.getTime()+.02&&this.syncAudio(),void this.request();if(this.audio.isReady()&&1===t.speed&&this.audio.isInRange(this.status.time)&&this.status.framesToSeconds(this.playback.frame+1)<this.audio.getTime()-.02){const t=this.status.secondsToFrames(this.audio.getTime());await this.playback.seek(t)}else this.status.frame<this.endFrame&&(await this.playback.progress(),1!==t.speed&&this.syncAudio())}!t.paused&&this.playback.currentScene.slides.isWaiting()&&(this.togglePlayback(!1),t.paused=!0),await this.render.dispatch(),this.frame.current=this.playback.frame,this.request()}request(){this.active&&(this.requestId??(this.requestId=requestAnimationFrame((async t=>{if(this.requestId=null,t-this.renderTime>=1e3/(this.status.fps+5)){this.renderTime=t,await this.lock.acquire();try{await this.run()}catch(e){this.logger.error(e)}this.lock.release()}else this.request()}))))}clampRange(t){return(0,a.uZ)(this.startFrame,this.endFrame,t)}isInRange(t){return t>=this.startFrame&&t<=this.endFrame}syncAudio(t){void 0===t&&(t=0),this.audio.setTime(this.status.framesToSeconds(this.playback.frame+t))}}},9989:(t,e,n)=>{"use strict";n.d(e,{H:()=>r});var o=n(1119),s=n(29797);class r{get canvasSize(){return this.size.scale(this.resolutionScale)}constructor(){this.background=null,this.resolutionScale=1,this.colorSpace="srgb",this.size=s.F.zero,this.finalBuffer=document.createElement("canvas"),this.currentBuffer=document.createElement("canvas"),this.previousBuffer=document.createElement("canvas");const t=this.colorSpace;this.context=(0,o.f)({colorSpace:t},this.finalBuffer),this.currentContext=(0,o.f)({colorSpace:t},this.currentBuffer),this.previousContext=(0,o.f)({colorSpace:t},this.previousBuffer)}configure(t){let{colorSpace:e=this.colorSpace,size:n=this.size,resolutionScale:s=this.resolutionScale,background:r=this.background}=t;e!==this.colorSpace&&(this.colorSpace=e,this.context=(0,o.f)({colorSpace:e},this.finalBuffer),this.currentContext=(0,o.f)({colorSpace:e},this.currentBuffer),this.previousContext=(0,o.f)({colorSpace:e},this.previousBuffer)),n.exactlyEquals(this.size)&&s===this.resolutionScale||(this.resolutionScale=s,this.size=n,this.resizeCanvas(this.context),this.resizeCanvas(this.currentContext),this.resizeCanvas(this.previousContext)),this.background="string"==typeof r?r:(null==r?void 0:r.serialize())??null}async render(t,e){e&&(this.transformCanvas(this.previousContext),await e.render(this.previousContext)),this.transformCanvas(this.currentContext),await t.render(this.currentContext);const n=this.canvasSize;this.context.clearRect(0,0,n.width,n.height),this.background&&(this.context.save(),this.context.fillStyle=this.background,this.context.fillRect(0,0,n.width,n.height),this.context.restore()),e&&this.context.drawImage(this.previousBuffer,0,0),this.context.drawImage(this.currentBuffer,0,0)}transformCanvas(t){const e=this.canvasSize.scale(.5);t.setTransform(this.resolutionScale,0,0,this.resolutionScale,e.x,e.y)}resizeCanvas(t){const e=this.canvasSize;t.canvas.width=e.width,t.canvas.height=e.height}}},42075:(t,e,n)=>{"use strict";function o(t){const e={[t.name]:t},n=Object.getOwnPropertyDescriptor(e,t.name);if(n){for(var o=arguments.length,s=new Array(o>1?o-1:0),r=1;r<o;r++)s[r-1]=arguments[r];for(let o=s.length-1;o>=0;o--)s[o](e,t.name,n)}}n.d(e,{G:()=>o})},79116:(t,e,n)=>{"use strict";n.d(e,{V:()=>s});const o=Symbol.for("@motion-canvas/core/decorators/UNINITIALIZED");function s(t){return(e,n)=>{let s=o;Object.defineProperty(e,n,{get(){return s===o&&(s=t.call(this)),s}})}}},67292:(t,e,n)=>{"use strict";function o(t){return function(e,n,o){o.value.prototype.name=t??n,o.value.prototype.threadable=!0}}n.d(e,{C:()=>o})},96881:(t,e,n)=>{"use strict";n.d(e,{p:()=>s});var o=n(11395);class s extends o.p{dispatch(t){this.notifySubscribers(t)}}},11395:(t,e,n)=>{"use strict";n.d(e,{l:()=>s,p:()=>o});class o{constructor(){this.subscribable=new s(this),this.subscribers=new Set}subscribe(t){return this.subscribers.add(t),()=>this.unsubscribe(t)}unsubscribe(t){this.subscribers.delete(t)}clear(){this.subscribers.clear()}notifySubscribers(t){return[...this.subscribers].map((e=>e(t)))}}class s{constructor(t){this.dispatcher=t}subscribe(t){return this.dispatcher.subscribe(t)}unsubscribe(t){this.dispatcher.unsubscribe(t)}}},1323:(t,e,n)=>{"use strict";n.d(e,{G:()=>s});var o=n(11395);class s extends o.p{set current(t){this.value=t,this.notifySubscribers(t)}get current(){return this.value}constructor(t){super(),this.value=t,this.subscribable=new r(this)}subscribe(t,e){void 0===e&&(e=!0);const n=super.subscribe(t);return e&&t(this.value),n}}class r extends o.l{get current(){return this.dispatcher.current}subscribe(t,e){return void 0===e&&(e=!0),this.dispatcher.subscribe(t,e)}}},5376:(t,e,n)=>{"use strict";n.d(e,{$:()=>i});var o=n(51284),s=n(42075),r=n(67292);function*i(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];for(const o of e)yield o;yield*(0,o.v)(...e)}(0,s.G)(i,(0,r.C)())},77396:(t,e,n)=>{"use strict";n.d(e,{K:()=>s});var o=n(75168);function s(t,e){let n;return"string"==typeof t?(n=e(),(0,o.i)(n,t)):(n=t(),(0,o.i)(n,n)),n}},82344:(t,e,n)=>{"use strict";n.d(e,{C:()=>s});var o=n(1323);class s{get onChanged(){return this.value.subscribable}constructor(t,e){this.name=t,this.value=new o.G(e)}get(){return this.value.current}set(t){this.value.current=this.parse(t)}parse(t){return t}serialize(){return this.value.current}clone(){return new this.constructor(this.name,this.get())}}},92673:(t,e,n)=>{"use strict";n.d(e,{v:()=>r});var o=n(82344);class s extends o.C{constructor(t,e){const n=new Map(Object.entries(e));super(t,Object.fromEntries(Array.from(n,(t=>{let[e,n]=t;return[e,n.get()]})))),this.ignoreChange=!1,this.customFields={},this.handleChange=()=>{this.ignoreChange||(this.value.current=this.transform("get"))},this.fields=n;for(const[o,s]of this.fields)Object.defineProperty(this,o,{value:s}),s.onChanged.subscribe(this.handleChange)}set(t){this.ignoreChange=!0;for(const[e,n]of Object.entries(t)){const t=this.fields.get(e);t?t.set(n):this.customFields[e]=n}this.ignoreChange=!1,this.handleChange()}serialize(){return this.transform("serialize")}clone(){return new this.constructor(this.name,this.transform("clone"))}transform(t){return{...Object.fromEntries(Array.from(this.fields,(e=>{let[n,o]=e;return[n,o[t]()]}))),...this.customFields}}}const r=s},11726:(t,e,n)=>{"use strict";n.d(e,{k:()=>r});var o=n(13170),s=n(37762);class r{constructor(t){this.state=t}static createSeed(){return Math.floor(4294967296*Math.random())}nextFloat(t,e){return void 0===t&&(t=0),void 0===e&&(e=1),(0,o.UI)(t,e,this.next())}nextInt(t,e){void 0===t&&(t=0),void 0===e&&(e=4294967296);let n=Math.floor((0,o.UI)(t,e,this.next()));return n===e&&(n=t),n}floatArray(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,s.w)(t).map((()=>this.nextFloat(e,n)))}intArray(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=4294967296),(0,s.w)(t).map((()=>this.nextInt(e,n)))}spawn(){return new r(this.nextInt())}next(){this.state|=0,this.state=this.state+1831565813|0;let t=Math.imul(this.state^this.state>>>15,1|this.state);return t=t+Math.imul(t^t>>>7,61|t)^t,((t^t>>>14)>>>0)/4294967296}}},46096:(t,e,n)=>{"use strict";n.d(e,{N:()=>i});var o=n(13170),s=n(16249),r=n(93214);class i extends s.V{constructor(t,e,n,i,a){void 0===a&&(a=void 0),super(void 0,i,a),this.entries=t,this.signals=[],this.parser=e;for(const p of t){const t=new s.V((0,r.P)(n)?()=>e(n())[p]:e(n)[p],o.UI,a??this.invokable).toSignal();this.signals.push([p,t]),Object.defineProperty(this.invokable,p,{value:t})}}toSignal(){return this.invokable}parse(t){return this.parser(t)}get(){return this.parse(Object.fromEntries(this.signals.map((t=>{let[e,n]=t;return[e,n()]}))))}set(t){if((0,r.P)(t))for(const[e,n]of this.signals)n((()=>this.parser(t())[e]));else{const e=this.parse(t);for(const[t,n]of this.signals)n(e[t])}return this.owner}reset(){for(const[,t]of this.signals)t.reset();return this.owner}save(){for(const[,t]of this.signals)t.save();return this.owner}}},81865:(t,e,n)=>{"use strict";n.d(e,{h:()=>i});var o=n(3163),s=n(90031),r=n(76062);class i extends r.k{constructor(t,e){super(e),this.factory=t,this.markDirty()}toSignal(){return this.invokable}dispose(){super.dispose(),this.last=void 0}invoke(){if(this.event.isRaised()){this.clearDependencies(),this.startCollecting();try{this.last=this.factory(...arguments)}catch(e){var t;(0,o.wL)().error({...(0,s.d)(e),inspect:null==(t=this.owner)?void 0:t.key})}this.finishCollecting()}return this.event.reset(),this.collect(),this.last}}},76062:(t,e,n)=>{"use strict";n.d(e,{k:()=>i});var o=n(11395);class s extends o.p{constructor(){super(...arguments),this.value=!1}raise(){this.value||(this.value=!0,this.notifySubscribers())}reset(){this.value=!1}isRaised(){return this.value}subscribe(t){const e=super.subscribe(t);return this.value&&t(),e}}var r=n(49111);class i{static collectPromise(t,e){void 0===e&&(e=null);const n={promise:t,value:e,stack:(new Error).stack},o=this.collectionStack.at(-1);return o&&(n.owner=o.owner),t.then((t=>{n.value=t,null==o||o.markDirty()})),this.promises.push(n),n}static consumePromises(){const t=this.promises;return this.promises=[],t}constructor(t){this.owner=t,this.dependencies=new Set,this.event=new s,this.markDirty=()=>this.event.raise(),this.invokable=this.invoke.bind(this),Object.defineProperty(this.invokable,"context",{value:this}),Object.defineProperty(this.invokable,"toPromise",{value:this.toPromise.bind(this)})}invoke(){}startCollecting(){if(i.collectionSet.has(this))throw new r.t("A circular dependency occurred between signals.","This can happen when signals reference each other in a loop.\n        Try using the attached stack trace to locate said loop.");i.collectionSet.add(this),i.collectionStack.push(this)}finishCollecting(){if(i.collectionSet.delete(this),i.collectionStack.pop()!==this)throw new Error("collectStart/collectEnd was called out of order.")}clearDependencies(){this.dependencies.forEach((t=>t.unsubscribe(this.markDirty))),this.dependencies.clear()}collect(){const t=i.collectionStack.at(-1);t&&(t.dependencies.add(this.event.subscribable),this.event.subscribe(t.markDirty))}dispose(){this.clearDependencies(),this.event.clear(),this.owner=null}async toPromise(){let t=i.consumePromises();do{await Promise.all(t.map((t=>t.promise))),this.invokable(),t=i.consumePromises()}while(t.length>0);return this.invokable}}i.collectionSet=new Set,i.collectionStack=[],i.promises=[]},16249:(t,e,n)=>{"use strict";n.d(e,{V:()=>u});var o=n(97074),s=n(74534),r=n(3163),i=n(90031),a=n(77396),p=n(76062),c=n(93214),l=n(60771);class u extends p.k{constructor(t,e,n){void 0===n&&(n=void 0),super(n),this.initial=t,this.interpolation=e,this.parser=t=>t,Object.defineProperty(this.invokable,"reset",{value:this.reset.bind(this)}),Object.defineProperty(this.invokable,"save",{value:this.save.bind(this)}),Object.defineProperty(this.invokable,"isInitial",{value:this.isInitial.bind(this)}),void 0!==this.initial&&(this.current=this.initial,this.markDirty(),(0,c.P)(this.initial)||(this.last=this.parse(this.initial)))}toSignal(){return this.invokable}parse(t){return this.parser(t)}wrap(t){return(0,c.P)(t)?()=>this.parse(t()):this.parse(t)}setInitial(t){this.initial=t}setParser(t){this.parser=t,void 0===this.current||(0,c.P)(this.current)||(this.last=this.parse(this.current)),this.markDirty()}set(t){return t===l.T&&(t=this.initial),this.current===t||(this.current=t,this.markDirty(),this.clearDependencies(),(0,c.P)(t)||(this.last=this.parse(t))),this.owner}get(){if(this.event.isRaised()&&(0,c.P)(this.current)){this.clearDependencies(),this.startCollecting();try{this.last=this.parse(this.current())}catch(e){var t;(0,r.wL)().error({...(0,i.d)(e),inspect:null==(t=this.owner)?void 0:t.key})}this.finishCollecting()}return this.event.reset(),this.collect(),this.last}invoke(t,e,n,s){return void 0===n&&(n=o.qb),void 0===s&&(s=this.interpolation),void 0===t?this.get():void 0===e?this.set(t):this.makeAnimate(n,s)(t,e)}makeAnimate(t,e,n){var o=this;return function(s,r,i,p){void 0===i&&(i=t),void 0===p&&(p=e);const c=o.tween(s,r,i,p);let l=c;return n&&(l=(0,a.K)((function*(){yield*n,yield*c}))),l.to=o.makeAnimate(i,p,l),l}}*tween(t,e,n,o){t===l.T&&(t=this.initial),yield*this.doTween(this.parse((0,c.P)(t)?t():t),e,n,o),this.set(t)}*doTween(t,e,n,o){const r=this.get();yield*(0,s.i)(e,(e=>{this.set(o(r,t,n(e)))}))}dispose(){super.dispose(),this.initial=void 0,this.current=void 0,this.last=void 0}reset(){return void 0!==this.initial&&this.set(this.initial),this.owner}save(){return this.set(this.get())}isInitial(){return this.collect(),this.current===this.initial}raw(){return this.current}}},73662:(t,e,n)=>{"use strict";n.d(e,{D:()=>s});var o=n(81865);function s(t,e){return new o.h(t,e).toSignal()}},97140:(t,e,n)=>{"use strict";n.d(e,{g:()=>r});var o=n(13170),s=n(16249);function r(t,e,n){return void 0===e&&(e=o.o0),new s.V(t,e,n).toSignal()}},93214:(t,e,n)=>{"use strict";function o(t){return"function"==typeof t}n.d(e,{P:()=>o})},60771:(t,e,n)=>{"use strict";n.d(e,{T:()=>o});const o=Symbol.for("@motion-canvas/core/signals/default")},50580:(t,e,n)=>{"use strict";n.d(e,{j:()=>i});var o=n(56632),s=n(97140),r=n(75168);class i{get fixed(){return this.fixedTime}get canceled(){var t;return this.isCanceled||((null==(t=this.parent)?void 0:t.canceled)??!1)}constructor(t){this.runner=t,this.children=[],this.time=(0,s.g)(0),this.parent=null,this.isCanceled=!1,this.fixedTime=0}next(){(0,o.h$)(this);const t=this.runner.next(this.value);return(0,o.kw)(this),this.value=null,t}update(t){this.time(this.time()+t),this.fixedTime+=t,this.children=this.children.filter((t=>!t.canceled))}add(t){t.cancel(),t.parent=this,t.isCanceled=!1,t.time(this.time()),t.fixedTime=this.fixedTime,this.children.push(t),(0,r.i)(t.runner,`unknown ${this.children.length}`)}cancel(){this.isCanceled=!0,this.parent=null}}},80638:(t,e,n)=>{"use strict";function o(t){return t&&("object"==typeof t||"function"==typeof t)&&"toPromise"in t}function s(t){return null!==t&&"object"==typeof t&&Symbol.iterator in t&&"next"in t}n.d(e,{R:()=>s,x:()=>o})},51284:(t,e,n)=>{"use strict";n.d(e,{v:()=>i});var o=n(42075),s=n(67292),r=n(56632);function*i(t){let e=!0;for(var n=arguments.length,o=new Array(n>1?n-1:0),s=1;s<n;s++)o[s-1]=arguments[s];"boolean"==typeof t?e=t:o.push(t);const i=(0,r.nn)(),a=o.map((t=>i.children.find((e=>e.runner===t)))).filter((t=>t)),p=i.time();let c;if(e){for(;a.find((t=>!t.canceled));)yield;c=Math.max(...a.map((t=>t.time())))}else{for(;!a.find((t=>t.canceled));)yield;const t=a.filter((t=>t.canceled));c=Math.min(...t.map((t=>t.time())))}i.time(Math.max(p,c))}(0,o.G)(i,(0,s.C)())},75168:(t,e,n)=>{"use strict";function o(t,e){const n=Object.getPrototypeOf(t);n.threadable||(n.threadable=!0,n.name="string"==typeof e?e:s(e))}function s(t){return Object.getPrototypeOf(t).name??null}n.d(e,{i:()=>o,z:()=>s})},5881:(t,e,n)=>{"use strict";n.d(e,{C:()=>l,t:()=>c});var o=n(42075),s=n(67292),r=n(50580),i=n(80638),a=n(75168),p=n(97715);function c(t){return"function"==typeof(null==t?void 0:t.then)}function*l(t,e){const n=(0,p.te)(),o=t();(0,a.i)(o,"root");const s=new r.j(o);null==e||e(s);let c=[s];for(;c.length>0;){const t=[],e=[...c],o=n.framesToSeconds(1)*n.speed;for(;e.length>0;){const n=e.pop();if(!n||n.canceled)continue;const s=n.next();if(s.done)n.cancel();else if((0,i.R)(s.value)){const t=new r.j(s.value);n.value=s.value,n.add(t),e.push(n),e.push(t)}else s.value?(n.value=yield s.value,e.push(n)):(n.update(o),t.unshift(n))}c=t.filter((t=>!t.canceled)),c.length>0&&(yield)}}(0,o.G)(l,(0,s.C)())},13170:(t,e,n)=>{"use strict";n.d(e,{JC:()=>r,UI:()=>a,Vz:()=>u,a2:()=>p,o0:()=>i,uZ:()=>c,vl:()=>l});var o=n(3163),s=n(29797);function r(t,e,n){if(e.length>=t.length){const o=Math.floor(e.length*n),s=Math.floor(a(t.length-1,e.length,n));let r="";for(let n=0;n<e.length;n++)n<o?r+=e[n]:(t[n]||n<=s)&&(r+=t[n]??e[n]);return r}{const o=Math.round(t.length*(1-n)),s=Math.floor(a(t.length+1,e.length,n)),r=[];for(let n=t.length-1;n>=0;n--)n<o?r.unshift(t[n]):(e[n]||n<s)&&r.unshift(e[n]??t[n]);return r.join("")}}function i(t,e,n,s){if(void 0===s&&(s=!1),0===n)return t;if(1===n)return e;if(null!=t&&null!=e){if("number"==typeof t&&"number"==typeof e)return a(t,e,n);if("string"==typeof t&&"string"==typeof e)return r(t,e,n);if("boolean"==typeof t&&"boolean"==typeof e)return n<.5?t:e;if("lerp"in t)return t.lerp(e,n);if(t&&e&&"object"==typeof t&&"object"==typeof e)if(Array.isArray(t)&&Array.isArray(e)){if(t.length===e.length)return t.map(((t,o)=>i(t,e[o],n)))}else{let o=!1;if(t instanceof Map||e instanceof Map||(o=!0,t=new Map(Object.entries(t)),e=new Map(Object.entries(e))),t instanceof Map&&e instanceof Map){const s=new Map;for(const o of new Set([...t.keys(),...e.keys()])){const r=i(t.get(o),e.get(o),n,!0);void 0!==r&&s.set(o,r)}return o?Object.fromEntries(s):s}}return e}s||(0,o.wL)().warn(`Attempting to lerp ${t} -> ${e} may result in unexpected behavior.`)}function a(t,e,n){return t+(e-t)*n}function p(t,e,n,o,s){return n+(s-t)*(o-n)/(e-t)}function c(t,e,n){return n<t?t:n>e?e:n}function l(t,e,n,o,s){const r=p(t,e,n,o,s);return n>o&&([n,o]=[o,n]),c(n,o,r)}function u(t,e,n){let o=e;n>1?n=1/n:o=!o;const r=a(o?Math.acos(c(-1,1,1-t)):Math.asin(t),a(0,Math.PI/2,t),n);let i=Math.sin(r),p=1-Math.cos(r);return e&&([i,p]=[p,i]),new s.F(i,p)}},97074:(t,e,n)=>{"use strict";n.d(e,{BH:()=>F,Bl:()=>b,C6:()=>B,FG:()=>p,Fs:()=>a,GE:()=>z,Ge:()=>v,Ij:()=>E,J7:()=>f,Kx:()=>Z,Mg:()=>X,N1:()=>r,O$:()=>s,Q9:()=>u,SJ:()=>W,UE:()=>P,Y3:()=>y,Yw:()=>I,ad:()=>D,cv:()=>U,du:()=>N,eE:()=>O,e_:()=>M,ei:()=>x,en:()=>G,g4:()=>h,hN:()=>_,hl:()=>c,j$:()=>C,jv:()=>S,lj:()=>T,mC:()=>A,n5:()=>k,pl:()=>w,qS:()=>L,qb:()=>d,rz:()=>g,sK:()=>j,to:()=>l,vh:()=>i,w2:()=>m,zk:()=>R});var o=n(13170);function s(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,o.a2)(-1,1,e,n,Math.sin(t))}function r(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.cos(t*Math.PI/2),(0,o.UI)(e,n,t)}function i(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=Math.sin(t*Math.PI/2),(0,o.UI)(e,n,t)}function a(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=-(Math.cos(Math.PI*t)-1)/2,(0,o.UI)(e,n,t)}function p(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t,(0,o.UI)(e,n,t)}function c(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,2),(0,o.UI)(e,n,t)}function l(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2,(0,o.UI)(e,n,t)}function u(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t*t,(0,o.UI)(e,n,t)}function m(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,3),(0,o.UI)(e,n,t)}function d(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,(0,o.UI)(e,n,t)}function h(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t*t*t,(0,o.UI)(e,n,t)}function y(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,4),(0,o.UI)(e,n,t)}function f(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?8*t*t*t*t:1-Math.pow(-2*t+2,4)/2,(0,o.UI)(e,n,t)}function k(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t*t*t*t,(0,o.UI)(e,n,t)}function w(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,5),(0,o.UI)(e,n,t)}function g(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?16*t*t*t*t*t:1-Math.pow(-2*t+2,5)/2,(0,o.UI)(e,n,t)}function M(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=0===t?0:Math.pow(2,10*t-10),(0,o.UI)(e,n,t)}function D(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1===t?1:1-Math.pow(2,-10*t),(0,o.UI)(e,n,t)}function _(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=0===t?0:1===t?1:t<.5?Math.pow(2,20*t-10)/2:(2-Math.pow(2,-20*t+10))/2,(0,o.UI)(e,n,t)}function X(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.sqrt(1-Math.pow(t,2)),(0,o.UI)(e,n,t)}function x(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=Math.sqrt(1-Math.pow(t-1,2)),(0,o.UI)(e,n,t)}function v(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?(1-Math.sqrt(1-Math.pow(2*t,2)))/2:(Math.sqrt(1-Math.pow(-2*t+2,2))+1)/2,(0,o.UI)(e,n,t)}function C(t){return void 0===t&&(t=1.70158),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=(t+1)*e*e*e-t*e*e,(0,o.UI)(n,s,e)}}function T(t){return void 0===t&&(t=1.70158),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=1+(t+1)*Math.pow(e-1,3)+t*Math.pow(e-1,2),(0,o.UI)(n,s,e)}}function b(t,e){return void 0===t&&(t=1.70158),void 0===e&&(e=1.525),function(n,s,r){return void 0===s&&(s=0),void 0===r&&(r=1),n=n<.5?Math.pow(2*n,2)*(2*(t*e+1)*n-t*e)/2:(Math.pow(2*n-2,2)*((t*e+1)*(2*n-2)+t*e)+2)/2,(0,o.UI)(s,r,n)}}function L(t){return void 0===t&&(t=2.094395),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=0===e?0:1===e?1:-Math.pow(2,10*e-10)*Math.sin((10*e-10.75)*t),(0,o.UI)(n,s,e)}}function Z(t){return void 0===t&&(t=2.094395),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=0===e?0:1===e?1:Math.pow(2,-10*e)*Math.sin((10*e-.75)*t)+1,(0,o.UI)(n,s,e)}}function N(t){return void 0===t&&(t=1.39626),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=0===e?0:1===e?1:e<.5?-Math.pow(2,20*e-10)*Math.sin((20*e-11.125)*t)/2:Math.pow(2,-20*e+10)*Math.sin((20*e-11.125)*t)/2+1,(0,o.UI)(n,s,e)}}function S(t,e){void 0===t&&(t=7.5625),void 0===e&&(e=2.75);const n=R(t,e);return function(t,e,o){return void 0===e&&(e=0),void 0===o&&(o=1),1-n(1-t,e,o)}}function R(t,e){return void 0===t&&(t=7.5625),void 0===e&&(e=2.75),function(n,s,r){return void 0===s&&(s=0),void 0===r&&(r=1),n<1/e?n*=t*n:n=n<2/e?t*(n-=1.505/e)*n+.75:n<2.5/e?t*(n-=2.25/e)*n+.9375:t*(n-=2.625/e)*n+.984375,(0,o.UI)(s,r,n)}}function E(t,e){void 0===t&&(t=7.5625),void 0===e&&(e=2.75);const n=R(t,e);return function(t,e,o){return void 0===e&&(e=0),void 0===o&&(o=1),t<.5?(1-n(1-2*t,e,o))/2:(1+n(2*t-1,e,o))/2}}function z(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,o.UI)(e,n,t)}function A(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,o.a2)(-1,1,e,n,Math.cos(t))}const I=C(),P=T(),F=b(),W=S(),B=R(),G=E(),O=L(),j=Z(),U=N()},74534:(t,e,n)=>{"use strict";n.d(e,{i:()=>i});var o=n(42075),s=n(67292),r=n(56632);function*i(t,e,n){const o=(0,r.nn)(),s=o.time(),i=o.time()+t;for(e(0,0);i>o.fixed;){const n=o.fixed-s;n>0&&e(n/t,n),yield}o.time(i),e(1,t),null==n||n(1,t)}(0,o.G)(i,(0,s.C)())},23357:(t,e,n)=>{"use strict";n.d(e,{b:()=>i});var o=n(29797),s=n(13170),r=n(46096);class i{static createSignal(t,e){return void 0===e&&(e=i.lerp),new r.N(["x","y","width","height"],(t=>new i(t)),t,e).toSignal()}static lerp(t,e,n){let r,a,p,c;return"number"==typeof n?r=a=p=c=n:n instanceof o.F?(r=p=n.x,a=c=n.y):(r=n.x,a=n.y,p=n.width,c=n.height),new i((0,s.UI)(t.x,e.x,r),(0,s.UI)(t.y,e.y,a),(0,s.UI)(t.width,e.width,p),(0,s.UI)(t.height,e.height,c))}static arcLerp(t,e,n,o,r){return void 0===o&&(o=!1),r??(r=(t.position.sub(e.position).ctg+t.size.sub(e.size).ctg)/2),i.lerp(t,e,(0,s.Vz)(n,o,r))}static fromSizeCentered(t){return new i(-t.width/2,-t.height/2,t.width,t.height)}static fromPoints(){let t=1/0,e=1/0,n=-1/0,o=-1/0;for(var s=arguments.length,r=new Array(s),a=0;a<s;a++)r[a]=arguments[a];for(const i of r)i.x>n&&(n=i.x),i.x<t&&(t=i.x),i.y>o&&(o=i.y),i.y<e&&(e=i.y);return new i(t,e,n-t,o-e)}static fromBBoxes(){let t=1/0,e=1/0,n=-1/0,o=-1/0;for(var s=arguments.length,r=new Array(s),a=0;a<s;a++)r[a]=arguments[a];for(const i of r){const s=i.x+i.width;s>n&&(n=s),i.x<t&&(t=i.x);const r=i.y+i.height;r>o&&(o=r),i.y<e&&(e=i.y)}return new i(t,e,n-t,o-e)}lerp(t,e){return i.lerp(this,t,e)}get position(){return new o.F(this.x,this.y)}set position(t){this.x=t.x,this.y=t.y}get size(){return new o.F(this.width,this.height)}get center(){return new o.F(this.x+this.width/2,this.y+this.height/2)}get left(){return this.x}set left(t){this.width+=this.x-t,this.x=t}get right(){return this.x+this.width}set right(t){this.width=t-this.x}get top(){return this.y}set top(t){this.height+=this.y-t,this.y=t}get bottom(){return this.y+this.height}set bottom(t){this.height=t-this.y}get topLeft(){return this.position}get topRight(){return new o.F(this.x+this.width,this.y)}get bottomLeft(){return new o.F(this.x,this.y+this.height)}get bottomRight(){return new o.F(this.x+this.width,this.y+this.height)}get corners(){return[this.topLeft,this.topRight,this.bottomRight,this.bottomLeft]}get pixelPerfect(){return new i(Math.floor(this.x),Math.floor(this.y),Math.ceil(this.width+1),Math.ceil(this.height+1))}constructor(t,e,n,s){if(void 0===e&&(e=0),void 0===n&&(n=0),void 0===s&&(s=0),this.x=0,this.y=0,this.width=0,this.height=0,null!=t){if("number"==typeof t)return this.x=t,this.y=e,this.width=n,void(this.height=s);if(t instanceof o.F)return this.x=t.x,this.y=t.y,void(e instanceof o.F&&(this.width=e.x,this.height=e.y));if(Array.isArray(t))return this.x=t[0],this.y=t[1],this.width=t[2],void(this.height=t[3]);this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height}}transform(t){return new i(this.position.transformAsPoint(t),this.size.transform(t))}transformCorners(t){return this.corners.map((e=>e.transformAsPoint(t)))}expand(t){return new i(this.x-t,this.y-t,this.width+2*t,this.height+2*t)}addSpacing(t){const e=new i(this);return e.left-=t.left,e.top-=t.top,e.right+=t.right,e.bottom+=t.bottom,e}includes(t){return t.x>=this.x&&t.x<=this.x+this.width&&t.y>=this.y&&t.y<=this.y+this.height}intersects(t){return this.left<t.right&&this.right>t.left&&this.top<t.bottom&&this.bottom>t.top}intersection(t){const e=new i;return this.intersects(t)&&(e.left=Math.max(this.left,t.left),e.top=Math.max(this.top,t.top),e.right=Math.min(this.right,t.right),e.bottom=Math.min(this.bottom,t.bottom)),e}toSymbol(){return i.symbol}serialize(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}i.symbol=Symbol.for("@motion-canvas/core/types/Rect")},74741:(t,e,n)=>{"use strict";n.d(e,{$H:()=>r,Ib:()=>s,X6:()=>i});var o=n(29797);const s=1e-6;function r(t,e){const n=t/180*Math.PI;return 180*o.F.fromRadians(n).transform(e).radians/Math.PI}function i(t,e){return Math.sqrt(e.m11*e.m11+e.m12*e.m12)*t}},98378:(t,e,n)=>{"use strict";n.d(e,{M5:()=>o,Nm:()=>s,WS:()=>p,aP:()=>r,lk:()=>a});var o,s,r,i=n(29797);function a(t,e){return void 0===e&&(e=o.Horizontal|o.Vertical),e&o.Vertical&&(t&s.Top?t=t&~s.Top|s.Bottom:t&s.Bottom&&(t=t&~s.Bottom|s.Top)),e&o.Horizontal&&(t&s.Left?t=t&~s.Left|s.Right:t&s.Right&&(t=t&~s.Right|s.Left)),t}function p(t){if(t===r.Middle)return i.F.zero;let e=0;t&s.Left?e=-1:t&s.Right&&(e=1);let n=0;return t&s.Top?n=-1:t&s.Bottom&&(n=1),new i.F(e,n)}!function(t){t[t.Vertical=1]="Vertical",t[t.Horizontal=2]="Horizontal"}(o||(o={})),function(t){t[t.Top=4]="Top",t[t.Bottom=8]="Bottom",t[t.Left=16]="Left",t[t.Right=32]="Right"}(s||(s={})),function(t){t[t.Middle=3]="Middle",t[t.Top=5]="Top",t[t.Bottom=9]="Bottom",t[t.Left=18]="Left",t[t.Right=34]="Right",t[t.TopLeft=20]="TopLeft",t[t.TopRight=36]="TopRight",t[t.BottomLeft=24]="BottomLeft",t[t.BottomRight=40]="BottomRight"}(r||(r={}))},43188:(t,e,n)=>{"use strict";n.d(e,{K:()=>r});var o=n(13170),s=n(46096);class r{static createSignal(t,e){return void 0===e&&(e=r.lerp),new s.N(["top","right","bottom","left"],(t=>new r(t)),t,e).toSignal()}static lerp(t,e,n){return new r((0,o.UI)(t.top,e.top,n),(0,o.UI)(t.right,e.right,n),(0,o.UI)(t.bottom,e.bottom,n),(0,o.UI)(t.left,e.left,n))}get x(){return this.left+this.right}get y(){return this.top+this.bottom}constructor(t,e,n,o){if(void 0===t&&(t=0),this.top=0,this.right=0,this.bottom=0,this.left=0,null!=t){if(Array.isArray(t)&&(o=t[3],n=t[2],e=t[1],t=t[0]),"number"==typeof t)return this.top=t,this.right=void 0!==e?e:t,this.bottom=void 0!==n?n:t,void(this.left=void 0!==o?o:void 0!==e?e:t);this.top=t.top,this.right=t.right,this.bottom=t.bottom,this.left=t.left}}lerp(t,e){return r.lerp(this,t,e)}scale(t){return new r(this.top*t,this.right*t,this.bottom*t,this.left*t)}addScalar(t){return new r(this.top+t,this.right+t,this.bottom+t,this.left+t)}toSymbol(){return r.symbol}serialize(){return{top:this.top,right:this.right,bottom:this.bottom,left:this.left}}}r.symbol=Symbol.for("@motion-canvas/core/types/Spacing")},29797:(t,e,n)=>{"use strict";n.d(e,{F:()=>i});var o=n(13170),s=n(98378),r=n(46096);class i{static createSignal(t,e,n){return void 0===e&&(e=i.lerp),new r.N(["x","y"],(t=>new i(t)),t,e,n).toSignal()}static lerp(t,e,n){let s,r;return"number"==typeof n?s=r=n:(s=n.x,r=n.y),new i((0,o.UI)(t.x,e.x,s),(0,o.UI)(t.y,e.y,r))}static arcLerp(t,e,n,s,r){return void 0===s&&(s=!1),r??(r=t.sub(e).ctg),i.lerp(t,e,(0,o.Vz)(n,s,r))}static fromOrigin(t){const e=new i;return t===s.aP.Middle||(t&s.Nm.Left?e.x=-1:t&s.Nm.Right&&(e.x=1),t&s.Nm.Top?e.y=-1:t&s.Nm.Bottom&&(e.y=1)),e}static fromScalar(t){return new i(t,t)}static fromRadians(t){return new i(Math.cos(t),Math.sin(t))}static magnitude(t,e){return Math.sqrt(t*t+e*e)}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}get magnitude(){return i.magnitude(this.x,this.y)}get normalized(){return this.scale(1/i.magnitude(this.x,this.y))}get safe(){return new i(isNaN(this.x)?0:this.x,isNaN(this.y)?0:this.y)}get flipped(){return new i(-this.x,-this.y)}get floored(){return new i(Math.floor(this.x),Math.floor(this.y))}get perpendicular(){return new i(this.y,-this.x)}get radians(){return Math.atan2(this.y,this.x)}get ctg(){return this.x/this.y}constructor(t,e){if(this.x=0,this.y=0,null!=t){if("object"!=typeof t)return this.x=t,void(this.y=e??t);if(Array.isArray(t))return this.x=t[0],void(this.y=t[1]);if("width"in t)return this.x=t.width,void(this.y=t.height);this.x=t.x,this.y=t.y}}lerp(t,e){return i.lerp(this,t,e)}getOriginOffset(t){const e=i.fromOrigin(t);return e.x*=this.x/2,e.y*=this.y/2,e}scale(t){return new i(this.x*t,this.y*t)}transformAsPoint(t){return new i(this.x*t.m11+this.y*t.m21+t.m41,this.x*t.m12+this.y*t.m22+t.m42)}transform(t){return new i(this.x*t.m11+this.y*t.m21,this.x*t.m12+this.y*t.m22)}mul(t){const e=new i(t);return new i(this.x*e.x,this.y*e.y)}div(t){const e=new i(t);return new i(this.x/e.x,this.y/e.y)}add(t){const e=new i(t);return new i(this.x+e.x,this.y+e.y)}sub(t){const e=new i(t);return new i(this.x-e.x,this.y-e.y)}dot(t){const e=new i(t);return this.x*e.x+this.y*e.y}addX(t){return new i(this.x+t,this.y)}addY(t){return new i(this.x,this.y+t)}toSymbol(){return i.symbol}serialize(){return{x:this.x,y:this.y}}exactlyEquals(t){return this.x===t.x&&this.y===t.y}}i.symbol=Symbol.for("@motion-canvas/core/types/Vector2"),i.zero=new i,i.one=new i(1,1),i.right=new i(1,0),i.left=new i(-1,0),i.up=new i(0,1),i.down=new i(0,-1)},49111:(t,e,n)=>{"use strict";n.d(e,{t:()=>o});class o extends Error{constructor(t,e){super(t),this.remarks=e}}},15649:(t,e,n)=>{"use strict";n.d(e,{L:()=>o});class o{constructor(){this.resolveCurrent=null,this.current=null}async acquire(){for(;this.current;)await this.current;this.current=new Promise((t=>{this.resolveCurrent=t}))}release(){var t;this.current=null,null==(t=this.resolveCurrent)||t.call(this),this.resolveCurrent=null}}},15688:(t,e,n)=>{"use strict";function o(t){return t[0].toUpperCase()+t.slice(1)}n.d(e,{k:()=>o})},90031:(t,e,n)=>{"use strict";function o(t){return{message:t.message,stack:t.stack,remarks:t.remarks}}n.d(e,{d:()=>o})},1119:(t,e,n)=>{"use strict";function o(t,e){void 0===e&&(e=document.createElement("canvas"));const n=e.getContext("2d",t);if(!n)throw new Error("Could not create a 2D context.");return n}n.d(e,{f:()=>o})},37762:(t,e,n)=>{"use strict";function o(t,e,n){let o=0,s=t;void 0!==e&&(o=t,s=e),n=void 0===n?o<s?1:-1:n;const r=[];let i=Math.max(Math.ceil((s-o)/n),0),a=0;for(;i--;)r[a++]=o,o+=n;return r}n.d(e,{w:()=>o})},97715:(t,e,n)=>{"use strict";n.d(e,{Mh:()=>i,te:()=>s,wA:()=>r});const o=[];function s(){const t=o.at(-1);if(!t)throw new Error("The playback is not available in the current context.");return t}function r(t){o.push(t)}function i(t){if(o.pop()!==t)throw new Error("startPlayback/endPlayback were called out of order.")}},3163:(t,e,n)=>{"use strict";n.d(e,{$r:()=>s,DO:()=>r,ug:()=>i,vl:()=>p,wL:()=>a});const o=[];function s(){const t=o.at(-1);if(!t)throw new Error("The scene is not available in the current context.");return t}function r(t){o.push(t)}function i(t){if(o.pop()!==t)throw new Error("startScene/endScene were called out of order.")}function a(){var t;return(null==(t=o.at(-1))?void 0:t.logger)??console}function p(){s().enterCanTransitionOut()}},56632:(t,e,n)=>{"use strict";n.d(e,{h$:()=>i,kw:()=>a,nn:()=>r});var o=n(49111);const s=[];function r(){const t=s.at(-1);if(!t)throw new o.t("The thread is not available in the current context.","<p><code>useThread()</code> can only be called from within generator functions.\n      It&#39;s not available during rendering.</p>\n");return t}function i(t){s.push(t)}function a(t){if(s.pop()!==t)throw new Error("startThread/endThread was called out of order.")}},64415:(t,e,n)=>{"use strict";n.r(e),n.d(e,{default:()=>h});var o=n(2784),s=n(42104),r=n(49072),i=n(76183),a=n(31930),p=n(88617),c=n(80068),l=n(57708),u=n(70532),m=n(37390),d=n(89741);function h(t){var e,n,h;let{route:y}=t;const f=(0,p.RU)(y.projectId),k=f[y.reflectionId],[w]=(0,l.mN)(),g=(0,d.Z)(),M=(0,o.useMemo)((()=>{const t=[];if(!k.groups||k.kind===m.W.Project)return t;for(const e of k.groups)if(t.push({value:e.title,id:e.title,level:2}),e.children)for(const n of e.children){const e=f[n];!e||e.hasOwnPage||g&&!(0,l.It)(w,e)||t.push({value:`<code>${e.name}</code>`,id:e.anchor,level:3})}return t}),[w,k,g]);return o.createElement(i.b,{content:{frontMatter:{},metadata:{id:k.docId,unversionedId:k.docId,version:"current",title:k.name,description:null==(e=k.comment)?void 0:e.summaryText,slug:k.url,permalink:k.url,editUrl:(null==(n=k.sources)||null==(h=n[0])?void 0:h.url)??void 0,draft:!1,tags:[],frontMatter:{},next:k.next,previous:k.previous},toc:M,assets:{}}},o.createElement(c.Y0,null,o.createElement(s.Z,null),o.createElement(u.Z,null,o.createElement(r.Z,null,o.createElement(a.Z,{reflection:k})))))}},62296:(t,e,n)=>{"use strict";n.d(e,{Z:()=>aXt});var o={};n.r(o),n.d(o,{content_0_0:()=>p,content_0_10:()=>w,content_0_100:()=>te,content_0_1000:()=>Fk,content_0_1002:()=>Bk,content_0_1004:()=>Ok,content_0_1006:()=>Uk,content_0_1008:()=>Vk,content_0_1010:()=>Hk,content_0_1012:()=>Yk,content_0_1014:()=>Qk,content_0_1016:()=>ew,content_0_1018:()=>ow,content_0_102:()=>ne,content_0_1020:()=>rw,content_0_1022:()=>aw,content_0_1024:()=>cw,content_0_1026:()=>uw,content_0_1028:()=>dw,content_0_1030:()=>yw,content_0_104:()=>se,content_0_106:()=>ie,content_0_108:()=>pe,content_0_110:()=>le,content_0_112:()=>me,content_0_114:()=>he,content_0_116:()=>fe,content_0_118:()=>we,content_0_12:()=>M,content_0_120:()=>Me,content_0_122:()=>_e,content_0_124:()=>xe,content_0_126:()=>Ce,content_0_128:()=>be,content_0_130:()=>Ze,content_0_132:()=>Se,content_0_134:()=>Ee,content_0_136:()=>Ae,content_0_138:()=>Pe,content_0_14:()=>_,content_0_140:()=>We,content_0_142:()=>Ge,content_0_144:()=>je,content_0_146:()=>qe,content_0_148:()=>$e,content_0_150:()=>Je,content_0_152:()=>Ke,content_0_154:()=>tn,content_0_156:()=>nn,content_0_158:()=>sn,content_0_16:()=>x,content_0_160:()=>an,content_0_162:()=>cn,content_0_164:()=>un,content_0_166:()=>dn,content_0_168:()=>yn,content_0_170:()=>kn,content_0_172:()=>gn,content_0_174:()=>Dn,content_0_176:()=>Xn,content_0_178:()=>vn,content_0_18:()=>C,content_0_180:()=>Tn,content_0_182:()=>Ln,content_0_184:()=>Nn,content_0_186:()=>Rn,content_0_188:()=>zn,content_0_190:()=>In,content_0_192:()=>Fn,content_0_194:()=>Bn,content_0_196:()=>On,content_0_198:()=>Un,content_0_2:()=>l,content_0_20:()=>b,content_0_200:()=>Vn,content_0_202:()=>Hn,content_0_204:()=>Yn,content_0_206:()=>Qn,content_0_208:()=>eo,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>ao,content_0_216:()=>co,content_0_218:()=>uo,content_0_22:()=>Z,content_0_220:()=>ho,content_0_222:()=>fo,content_0_224:()=>wo,content_0_226:()=>Mo,content_0_228:()=>_o,content_0_230:()=>xo,content_0_232:()=>Co,content_0_234:()=>bo,content_0_236:()=>Zo,content_0_238:()=>So,content_0_24:()=>S,content_0_240:()=>Eo,content_0_242:()=>Ao,content_0_244:()=>Po,content_0_246:()=>Wo,content_0_248:()=>Go,content_0_250:()=>jo,content_0_252:()=>qo,content_0_254:()=>$o,content_0_256:()=>Jo,content_0_258:()=>Ko,content_0_26:()=>E,content_0_260:()=>ts,content_0_262:()=>ns,content_0_264:()=>ss,content_0_266:()=>is,content_0_268:()=>ps,content_0_270:()=>ls,content_0_272:()=>ms,content_0_274:()=>hs,content_0_276:()=>fs,content_0_278:()=>ws,content_0_28:()=>A,content_0_280:()=>Ms,content_0_282:()=>_s,content_0_284:()=>xs,content_0_286:()=>Cs,content_0_288:()=>bs,content_0_290:()=>Zs,content_0_292:()=>Ss,content_0_294:()=>Es,content_0_296:()=>As,content_0_298:()=>Ps,content_0_30:()=>P,content_0_300:()=>Ws,content_0_302:()=>Gs,content_0_304:()=>js,content_0_306:()=>qs,content_0_308:()=>$s,content_0_310:()=>Js,content_0_312:()=>Ks,content_0_314:()=>tr,content_0_316:()=>nr,content_0_318:()=>sr,content_0_32:()=>W,content_0_320:()=>ir,content_0_322:()=>pr,content_0_324:()=>lr,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>fr,content_0_332:()=>wr,content_0_334:()=>Mr,content_0_336:()=>_r,content_0_338:()=>xr,content_0_34:()=>G,content_0_340:()=>Cr,content_0_342:()=>br,content_0_344:()=>Zr,content_0_346:()=>Sr,content_0_348:()=>Er,content_0_350:()=>Ar,content_0_352:()=>Pr,content_0_354:()=>Wr,content_0_356:()=>Gr,content_0_358:()=>jr,content_0_36:()=>j,content_0_360:()=>qr,content_0_362:()=>$r,content_0_364:()=>Jr,content_0_366:()=>Kr,content_0_368:()=>ti,content_0_370:()=>ni,content_0_372:()=>si,content_0_374:()=>ii,content_0_376:()=>pi,content_0_378:()=>li,content_0_38:()=>q,content_0_380:()=>mi,content_0_382:()=>hi,content_0_384:()=>fi,content_0_386:()=>wi,content_0_388:()=>Mi,content_0_390:()=>_i,content_0_392:()=>xi,content_0_394:()=>Ci,content_0_396:()=>bi,content_0_398:()=>Zi,content_0_4:()=>m,content_0_40:()=>$,content_0_400:()=>Si,content_0_402:()=>Ei,content_0_404:()=>Ai,content_0_406:()=>Pi,content_0_408:()=>Wi,content_0_410:()=>Gi,content_0_412:()=>ji,content_0_414:()=>qi,content_0_416:()=>$i,content_0_418:()=>Ji,content_0_42:()=>J,content_0_420:()=>Ki,content_0_422:()=>ta,content_0_424:()=>na,content_0_426:()=>sa,content_0_428:()=>ia,content_0_430:()=>pa,content_0_432:()=>la,content_0_434:()=>ma,content_0_436:()=>ha,content_0_438:()=>fa,content_0_44:()=>K,content_0_440:()=>wa,content_0_442:()=>Ma,content_0_444:()=>_a,content_0_446:()=>xa,content_0_448:()=>Ca,content_0_450:()=>ba,content_0_452:()=>Za,content_0_454:()=>Sa,content_0_456:()=>Ea,content_0_458:()=>Aa,content_0_46:()=>tt,content_0_460:()=>Pa,content_0_462:()=>Wa,content_0_464:()=>Ga,content_0_466:()=>ja,content_0_468:()=>qa,content_0_470:()=>$a,content_0_472:()=>Ja,content_0_474:()=>Ka,content_0_476:()=>tp,content_0_478:()=>np,content_0_48:()=>nt,content_0_480:()=>sp,content_0_482:()=>ip,content_0_484:()=>pp,content_0_486:()=>lp,content_0_488:()=>mp,content_0_490:()=>hp,content_0_492:()=>fp,content_0_494:()=>wp,content_0_496:()=>Mp,content_0_498:()=>_p,content_0_50:()=>st,content_0_500:()=>xp,content_0_502:()=>Cp,content_0_504:()=>bp,content_0_506:()=>Zp,content_0_508:()=>Sp,content_0_510:()=>Ep,content_0_512:()=>Ap,content_0_514:()=>Pp,content_0_516:()=>Wp,content_0_518:()=>Gp,content_0_52:()=>it,content_0_520:()=>jp,content_0_522:()=>qp,content_0_524:()=>$p,content_0_526:()=>Jp,content_0_528:()=>Kp,content_0_530:()=>tc,content_0_532:()=>nc,content_0_534:()=>sc,content_0_536:()=>ic,content_0_538:()=>pc,content_0_54:()=>pt,content_0_540:()=>lc,content_0_542:()=>mc,content_0_544:()=>hc,content_0_546:()=>fc,content_0_548:()=>wc,content_0_550:()=>Mc,content_0_552:()=>_c,content_0_554:()=>xc,content_0_556:()=>Cc,content_0_558:()=>bc,content_0_56:()=>lt,content_0_560:()=>Zc,content_0_562:()=>Sc,content_0_564:()=>Ec,content_0_566:()=>Ac,content_0_568:()=>Pc,content_0_570:()=>Wc,content_0_572:()=>Gc,content_0_574:()=>jc,content_0_576:()=>qc,content_0_578:()=>$c,content_0_58:()=>mt,content_0_580:()=>Jc,content_0_582:()=>Kc,content_0_584:()=>tl,content_0_586:()=>nl,content_0_588:()=>sl,content_0_590:()=>il,content_0_592:()=>pl,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>fl,content_0_602:()=>wl,content_0_604:()=>Ml,content_0_606:()=>_l,content_0_608:()=>xl,content_0_610:()=>Cl,content_0_612:()=>bl,content_0_614:()=>Zl,content_0_616:()=>Sl,content_0_618:()=>El,content_0_62:()=>ft,content_0_620:()=>Al,content_0_622:()=>Pl,content_0_624:()=>Wl,content_0_626:()=>Gl,content_0_628:()=>jl,content_0_630:()=>ql,content_0_632:()=>$l,content_0_634:()=>Jl,content_0_636:()=>Kl,content_0_638:()=>tu,content_0_64:()=>wt,content_0_640:()=>nu,content_0_642:()=>su,content_0_644:()=>iu,content_0_646:()=>pu,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>fu,content_0_656:()=>wu,content_0_658:()=>Mu,content_0_66:()=>Mt,content_0_660:()=>_u,content_0_662:()=>xu,content_0_664:()=>Cu,content_0_666:()=>bu,content_0_668:()=>Zu,content_0_670:()=>Su,content_0_672:()=>Eu,content_0_674:()=>Au,content_0_676:()=>Pu,content_0_678:()=>Wu,content_0_68:()=>_t,content_0_680:()=>Gu,content_0_682:()=>ju,content_0_684:()=>qu,content_0_686:()=>$u,content_0_688:()=>Ju,content_0_690:()=>Ku,content_0_692:()=>tm,content_0_694:()=>nm,content_0_696:()=>sm,content_0_698:()=>im,content_0_70:()=>xt,content_0_700:()=>pm,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>fm,content_0_710:()=>wm,content_0_712:()=>Mm,content_0_714:()=>_m,content_0_716:()=>xm,content_0_718:()=>Cm,content_0_72:()=>Ct,content_0_720:()=>bm,content_0_722:()=>Zm,content_0_724:()=>Sm,content_0_726:()=>Em,content_0_728:()=>Am,content_0_730:()=>Pm,content_0_732:()=>Wm,content_0_734:()=>Gm,content_0_736:()=>jm,content_0_738:()=>qm,content_0_74:()=>bt,content_0_740:()=>$m,content_0_742:()=>Jm,content_0_744:()=>Km,content_0_746:()=>td,content_0_748:()=>nd,content_0_750:()=>sd,content_0_752:()=>id,content_0_754:()=>pd,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>Zt,content_0_760:()=>hd,content_0_762:()=>fd,content_0_764:()=>wd,content_0_766:()=>Md,content_0_768:()=>_d,content_0_770:()=>xd,content_0_772:()=>Cd,content_0_774:()=>bd,content_0_776:()=>Zd,content_0_778:()=>Sd,content_0_78:()=>St,content_0_780:()=>Ed,content_0_782:()=>Ad,content_0_784:()=>Pd,content_0_786:()=>Wd,content_0_788:()=>Gd,content_0_790:()=>jd,content_0_792:()=>qd,content_0_794:()=>$d,content_0_796:()=>Jd,content_0_798:()=>Kd,content_0_8:()=>f,content_0_80:()=>Et,content_0_800:()=>th,content_0_802:()=>nh,content_0_804:()=>sh,content_0_806:()=>ih,content_0_808:()=>ph,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>fh,content_0_818:()=>wh,content_0_82:()=>At,content_0_820:()=>Mh,content_0_822:()=>_h,content_0_824:()=>xh,content_0_826:()=>Ch,content_0_828:()=>bh,content_0_830:()=>Zh,content_0_832:()=>Sh,content_0_834:()=>Eh,content_0_836:()=>Ah,content_0_838:()=>Ph,content_0_84:()=>Pt,content_0_840:()=>Wh,content_0_842:()=>Gh,content_0_844:()=>jh,content_0_846:()=>qh,content_0_848:()=>$h,content_0_850:()=>Jh,content_0_852:()=>Kh,content_0_854:()=>ty,content_0_856:()=>ny,content_0_858:()=>sy,content_0_86:()=>Wt,content_0_860:()=>iy,content_0_862:()=>py,content_0_864:()=>ly,content_0_866:()=>my,content_0_868:()=>hy,content_0_870:()=>fy,content_0_872:()=>wy,content_0_874:()=>My,content_0_876:()=>_y,content_0_878:()=>xy,content_0_88:()=>Gt,content_0_880:()=>Cy,content_0_882:()=>by,content_0_884:()=>Zy,content_0_886:()=>Sy,content_0_888:()=>Ey,content_0_890:()=>Ay,content_0_892:()=>Py,content_0_894:()=>Wy,content_0_896:()=>Gy,content_0_898:()=>jy,content_0_90:()=>jt,content_0_900:()=>qy,content_0_902:()=>$y,content_0_904:()=>Jy,content_0_906:()=>Ky,content_0_908:()=>tf,content_0_910:()=>nf,content_0_912:()=>sf,content_0_914:()=>af,content_0_916:()=>cf,content_0_918:()=>uf,content_0_92:()=>qt,content_0_920:()=>df,content_0_922:()=>yf,content_0_924:()=>kf,content_0_926:()=>gf,content_0_928:()=>Df,content_0_930:()=>Xf,content_0_932:()=>vf,content_0_934:()=>Tf,content_0_936:()=>Lf,content_0_938:()=>Nf,content_0_94:()=>$t,content_0_940:()=>Rf,content_0_942:()=>zf,content_0_944:()=>If,content_0_946:()=>Ff,content_0_948:()=>Bf,content_0_950:()=>Of,content_0_952:()=>Uf,content_0_954:()=>Vf,content_0_956:()=>Hf,content_0_958:()=>Yf,content_0_96:()=>Jt,content_0_960:()=>Qf,content_0_962:()=>ek,content_0_964:()=>ok,content_0_966:()=>rk,content_0_968:()=>ak,content_0_970:()=>ck,content_0_972:()=>uk,content_0_974:()=>dk,content_0_976:()=>yk,content_0_978:()=>kk,content_0_98:()=>Kt,content_0_980:()=>gk,content_0_982:()=>Dk,content_0_984:()=>Xk,content_0_986:()=>vk,content_0_988:()=>Tk,content_0_990:()=>Lk,content_0_992:()=>Nk,content_0_994:()=>Rk,content_0_996:()=>zk,content_0_998:()=>Ik,content_2228_0:()=>kw,content_2228_10:()=>Tw,content_2228_100:()=>cM,content_2228_1000:()=>UA,content_2228_1002:()=>VA,content_2228_1004:()=>HA,content_2228_1006:()=>YA,content_2228_1008:()=>QA,content_2228_1010:()=>eI,content_2228_1012:()=>oI,content_2228_1014:()=>rI,content_2228_1016:()=>aI,content_2228_1018:()=>cI,content_2228_102:()=>uM,content_2228_1020:()=>uI,content_2228_1022:()=>dI,content_2228_1024:()=>yI,content_2228_1026:()=>kI,content_2228_1028:()=>gI,content_2228_1030:()=>DI,content_2228_1032:()=>XI,content_2228_1034:()=>vI,content_2228_1036:()=>TI,content_2228_1038:()=>LI,content_2228_104:()=>dM,content_2228_1040:()=>NI,content_2228_1042:()=>RI,content_2228_1044:()=>zI,content_2228_1046:()=>II,content_2228_1048:()=>FI,content_2228_1050:()=>BI,content_2228_1052:()=>OI,content_2228_1054:()=>UI,content_2228_1056:()=>VI,content_2228_1058:()=>HI,content_2228_106:()=>yM,content_2228_1060:()=>YI,content_2228_1062:()=>QI,content_2228_1064:()=>eP,content_2228_1066:()=>oP,content_2228_1068:()=>rP,content_2228_1070:()=>aP,content_2228_1072:()=>cP,content_2228_1074:()=>uP,content_2228_1076:()=>dP,content_2228_1078:()=>yP,content_2228_108:()=>kM,content_2228_1080:()=>kP,content_2228_1082:()=>gP,content_2228_1084:()=>DP,content_2228_1086:()=>XP,content_2228_1088:()=>vP,content_2228_1090:()=>TP,content_2228_1092:()=>LP,content_2228_1094:()=>NP,content_2228_1096:()=>RP,content_2228_1098:()=>zP,content_2228_110:()=>gM,content_2228_1100:()=>IP,content_2228_1102:()=>FP,content_2228_1104:()=>BP,content_2228_1106:()=>OP,content_2228_1108:()=>UP,content_2228_1110:()=>VP,content_2228_1112:()=>HP,content_2228_1114:()=>YP,content_2228_1116:()=>QP,content_2228_1118:()=>eF,content_2228_112:()=>DM,content_2228_1120:()=>oF,content_2228_1122:()=>rF,content_2228_1124:()=>aF,content_2228_1126:()=>cF,content_2228_1128:()=>uF,content_2228_1130:()=>dF,content_2228_1132:()=>yF,content_2228_1134:()=>kF,content_2228_1136:()=>gF,content_2228_1138:()=>DF,content_2228_114:()=>XM,content_2228_1140:()=>XF,content_2228_1142:()=>vF,content_2228_1144:()=>TF,content_2228_1146:()=>LF,content_2228_1148:()=>NF,content_2228_1150:()=>RF,content_2228_1152:()=>zF,content_2228_1154:()=>IF,content_2228_1156:()=>FF,content_2228_1158:()=>BF,content_2228_116:()=>vM,content_2228_1160:()=>OF,content_2228_1162:()=>UF,content_2228_1164:()=>VF,content_2228_1166:()=>HF,content_2228_1168:()=>YF,content_2228_1170:()=>QF,content_2228_1172:()=>eW,content_2228_1174:()=>oW,content_2228_1176:()=>rW,content_2228_1178:()=>aW,content_2228_118:()=>TM,content_2228_1180:()=>cW,content_2228_1182:()=>uW,content_2228_1184:()=>dW,content_2228_1186:()=>yW,content_2228_1188:()=>kW,content_2228_1190:()=>gW,content_2228_1192:()=>DW,content_2228_1194:()=>XW,content_2228_1196:()=>vW,content_2228_1198:()=>TW,content_2228_12:()=>Lw,content_2228_120:()=>LM,content_2228_1200:()=>LW,content_2228_1202:()=>NW,content_2228_1204:()=>RW,content_2228_1206:()=>zW,content_2228_1208:()=>IW,content_2228_1210:()=>FW,content_2228_1212:()=>BW,content_2228_1214:()=>OW,content_2228_1216:()=>UW,content_2228_1218:()=>VW,content_2228_122:()=>NM,content_2228_1220:()=>HW,content_2228_1222:()=>YW,content_2228_1224:()=>QW,content_2228_1226:()=>eB,content_2228_1228:()=>oB,content_2228_1230:()=>rB,content_2228_1232:()=>aB,content_2228_1234:()=>cB,content_2228_1236:()=>uB,content_2228_1238:()=>dB,content_2228_124:()=>RM,content_2228_1240:()=>yB,content_2228_1242:()=>kB,content_2228_1244:()=>gB,content_2228_1246:()=>DB,content_2228_1248:()=>XB,content_2228_1250:()=>vB,content_2228_1252:()=>TB,content_2228_1254:()=>LB,content_2228_1256:()=>NB,content_2228_1258:()=>RB,content_2228_126:()=>zM,content_2228_1260:()=>zB,content_2228_1262:()=>IB,content_2228_1264:()=>FB,content_2228_1266:()=>BB,content_2228_1268:()=>OB,content_2228_1270:()=>UB,content_2228_1272:()=>VB,content_2228_1274:()=>HB,content_2228_1276:()=>YB,content_2228_1278:()=>QB,content_2228_128:()=>IM,content_2228_1280:()=>eG,content_2228_1282:()=>oG,content_2228_1284:()=>rG,content_2228_1286:()=>aG,content_2228_1288:()=>cG,content_2228_1290:()=>uG,content_2228_1292:()=>dG,content_2228_1294:()=>yG,content_2228_1296:()=>kG,content_2228_1298:()=>gG,content_2228_130:()=>FM,content_2228_1300:()=>DG,content_2228_1302:()=>XG,content_2228_1304:()=>vG,content_2228_1306:()=>TG,content_2228_1308:()=>LG,content_2228_1310:()=>NG,content_2228_1312:()=>RG,content_2228_1314:()=>zG,content_2228_1316:()=>IG,content_2228_1318:()=>FG,content_2228_132:()=>BM,content_2228_1320:()=>BG,content_2228_1322:()=>OG,content_2228_1324:()=>UG,content_2228_1326:()=>VG,content_2228_1328:()=>HG,content_2228_1330:()=>YG,content_2228_1332:()=>QG,content_2228_1334:()=>eO,content_2228_1336:()=>oO,content_2228_1338:()=>rO,content_2228_134:()=>OM,content_2228_1340:()=>aO,content_2228_1342:()=>cO,content_2228_1344:()=>uO,content_2228_1346:()=>dO,content_2228_1348:()=>yO,content_2228_1350:()=>kO,content_2228_1352:()=>gO,content_2228_1354:()=>DO,content_2228_1356:()=>XO,content_2228_1358:()=>vO,content_2228_136:()=>UM,content_2228_1360:()=>TO,content_2228_1362:()=>LO,content_2228_1364:()=>NO,content_2228_1366:()=>RO,content_2228_1368:()=>zO,content_2228_1370:()=>IO,content_2228_1372:()=>FO,content_2228_1374:()=>BO,content_2228_1376:()=>OO,content_2228_1378:()=>UO,content_2228_138:()=>VM,content_2228_1380:()=>VO,content_2228_1382:()=>HO,content_2228_1384:()=>YO,content_2228_1386:()=>QO,content_2228_1388:()=>ej,content_2228_1390:()=>oj,content_2228_1392:()=>rj,content_2228_1394:()=>aj,content_2228_1396:()=>cj,content_2228_1398:()=>uj,content_2228_14:()=>Nw,content_2228_140:()=>HM,content_2228_1400:()=>dj,content_2228_1402:()=>yj,content_2228_1404:()=>kj,content_2228_1406:()=>gj,content_2228_1408:()=>Dj,content_2228_1410:()=>Xj,content_2228_1412:()=>vj,content_2228_1414:()=>Tj,content_2228_1416:()=>Lj,content_2228_1418:()=>Nj,content_2228_142:()=>YM,content_2228_1420:()=>Rj,content_2228_1422:()=>zj,content_2228_1424:()=>Ij,content_2228_1426:()=>Fj,content_2228_1428:()=>Bj,content_2228_1430:()=>Oj,content_2228_1432:()=>Uj,content_2228_1434:()=>Vj,content_2228_1436:()=>Hj,content_2228_1438:()=>Yj,content_2228_144:()=>QM,content_2228_1440:()=>Qj,content_2228_1442:()=>eU,content_2228_1444:()=>oU,content_2228_1446:()=>rU,content_2228_1448:()=>aU,content_2228_1450:()=>cU,content_2228_1452:()=>uU,content_2228_1454:()=>dU,content_2228_1456:()=>yU,content_2228_1458:()=>kU,content_2228_146:()=>eD,content_2228_1460:()=>gU,content_2228_1462:()=>DU,content_2228_1464:()=>XU,content_2228_1466:()=>vU,content_2228_1468:()=>TU,content_2228_1470:()=>LU,content_2228_1472:()=>NU,content_2228_1474:()=>RU,content_2228_1476:()=>zU,content_2228_1478:()=>IU,content_2228_148:()=>oD,content_2228_1480:()=>FU,content_2228_1482:()=>BU,content_2228_1484:()=>OU,content_2228_1486:()=>UU,content_2228_1488:()=>VU,content_2228_1490:()=>HU,content_2228_1492:()=>YU,content_2228_1494:()=>QU,content_2228_1496:()=>eq,content_2228_1498:()=>oq,content_2228_150:()=>rD,content_2228_1500:()=>rq,content_2228_1502:()=>aq,content_2228_1504:()=>cq,content_2228_1506:()=>uq,content_2228_1508:()=>dq,content_2228_1510:()=>yq,content_2228_1512:()=>kq,content_2228_1514:()=>gq,content_2228_1516:()=>Dq,content_2228_1518:()=>Xq,content_2228_152:()=>aD,content_2228_1520:()=>vq,content_2228_1522:()=>Tq,content_2228_1524:()=>Lq,content_2228_1526:()=>Nq,content_2228_1528:()=>Rq,content_2228_1530:()=>zq,content_2228_1532:()=>Iq,content_2228_1534:()=>Fq,content_2228_1536:()=>Bq,content_2228_1538:()=>Oq,content_2228_154:()=>cD,content_2228_1540:()=>Uq,content_2228_1542:()=>Vq,content_2228_1544:()=>Hq,content_2228_1546:()=>Yq,content_2228_1548:()=>Qq,content_2228_1550:()=>eV,content_2228_1552:()=>oV,content_2228_1554:()=>rV,content_2228_1556:()=>aV,content_2228_1558:()=>cV,content_2228_156:()=>uD,content_2228_1560:()=>uV,content_2228_1562:()=>dV,content_2228_1564:()=>yV,content_2228_1566:()=>kV,content_2228_1568:()=>gV,content_2228_1570:()=>DV,content_2228_1572:()=>XV,content_2228_1574:()=>vV,content_2228_1576:()=>TV,content_2228_1578:()=>LV,content_2228_158:()=>dD,content_2228_1580:()=>NV,content_2228_1582:()=>RV,content_2228_1584:()=>zV,content_2228_1586:()=>IV,content_2228_1588:()=>FV,content_2228_1590:()=>BV,content_2228_1592:()=>OV,content_2228_1594:()=>UV,content_2228_1596:()=>VV,content_2228_1598:()=>HV,content_2228_16:()=>Rw,content_2228_160:()=>yD,content_2228_1600:()=>YV,content_2228_1602:()=>QV,content_2228_1604:()=>e$,content_2228_1606:()=>o$,content_2228_1608:()=>r$,content_2228_1610:()=>a$,content_2228_1612:()=>c$,content_2228_1614:()=>u$,content_2228_1616:()=>d$,content_2228_1618:()=>y$,content_2228_162:()=>kD,content_2228_1620:()=>k$,content_2228_1622:()=>g$,content_2228_1624:()=>D$,content_2228_1626:()=>X$,content_2228_1628:()=>v$,content_2228_1630:()=>T$,content_2228_1632:()=>L$,content_2228_1634:()=>N$,content_2228_1636:()=>R$,content_2228_1638:()=>z$,content_2228_164:()=>gD,content_2228_1640:()=>I$,content_2228_1642:()=>F$,content_2228_1644:()=>B$,content_2228_1646:()=>O$,content_2228_1648:()=>U$,content_2228_1650:()=>V$,content_2228_1652:()=>H$,content_2228_1654:()=>Y$,content_2228_1656:()=>Q$,content_2228_1658:()=>eH,content_2228_166:()=>DD,content_2228_1660:()=>oH,content_2228_1662:()=>rH,content_2228_1664:()=>aH,content_2228_1666:()=>cH,content_2228_1668:()=>uH,content_2228_1670:()=>dH,content_2228_1672:()=>yH,content_2228_1674:()=>kH,content_2228_1676:()=>gH,content_2228_1678:()=>DH,content_2228_168:()=>XD,content_2228_1680:()=>XH,content_2228_1682:()=>vH,content_2228_1684:()=>TH,content_2228_1686:()=>LH,content_2228_1688:()=>NH,content_2228_1690:()=>RH,content_2228_1692:()=>zH,content_2228_1694:()=>IH,content_2228_1696:()=>FH,content_2228_1698:()=>BH,content_2228_170:()=>vD,content_2228_1700:()=>OH,content_2228_1702:()=>UH,content_2228_1704:()=>VH,content_2228_1706:()=>HH,content_2228_1708:()=>YH,content_2228_1710:()=>QH,content_2228_1712:()=>eJ,content_2228_1714:()=>oJ,content_2228_1716:()=>rJ,content_2228_1718:()=>aJ,content_2228_172:()=>TD,content_2228_1720:()=>cJ,content_2228_1722:()=>uJ,content_2228_1724:()=>dJ,content_2228_1726:()=>yJ,content_2228_1728:()=>kJ,content_2228_1730:()=>gJ,content_2228_1732:()=>DJ,content_2228_1734:()=>XJ,content_2228_1736:()=>vJ,content_2228_1738:()=>TJ,content_2228_174:()=>LD,content_2228_1740:()=>LJ,content_2228_1742:()=>NJ,content_2228_1744:()=>RJ,content_2228_1746:()=>zJ,content_2228_1748:()=>IJ,content_2228_1750:()=>FJ,content_2228_1752:()=>BJ,content_2228_1754:()=>OJ,content_2228_1756:()=>UJ,content_2228_1758:()=>VJ,content_2228_176:()=>ND,content_2228_1760:()=>HJ,content_2228_1762:()=>YJ,content_2228_1764:()=>QJ,content_2228_1766:()=>eY,content_2228_1768:()=>oY,content_2228_1770:()=>rY,content_2228_1772:()=>aY,content_2228_1774:()=>cY,content_2228_1776:()=>uY,content_2228_1778:()=>dY,content_2228_178:()=>RD,content_2228_1780:()=>yY,content_2228_1782:()=>kY,content_2228_1784:()=>gY,content_2228_1786:()=>DY,content_2228_1788:()=>XY,content_2228_1790:()=>vY,content_2228_1792:()=>TY,content_2228_1794:()=>LY,content_2228_1796:()=>NY,content_2228_1798:()=>RY,content_2228_18:()=>zw,content_2228_180:()=>zD,content_2228_1800:()=>zY,content_2228_1802:()=>IY,content_2228_1804:()=>FY,content_2228_1806:()=>BY,content_2228_1808:()=>OY,content_2228_1810:()=>UY,content_2228_1812:()=>VY,content_2228_1814:()=>HY,content_2228_1816:()=>YY,content_2228_1818:()=>QY,content_2228_182:()=>ID,content_2228_1820:()=>eK,content_2228_1822:()=>oK,content_2228_1824:()=>rK,content_2228_1826:()=>aK,content_2228_1828:()=>cK,content_2228_1830:()=>uK,content_2228_1832:()=>dK,content_2228_1834:()=>yK,content_2228_1836:()=>kK,content_2228_1838:()=>gK,content_2228_184:()=>FD,content_2228_1840:()=>DK,content_2228_1842:()=>XK,content_2228_1844:()=>vK,content_2228_1846:()=>TK,content_2228_1848:()=>LK,content_2228_1850:()=>NK,content_2228_1852:()=>RK,content_2228_1854:()=>zK,content_2228_1856:()=>IK,content_2228_1858:()=>FK,content_2228_186:()=>BD,content_2228_1860:()=>BK,content_2228_1862:()=>OK,content_2228_1864:()=>UK,content_2228_1866:()=>VK,content_2228_1868:()=>HK,content_2228_1870:()=>YK,content_2228_1872:()=>QK,content_2228_1874:()=>eQ,content_2228_1876:()=>oQ,content_2228_1878:()=>rQ,content_2228_188:()=>OD,content_2228_1880:()=>aQ,content_2228_1882:()=>cQ,content_2228_1884:()=>uQ,content_2228_1886:()=>dQ,content_2228_1888:()=>yQ,content_2228_1890:()=>kQ,content_2228_1892:()=>gQ,content_2228_1894:()=>DQ,content_2228_1896:()=>XQ,content_2228_1898:()=>vQ,content_2228_190:()=>UD,content_2228_1900:()=>TQ,content_2228_1902:()=>LQ,content_2228_1904:()=>NQ,content_2228_1906:()=>RQ,content_2228_1908:()=>zQ,content_2228_1910:()=>IQ,content_2228_1912:()=>FQ,content_2228_1914:()=>BQ,content_2228_1916:()=>OQ,content_2228_1918:()=>UQ,content_2228_192:()=>VD,content_2228_1920:()=>VQ,content_2228_1922:()=>HQ,content_2228_1924:()=>YQ,content_2228_1926:()=>QQ,content_2228_1928:()=>e0,content_2228_1930:()=>o0,content_2228_1932:()=>r0,content_2228_1934:()=>a0,content_2228_1936:()=>c0,content_2228_1938:()=>u0,content_2228_194:()=>HD,content_2228_1940:()=>d0,content_2228_1942:()=>y0,content_2228_1944:()=>k0,content_2228_1946:()=>g0,content_2228_1948:()=>D0,content_2228_1950:()=>X0,content_2228_1952:()=>v0,content_2228_1954:()=>T0,content_2228_1956:()=>L0,content_2228_1958:()=>N0,content_2228_196:()=>YD,content_2228_1960:()=>R0,content_2228_1962:()=>z0,content_2228_1964:()=>I0,content_2228_1966:()=>F0,content_2228_1968:()=>B0,content_2228_1970:()=>O0,content_2228_1972:()=>U0,content_2228_1974:()=>V0,content_2228_1976:()=>H0,content_2228_1978:()=>Y0,content_2228_198:()=>QD,content_2228_1980:()=>Q0,content_2228_1982:()=>e2,content_2228_1984:()=>o2,content_2228_1986:()=>r2,content_2228_1988:()=>a2,content_2228_1990:()=>c2,content_2228_1992:()=>u2,content_2228_1994:()=>d2,content_2228_1996:()=>y2,content_2228_1998:()=>k2,content_2228_2:()=>gw,content_2228_20:()=>Iw,content_2228_200:()=>e_,content_2228_2000:()=>g2,content_2228_2002:()=>D2,content_2228_2004:()=>X2,content_2228_2006:()=>v2,content_2228_2008:()=>T2,content_2228_2010:()=>L2,content_2228_2012:()=>N2,content_2228_2014:()=>R2,content_2228_2016:()=>z2,content_2228_2018:()=>I2,content_2228_202:()=>o_,content_2228_2020:()=>F2,content_2228_2022:()=>B2,content_2228_2024:()=>O2,content_2228_2026:()=>U2,content_2228_2028:()=>V2,content_2228_2030:()=>H2,content_2228_2032:()=>Y2,content_2228_2034:()=>Q2,content_2228_2036:()=>e8,content_2228_2038:()=>o8,content_2228_204:()=>r_,content_2228_2040:()=>r8,content_2228_2042:()=>a8,content_2228_2044:()=>c8,content_2228_2046:()=>u8,content_2228_2048:()=>d8,content_2228_2050:()=>y8,content_2228_2052:()=>k8,content_2228_2054:()=>g8,content_2228_2056:()=>D8,content_2228_2058:()=>X8,content_2228_206:()=>a_,content_2228_2060:()=>v8,content_2228_2062:()=>T8,content_2228_2064:()=>L8,content_2228_2066:()=>N8,content_2228_2068:()=>R8,content_2228_2070:()=>z8,content_2228_2072:()=>I8,content_2228_2074:()=>F8,content_2228_2076:()=>B8,content_2228_2078:()=>O8,content_2228_208:()=>c_,content_2228_2080:()=>U8,content_2228_2082:()=>V8,content_2228_2084:()=>H8,content_2228_2086:()=>Y8,content_2228_2088:()=>Q8,content_2228_2090:()=>e1,content_2228_2092:()=>o1,content_2228_2094:()=>r1,content_2228_2096:()=>a1,content_2228_2098:()=>c1,content_2228_210:()=>u_,content_2228_2100:()=>u1,content_2228_2102:()=>d1,content_2228_2104:()=>y1,content_2228_2106:()=>k1,content_2228_2108:()=>g1,content_2228_2110:()=>D1,content_2228_2112:()=>X1,content_2228_2114:()=>v1,content_2228_2116:()=>T1,content_2228_2118:()=>L1,content_2228_212:()=>d_,content_2228_2120:()=>N1,content_2228_2122:()=>R1,content_2228_2124:()=>z1,content_2228_2126:()=>I1,content_2228_2128:()=>F1,content_2228_2130:()=>B1,content_2228_2132:()=>O1,content_2228_2134:()=>U1,content_2228_2136:()=>V1,content_2228_2138:()=>H1,content_2228_214:()=>y_,content_2228_2140:()=>Y1,content_2228_2142:()=>Q1,content_2228_2144:()=>e3,content_2228_2146:()=>o3,content_2228_2148:()=>r3,content_2228_2150:()=>a3,content_2228_2152:()=>c3,content_2228_2154:()=>u3,content_2228_2156:()=>d3,content_2228_2158:()=>y3,content_2228_216:()=>k_,content_2228_2160:()=>k3,content_2228_2162:()=>g3,content_2228_2164:()=>D3,content_2228_2166:()=>X3,content_2228_2168:()=>v3,content_2228_2170:()=>T3,content_2228_2172:()=>L3,content_2228_2174:()=>N3,content_2228_2176:()=>R3,content_2228_2178:()=>z3,content_2228_218:()=>g_,content_2228_2180:()=>I3,content_2228_2182:()=>F3,content_2228_2184:()=>B3,content_2228_2186:()=>O3,content_2228_2188:()=>U3,content_2228_2190:()=>V3,content_2228_2192:()=>H3,content_2228_2194:()=>Y3,content_2228_2196:()=>Q3,content_2228_2198:()=>e4,content_2228_22:()=>Fw,content_2228_220:()=>D_,content_2228_2200:()=>o4,content_2228_2202:()=>r4,content_2228_2204:()=>a4,content_2228_2206:()=>c4,content_2228_2208:()=>u4,content_2228_2210:()=>d4,content_2228_2212:()=>y4,content_2228_2214:()=>k4,content_2228_2216:()=>g4,content_2228_2218:()=>D4,content_2228_222:()=>X_,content_2228_2220:()=>X4,content_2228_2222:()=>v4,content_2228_2224:()=>T4,content_2228_2226:()=>L4,content_2228_2228:()=>N4,content_2228_2230:()=>R4,content_2228_2232:()=>z4,content_2228_2234:()=>I4,content_2228_2236:()=>F4,content_2228_2238:()=>B4,content_2228_224:()=>v_,content_2228_2240:()=>O4,content_2228_2242:()=>U4,content_2228_2244:()=>V4,content_2228_2246:()=>H4,content_2228_2248:()=>Y4,content_2228_2250:()=>Q4,content_2228_2252:()=>e6,content_2228_2254:()=>o6,content_2228_2256:()=>r6,content_2228_2258:()=>a6,content_2228_226:()=>T_,content_2228_2260:()=>c6,content_2228_2262:()=>u6,content_2228_2264:()=>d6,content_2228_2266:()=>y6,content_2228_2268:()=>k6,content_2228_2270:()=>g6,content_2228_2272:()=>D6,content_2228_2274:()=>X6,content_2228_2276:()=>v6,content_2228_2278:()=>T6,content_2228_228:()=>L_,content_2228_2280:()=>L6,content_2228_2282:()=>N6,content_2228_2284:()=>R6,content_2228_2286:()=>z6,content_2228_2288:()=>I6,content_2228_2290:()=>F6,content_2228_2292:()=>B6,content_2228_2294:()=>O6,content_2228_2296:()=>U6,content_2228_2298:()=>V6,content_2228_230:()=>N_,content_2228_2300:()=>H6,content_2228_2302:()=>Y6,content_2228_2304:()=>Q6,content_2228_2306:()=>e5,content_2228_2308:()=>o5,content_2228_2310:()=>r5,content_2228_2312:()=>a5,content_2228_2314:()=>c5,content_2228_2316:()=>u5,content_2228_2318:()=>d5,content_2228_232:()=>R_,content_2228_2320:()=>y5,content_2228_2322:()=>k5,content_2228_2324:()=>g5,content_2228_2326:()=>D5,content_2228_2328:()=>X5,content_2228_2330:()=>v5,content_2228_2332:()=>T5,content_2228_2334:()=>L5,content_2228_2336:()=>N5,content_2228_2338:()=>R5,content_2228_234:()=>z_,content_2228_2340:()=>z5,content_2228_2342:()=>I5,content_2228_2344:()=>F5,content_2228_2346:()=>B5,content_2228_2348:()=>O5,content_2228_2350:()=>U5,content_2228_2352:()=>V5,content_2228_2354:()=>H5,content_2228_2356:()=>Y5,content_2228_2358:()=>Q5,content_2228_236:()=>I_,content_2228_2360:()=>e7,content_2228_2362:()=>o7,content_2228_2364:()=>r7,content_2228_2366:()=>a7,content_2228_2368:()=>c7,content_2228_2370:()=>u7,content_2228_2372:()=>d7,content_2228_2374:()=>y7,content_2228_2376:()=>k7,content_2228_2378:()=>g7,content_2228_238:()=>F_,content_2228_2380:()=>D7,content_2228_2382:()=>X7,content_2228_2384:()=>v7,content_2228_2386:()=>T7,content_2228_2388:()=>L7,content_2228_2390:()=>N7,content_2228_2392:()=>R7,content_2228_2394:()=>z7,content_2228_2396:()=>I7,content_2228_2398:()=>F7,content_2228_24:()=>Bw,content_2228_240:()=>B_,content_2228_2400:()=>B7,content_2228_2402:()=>O7,content_2228_2404:()=>U7,content_2228_2406:()=>V7,content_2228_2408:()=>H7,content_2228_2410:()=>Y7,content_2228_2412:()=>Q7,content_2228_2414:()=>e9,content_2228_2416:()=>o9,content_2228_2418:()=>r9,content_2228_242:()=>O_,content_2228_2420:()=>a9,content_2228_2422:()=>c9,content_2228_2424:()=>u9,content_2228_2426:()=>d9,content_2228_2428:()=>y9,content_2228_2430:()=>k9,content_2228_2432:()=>g9,content_2228_2434:()=>D9,content_2228_2436:()=>X9,content_2228_2438:()=>v9,content_2228_244:()=>U_,content_2228_2440:()=>T9,content_2228_2442:()=>L9,content_2228_2444:()=>N9,content_2228_2446:()=>R9,content_2228_2448:()=>z9,content_2228_2450:()=>I9,content_2228_2452:()=>F9,content_2228_2454:()=>B9,content_2228_2456:()=>O9,content_2228_2458:()=>U9,content_2228_246:()=>V_,content_2228_2460:()=>V9,content_2228_2462:()=>H9,content_2228_2464:()=>Y9,content_2228_2466:()=>Q9,content_2228_2468:()=>ett,content_2228_2470:()=>ott,content_2228_2472:()=>rtt,content_2228_2474:()=>att,content_2228_2476:()=>ctt,content_2228_2478:()=>utt,content_2228_248:()=>H_,content_2228_2480:()=>dtt,content_2228_2482:()=>ytt,content_2228_2484:()=>ktt,content_2228_2486:()=>gtt,content_2228_2488:()=>Dtt,content_2228_2490:()=>Xtt,content_2228_2492:()=>vtt,content_2228_2494:()=>Ttt,content_2228_2496:()=>Ltt,content_2228_2498:()=>Ntt,content_2228_250:()=>Y_,content_2228_2500:()=>Rtt,content_2228_2502:()=>ztt,content_2228_2504:()=>Itt,content_2228_2506:()=>Ftt,content_2228_2508:()=>Btt,content_2228_2510:()=>Ott,content_2228_2512:()=>Utt,content_2228_2514:()=>Vtt,content_2228_2516:()=>Htt,content_2228_2518:()=>Ytt,content_2228_252:()=>Q_,content_2228_2520:()=>Qtt,content_2228_2522:()=>eet,content_2228_2524:()=>oet,content_2228_2526:()=>ret,content_2228_2528:()=>aet,content_2228_2530:()=>cet,content_2228_2532:()=>met,content_2228_2534:()=>het,content_2228_2536:()=>fet,content_2228_2538:()=>wet,content_2228_254:()=>eX,content_2228_2540:()=>Met,content_2228_2542:()=>_et,content_2228_2544:()=>xet,content_2228_2546:()=>Cet,content_2228_2548:()=>bet,content_2228_2550:()=>Zet,content_2228_2552:()=>Set,content_2228_2554:()=>Eet,content_2228_2556:()=>Aet,content_2228_2558:()=>Pet,content_2228_256:()=>oX,content_2228_2560:()=>Wet,content_2228_2562:()=>Get,content_2228_2564:()=>jet,content_2228_2566:()=>qet,content_2228_2568:()=>$et,content_2228_2570:()=>Jet,content_2228_2572:()=>Ket,content_2228_2574:()=>tnt,content_2228_2576:()=>nnt,content_2228_2578:()=>snt,content_2228_258:()=>rX,content_2228_2580:()=>int,content_2228_2582:()=>pnt,content_2228_2584:()=>lnt,content_2228_2586:()=>mnt,content_2228_2588:()=>hnt,content_2228_2590:()=>fnt,content_2228_2592:()=>wnt,content_2228_2594:()=>Mnt,content_2228_2596:()=>_nt,content_2228_2598:()=>xnt,content_2228_26:()=>Ow,content_2228_260:()=>aX,content_2228_2600:()=>Cnt,content_2228_2602:()=>bnt,content_2228_2604:()=>Znt,content_2228_2606:()=>Snt,content_2228_2608:()=>Ent,content_2228_2610:()=>Ant,content_2228_2612:()=>Pnt,content_2228_2614:()=>Wnt,content_2228_2616:()=>Gnt,content_2228_2618:()=>jnt,content_2228_262:()=>cX,content_2228_2620:()=>qnt,content_2228_2622:()=>$nt,content_2228_2624:()=>Jnt,content_2228_2626:()=>Knt,content_2228_2628:()=>tot,content_2228_2630:()=>not,content_2228_2632:()=>sot,content_2228_2634:()=>iot,content_2228_2636:()=>pot,content_2228_2638:()=>lot,content_2228_264:()=>uX,content_2228_2640:()=>mot,content_2228_2642:()=>hot,content_2228_2644:()=>fot,content_2228_2646:()=>wot,content_2228_2648:()=>Mot,content_2228_2650:()=>_ot,content_2228_2652:()=>xot,content_2228_2654:()=>Cot,content_2228_2656:()=>bot,content_2228_2658:()=>Zot,content_2228_266:()=>dX,content_2228_2660:()=>Sot,content_2228_2662:()=>Eot,content_2228_2664:()=>Aot,content_2228_2666:()=>Pot,content_2228_2668:()=>Wot,content_2228_2670:()=>Got,content_2228_2672:()=>jot,content_2228_2674:()=>qot,content_2228_2676:()=>$ot,content_2228_2678:()=>Jot,content_2228_268:()=>yX,content_2228_2680:()=>Kot,content_2228_2682:()=>tst,content_2228_2684:()=>nst,content_2228_2686:()=>sst,content_2228_2688:()=>ist,content_2228_2690:()=>pst,content_2228_2692:()=>lst,content_2228_2694:()=>mst,content_2228_2696:()=>hst,content_2228_2698:()=>fst,content_2228_270:()=>kX,content_2228_2700:()=>wst,content_2228_2702:()=>Mst,content_2228_2704:()=>_st,content_2228_2706:()=>xst,content_2228_2708:()=>Cst,content_2228_2710:()=>bst,content_2228_2712:()=>Zst,content_2228_2714:()=>Sst,content_2228_2716:()=>Est,content_2228_2718:()=>Ast,content_2228_272:()=>gX,content_2228_2720:()=>Pst,content_2228_2722:()=>Wst,content_2228_2724:()=>Gst,content_2228_2726:()=>jst,content_2228_2728:()=>qst,content_2228_2730:()=>$st,content_2228_2732:()=>Jst,content_2228_2734:()=>Kst,content_2228_2736:()=>trt,content_2228_2738:()=>nrt,content_2228_274:()=>DX,content_2228_2740:()=>srt,content_2228_2742:()=>irt,content_2228_2744:()=>prt,content_2228_2746:()=>lrt,content_2228_2748:()=>mrt,content_2228_2750:()=>hrt,content_2228_2752:()=>frt,content_2228_2754:()=>wrt,content_2228_2756:()=>Mrt,content_2228_2758:()=>_rt,content_2228_276:()=>XX,content_2228_2760:()=>xrt,content_2228_2762:()=>Crt,content_2228_2764:()=>brt,content_2228_2766:()=>Zrt,content_2228_2768:()=>Srt,content_2228_2770:()=>Ert,content_2228_2772:()=>Art,content_2228_2774:()=>Prt,content_2228_2776:()=>Wrt,content_2228_2778:()=>Grt,content_2228_278:()=>vX,content_2228_2780:()=>jrt,content_2228_2782:()=>qrt,content_2228_2784:()=>$rt,content_2228_2786:()=>Jrt,content_2228_2788:()=>Krt,content_2228_2790:()=>tit,content_2228_2792:()=>nit,content_2228_2794:()=>sit,content_2228_2796:()=>iit,content_2228_2798:()=>pit,content_2228_28:()=>Uw,content_2228_280:()=>TX,content_2228_2800:()=>lit,content_2228_2802:()=>mit,content_2228_2804:()=>hit,content_2228_2806:()=>fit,content_2228_2808:()=>wit,content_2228_2810:()=>Mit,content_2228_2812:()=>_it,content_2228_2814:()=>xit,content_2228_2816:()=>Cit,content_2228_2818:()=>bit,content_2228_282:()=>LX,content_2228_2820:()=>Zit,content_2228_2822:()=>Sit,content_2228_2824:()=>Eit,content_2228_2826:()=>Ait,content_2228_2828:()=>Pit,content_2228_2830:()=>Wit,content_2228_2832:()=>Git,content_2228_2834:()=>jit,content_2228_2836:()=>qit,content_2228_2838:()=>$it,content_2228_284:()=>NX,content_2228_2840:()=>Jit,content_2228_2842:()=>Kit,content_2228_2844:()=>tat,content_2228_2846:()=>nat,content_2228_2848:()=>sat,content_2228_2850:()=>iat,content_2228_2852:()=>pat,content_2228_2854:()=>lat,content_2228_2856:()=>mat,content_2228_2858:()=>hat,content_2228_286:()=>RX,content_2228_2860:()=>fat,content_2228_2862:()=>wat,content_2228_2864:()=>Mat,content_2228_2866:()=>_at,content_2228_2868:()=>xat,content_2228_2870:()=>Cat,content_2228_2872:()=>bat,content_2228_2874:()=>Zat,content_2228_2876:()=>Sat,content_2228_2878:()=>Eat,content_2228_288:()=>zX,content_2228_2880:()=>Aat,content_2228_2882:()=>Pat,content_2228_2884:()=>Wat,content_2228_2886:()=>Gat,content_2228_2888:()=>jat,content_2228_2890:()=>qat,content_2228_2892:()=>$at,content_2228_2894:()=>Jat,content_2228_2896:()=>Kat,content_2228_2898:()=>tpt,content_2228_290:()=>IX,content_2228_2900:()=>npt,content_2228_2902:()=>spt,content_2228_2904:()=>ipt,content_2228_2906:()=>ppt,content_2228_2908:()=>lpt,content_2228_2910:()=>mpt,content_2228_2912:()=>hpt,content_2228_2914:()=>fpt,content_2228_2916:()=>wpt,content_2228_2918:()=>Mpt,content_2228_292:()=>FX,content_2228_2920:()=>_pt,content_2228_2922:()=>xpt,content_2228_2924:()=>Cpt,content_2228_2926:()=>bpt,content_2228_2928:()=>Zpt,content_2228_2930:()=>Spt,content_2228_2932:()=>Ept,content_2228_2934:()=>Apt,content_2228_2936:()=>Ppt,content_2228_2938:()=>Wpt,content_2228_294:()=>BX,content_2228_2940:()=>Gpt,content_2228_2942:()=>jpt,content_2228_2944:()=>qpt,content_2228_2946:()=>$pt,content_2228_2948:()=>Jpt,content_2228_2950:()=>Kpt,content_2228_2952:()=>tct,content_2228_2954:()=>nct,content_2228_2956:()=>sct,content_2228_2958:()=>ict,content_2228_296:()=>OX,content_2228_2960:()=>pct,content_2228_2962:()=>lct,content_2228_2964:()=>mct,content_2228_2966:()=>hct,content_2228_2968:()=>fct,content_2228_2970:()=>wct,content_2228_2972:()=>Mct,content_2228_2974:()=>_ct,content_2228_2976:()=>xct,content_2228_2978:()=>Cct,content_2228_298:()=>UX,content_2228_2980:()=>bct,content_2228_2982:()=>Zct,content_2228_2984:()=>Sct,content_2228_2986:()=>Ect,content_2228_2988:()=>Act,content_2228_2990:()=>Pct,content_2228_2992:()=>Wct,content_2228_2994:()=>Gct,content_2228_2996:()=>jct,content_2228_2998:()=>qct,content_2228_30:()=>Vw,content_2228_300:()=>VX,content_2228_3000:()=>$ct,content_2228_3002:()=>Jct,content_2228_3004:()=>Kct,content_2228_3006:()=>tlt,content_2228_3008:()=>nlt,content_2228_3010:()=>slt,content_2228_3012:()=>ilt,content_2228_3014:()=>plt,content_2228_3016:()=>llt,content_2228_3018:()=>mlt,content_2228_302:()=>HX,content_2228_3020:()=>hlt,content_2228_3022:()=>flt,content_2228_3024:()=>wlt,content_2228_3026:()=>Mlt,content_2228_3028:()=>_lt,content_2228_3030:()=>xlt,content_2228_3032:()=>Clt,content_2228_3034:()=>blt,content_2228_3036:()=>Zlt,content_2228_3038:()=>Slt,content_2228_304:()=>YX,content_2228_3040:()=>Elt,content_2228_3042:()=>Alt,content_2228_3044:()=>Plt,content_2228_3046:()=>Wlt,content_2228_3048:()=>Glt,content_2228_3050:()=>jlt,content_2228_3052:()=>qlt,content_2228_3054:()=>$lt,content_2228_3056:()=>Jlt,content_2228_3058:()=>Klt,content_2228_306:()=>QX,content_2228_3060:()=>tut,content_2228_3062:()=>nut,content_2228_3064:()=>sut,content_2228_3066:()=>iut,content_2228_3068:()=>put,content_2228_3070:()=>lut,content_2228_3072:()=>mut,content_2228_3074:()=>hut,content_2228_3076:()=>fut,content_2228_3078:()=>wut,content_2228_308:()=>ex,content_2228_3080:()=>Mut,content_2228_3082:()=>_ut,content_2228_3084:()=>xut,content_2228_3086:()=>Cut,content_2228_3088:()=>but,content_2228_3090:()=>Zut,content_2228_3092:()=>Sut,content_2228_3094:()=>Eut,content_2228_3096:()=>Aut,content_2228_3098:()=>Put,content_2228_310:()=>ox,content_2228_3100:()=>Wut,content_2228_3102:()=>Gut,content_2228_3104:()=>jut,content_2228_3106:()=>qut,content_2228_3108:()=>$ut,content_2228_3110:()=>Jut,content_2228_3112:()=>Kut,content_2228_3114:()=>tmt,content_2228_3116:()=>nmt,content_2228_3118:()=>smt,content_2228_312:()=>rx,content_2228_3120:()=>imt,content_2228_3122:()=>pmt,content_2228_3124:()=>lmt,content_2228_3126:()=>mmt,content_2228_3128:()=>hmt,content_2228_3130:()=>fmt,content_2228_3132:()=>wmt,content_2228_3134:()=>Mmt,content_2228_3136:()=>_mt,content_2228_3138:()=>xmt,content_2228_314:()=>ax,content_2228_3140:()=>Cmt,content_2228_3142:()=>bmt,content_2228_3144:()=>Zmt,content_2228_3146:()=>Smt,content_2228_3148:()=>Emt,content_2228_3150:()=>Amt,content_2228_3152:()=>Pmt,content_2228_3154:()=>Wmt,content_2228_3156:()=>Gmt,content_2228_3158:()=>jmt,content_2228_316:()=>cx,content_2228_3160:()=>qmt,content_2228_3162:()=>$mt,content_2228_3164:()=>Jmt,content_2228_3166:()=>Kmt,content_2228_3168:()=>tdt,content_2228_3170:()=>ndt,content_2228_3172:()=>sdt,content_2228_3174:()=>idt,content_2228_3176:()=>pdt,content_2228_3178:()=>ldt,content_2228_318:()=>ux,content_2228_3180:()=>mdt,content_2228_3182:()=>hdt,content_2228_3184:()=>fdt,content_2228_3186:()=>wdt,content_2228_3188:()=>Mdt,content_2228_3190:()=>_dt,content_2228_3192:()=>xdt,content_2228_3194:()=>Cdt,content_2228_3196:()=>bdt,content_2228_3198:()=>Zdt,content_2228_32:()=>Hw,content_2228_320:()=>dx,content_2228_3200:()=>Sdt,content_2228_3202:()=>Edt,content_2228_3204:()=>Adt,content_2228_3206:()=>Pdt,content_2228_3208:()=>Wdt,content_2228_3210:()=>Gdt,content_2228_3212:()=>jdt,content_2228_3214:()=>qdt,content_2228_3216:()=>$dt,content_2228_3218:()=>Jdt,content_2228_322:()=>yx,content_2228_3220:()=>Kdt,content_2228_3222:()=>tht,content_2228_3224:()=>nht,content_2228_3226:()=>sht,content_2228_3228:()=>iht,content_2228_3230:()=>pht,content_2228_3232:()=>lht,content_2228_3234:()=>mht,content_2228_3236:()=>hht,content_2228_3238:()=>fht,content_2228_324:()=>kx,content_2228_3240:()=>wht,content_2228_3242:()=>Mht,content_2228_3244:()=>_ht,content_2228_3246:()=>xht,content_2228_3248:()=>Cht,content_2228_3250:()=>bht,content_2228_3252:()=>Zht,content_2228_3254:()=>Sht,content_2228_3256:()=>Eht,content_2228_3258:()=>Aht,content_2228_326:()=>gx,content_2228_3260:()=>Pht,content_2228_3262:()=>Wht,content_2228_3264:()=>Ght,content_2228_3266:()=>jht,content_2228_3268:()=>qht,content_2228_3270:()=>$ht,content_2228_3272:()=>Jht,content_2228_3274:()=>Kht,content_2228_3276:()=>tyt,content_2228_3278:()=>nyt,content_2228_328:()=>Dx,content_2228_3280:()=>syt,content_2228_3282:()=>iyt,content_2228_3284:()=>pyt,content_2228_3286:()=>lyt,content_2228_3288:()=>myt,content_2228_3290:()=>hyt,content_2228_3292:()=>fyt,content_2228_3294:()=>wyt,content_2228_3296:()=>Myt,content_2228_3298:()=>_yt,content_2228_330:()=>Xx,content_2228_3300:()=>xyt,content_2228_3302:()=>Cyt,content_2228_3304:()=>byt,content_2228_3306:()=>Zyt,content_2228_3308:()=>Syt,content_2228_3310:()=>Eyt,content_2228_3312:()=>Ayt,content_2228_3314:()=>Pyt,content_2228_3316:()=>Wyt,content_2228_3318:()=>Gyt,content_2228_332:()=>vx,content_2228_3320:()=>jyt,content_2228_3322:()=>qyt,content_2228_3324:()=>$yt,content_2228_3326:()=>Jyt,content_2228_3328:()=>Kyt,content_2228_3330:()=>tft,content_2228_3332:()=>nft,content_2228_3334:()=>sft,content_2228_3336:()=>ift,content_2228_3338:()=>pft,content_2228_334:()=>Tx,content_2228_3340:()=>lft,content_2228_3342:()=>mft,content_2228_3344:()=>hft,content_2228_3346:()=>fft,content_2228_3348:()=>wft,content_2228_3350:()=>Mft,content_2228_3352:()=>_ft,content_2228_3354:()=>xft,content_2228_3356:()=>Cft,content_2228_3358:()=>bft,content_2228_336:()=>Lx,content_2228_3360:()=>Zft,content_2228_3362:()=>Sft,content_2228_3364:()=>Eft,content_2228_3366:()=>Aft,content_2228_3368:()=>Pft,content_2228_3370:()=>Wft,content_2228_3372:()=>Gft,content_2228_3374:()=>jft,content_2228_3376:()=>qft,content_2228_3378:()=>$ft,content_2228_338:()=>Nx,content_2228_3380:()=>Jft,content_2228_3382:()=>Kft,content_2228_3384:()=>tkt,content_2228_3386:()=>nkt,content_2228_3388:()=>skt,content_2228_3390:()=>ikt,content_2228_3392:()=>pkt,content_2228_3394:()=>lkt,content_2228_3396:()=>mkt,content_2228_3398:()=>hkt,content_2228_34:()=>Yw,content_2228_340:()=>Rx,content_2228_3400:()=>fkt,content_2228_3402:()=>wkt,content_2228_3404:()=>Mkt,content_2228_3406:()=>_kt,content_2228_3408:()=>xkt,content_2228_3410:()=>Ckt,content_2228_3412:()=>bkt,content_2228_3414:()=>Zkt,content_2228_3416:()=>Skt,content_2228_3418:()=>Ekt,content_2228_342:()=>zx,content_2228_3420:()=>Akt,content_2228_3422:()=>Pkt,content_2228_3424:()=>Wkt,content_2228_3426:()=>Gkt,content_2228_3428:()=>jkt,content_2228_3430:()=>qkt,content_2228_3432:()=>$kt,content_2228_3434:()=>Jkt,content_2228_3436:()=>Kkt,content_2228_3438:()=>twt,content_2228_344:()=>Ix,content_2228_3440:()=>nwt,content_2228_3442:()=>swt,content_2228_3444:()=>iwt,content_2228_3446:()=>pwt,content_2228_3448:()=>lwt,content_2228_3450:()=>mwt,content_2228_3452:()=>hwt,content_2228_3454:()=>fwt,content_2228_3456:()=>wwt,content_2228_3458:()=>Mwt,content_2228_346:()=>Fx,content_2228_3460:()=>_wt,content_2228_3462:()=>xwt,content_2228_3464:()=>Cwt,content_2228_3466:()=>bwt,content_2228_3468:()=>Zwt,content_2228_3470:()=>Swt,content_2228_3472:()=>Ewt,content_2228_3474:()=>Awt,content_2228_3476:()=>Pwt,content_2228_3478:()=>Wwt,content_2228_348:()=>Bx,content_2228_3480:()=>Gwt,content_2228_3482:()=>jwt,content_2228_3484:()=>qwt,content_2228_3486:()=>$wt,content_2228_3488:()=>Jwt,content_2228_3490:()=>Kwt,content_2228_3492:()=>tgt,content_2228_3494:()=>ngt,content_2228_3496:()=>sgt,content_2228_3498:()=>igt,content_2228_350:()=>Ox,content_2228_3500:()=>pgt,content_2228_3502:()=>lgt,content_2228_3504:()=>mgt,content_2228_3506:()=>hgt,content_2228_3508:()=>fgt,content_2228_3510:()=>wgt,content_2228_3512:()=>Mgt,content_2228_3514:()=>_gt,content_2228_3516:()=>xgt,content_2228_3518:()=>Cgt,content_2228_352:()=>Ux,content_2228_3520:()=>bgt,content_2228_3522:()=>Zgt,content_2228_3524:()=>Sgt,content_2228_3526:()=>Egt,content_2228_3528:()=>Agt,content_2228_3530:()=>Pgt,content_2228_3532:()=>Wgt,content_2228_3534:()=>Ggt,content_2228_3536:()=>jgt,content_2228_3538:()=>qgt,content_2228_354:()=>Vx,content_2228_3540:()=>$gt,content_2228_3542:()=>Jgt,content_2228_3544:()=>Kgt,content_2228_3546:()=>tMt,content_2228_3548:()=>nMt,content_2228_3550:()=>sMt,content_2228_3552:()=>iMt,content_2228_3554:()=>pMt,content_2228_3556:()=>lMt,content_2228_3558:()=>mMt,content_2228_356:()=>Hx,content_2228_3560:()=>hMt,content_2228_3562:()=>fMt,content_2228_3564:()=>wMt,content_2228_3566:()=>MMt,content_2228_3568:()=>_Mt,content_2228_3570:()=>xMt,content_2228_3572:()=>CMt,content_2228_3574:()=>bMt,content_2228_3576:()=>ZMt,content_2228_3578:()=>SMt,content_2228_358:()=>Yx,content_2228_3580:()=>EMt,content_2228_3582:()=>AMt,content_2228_3584:()=>PMt,content_2228_3586:()=>WMt,content_2228_3588:()=>GMt,content_2228_3590:()=>jMt,content_2228_3592:()=>qMt,content_2228_3594:()=>$Mt,content_2228_3596:()=>JMt,content_2228_3598:()=>KMt,content_2228_36:()=>Qw,content_2228_360:()=>Qx,content_2228_3600:()=>tDt,content_2228_3602:()=>nDt,content_2228_3604:()=>sDt,content_2228_3606:()=>iDt,content_2228_3608:()=>pDt,content_2228_3610:()=>lDt,content_2228_3612:()=>mDt,content_2228_3614:()=>hDt,content_2228_3616:()=>fDt,content_2228_3618:()=>wDt,content_2228_362:()=>ev,content_2228_3620:()=>MDt,content_2228_3622:()=>_Dt,content_2228_3624:()=>xDt,content_2228_3626:()=>CDt,content_2228_3628:()=>bDt,content_2228_3630:()=>ZDt,content_2228_3632:()=>SDt,content_2228_3634:()=>EDt,content_2228_3636:()=>ADt,content_2228_3638:()=>PDt,content_2228_364:()=>ov,content_2228_3640:()=>WDt,content_2228_3642:()=>GDt,content_2228_3644:()=>jDt,content_2228_3646:()=>qDt,content_2228_3648:()=>$Dt,content_2228_3650:()=>JDt,content_2228_3652:()=>KDt,content_2228_3654:()=>t_t,content_2228_3656:()=>n_t,content_2228_3658:()=>s_t,content_2228_366:()=>rv,content_2228_3660:()=>i_t,content_2228_3662:()=>p_t,content_2228_3664:()=>l_t,content_2228_3666:()=>m_t,content_2228_3668:()=>h_t,content_2228_3670:()=>f_t,content_2228_3672:()=>w_t,content_2228_3674:()=>M_t,content_2228_3676:()=>__t,content_2228_3678:()=>x_t,content_2228_368:()=>av,content_2228_3680:()=>C_t,content_2228_3682:()=>b_t,content_2228_3684:()=>Z_t,content_2228_3686:()=>S_t,content_2228_3688:()=>E_t,content_2228_3690:()=>A_t,content_2228_3692:()=>P_t,content_2228_3694:()=>W_t,content_2228_3696:()=>G_t,content_2228_3698:()=>j_t,content_2228_370:()=>cv,content_2228_3700:()=>q_t,content_2228_3702:()=>$_t,content_2228_3704:()=>J_t,content_2228_3706:()=>K_t,content_2228_3708:()=>tXt,content_2228_3710:()=>nXt,content_2228_3712:()=>sXt,content_2228_3714:()=>iXt,content_2228_372:()=>uv,content_2228_374:()=>dv,content_2228_376:()=>yv,content_2228_378:()=>kv,content_2228_38:()=>eg,content_2228_380:()=>gv,content_2228_382:()=>Dv,content_2228_384:()=>Xv,content_2228_386:()=>vv,content_2228_388:()=>Tv,content_2228_390:()=>Lv,content_2228_392:()=>Nv,content_2228_394:()=>Rv,content_2228_396:()=>zv,content_2228_398:()=>Iv,content_2228_4:()=>Dw,content_2228_40:()=>og,content_2228_400:()=>Fv,content_2228_402:()=>Bv,content_2228_404:()=>Ov,content_2228_406:()=>Uv,content_2228_408:()=>Vv,content_2228_410:()=>Hv,content_2228_412:()=>Yv,content_2228_414:()=>Qv,content_2228_416:()=>eC,content_2228_418:()=>oC,content_2228_42:()=>rg,content_2228_420:()=>rC,content_2228_422:()=>aC,content_2228_424:()=>cC,content_2228_426:()=>uC,content_2228_428:()=>dC,content_2228_430:()=>yC,content_2228_432:()=>kC,content_2228_434:()=>gC,content_2228_436:()=>DC,content_2228_438:()=>XC,content_2228_44:()=>ag,content_2228_440:()=>vC,content_2228_442:()=>TC,content_2228_444:()=>LC,content_2228_446:()=>NC,content_2228_448:()=>RC,content_2228_450:()=>zC,content_2228_452:()=>IC,content_2228_454:()=>FC,content_2228_456:()=>BC,content_2228_458:()=>OC,content_2228_46:()=>cg,content_2228_460:()=>UC,content_2228_462:()=>VC,content_2228_464:()=>HC,content_2228_466:()=>YC,content_2228_468:()=>QC,content_2228_470:()=>eT,content_2228_472:()=>oT,content_2228_474:()=>rT,content_2228_476:()=>aT,content_2228_478:()=>cT,content_2228_48:()=>ug,content_2228_480:()=>uT,content_2228_482:()=>dT,content_2228_484:()=>yT,content_2228_486:()=>kT,content_2228_488:()=>gT,content_2228_490:()=>DT,content_2228_492:()=>XT,content_2228_494:()=>vT,content_2228_496:()=>TT,content_2228_498:()=>LT,content_2228_50:()=>dg,content_2228_500:()=>NT,content_2228_502:()=>RT,content_2228_504:()=>zT,content_2228_506:()=>IT,content_2228_508:()=>FT,content_2228_510:()=>BT,content_2228_512:()=>OT,content_2228_514:()=>UT,content_2228_516:()=>VT,content_2228_518:()=>HT,content_2228_52:()=>yg,content_2228_520:()=>YT,content_2228_522:()=>QT,content_2228_524:()=>eb,content_2228_526:()=>ob,content_2228_528:()=>rb,content_2228_530:()=>ab,content_2228_532:()=>cb,content_2228_534:()=>ub,content_2228_536:()=>db,content_2228_538:()=>yb,content_2228_54:()=>kg,content_2228_540:()=>kb,content_2228_542:()=>gb,content_2228_544:()=>Db,content_2228_546:()=>Xb,content_2228_548:()=>vb,content_2228_550:()=>Tb,content_2228_552:()=>Lb,content_2228_554:()=>Nb,content_2228_556:()=>Rb,content_2228_558:()=>zb,content_2228_56:()=>gg,content_2228_560:()=>Ib,content_2228_562:()=>Fb,content_2228_564:()=>Bb,content_2228_566:()=>Ob,content_2228_568:()=>Ub,content_2228_570:()=>Vb,content_2228_572:()=>Hb,content_2228_574:()=>Yb,content_2228_576:()=>Qb,content_2228_578:()=>eL,content_2228_58:()=>Dg,content_2228_580:()=>oL,content_2228_582:()=>rL,content_2228_584:()=>aL,content_2228_586:()=>cL,content_2228_588:()=>uL,content_2228_590:()=>dL,content_2228_592:()=>yL,content_2228_594:()=>kL,content_2228_596:()=>gL,content_2228_598:()=>DL,content_2228_6:()=>Xw,content_2228_60:()=>Xg,content_2228_600:()=>XL,content_2228_602:()=>vL,content_2228_604:()=>TL,content_2228_606:()=>LL,content_2228_608:()=>NL,content_2228_610:()=>RL,content_2228_612:()=>zL,content_2228_614:()=>IL,content_2228_616:()=>FL,content_2228_618:()=>BL,content_2228_62:()=>vg,content_2228_620:()=>OL,content_2228_622:()=>UL,content_2228_624:()=>VL,content_2228_626:()=>HL,content_2228_628:()=>YL,content_2228_630:()=>QL,content_2228_632:()=>eZ,content_2228_634:()=>oZ,content_2228_636:()=>rZ,content_2228_638:()=>aZ,content_2228_64:()=>Tg,content_2228_640:()=>cZ,content_2228_642:()=>uZ,content_2228_644:()=>dZ,content_2228_646:()=>yZ,content_2228_648:()=>kZ,content_2228_650:()=>gZ,content_2228_652:()=>DZ,content_2228_654:()=>XZ,content_2228_656:()=>vZ,content_2228_658:()=>TZ,content_2228_66:()=>Lg,content_2228_660:()=>LZ,content_2228_662:()=>NZ,content_2228_664:()=>RZ,content_2228_666:()=>zZ,content_2228_668:()=>IZ,content_2228_670:()=>FZ,content_2228_672:()=>BZ,content_2228_674:()=>OZ,content_2228_676:()=>UZ,content_2228_678:()=>VZ,content_2228_68:()=>Ng,content_2228_680:()=>HZ,content_2228_682:()=>YZ,content_2228_684:()=>QZ,content_2228_686:()=>eN,content_2228_688:()=>oN,content_2228_690:()=>rN,content_2228_692:()=>aN,content_2228_694:()=>cN,content_2228_696:()=>uN,content_2228_698:()=>dN,content_2228_70:()=>Rg,content_2228_700:()=>yN,content_2228_702:()=>kN,content_2228_704:()=>gN,content_2228_706:()=>DN,content_2228_708:()=>XN,content_2228_710:()=>vN,content_2228_712:()=>TN,content_2228_714:()=>LN,content_2228_716:()=>NN,content_2228_718:()=>RN,content_2228_72:()=>zg,content_2228_720:()=>zN,content_2228_722:()=>IN,content_2228_724:()=>FN,content_2228_726:()=>BN,content_2228_728:()=>ON,content_2228_730:()=>UN,content_2228_732:()=>VN,content_2228_734:()=>HN,content_2228_736:()=>YN,content_2228_738:()=>QN,content_2228_74:()=>Ig,content_2228_740:()=>eS,content_2228_742:()=>oS,content_2228_744:()=>rS,content_2228_746:()=>aS,content_2228_748:()=>cS,content_2228_750:()=>uS,content_2228_752:()=>dS,content_2228_754:()=>yS,content_2228_756:()=>kS,content_2228_758:()=>gS,content_2228_76:()=>Fg,content_2228_760:()=>DS,content_2228_762:()=>XS,content_2228_764:()=>vS,content_2228_766:()=>TS,content_2228_768:()=>LS,content_2228_770:()=>NS,content_2228_772:()=>RS,content_2228_774:()=>zS,content_2228_776:()=>IS,content_2228_778:()=>FS,content_2228_78:()=>Bg,content_2228_780:()=>BS,content_2228_782:()=>OS,content_2228_784:()=>US,content_2228_786:()=>VS,content_2228_788:()=>HS,content_2228_790:()=>YS,content_2228_792:()=>QS,content_2228_794:()=>eR,content_2228_796:()=>oR,content_2228_798:()=>rR,content_2228_8:()=>vw,content_2228_80:()=>Og,content_2228_800:()=>aR,content_2228_802:()=>cR,content_2228_804:()=>uR,content_2228_806:()=>dR,content_2228_808:()=>yR,content_2228_810:()=>kR,content_2228_812:()=>gR,content_2228_814:()=>DR,content_2228_816:()=>XR,content_2228_818:()=>vR,content_2228_82:()=>Ug,content_2228_820:()=>TR,content_2228_822:()=>LR,content_2228_824:()=>NR,content_2228_826:()=>RR,content_2228_828:()=>zR,content_2228_830:()=>IR,content_2228_832:()=>FR,content_2228_834:()=>BR,content_2228_836:()=>OR,content_2228_838:()=>UR,content_2228_84:()=>Vg,content_2228_840:()=>VR,content_2228_842:()=>HR,content_2228_844:()=>YR,content_2228_846:()=>QR,content_2228_848:()=>eE,content_2228_850:()=>oE,content_2228_852:()=>rE,content_2228_854:()=>aE,content_2228_856:()=>cE,content_2228_858:()=>uE,content_2228_86:()=>Hg,content_2228_860:()=>dE,content_2228_862:()=>yE,content_2228_864:()=>kE,content_2228_866:()=>gE,content_2228_868:()=>DE,content_2228_870:()=>XE,content_2228_872:()=>vE,content_2228_874:()=>TE,content_2228_876:()=>LE,content_2228_878:()=>NE,content_2228_88:()=>Yg,content_2228_880:()=>RE,content_2228_882:()=>zE,content_2228_884:()=>IE,content_2228_886:()=>FE,content_2228_888:()=>BE,content_2228_890:()=>OE,content_2228_892:()=>UE,content_2228_894:()=>VE,content_2228_896:()=>HE,content_2228_898:()=>YE,content_2228_90:()=>Qg,content_2228_900:()=>QE,content_2228_902:()=>ez,content_2228_904:()=>oz,content_2228_906:()=>rz,content_2228_908:()=>az,content_2228_910:()=>cz,content_2228_912:()=>uz,content_2228_914:()=>dz,content_2228_916:()=>yz,content_2228_918:()=>kz,content_2228_92:()=>eM,content_2228_920:()=>gz,content_2228_922:()=>Dz,content_2228_924:()=>Xz,content_2228_926:()=>vz,content_2228_928:()=>Tz,content_2228_930:()=>Lz,content_2228_932:()=>Nz,content_2228_934:()=>Rz,content_2228_936:()=>zz,content_2228_938:()=>Iz,content_2228_94:()=>oM,content_2228_940:()=>Fz,content_2228_942:()=>Bz,content_2228_944:()=>Oz,content_2228_946:()=>Uz,content_2228_948:()=>Vz,content_2228_950:()=>Hz,content_2228_952:()=>Yz,content_2228_954:()=>Qz,content_2228_956:()=>eA,content_2228_958:()=>oA,content_2228_96:()=>rM,content_2228_960:()=>rA,content_2228_962:()=>aA,content_2228_964:()=>cA,content_2228_966:()=>uA,content_2228_968:()=>dA,content_2228_970:()=>yA,content_2228_972:()=>kA,content_2228_974:()=>gA,content_2228_976:()=>DA,content_2228_978:()=>XA,content_2228_98:()=>aM,content_2228_980:()=>vA,content_2228_982:()=>TA,content_2228_984:()=>LA,content_2228_986:()=>NA,content_2228_988:()=>RA,content_2228_990:()=>zA,content_2228_992:()=>IA,content_2228_994:()=>FA,content_2228_996:()=>BA,content_2228_998:()=>OA});var s=n(2784),r=n(7896),i=n(30876);const a={toc:[]};function p(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Property decorators."))}p.isMDXComponent=!0;const c={toc:[]};function l(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,i.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a lazy decorator."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A function that returns the value of this property."))}h.isMDXComponent=!0;const y={toc:[]};function f(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},y,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscriptions and triggering of events."))}f.isMDXComponent=!0;const k={toc:[]};function w(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},k,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,i.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}w.isMDXComponent=!0;const g={toc:[]};function M(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}M.isMDXComponent=!0;const D={toc:[]};function _(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},D,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Dispatches an asynchronous ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,i.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}_.isMDXComponent=!0;const X={toc:[]};function x(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},X,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe all subscribers from the event."))}x.isMDXComponent=!0;const v={toc:[]};function C(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},v,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A callback function that cancels the subscription."))}C.isMDXComponent=!0;const T={toc:[]};function b(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},T,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."))}b.isMDXComponent=!0;const L={toc:[]};function Z(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},L,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}Z.isMDXComponent=!0;const N={toc:[]};function S(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},N,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}S.isMDXComponent=!0;const R={toc:[]};function E(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},R,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}E.isMDXComponent=!0;const z={toc:[]};function A(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the argument passed to subscribers."))}A.isMDXComponent=!0;const I={toc:[]};function P(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}P.isMDXComponent=!0;const F={toc:[]};function W(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},F,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Dispatches a ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,i.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}W.isMDXComponent=!0;const B={toc:[]};function G(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},B,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe all subscribers from the event."))}G.isMDXComponent=!0;const O={toc:[]};function j(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},O,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A callback function that cancels the subscription."))}j.isMDXComponent=!0;const U={toc:[]};function q(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},U,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."))}q.isMDXComponent=!0;const V={toc:[]};function $(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},V,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}$.isMDXComponent=!0;const H={toc:[]};function J(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}J.isMDXComponent=!0;const Y={toc:[]};function K(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Y,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}K.isMDXComponent=!0;const Q={toc:[]};function tt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Q,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the value argument to subscribers."))}tt.isMDXComponent=!0;const et={toc:[]};function nt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},et,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A base for dispatching ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,i.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}nt.isMDXComponent=!0;const ot={toc:[]};function st(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe all subscribers from the event."))}st.isMDXComponent=!0;const rt={toc:[]};function it(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A callback function that cancels the subscription."))}it.isMDXComponent=!0;const at={toc:[]};function pt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},at,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."))}pt.isMDXComponent=!0;const ct={toc:[]};function lt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}ht.isMDXComponent=!0;const yt={toc:[]};function ft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the argument passed to subscribers."))}ft.isMDXComponent=!0;const kt={toc:[]};function wt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the callback function."))}wt.isMDXComponent=!0;const gt={toc:[]};function Mt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,i.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,i.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}Mt.isMDXComponent=!0;const Dt={toc:[]};function _t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}_t.isMDXComponent=!0;const Xt={toc:[]};function xt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Dispatches a ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,i.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}xt.isMDXComponent=!0;const vt={toc:[]};function Ct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe all subscribers from the event."))}Ct.isMDXComponent=!0;const Tt={toc:[]};function bt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Are subscribers being notified?"))}bt.isMDXComponent=!0;const Lt={toc:[]};function Zt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Notify all current and future subscribers."))}Zt.isMDXComponent=!0;const Nt={toc:[]};function St(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Stop notifying future subscribers."))}St.isMDXComponent=!0;const Rt={toc:[]};function Et(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A callback function that cancels the subscription."))}Et.isMDXComponent=!0;const zt={toc:[]};function At(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."))}At.isMDXComponent=!0;const It={toc:[]};function Pt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},It,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}Pt.isMDXComponent=!0;const Ft={toc:[]};function Wt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}Wt.isMDXComponent=!0;const Bt={toc:[]};function Gt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}Gt.isMDXComponent=!0;const Ot={toc:[]};function jt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}jt.isMDXComponent=!0;const Ut={toc:[]};function qt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provides safe access to the public interface of ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,i.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}qt.isMDXComponent=!0;const Vt={toc:[]};function $t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A callback function that cancels the subscription."))}$t.isMDXComponent=!0;const Ht={toc:[]};function Jt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."))}Jt.isMDXComponent=!0;const Yt={toc:[]};function Kt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}Kt.isMDXComponent=!0;const Qt={toc:[]};function te(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}te.isMDXComponent=!0;const ee={toc:[]};function ne(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ee,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}ne.isMDXComponent=!0;const oe={toc:[]};function se(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the argument passed to subscribers."))}se.isMDXComponent=!0;const re={toc:[]};function ie(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},re,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the callback function."))}ie.isMDXComponent=!0;const ae={toc:[]};function pe(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ae,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}pe.isMDXComponent=!0;const ce={toc:[]};function le(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ce,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provides safe access to the public interface of ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,i.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}le.isMDXComponent=!0;const ue={toc:[]};function me(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ue,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the most recent value of this dispatcher."))}me.isMDXComponent=!0;const de={toc:[]};function he(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},de,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Callback function that cancels the subscription."))}he.isMDXComponent=!0;const ye={toc:[]};function fe(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ye,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."),(0,i.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}fe.isMDXComponent=!0;const ke={toc:[]};function we(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ke,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}we.isMDXComponent=!0;const ge={toc:[]};function Me(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ge,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Me.isMDXComponent=!0;const De={toc:[]};function _e(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},De,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Callback function that cancels the subscription."))}_e.isMDXComponent=!0;const Xe={toc:[]};function xe(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."),(0,i.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}xe.isMDXComponent=!0;const ve={toc:[]};function Ce(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ve,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}Ce.isMDXComponent=!0;const Te={toc:[]};function be(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Te,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}be.isMDXComponent=!0;const Le={toc:[]};function Ze(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Le,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the value passed to subscribers."))}Ze.isMDXComponent=!0;const Ne={toc:[]};function Se(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ne,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}Se.isMDXComponent=!0;const Re={toc:[]};function Ee(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Re,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Ee.isMDXComponent=!0;const ze={toc:[]};function Ae(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ze,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Dispatches a ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,i.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Ae.isMDXComponent=!0;const Ie={toc:[]};function Pe(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ie,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The initial value."))}Pe.isMDXComponent=!0;const Fe={toc:[]};function We(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the most recent value of this dispatcher."))}We.isMDXComponent=!0;const Be={toc:[]};function Ge(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Be,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Setting the value will immediately notify all subscribers."))}Ge.isMDXComponent=!0;const Oe={toc:[]};function je(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Set the current value of this dispatcher."))}je.isMDXComponent=!0;const Ue={toc:[]};function qe(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ue,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new value."))}qe.isMDXComponent=!0;const Ve={toc:[]};function $e(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ve,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe all subscribers from the event."))}$e.isMDXComponent=!0;const He={toc:[]};function Je(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},He,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Callback function that cancels the subscription."))}Je.isMDXComponent=!0;const Ye={toc:[]};function Ke(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ye,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."),(0,i.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ke.isMDXComponent=!0;const Qe={toc:[]};function tn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}tn.isMDXComponent=!0;const en={toc:[]};function nn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},en,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}nn.isMDXComponent=!0;const on={toc:[]};function sn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},on,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}sn.isMDXComponent=!0;const rn={toc:[]};function an(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}an.isMDXComponent=!0;const pn={toc:[]};function cn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the value passed to subscribers."))}cn.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ln,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provides safe access to the public interface of ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,i.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}dn.isMDXComponent=!0;const hn={toc:[]};function yn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the argument passed to subscribers."))}yn.isMDXComponent=!0;const fn={toc:[]};function kn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}kn.isMDXComponent=!0;const wn={toc:[]};function gn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provides safe access to the public interface of ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,i.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}gn.isMDXComponent=!0;const Mn={toc:[]};function Dn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the argument passed to subscribers."))}Dn.isMDXComponent=!0;const _n={toc:[]};function Xn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_n,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Xn.isMDXComponent=!0;const xn={toc:[]};function vn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provides safe access to the public interface of ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,i.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}vn.isMDXComponent=!0;const Cn={toc:[]};function Tn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}Tn.isMDXComponent=!0;const bn={toc:[]};function Ln(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The amount of times the timer has ticked."))}Ln.isMDXComponent=!0;const Zn={toc:[]};function Nn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The generator responsible for running this timer."))}Nn.isMDXComponent=!0;const Sn={toc:[]};function Rn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait until the timer ticks."))}Rn.isMDXComponent=!0;const En={toc:[]};function zn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},En,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The current iteration index."))}zn.isMDXComponent=!0;const An={toc:[]};function In(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},An,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}In.isMDXComponent=!0;const Pn={toc:[]};function Fn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Fn.isMDXComponent=!0;const Wn={toc:[]};function Bn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to run."))}Bn.isMDXComponent=!0;const Gn={toc:[]};function On(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}On.isMDXComponent=!0;const jn={toc:[]};function Un(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Un.isMDXComponent=!0;const qn={toc:[]};function Vn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to run."))}Vn.isMDXComponent=!0;const $n={toc:[]};function Hn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$n,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,i.kt)("p",null,"Note that the same animation can be written as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,i.kt)("p",null,"The reason ",(0,i.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}Hn.isMDXComponent=!0;const Jn={toc:[]};function Yn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Run tasks one after another."))}Yn.isMDXComponent=!0;const Kn={toc:[]};function Qn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to run."))}Qn.isMDXComponent=!0;const to={toc:[]};function eo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},to,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,i.kt)("p",null,"Note that the same animation can be written as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,i.kt)("p",null,"The reason ",(0,i.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}eo.isMDXComponent=!0;const no={toc:[]};function oo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},no,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}oo.isMDXComponent=!0;const so={toc:[]};function ro(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},so,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The delay in seconds"))}ro.isMDXComponent=!0;const io={toc:[]};function ao(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},io,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The task or callback to run after the delay."))}ao.isMDXComponent=!0;const po={toc:[]};function co(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},po,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}co.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Call the given callback every N seconds."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The interval between subsequent calls."))}ho.isMDXComponent=!0;const yo={toc:[]};function fo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The callback to be called."))}fo.isMDXComponent=!0;const ko={toc:[]};function wo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ko,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Each time iteration waits until the previous one is completed."))}wo.isMDXComponent=!0;const go={toc:[]};function Mo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},go,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n});\n")))}Mo.isMDXComponent=!0;const Do={toc:[]};function _o(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Do,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Run the given generator N times."))}_o.isMDXComponent=!0;const Xo={toc:[]};function xo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The number of iterations."))}xo.isMDXComponent=!0;const vo={toc:[]};function Co(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each iteration."))}Co.isMDXComponent=!0;const To={toc:[]};function bo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},To,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Do nothing."))}bo.isMDXComponent=!0;const Lo={toc:[]};function Zo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Zo.isMDXComponent=!0;const No={toc:[]};function So(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},No,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Turn the given generator function into a threadable generator."))}So.isMDXComponent=!0;const Ro={toc:[]};function Eo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ro,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A generator function or a factory that creates the generator."))}Eo.isMDXComponent=!0;const zo={toc:[]};function Ao(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Ao.isMDXComponent=!0;const Io={toc:[]};function Po(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Io,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Turn the given generator function into a threadable generator."))}Po.isMDXComponent=!0;const Fo={toc:[]};function Wo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An optional name used when displaying this generator in the UI."))}Wo.isMDXComponent=!0;const Bo={toc:[]};function Go(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A generator function or a factory that creates the generator."))}Go.isMDXComponent=!0;const Oo={toc:[]};function jo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}jo.isMDXComponent=!0;const Uo={toc:[]};function qo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}qo.isMDXComponent=!0;const Vo={toc:[]};function $o(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Start all tasks one after another with a constant delay between."))}$o.isMDXComponent=!0;const Ho={toc:[]};function Jo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ho,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The delay between each of the tasks."))}Jo.isMDXComponent=!0;const Yo={toc:[]};function Ko(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to be run in a sequence."))}Ko.isMDXComponent=!0;const Qo={toc:[]};function ts(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}ts.isMDXComponent=!0;const es={toc:[]};function ns(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},es,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for the given amount of time."))}ns.isMDXComponent=!0;const os={toc:[]};function ss(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},os,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The relative time in seconds."))}ss.isMDXComponent=!0;const rs={toc:[]};function is(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An optional task to be run after the function completes."))}is.isMDXComponent=!0;const as={toc:[]};function ps(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},as,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}ps.isMDXComponent=!0;const cs={toc:[]};function ls(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},us,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait until the given time event."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ds,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The name of the time event."))}hs.isMDXComponent=!0;const ys={toc:[]};function fs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ys,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An optional task to be run after the function completes."))}fs.isMDXComponent=!0;const ks={toc:[]};function ws(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ks,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Multi-media management."))}ws.isMDXComponent=!0;const gs={toc:[]};function Ms(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Ms.isMDXComponent=!0;const Ds={toc:[]};function _s(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ds,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Pause/resume the audio."))}_s.isMDXComponent=!0;const Xs={toc:[]};function xs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the audio should be paused or resumed."))}xs.isMDXComponent=!0;const vs={toc:[]};function Cs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The absolute biggest value from the peaks array."))}Cs.isMDXComponent=!0;const Ts={toc:[]};function bs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ts,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The amount of samples taken."))}bs.isMDXComponent=!0;const Ls={toc:[]};function Zs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ls,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Zs.isMDXComponent=!0;const Ns={toc:[]};function Ss(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ns,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Samples per seconds."))}Ss.isMDXComponent=!0;const Rs={toc:[]};function Es(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Abstract scene representations and related utilities."))}Es.isMDXComponent=!0;const zs={toc:[]};function As(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Signifies the various stages of a ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,i.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}As.isMDXComponent=!0;const Is={toc:[]};function Ps(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Is,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Occurs after a render ends."))}Ps.isMDXComponent=!0;const Fs={toc:[]};function Ws(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}Ws.isMDXComponent=!0;const Bs={toc:[]};function Gs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,i.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}Gs.isMDXComponent=!0;const Os={toc:[]};function js(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Os,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,i.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}js.isMDXComponent=!0;const Us={toc:[]};function qs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Us,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Describes the state of a scene."))}qs.isMDXComponent=!0;const Vs={toc:[]};function $s(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}$s.isMDXComponent=!0;const Hs={toc:[]};function Js(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene has finished transitioning in."))}Js.isMDXComponent=!0;const Ys={toc:[]};function Ks(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ys,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,i.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,i.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}Ks.isMDXComponent=!0;const Qs={toc:[]};function tr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene is ready to transition out."))}tr.isMDXComponent=!0;const er={toc:[]};function nr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},er,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Invoking ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,i.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}nr.isMDXComponent=!0;const or={toc:[]};function sr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},or,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene has finished."))}sr.isMDXComponent=!0;const rr={toc:[]};function ir(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene has just been created/reset."))}ir.isMDXComponent=!0;const ar={toc:[]};function pr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ar,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The default implementation of the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,i.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,i.kt)("p",null,"Uses generators to control the animation."))}pr.isMDXComponent=!0;const cr={toc:[]};function lr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will be passed as the second argument to the constructor."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ur,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Name of the scene."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reference to the project."))}hr.isMDXComponent=!0;const yr={toc:[]};function fr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,i.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}fr.isMDXComponent=!0;const kr={toc:[]};function wr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,i.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}wr.isMDXComponent=!0;const gr={toc:[]};function Mr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The frame at which this scene starts."))}Mr.isMDXComponent=!0;const Dr={toc:[]};function _r(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The frame at which this scene ends."))}_r.isMDXComponent=!0;const Xr={toc:[]};function xr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the cached data changes."))}xr.isMDXComponent=!0;const vr={toc:[]};function Cr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered after scene is recalculated."))}Cr.isMDXComponent=!0;const Tr={toc:[]};function br(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the scene is reloaded."))}br.isMDXComponent=!0;const Lr={toc:[]};function Zr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Zr.isMDXComponent=!0;const Nr={toc:[]};function Sr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the scene is reset."))}Sr.isMDXComponent=!0;const Rr={toc:[]};function Er(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the main thread changes."))}Er.isMDXComponent=!0;const zr={toc:[]};function Ar(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Ar.isMDXComponent=!0;const Ir={toc:[]};function Pr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ir,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,i.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Pr.isMDXComponent=!0;const Fr={toc:[]};function Wr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,i.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Wr.isMDXComponent=!0;const Br={toc:[]};function Gr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Br,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,i.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}Gr.isMDXComponent=!0;const Or={toc:[]};function jr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Or,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,i.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}jr.isMDXComponent=!0;const Ur={toc:[]};function qr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ur,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}qr.isMDXComponent=!0;const Vr={toc:[]};function $r(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Invoke the given callback in the context of this scene."))}$r.isMDXComponent=!0;const Hr={toc:[]};function Jr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The callback to invoke."))}Jr.isMDXComponent=!0;const Yr={toc:[]};function Kr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the size of this scene."),(0,i.kt)("p",null,"Usually return ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}Kr.isMDXComponent=!0;const Qr={toc:[]};function ti(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,i.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}ti.isMDXComponent=!0;const ei={toc:[]};function ni(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ei,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene cached?"),(0,i.kt)("p",null,"Used only by ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,i.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,i.kt)("p",null,"Should always return ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}ni.isMDXComponent=!0;const oi={toc:[]};function si(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,i.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}si.isMDXComponent=!0;const ri={toc:[]};function ii(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ri,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Progress this scene one frame forward."))}ii.isMDXComponent=!0;const ai={toc:[]};function pi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ai,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,i.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,i.kt)("p",null,"At the end of execution, this method should set ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,i.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,i.kt)("p",null,"Should trigger ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,i.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}pi.isMDXComponent=!0;const ci={toc:[]};function li(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ci,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Recalculate the scene."))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ui,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,i.kt)("p",null,"Should trigger ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,i.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},di,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reload the scene."))}hi.isMDXComponent=!0;const yi={toc:[]};function fi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If present, an updated version of the description."))}fi.isMDXComponent=!0;const ki={toc:[]};function wi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ki,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render the scene onto a canvas."))}wi.isMDXComponent=!0;const gi={toc:[]};function Mi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to used when rendering."))}Mi.isMDXComponent=!0;const Di={toc:[]};function _i(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Di,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset this scene to its initial state."))}_i.isMDXComponent=!0;const Xi={toc:[]};function xi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If present, the previous scene."))}xi.isMDXComponent=!0;const vi={toc:[]};function Ci(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the view."),(0,i.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,i.kt)("p",null,"Can modify the state of the view."))}Ci.isMDXComponent=!0;const Ti={toc:[]};function bi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ti,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Lifecycle events for ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,i.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}bi.isMDXComponent=!0;const Li={toc:[]};function Zi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Li,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A random number generator based on\n",(0,i.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,i.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Zi.isMDXComponent=!0;const Ni={toc:[]};function Si(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ni,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get an array filled with random floats in the given range."))}Si.isMDXComponent=!0;const Ri={toc:[]};function Ei(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ri,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The size of the array."))}Ei.isMDXComponent=!0;const zi={toc:[]};function Ai(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."))}Ai.isMDXComponent=!0;const Ii={toc:[]};function Pi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ii,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range."))}Pi.isMDXComponent=!0;const Fi={toc:[]};function Wi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get an array filled with random integers in the given range."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"}),(0,i.kt)("li",{parentName:"ul"})))}Wi.isMDXComponent=!0;const Bi={toc:[]};function Gi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The size of the array."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"})))}Gi.isMDXComponent=!0;const Oi={toc:[]};function ji(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"})))}ji.isMDXComponent=!0;const Ui={toc:[]};function qi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ui,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range. Exclusive."))}qi.isMDXComponent=!0;const Vi={toc:[]};function $i(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the next random float in the given range."))}$i.isMDXComponent=!0;const Hi={toc:[]};function Ji(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."))}Ji.isMDXComponent=!0;const Yi={toc:[]};function Ki(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range."))}Ki.isMDXComponent=!0;const Qi={toc:[]};function ta(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the next random integer in the given range."))}ta.isMDXComponent=!0;const ea={toc:[]};function na(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ea,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."))}na.isMDXComponent=!0;const oa={toc:[]};function sa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range. Exclusive."))}sa.isMDXComponent=!0;const ra={toc:[]};function ia(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ra,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a new independent generator."))}ia.isMDXComponent=!0;const aa={toc:[]};function pa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get variable signal if exists or create signal if not"))}pa.isMDXComponent=!0;const ca={toc:[]};function la(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ca,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The name of the variable."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ua,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},da,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get variable signal if exists or create signal if not"))}ha.isMDXComponent=!0;const ya={toc:[]};function fa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ya,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset all stored signals."))}fa.isMDXComponent=!0;const ka={toc:[]};function wa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ka,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update all signals with new project variable values."))}wa.isMDXComponent=!0;const ga={toc:[]};function Ma(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ga,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Describes cached information about the timing of a scene."))}Ma.isMDXComponent=!0;const Da={toc:[]};function _a(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Da,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Describes a complete scene together with the meta file."))}_a.isMDXComponent=!0;const Xa={toc:[]};function xa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Configuration object."))}xa.isMDXComponent=!0;const va={toc:[]};function Ca(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},va,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The class used to instantiate the scene."))}Ca.isMDXComponent=!0;const Ta={toc:[]};function ba(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ta,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The stack trace at the moment of creation."))}ba.isMDXComponent=!0;const La={toc:[]};function Za(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},La,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the configuration object."))}Za.isMDXComponent=!0;const Na={toc:[]};function Sa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Na,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Sa.isMDXComponent=!0;const Ra={toc:[]};function Ea(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ra,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}Ea.isMDXComponent=!0;const za={toc:[]};function Aa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},za,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for the inspected element."))}Aa.isMDXComponent=!0;const Ia={toc:[]};function Pa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ia,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The element for which to draw an overlay."))}Pa.isMDXComponent=!0;const Fa={toc:[]};function Wa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}Wa.isMDXComponent=!0;const Ba={toc:[]};function Ga(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ba,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Ga.isMDXComponent=!0;const Oa={toc:[]};function ja(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}ja.isMDXComponent=!0;const Ua={toc:[]};function qa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ua,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the attributes of the inspected element."))}qa.isMDXComponent=!0;const Va={toc:[]};function $a(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Va,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The element to inspect."))}$a.isMDXComponent=!0;const Ha={toc:[]};function Ja(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ha,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a possible element to inspect at a given position."))}Ja.isMDXComponent=!0;const Ya={toc:[]};function Ka(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ya,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The x coordinate."))}Ka.isMDXComponent=!0;const Qa={toc:[]};function tp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The y coordinate."))}tp.isMDXComponent=!0;const ep={toc:[]};function np(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ep,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}np.isMDXComponent=!0;const op={toc:[]};function sp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},op,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the inspected element is still valid."))}sp.isMDXComponent=!0;const rp={toc:[]};function ip(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The element to validate."))}ip.isMDXComponent=!0;const ap={toc:[]};function pp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ap,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,i.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}pp.isMDXComponent=!0;const cp={toc:[]};function lp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The main interface for scenes."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},up,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will be passed as the second argument to the constructor."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Name of the scene."))}hp.isMDXComponent=!0;const yp={toc:[]};function fp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reference to the project."))}fp.isMDXComponent=!0;const kp={toc:[]};function wp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,i.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}wp.isMDXComponent=!0;const gp={toc:[]};function Mp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,i.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Mp.isMDXComponent=!0;const Dp={toc:[]};function _p(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The frame at which this scene starts."))}_p.isMDXComponent=!0;const Xp={toc:[]};function xp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The frame at which this scene ends."))}xp.isMDXComponent=!0;const vp={toc:[]};function Cp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,i.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Cp.isMDXComponent=!0;const Tp={toc:[]};function bp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the cached data changes."))}bp.isMDXComponent=!0;const Lp={toc:[]};function Zp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered after scene is recalculated."))}Zp.isMDXComponent=!0;const Np={toc:[]};function Sp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Np,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the scene is reloaded."))}Sp.isMDXComponent=!0;const Rp={toc:[]};function Ep(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Ep.isMDXComponent=!0;const zp={toc:[]};function Ap(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the scene is reset."))}Ap.isMDXComponent=!0;const Ip={toc:[]};function Pp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ip,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Pp.isMDXComponent=!0;const Fp={toc:[]};function Wp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,i.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Wp.isMDXComponent=!0;const Bp={toc:[]};function Gp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,i.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Gp.isMDXComponent=!0;const Op={toc:[]};function jp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Op,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,i.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}jp.isMDXComponent=!0;const Up={toc:[]};function qp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Up,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,i.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}qp.isMDXComponent=!0;const Vp={toc:[]};function $p(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the size of this scene."),(0,i.kt)("p",null,"Usually return ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}$p.isMDXComponent=!0;const Hp={toc:[]};function Jp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,i.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}Jp.isMDXComponent=!0;const Yp={toc:[]};function Kp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene cached?"),(0,i.kt)("p",null,"Used only by ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,i.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,i.kt)("p",null,"Should always return ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}Kp.isMDXComponent=!0;const Qp={toc:[]};function tc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,i.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}tc.isMDXComponent=!0;const ec={toc:[]};function nc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ec,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Progress this scene one frame forward."))}nc.isMDXComponent=!0;const oc={toc:[]};function sc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,i.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,i.kt)("p",null,"At the end of execution, this method should set ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,i.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,i.kt)("p",null,"Should trigger ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,i.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}sc.isMDXComponent=!0;const rc={toc:[]};function ic(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Recalculate the scene."))}ic.isMDXComponent=!0;const ac={toc:[]};function pc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ac,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,i.kt)("p",null,"Should trigger ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,i.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}pc.isMDXComponent=!0;const cc={toc:[]};function lc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reload the scene."))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If present, an updated version of the description."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render the scene onto a canvas."))}hc.isMDXComponent=!0;const yc={toc:[]};function fc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to used when rendering."))}fc.isMDXComponent=!0;const kc={toc:[]};function wc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset this scene to its initial state."))}wc.isMDXComponent=!0;const gc={toc:[]};function Mc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If present, the previous scene."))}Mc.isMDXComponent=!0;const Dc={toc:[]};function _c(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the configuration object."))}_c.isMDXComponent=!0;const Xc={toc:[]};function xc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Each class implementing the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,i.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}xc.isMDXComponent=!0;const vc={toc:[]};function Cc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constructor used when creating new scenes."))}Cc.isMDXComponent=!0;const Tc={toc:[]};function bc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,i.kt)("inlineCode",{parentName:"a"},"config")),"."))}bc.isMDXComponent=!0;const Lc={toc:[]};function Zc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Describes a scene exposed by scene files."))}Zc.isMDXComponent=!0;const Nc={toc:[]};function Sc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Configuration object."))}Sc.isMDXComponent=!0;const Rc={toc:[]};function Ec(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The class used to instantiate the scene."))}Ec.isMDXComponent=!0;const zc={toc:[]};function Ac(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The stack trace at the moment of creation."))}Ac.isMDXComponent=!0;const Ic={toc:[]};function Pc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ic,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the configuration object."))}Pc.isMDXComponent=!0;const Fc={toc:[]};function Wc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A part of the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,i.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}Wc.isMDXComponent=!0;const Bc={toc:[]};function Gc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the configuration object."))}Gc.isMDXComponent=!0;const Oc={toc:[]};function jc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}jc.isMDXComponent=!0;const Uc={toc:[]};function qc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}qc.isMDXComponent=!0;const Vc={toc:[]};function $c(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the main thread changes."))}$c.isMDXComponent=!0;const Hc={toc:[]};function Jc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents attributes of an inspected element."))}Jc.isMDXComponent=!0;const Yc={toc:[]};function Kc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}Kc.isMDXComponent=!0;const Qc={toc:[]};function tl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents an element to inspect."))}tl.isMDXComponent=!0;const el={toc:[]};function nl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},el,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A runtime representation of the scene metadata."))}nl.isMDXComponent=!0;const ol={toc:[]};function sl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ol,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a runtime representation of the scene metadata."))}sl.isMDXComponent=!0;const rl={toc:[]};function il(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}il.isMDXComponent=!0;const al={toc:[]};function pl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},al,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}pl.isMDXComponent=!0;const cl={toc:[]};function ll(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the signal is currently using its initial value."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ul,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,i.kt)("p",null,"This method can be used to create copies of signals."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}hl.isMDXComponent=!0;const yl={toc:[]};function fl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the raw value of this signal."))}fl.isMDXComponent=!0;const kl={toc:[]};function wl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}wl.isMDXComponent=!0;const gl={toc:[]};function Ml(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Ml.isMDXComponent=!0;const Dl={toc:[]};function _l(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}_l.isMDXComponent=!0;const Xl={toc:[]};function xl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}xl.isMDXComponent=!0;const vl={toc:[]};function Cl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Cl.isMDXComponent=!0;const Tl={toc:[]};function bl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}bl.isMDXComponent=!0;const Ll={toc:[]};function Zl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ll,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the signal is currently using its initial value."))}Zl.isMDXComponent=!0;const Nl={toc:[]};function Sl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,i.kt)("p",null,"This method can be used to create copies of signals."))}Sl.isMDXComponent=!0;const Rl={toc:[]};function El(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}El.isMDXComponent=!0;const zl={toc:[]};function Al(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the raw value of this signal."))}Al.isMDXComponent=!0;const Il={toc:[]};function Pl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Il,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Pl.isMDXComponent=!0;const Fl={toc:[]};function Wl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Wl.isMDXComponent=!0;const Bl={toc:[]};function Gl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Gl.isMDXComponent=!0;const Ol={toc:[]};function jl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ol,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}jl.isMDXComponent=!0;const Ul={toc:[]};function ql(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ul,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Compute the current value of the signal and immediately set it."))}ql.isMDXComponent=!0;const Vl={toc:[]};function $l(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the signal is currently using its initial value."))}$l.isMDXComponent=!0;const Hl={toc:[]};function Jl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Jl.isMDXComponent=!0;const Yl={toc:[]};function Kl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Kl.isMDXComponent=!0;const Ql={toc:[]};function tu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ql,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Compute the current value of the signal and immediately set it."))}tu.isMDXComponent=!0;const eu={toc:[]};function nu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Thread management."))}nu.isMDXComponent=!0;const ou={toc:[]};function su(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ou,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,i.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}su.isMDXComponent=!0;const ru={toc:[]};function iu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ru,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A class representing an individual thread."))}iu.isMDXComponent=!0;const au={toc:[]};function pu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},au,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The generator wrapped by this thread."))}pu.isMDXComponent=!0;const cu={toc:[]};function lu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The generator wrapped by this thread."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Used by ",(0,i.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,i.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},du,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The current time of this thread."))}hu.isMDXComponent=!0;const yu={toc:[]};function fu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The next value to be passed to the wrapped generator."))}fu.isMDXComponent=!0;const ku={toc:[]};function wu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ku,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}wu.isMDXComponent=!0;const gu={toc:[]};function Mu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,i.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,i.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}Mu.isMDXComponent=!0;const Du={toc:[]};function _u(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Du,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The fixed time of this thread."))}_u.isMDXComponent=!0;const Xu={toc:[]};function xu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Progress the wrapped generator once."))}xu.isMDXComponent=!0;const vu={toc:[]};function Cu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the thread for the next update cycle."))}Cu.isMDXComponent=!0;const Tu={toc:[]};function bu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The delta time of the next cycle."))}bu.isMDXComponent=!0;const Lu={toc:[]};function Zu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A generator function or a normal function that returns a generator."))}Zu.isMDXComponent=!0;const Nu={toc:[]};function Su(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,i.kt)("p",null,"Progress to the next frame:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,i.kt)("p",null,"Run another generator synchronously:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,i.kt)("p",null,"Run another generator concurrently:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,i.kt)("p",null,"Await a Promise:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}Su.isMDXComponent=!0;const Ru={toc:[]};function Eu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ru,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}Eu.isMDXComponent=!0;const zu={toc:[]};function Au(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Cancel all listed tasks."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Au.isMDXComponent=!0;const Iu={toc:[]};function Pu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to cancel."))}Pu.isMDXComponent=!0;const Fu={toc:[]};function Wu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}Wu.isMDXComponent=!0;const Bu={toc:[]};function Gu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A possible ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}Gu.isMDXComponent=!0;const Ou={toc:[]};function ju(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ou,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the given value is a ",(0,i.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,i.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}ju.isMDXComponent=!0;const Uu={toc:[]};function qu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A possible thread ",(0,i.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,i.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}qu.isMDXComponent=!0;const Vu={toc:[]};function $u(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}$u.isMDXComponent=!0;const Hu={toc:[]};function Ju(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}Ju.isMDXComponent=!0;const Yu={toc:[]};function Ku(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to join."))}Ku.isMDXComponent=!0;const Qu={toc:[]};function tm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}tm.isMDXComponent=!0;const em={toc:[]};function nm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},em,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Pause the current generator until listed tasks are finished."))}nm.isMDXComponent=!0;const om={toc:[]};function sm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},om,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}sm.isMDXComponent=!0;const rm={toc:[]};function im(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to join."))}im.isMDXComponent=!0;const am={toc:[]};function pm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},am,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"From the perspective of the external generator, ",(0,i.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,i.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}pm.isMDXComponent=!0;const cm={toc:[]};function lm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},um,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a context in which generators can be run concurrently."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A function that returns the generator to run."))}hm.isMDXComponent=!0;const ym={toc:[]};function fm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ym,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}fm.isMDXComponent=!0;const km={toc:[]};function wm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},km,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Transitions between scenes."))}wm.isMDXComponent=!0;const gm={toc:[]};function Mm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Perform a transition that fades between the scenes."))}Mm.isMDXComponent=!0;const Dm={toc:[]};function _m(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition."))}_m.isMDXComponent=!0;const Xm={toc:[]};function xm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}xm.isMDXComponent=!0;const vm={toc:[]};function Cm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The direction in which to slide."))}Cm.isMDXComponent=!0;const Tm={toc:[]};function bm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition."))}bm.isMDXComponent=!0;const Lm={toc:[]};function Zm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}Zm.isMDXComponent=!0;const Nm={toc:[]};function Sm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The callback to use before the current scene is rendered."))}Sm.isMDXComponent=!0;const Rm={toc:[]};function Em(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The callback to use before the previous scene is rendered."))}Em.isMDXComponent=!0;const zm={toc:[]};function Am(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}Am.isMDXComponent=!0;const Im={toc:[]};function Pm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Im,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The area on which to zoom in."))}Pm.isMDXComponent=!0;const Fm={toc:[]};function Wm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition."))}Wm.isMDXComponent=!0;const Bm={toc:[]};function Gm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}Gm.isMDXComponent=!0;const Om={toc:[]};function jm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Om,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The area from which to zoom out."))}jm.isMDXComponent=!0;const Um={toc:[]};function qm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Um,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition."))}qm.isMDXComponent=!0;const Vm={toc:[]};function $m(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Interpolation and timing of tweens."))}$m.isMDXComponent=!0;const Hm={toc:[]};function Jm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Any old key that is missing in ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"})))}Jm.isMDXComponent=!0;const Ym={toc:[]};function Km(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ym,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A value matching the structure of from and to."))}Km.isMDXComponent=!0;const Qm={toc:[]};function td(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}td.isMDXComponent=!0;const ed={toc:[]};function nd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ed,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The input to favor when value is 0."))}nd.isMDXComponent=!0;const od={toc:[]};function sd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},od,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The input to favor when value is 1."))}sd.isMDXComponent=!0;const rd={toc:[]};function id(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}id.isMDXComponent=!0;const ad={toc:[]};function pd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ad,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A value matching the structure of from and to."))}pd.isMDXComponent=!0;const cd={toc:[]};function ld(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ud,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The input to favor when value is 0."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The input to favor when value is 1."))}hd.isMDXComponent=!0;const yd={toc:[]};function fd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}fd.isMDXComponent=!0;const kd={toc:[]};function wd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Complex types used in animations."))}wd.isMDXComponent=!0;const gd={toc:[]};function Md(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,i.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,i.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,i.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,i.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,i.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,i.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}Md.isMDXComponent=!0;const Dd={toc:[]};function _d(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the determinant of the matrix."))}_d.isMDXComponent=!0;const Xd={toc:[]};function xd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}xd.isMDXComponent=!0;const vd={toc:[]};function Cd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}Cd.isMDXComponent=!0;const Td={toc:[]};function bd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Td,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the inverse of the matrix."))}bd.isMDXComponent=!0;const Ld={toc:[]};function Zd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ld,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Zd.isMDXComponent=!0;const Nd={toc:[]};function Sd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}Sd.isMDXComponent=!0;const Rd={toc:[]};function Ed(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the provided matrix to this matrix."))}Ed.isMDXComponent=!0;const zd={toc:[]};function Ad(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The matrix to add"))}Ad.isMDXComponent=!0;const Id={toc:[]};function Pd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Id,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}Pd.isMDXComponent=!0;const Fd={toc:[]};function Wd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}Wd.isMDXComponent=!0;const Bd={toc:[]};function Gd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index of the component vector to retrieve."))}Gd.isMDXComponent=!0;const Od={toc:[]};function jd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Od,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}jd.isMDXComponent=!0;const Ud={toc:[]};function qd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ud,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}qd.isMDXComponent=!0;const Vd={toc:[]};function $d(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}$d.isMDXComponent=!0;const Hd={toc:[]};function Jd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The matrix to multiply with"))}Jd.isMDXComponent=!0;const Yd={toc:[]};function Kd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}Kd.isMDXComponent=!0;const Qd={toc:[]};function th(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"})))}th.isMDXComponent=!0;const eh={toc:[]};function nh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value by which to scale each term"))}nh.isMDXComponent=!0;const oh={toc:[]};function sh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}sh.isMDXComponent=!0;const rh={toc:[]};function ih(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}ih.isMDXComponent=!0;const ah={toc:[]};function ph(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ah,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}ph.isMDXComponent=!0;const ch={toc:[]};function lh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ch,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The angle by which to rotate the matrix"))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}hh.isMDXComponent=!0;const yh={toc:[]};function fh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index of the row to retrieve."))}fh.isMDXComponent=!0;const kh={toc:[]};function wh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}wh.isMDXComponent=!0;const gh={toc:[]};function Mh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}Mh.isMDXComponent=!0;const Dh={toc:[]};function _h(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Scale the x and y component vectors of the matrix."))}_h.isMDXComponent=!0;const Xh={toc:[]};function xh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The factor by which to scale the matrix"))}xh.isMDXComponent=!0;const vh={toc:[]};function Ch(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Ch.isMDXComponent=!0;const Th={toc:[]};function bh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Th,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}bh.isMDXComponent=!0;const Lh={toc:[]};function Zh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subtract the provided matrix from this matrix."))}Zh.isMDXComponent=!0;const Nh={toc:[]};function Sh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The matrix to subract"))}Sh.isMDXComponent=!0;const Rh={toc:[]};function Eh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Eh.isMDXComponent=!0;const zh={toc:[]};function Ah(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}Ah.isMDXComponent=!0;const Ih={toc:[]};function Ph(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ih,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}Ph.isMDXComponent=!0;const Fh={toc:[]};function Wh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The vector by which to translate the matrix"))}Wh.isMDXComponent=!0;const Bh={toc:[]};function Gh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents a two-dimensional vector."))}Gh.isMDXComponent=!0;const Oh={toc:[]};function jh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}jh.isMDXComponent=!0;const Uh={toc:[]};function qh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The unclipped RGB components."))}qh.isMDXComponent=!0;const Vh={toc:[]};function $h(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}$h.isMDXComponent=!0;const Hh={toc:[]};function Jh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}Jh.isMDXComponent=!0;const Yh={toc:[]};function Kh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Kh.isMDXComponent=!0;const Qh={toc:[]};function ty(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}ty.isMDXComponent=!0;const ey={toc:[]};function ny(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ey,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}ny.isMDXComponent=!0;const oy={toc:[]};function sy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}sy.isMDXComponent=!0;const ry={toc:[]};function iy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ry,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}iy.isMDXComponent=!0;const ay={toc:[]};function py(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ay,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Alias of ",(0,i.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}py.isMDXComponent=!0;const cy={toc:[]};function ly(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}ly.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the ",(0,i.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}hy.isMDXComponent=!0;const yy={toc:[]};function fy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the ",(0,i.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,i.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,i.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}fy.isMDXComponent=!0;const ky={toc:[]};function wy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ky,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}wy.isMDXComponent=!0;const gy={toc:[]};function My(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the ",(0,i.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,i.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,i.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}My.isMDXComponent=!0;const Dy={toc:[]};function _y(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}_y.isMDXComponent=!0;const Xy={toc:[]};function xy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the ",(0,i.kt)("strong",{parentName:"p"},"L"),", ",(0,i.kt)("strong",{parentName:"p"},"a"),", and ",(0,i.kt)("strong",{parentName:"p"},"b")," components."))}xy.isMDXComponent=!0;const vy={toc:[]};function Cy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}Cy.isMDXComponent=!0;const Ty={toc:[]};function by(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ty,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the ",(0,i.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,i.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,i.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}by.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ly,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}Zy.isMDXComponent=!0;const Ny={toc:[]};function Sy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ny,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}Sy.isMDXComponent=!0;const Ry={toc:[]};function Ey(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ry,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Ey.isMDXComponent=!0;const zy={toc:[]};function Ay(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}Ay.isMDXComponent=!0;const Iy={toc:[]};function Py(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get and set the color opacity."))}Py.isMDXComponent=!0;const Fy={toc:[]};function Wy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,i.kt)("code",null,"'rgb'")))}Wy.isMDXComponent=!0;const By={toc:[]};function Gy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},By,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Similar to saturate, but the opposite direction."))}Gy.isMDXComponent=!0;const Oy={toc:[]};function jy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"set"))}jy.isMDXComponent=!0;const Uy={toc:[]};function qy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns a single channel value.\nAlso"))}qy.isMDXComponent=!0;const Vy={toc:[]};function $y(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}$y.isMDXComponent=!0;const Hy={toc:[]};function Jy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color as hexadecimal string."))}Jy.isMDXComponent=!0;const Yy={toc:[]};function Ky(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,i.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,i.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}Ky.isMDXComponent=!0;const Qy={toc:[]};function tf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,i.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}tf.isMDXComponent=!0;const ef={toc:[]};function nf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ef,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}nf.isMDXComponent=!0;const of={toc:[]};function sf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},of,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}sf.isMDXComponent=!0;const rf={toc:[]};function af(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}af.isMDXComponent=!0;const pf={toc:[]};function cf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}cf.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}df.isMDXComponent=!0;const hf={toc:[]};function yf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}yf.isMDXComponent=!0;const ff={toc:[]};function kf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ff,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}kf.isMDXComponent=!0;const wf={toc:[]};function gf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}gf.isMDXComponent=!0;const Mf={toc:[]};function Df(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}Df.isMDXComponent=!0;const _f={toc:[]};function Xf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_f,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Convert the given origin to a vector representing its offset."))}Xf.isMDXComponent=!0;const xf={toc:[]};function vf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The origin to convert."))}vf.isMDXComponent=!0;const Cf={toc:[]};function Tf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"General utilities and helper functions."))}Tf.isMDXComponent=!0;const bf={toc:[]};function Lf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}Lf.isMDXComponent=!0;const Zf={toc:[]};function Nf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Optional override for formatting stack traces"))}Nf.isMDXComponent=!0;const Sf={toc:[]};function Rf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create .stack property on a target object"))}Rf.isMDXComponent=!0;const Ef={toc:[]};function zf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ef,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is a shortcut for calling ",(0,i.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}zf.isMDXComponent=!0;const Af={toc:[]};function If(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Af,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}If.isMDXComponent=!0;const Pf={toc:[]};function Ff(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Logs a debug message with an arbitrary payload."))}Ff.isMDXComponent=!0;const Wf={toc:[]};function Bf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The payload to log"))}Bf.isMDXComponent=!0;const Gf={toc:[]};function Of(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Mark the given function as deprecated."))}Of.isMDXComponent=!0;const jf={toc:[]};function Uf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The function to deprecate."))}Uf.isMDXComponent=!0;const qf={toc:[]};function Vf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The log message."))}Vf.isMDXComponent=!0;const $f={toc:[]};function Hf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$f,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The optional log remarks."))}Hf.isMDXComponent=!0;const Jf={toc:[]};function Yf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}Yf.isMDXComponent=!0;const Kf={toc:[]};function Qf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Mark the current scene as ready to transition out."))}Qf.isMDXComponent=!0;const tk={toc:[]};function ek(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}ek.isMDXComponent=!0;const nk={toc:[]};function ok(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,i.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}ok.isMDXComponent=!0;const sk={toc:[]};function rk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}rk.isMDXComponent=!0;const ik={toc:[]};function ak(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ik,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an array containing a range of numbers."))}ak.isMDXComponent=!0;const pk={toc:[]};function ck(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The length of the array."))}ck.isMDXComponent=!0;const lk={toc:[]};function uk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}uk.isMDXComponent=!0;const mk={toc:[]};function dk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an array containing a range of numbers."))}dk.isMDXComponent=!0;const hk={toc:[]};function yk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."))}yk.isMDXComponent=!0;const fk={toc:[]};function kk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range. ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}kk.isMDXComponent=!0;const wk={toc:[]};function gk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}gk.isMDXComponent=!0;const Mk={toc:[]};function Dk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an array containing a range of numbers."))}Dk.isMDXComponent=!0;const _k={toc:[]};function Xk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_k,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."))}Xk.isMDXComponent=!0;const xk={toc:[]};function vk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range. ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}vk.isMDXComponent=!0;const Ck={toc:[]};function Tk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ck,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value by which to increment or decrement."))}Tk.isMDXComponent=!0;const bk={toc:[]};function Lk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}Lk.isMDXComponent=!0;const Zk={toc:[]};function Nk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The function that will be provided the context before render."))}Nk.isMDXComponent=!0;const Sk={toc:[]};function Rk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}Rk.isMDXComponent=!0;const Ek={toc:[]};function zk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ek,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The function that will be provided the context after render."))}zk.isMDXComponent=!0;const Ak={toc:[]};function Ik(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ak,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}Ik.isMDXComponent=!0;const Pk={toc:[]};function Fk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}Fk.isMDXComponent=!0;const Wk={toc:[]};function Bk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the event in seconds."))}Bk.isMDXComponent=!0;const Gk={toc:[]};function Ok(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Register a time event and get its duration in seconds."))}Ok.isMDXComponent=!0;const jk={toc:[]};function Uk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The name of the event."))}Uk.isMDXComponent=!0;const qk={toc:[]};function Vk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a reference to the playback status."))}Vk.isMDXComponent=!0;const $k={toc:[]};function Hk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$k,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the random number generator for the current scene."))}Hk.isMDXComponent=!0;const Jk={toc:[]};function Yk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the random number generator for the given seed."))}Yk.isMDXComponent=!0;const Kk={toc:[]};function Qk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The seed for the generator."))}Qk.isMDXComponent=!0;const tw={toc:[]};function ew(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}ew.isMDXComponent=!0;const nw={toc:[]};function ow(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a reference to the current scene."))}ow.isMDXComponent=!0;const sw={toc:[]};function rw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a reference to the current thread."))}rw.isMDXComponent=!0;const iw={toc:[]};function aw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,i.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}aw.isMDXComponent=!0;const pw={toc:[]};function cw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}cw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the real time since the start of the animation."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This rewrites a remote url like ",(0,i.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,i.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}dw.isMDXComponent=!0;const hw={toc:[]};function yw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Route the given url through a local proxy."))}yw.isMDXComponent=!0;const fw={toc:[]};function kw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}kw.isMDXComponent=!0;const ww={toc:[]};function gw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ww,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A simple circle:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n/>\n")),(0,i.kt)("p",null,"An ellipse:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  width={300}\n  height={100}\n  fill={'lightseagreen'}\n/>\n")),(0,i.kt)("p",null,"A sector (pie chart):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  startAngle={30}\n  endAngle={270}\n  closed={true}\n/>\n")),(0,i.kt)("p",null,"An arc:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  startAngle={-90}\n  endAngle={90}\n/>\n")))}gw.isMDXComponent=!0;const Mw={toc:[]};function Dw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node for drawing circular shapes."))}Dw.isMDXComponent=!0;const _w={toc:[]};function Xw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_w,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}Xw.isMDXComponent=!0;const xw={toc:[]};function vw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}vw.isMDXComponent=!0;const Cw={toc:[]};function Tw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Tw.isMDXComponent=!0;const bw={toc:[]};function Lw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Lw.isMDXComponent=!0;const Zw={toc:[]};function Nw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}Nw.isMDXComponent=!0;const Sw={toc:[]};function Rw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}Rw.isMDXComponent=!0;const Ew={toc:[]};function zw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ew,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}zw.isMDXComponent=!0;const Aw={toc:[]};function Iw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Aw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A closed circle will look like a pie chart:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,i.kt)("p",null,"An open one will look like an arc:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}Iw.isMDXComponent=!0;const Pw={toc:[]};function Fw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"false"))}Fw.isMDXComponent=!0;const Ww={toc:[]};function Bw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ww,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the path of this circle should be closed."))}Bw.isMDXComponent=!0;const Gw={toc:[]};function Ow(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property can be used together with ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,i.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Ow.isMDXComponent=!0;const jw={toc:[]};function Uw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"360"))}Uw.isMDXComponent=!0;const qw={toc:[]};function Vw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ending angle in degrees for the circle sector."))}Vw.isMDXComponent=!0;const $w={toc:[]};function Hw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$w,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Hw.isMDXComponent=!0;const Jw={toc:[]};function Yw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}Yw.isMDXComponent=!0;const Kw={toc:[]};function Qw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Qw.isMDXComponent=!0;const tg={toc:[]};function eg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}eg.isMDXComponent=!0;const ng={toc:[]};function og(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ng,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}og.isMDXComponent=!0;const sg={toc:[]};function rg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}rg.isMDXComponent=!0;const ig={toc:[]};function ag(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ig,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}ag.isMDXComponent=!0;const pg={toc:[]};function cg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}cg.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}dg.isMDXComponent=!0;const hg={toc:[]};function yg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property can be used together with ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,i.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}yg.isMDXComponent=!0;const fg={toc:[]};function kg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"0"))}kg.isMDXComponent=!0;const wg={toc:[]};function gg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The starting angle in degrees for the circle sector."))}gg.isMDXComponent=!0;const Mg={toc:[]};function Dg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}Dg.isMDXComponent=!0;const _g={toc:[]};function Xg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_g,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Xg.isMDXComponent=!0;const xg={toc:[]};function vg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}vg.isMDXComponent=!0;const Cg={toc:[]};function Tg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}Tg.isMDXComponent=!0;const bg={toc:[]};function Lg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Lg.isMDXComponent=!0;const Zg={toc:[]};function Ng(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}Ng.isMDXComponent=!0;const Sg={toc:[]};function Rg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Rg.isMDXComponent=!0;const Eg={toc:[]};function zg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Eg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}zg.isMDXComponent=!0;const Ag={toc:[]};function Ig(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ag,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}Ig.isMDXComponent=!0;const Pg={toc:[]};function Fg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Fg.isMDXComponent=!0;const Wg={toc:[]};function Bg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}Bg.isMDXComponent=!0;const Gg={toc:[]};function Og(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Og.isMDXComponent=!0;const jg={toc:[]};function Ug(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}Ug.isMDXComponent=!0;const qg={toc:[]};function Vg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Vg.isMDXComponent=!0;const $g={toc:[]};function Hg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$g,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}Hg.isMDXComponent=!0;const Jg={toc:[]};function Yg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Yg.isMDXComponent=!0;const Kg={toc:[]};function Qg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}Qg.isMDXComponent=!0;const tM={toc:[]};function eM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}eM.isMDXComponent=!0;const nM={toc:[]};function oM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}oM.isMDXComponent=!0;const sM={toc:[]};function rM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}rM.isMDXComponent=!0;const iM={toc:[]};function aM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}aM.isMDXComponent=!0;const pM={toc:[]};function cM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}cM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}dM.isMDXComponent=!0;const hM={toc:[]};function yM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}yM.isMDXComponent=!0;const fM={toc:[]};function kM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kM.isMDXComponent=!0;const wM={toc:[]};function gM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}gM.isMDXComponent=!0;const MM={toc:[]};function DM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}DM.isMDXComponent=!0;const _M={toc:[]};function XM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_M,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}XM.isMDXComponent=!0;const xM={toc:[]};function vM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}vM.isMDXComponent=!0;const CM={toc:[]};function TM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}TM.isMDXComponent=!0;const bM={toc:[]};function LM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}LM.isMDXComponent=!0;const ZM={toc:[]};function NM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}NM.isMDXComponent=!0;const SM={toc:[]};function RM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}RM.isMDXComponent=!0;const EM={toc:[]};function zM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}zM.isMDXComponent=!0;const AM={toc:[]};function IM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}IM.isMDXComponent=!0;const PM={toc:[]};function FM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}FM.isMDXComponent=!0;const WM={toc:[]};function BM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}BM.isMDXComponent=!0;const GM={toc:[]};function OM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}OM.isMDXComponent=!0;const jM={toc:[]};function UM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}UM.isMDXComponent=!0;const qM={toc:[]};function VM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}VM.isMDXComponent=!0;const $M={toc:[]};function HM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$M,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}HM.isMDXComponent=!0;const JM={toc:[]};function YM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}YM.isMDXComponent=!0;const KM={toc:[]};function QM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}QM.isMDXComponent=!0;const tD={toc:[]};function eD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}eD.isMDXComponent=!0;const nD={toc:[]};function oD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}oD.isMDXComponent=!0;const sD={toc:[]};function rD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}rD.isMDXComponent=!0;const iD={toc:[]};function aD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}aD.isMDXComponent=!0;const pD={toc:[]};function cD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}cD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}dD.isMDXComponent=!0;const hD={toc:[]};function yD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}yD.isMDXComponent=!0;const fD={toc:[]};function kD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}kD.isMDXComponent=!0;const wD={toc:[]};function gD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}gD.isMDXComponent=!0;const MD={toc:[]};function DD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}DD.isMDXComponent=!0;const _D={toc:[]};function XD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_D,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}XD.isMDXComponent=!0;const xD={toc:[]};function vD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}vD.isMDXComponent=!0;const CD={toc:[]};function TD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}TD.isMDXComponent=!0;const bD={toc:[]};function LD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}LD.isMDXComponent=!0;const ZD={toc:[]};function ND(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}ND.isMDXComponent=!0;const SD={toc:[]};function RD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}RD.isMDXComponent=!0;const ED={toc:[]};function zD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ED,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}zD.isMDXComponent=!0;const AD={toc:[]};function ID(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}ID.isMDXComponent=!0;const PD={toc:[]};function FD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}FD.isMDXComponent=!0;const WD={toc:[]};function BD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}BD.isMDXComponent=!0;const GD={toc:[]};function OD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}OD.isMDXComponent=!0;const jD={toc:[]};function UD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}UD.isMDXComponent=!0;const qD={toc:[]};function VD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}VD.isMDXComponent=!0;const $D={toc:[]};function HD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$D,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}HD.isMDXComponent=!0;const JD={toc:[]};function YD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}YD.isMDXComponent=!0;const KD={toc:[]};function QD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}QD.isMDXComponent=!0;const t_={toc:[]};function e_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}e_.isMDXComponent=!0;const n_={toc:[]};function o_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}o_.isMDXComponent=!0;const s_={toc:[]};function r_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}r_.isMDXComponent=!0;const i_={toc:[]};function a_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}a_.isMDXComponent=!0;const p_={toc:[]};function c_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},p_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}c_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}d_.isMDXComponent=!0;const h_={toc:[]};function y_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}y_.isMDXComponent=!0;const f_={toc:[]};function k_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}k_.isMDXComponent=!0;const w_={toc:[]};function g_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}g_.isMDXComponent=!0;const M_={toc:[]};function D_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}D_.isMDXComponent=!0;const __={toc:[]};function X_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},__,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}X_.isMDXComponent=!0;const x_={toc:[]};function v_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}v_.isMDXComponent=!0;const C_={toc:[]};function T_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}T_.isMDXComponent=!0;const b_={toc:[]};function L_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}L_.isMDXComponent=!0;const Z_={toc:[]};function N_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}N_.isMDXComponent=!0;const S_={toc:[]};function R_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}R_.isMDXComponent=!0;const E_={toc:[]};function z_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}z_.isMDXComponent=!0;const A_={toc:[]};function I_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},A_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}I_.isMDXComponent=!0;const P_={toc:[]};function F_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},P_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}F_.isMDXComponent=!0;const W_={toc:[]};function B_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}B_.isMDXComponent=!0;const G_={toc:[]};function O_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}O_.isMDXComponent=!0;const j_={toc:[]};function U_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}U_.isMDXComponent=!0;const q_={toc:[]};function V_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}V_.isMDXComponent=!0;const $_={toc:[]};function H_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}H_.isMDXComponent=!0;const J_={toc:[]};function Y_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Y_.isMDXComponent=!0;const K_={toc:[]};function Q_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}Q_.isMDXComponent=!0;const tX={toc:[]};function eX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}eX.isMDXComponent=!0;const nX={toc:[]};function oX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}oX.isMDXComponent=!0;const sX={toc:[]};function rX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}rX.isMDXComponent=!0;const iX={toc:[]};function aX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}aX.isMDXComponent=!0;const pX={toc:[]};function cX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}cX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}dX.isMDXComponent=!0;const hX={toc:[]};function yX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}yX.isMDXComponent=!0;const fX={toc:[]};function kX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}kX.isMDXComponent=!0;const wX={toc:[]};function gX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}gX.isMDXComponent=!0;const MX={toc:[]};function DX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}DX.isMDXComponent=!0;const _X={toc:[]};function XX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_X,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}XX.isMDXComponent=!0;const xX={toc:[]};function vX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}vX.isMDXComponent=!0;const CX={toc:[]};function TX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}TX.isMDXComponent=!0;const bX={toc:[]};function LX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}LX.isMDXComponent=!0;const ZX={toc:[]};function NX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}NX.isMDXComponent=!0;const SX={toc:[]};function RX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}RX.isMDXComponent=!0;const EX={toc:[]};function zX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}zX.isMDXComponent=!0;const AX={toc:[]};function IX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}IX.isMDXComponent=!0;const PX={toc:[]};function FX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}FX.isMDXComponent=!0;const WX={toc:[]};function BX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}BX.isMDXComponent=!0;const GX={toc:[]};function OX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}OX.isMDXComponent=!0;const jX={toc:[]};function UX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}UX.isMDXComponent=!0;const qX={toc:[]};function VX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}VX.isMDXComponent=!0;const $X={toc:[]};function HX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$X,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}HX.isMDXComponent=!0;const JX={toc:[]};function YX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}YX.isMDXComponent=!0;const KX={toc:[]};function QX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}QX.isMDXComponent=!0;const tx={toc:[]};function ex(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}ex.isMDXComponent=!0;const nx={toc:[]};function ox(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}ox.isMDXComponent=!0;const sx={toc:[]};function rx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}rx.isMDXComponent=!0;const ix={toc:[]};function ax(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ix,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}ax.isMDXComponent=!0;const px={toc:[]};function cx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},px,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}cx.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}dx.isMDXComponent=!0;const hx={toc:[]};function yx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}yx.isMDXComponent=!0;const fx={toc:[]};function kx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}kx.isMDXComponent=!0;const wx={toc:[]};function gx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}gx.isMDXComponent=!0;const Mx={toc:[]};function Dx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}Dx.isMDXComponent=!0;const _x={toc:[]};function Xx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_x,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Xx.isMDXComponent=!0;const xx={toc:[]};function vx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}vx.isMDXComponent=!0;const Cx={toc:[]};function Tx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Tx.isMDXComponent=!0;const bx={toc:[]};function Lx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}Lx.isMDXComponent=!0;const Zx={toc:[]};function Nx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Nx.isMDXComponent=!0;const Sx={toc:[]};function Rx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Rx.isMDXComponent=!0;const Ex={toc:[]};function zx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ex,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}zx.isMDXComponent=!0;const Ax={toc:[]};function Ix(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ax,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Ix.isMDXComponent=!0;const Px={toc:[]};function Fx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Px,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}Fx.isMDXComponent=!0;const Wx={toc:[]};function Bx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Bx.isMDXComponent=!0;const Gx={toc:[]};function Ox(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Ox.isMDXComponent=!0;const jx={toc:[]};function Ux(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Ux.isMDXComponent=!0;const qx={toc:[]};function Vx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Vx.isMDXComponent=!0;const $x={toc:[]};function Hx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$x,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Hx.isMDXComponent=!0;const Jx={toc:[]};function Yx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}Yx.isMDXComponent=!0;const Kx={toc:[]};function Qx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}Qx.isMDXComponent=!0;const tv={toc:[]};function ev(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}ev.isMDXComponent=!0;const nv={toc:[]};function ov(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}ov.isMDXComponent=!0;const sv={toc:[]};function rv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}rv.isMDXComponent=!0;const iv={toc:[]};function av(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}av.isMDXComponent=!0;const pv={toc:[]};function cv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}cv.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}dv.isMDXComponent=!0;const hv={toc:[]};function yv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}yv.isMDXComponent=!0;const fv={toc:[]};function kv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}kv.isMDXComponent=!0;const wv={toc:[]};function gv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}gv.isMDXComponent=!0;const Mv={toc:[]};function Dv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}Dv.isMDXComponent=!0;const _v={toc:[]};function Xv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_v,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Xv.isMDXComponent=!0;const xv={toc:[]};function vv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}vv.isMDXComponent=!0;const Cv={toc:[]};function Tv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}Tv.isMDXComponent=!0;const bv={toc:[]};function Lv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Lv.isMDXComponent=!0;const Zv={toc:[]};function Nv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}Nv.isMDXComponent=!0;const Sv={toc:[]};function Rv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}Rv.isMDXComponent=!0;const Ev={toc:[]};function zv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ev,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}zv.isMDXComponent=!0;const Av={toc:[]};function Iv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Av,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Iv.isMDXComponent=!0;const Pv={toc:[]};function Fv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Fv.isMDXComponent=!0;const Wv={toc:[]};function Bv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Bv.isMDXComponent=!0;const Gv={toc:[]};function Ov(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Ov.isMDXComponent=!0;const jv={toc:[]};function Uv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Uv.isMDXComponent=!0;const qv={toc:[]};function Vv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Vv.isMDXComponent=!0;const $v={toc:[]};function Hv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$v,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Hv.isMDXComponent=!0;const Jv={toc:[]};function Yv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Yv.isMDXComponent=!0;const Kv={toc:[]};function Qv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}Qv.isMDXComponent=!0;const tC={toc:[]};function eC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}eC.isMDXComponent=!0;const nC={toc:[]};function oC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}oC.isMDXComponent=!0;const sC={toc:[]};function rC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}rC.isMDXComponent=!0;const iC={toc:[]};function aC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}aC.isMDXComponent=!0;const pC={toc:[]};function cC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}cC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}dC.isMDXComponent=!0;const hC={toc:[]};function yC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}yC.isMDXComponent=!0;const fC={toc:[]};function kC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}kC.isMDXComponent=!0;const wC={toc:[]};function gC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}gC.isMDXComponent=!0;const MC={toc:[]};function DC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}DC.isMDXComponent=!0;const _C={toc:[]};function XC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_C,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}XC.isMDXComponent=!0;const xC={toc:[]};function vC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}vC.isMDXComponent=!0;const CC={toc:[]};function TC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}TC.isMDXComponent=!0;const bC={toc:[]};function LC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}LC.isMDXComponent=!0;const ZC={toc:[]};function NC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}NC.isMDXComponent=!0;const SC={toc:[]};function RC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}RC.isMDXComponent=!0;const EC={toc:[]};function zC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}zC.isMDXComponent=!0;const AC={toc:[]};function IC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}IC.isMDXComponent=!0;const PC={toc:[]};function FC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}FC.isMDXComponent=!0;const WC={toc:[]};function BC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}BC.isMDXComponent=!0;const GC={toc:[]};function OC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}OC.isMDXComponent=!0;const jC={toc:[]};function UC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}UC.isMDXComponent=!0;const qC={toc:[]};function VC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}VC.isMDXComponent=!0;const $C={toc:[]};function HC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$C,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}HC.isMDXComponent=!0;const JC={toc:[]};function YC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}YC.isMDXComponent=!0;const KC={toc:[]};function QC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}QC.isMDXComponent=!0;const tT={toc:[]};function eT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}eT.isMDXComponent=!0;const nT={toc:[]};function oT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}oT.isMDXComponent=!0;const sT={toc:[]};function rT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}rT.isMDXComponent=!0;const iT={toc:[]};function aT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}aT.isMDXComponent=!0;const pT={toc:[]};function cT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}cT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}dT.isMDXComponent=!0;const hT={toc:[]};function yT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}yT.isMDXComponent=!0;const fT={toc:[]};function kT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}kT.isMDXComponent=!0;const wT={toc:[]};function gT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}gT.isMDXComponent=!0;const MT={toc:[]};function DT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}DT.isMDXComponent=!0;const _T={toc:[]};function XT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_T,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}XT.isMDXComponent=!0;const xT={toc:[]};function vT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}vT.isMDXComponent=!0;const CT={toc:[]};function TT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}TT.isMDXComponent=!0;const bT={toc:[]};function LT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}LT.isMDXComponent=!0;const ZT={toc:[]};function NT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}NT.isMDXComponent=!0;const ST={toc:[]};function RT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ST,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}RT.isMDXComponent=!0;const ET={toc:[]};function zT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ET,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}zT.isMDXComponent=!0;const AT={toc:[]};function IT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}IT.isMDXComponent=!0;const PT={toc:[]};function FT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}FT.isMDXComponent=!0;const WT={toc:[]};function BT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An Icon Component that provides an easy access to over 150k icons.\nSee ",(0,i.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}BT.isMDXComponent=!0;const GT={toc:[]};function OT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}OT.isMDXComponent=!0;const jT={toc:[]};function UT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}UT.isMDXComponent=!0;const qT={toc:[]};function VT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}VT.isMDXComponent=!0;const $T={toc:[]};function HT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$T,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}HT.isMDXComponent=!0;const JT={toc:[]};function YT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}YT.isMDXComponent=!0;const KT={toc:[]};function QT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}QT.isMDXComponent=!0;const tb={toc:[]};function eb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provide the color in one of the following formats:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"named color like ",(0,i.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,i.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}eb.isMDXComponent=!0;const nb={toc:[]};function ob(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"'white'"))}ob.isMDXComponent=!0;const sb={toc:[]};function rb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The color of the icon"))}rb.isMDXComponent=!0;const ib={toc:[]};function ab(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ib,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}ab.isMDXComponent=!0;const pb={toc:[]};function cb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}cb.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"You can find identifiers on ",(0,i.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}db.isMDXComponent=!0;const hb={toc:[]};function yb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The identifier of the icon."))}yb.isMDXComponent=!0;const fb={toc:[]};function kb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}kb.isMDXComponent=!0;const wb={toc:[]};function gb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}gb.isMDXComponent=!0;const Mb={toc:[]};function Db(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Db.isMDXComponent=!0;const _b={toc:[]};function Xb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_b,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}Xb.isMDXComponent=!0;const xb={toc:[]};function vb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}vb.isMDXComponent=!0;const Cb={toc:[]};function Tb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Tb.isMDXComponent=!0;const bb={toc:[]};function Lb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Lb.isMDXComponent=!0;const Zb={toc:[]};function Nb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Nb.isMDXComponent=!0;const Sb={toc:[]};function Rb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Rb.isMDXComponent=!0;const Eb={toc:[]};function zb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Eb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}zb.isMDXComponent=!0;const Ab={toc:[]};function Ib(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ab,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Ib.isMDXComponent=!0;const Pb={toc:[]};function Fb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Fb.isMDXComponent=!0;const Wb={toc:[]};function Bb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Bb.isMDXComponent=!0;const Gb={toc:[]};function Ob(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}Ob.isMDXComponent=!0;const jb={toc:[]};function Ub(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Ub.isMDXComponent=!0;const qb={toc:[]};function Vb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}Vb.isMDXComponent=!0;const $b={toc:[]};function Hb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$b,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}Hb.isMDXComponent=!0;const Jb={toc:[]};function Yb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Yb.isMDXComponent=!0;const Kb={toc:[]};function Qb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}Qb.isMDXComponent=!0;const tL={toc:[]};function eL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}eL.isMDXComponent=!0;const nL={toc:[]};function oL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}oL.isMDXComponent=!0;const sL={toc:[]};function rL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}rL.isMDXComponent=!0;const iL={toc:[]};function aL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}aL.isMDXComponent=!0;const pL={toc:[]};function cL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}cL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}dL.isMDXComponent=!0;const hL={toc:[]};function yL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}yL.isMDXComponent=!0;const fL={toc:[]};function kL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}kL.isMDXComponent=!0;const wL={toc:[]};function gL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}gL.isMDXComponent=!0;const ML={toc:[]};function DL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ML,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}DL.isMDXComponent=!0;const _L={toc:[]};function XL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_L,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}XL.isMDXComponent=!0;const xL={toc:[]};function vL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}vL.isMDXComponent=!0;const CL={toc:[]};function TL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}TL.isMDXComponent=!0;const bL={toc:[]};function LL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}LL.isMDXComponent=!0;const ZL={toc:[]};function NL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}NL.isMDXComponent=!0;const SL={toc:[]};function RL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}RL.isMDXComponent=!0;const EL={toc:[]};function zL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}zL.isMDXComponent=!0;const AL={toc:[]};function IL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}IL.isMDXComponent=!0;const PL={toc:[]};function FL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}FL.isMDXComponent=!0;const WL={toc:[]};function BL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}BL.isMDXComponent=!0;const GL={toc:[]};function OL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}OL.isMDXComponent=!0;const jL={toc:[]};function UL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given position."))}UL.isMDXComponent=!0;const qL={toc:[]};function VL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The position in local space at which to sample the color."))}VL.isMDXComponent=!0;const $L={toc:[]};function HL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$L,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given pixel."))}HL.isMDXComponent=!0;const JL={toc:[]};function YL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The pixel's position."))}YL.isMDXComponent=!0;const KL={toc:[]};function QL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"overrides ",(0,i.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}QL.isMDXComponent=!0;const tZ={toc:[]};function eZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}eZ.isMDXComponent=!0;const nZ={toc:[]};function oZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}oZ.isMDXComponent=!0;const sZ={toc:[]};function rZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}rZ.isMDXComponent=!0;const iZ={toc:[]};function aZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}aZ.isMDXComponent=!0;const pZ={toc:[]};function cZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}cZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function yZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}yZ.isMDXComponent=!0;const fZ={toc:[]};function kZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}kZ.isMDXComponent=!0;const wZ={toc:[]};function gZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}gZ.isMDXComponent=!0;const MZ={toc:[]};function DZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}DZ.isMDXComponent=!0;const _Z={toc:[]};function XZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_Z,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}XZ.isMDXComponent=!0;const xZ={toc:[]};function vZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}vZ.isMDXComponent=!0;const CZ={toc:[]};function TZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}TZ.isMDXComponent=!0;const bZ={toc:[]};function LZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}LZ.isMDXComponent=!0;const ZZ={toc:[]};function NZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}NZ.isMDXComponent=!0;const SZ={toc:[]};function RZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}RZ.isMDXComponent=!0;const EZ={toc:[]};function zZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}zZ.isMDXComponent=!0;const AZ={toc:[]};function IZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}IZ.isMDXComponent=!0;const PZ={toc:[]};function FZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}FZ.isMDXComponent=!0;const WZ={toc:[]};function BZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}BZ.isMDXComponent=!0;const GZ={toc:[]};function OZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}OZ.isMDXComponent=!0;const jZ={toc:[]};function UZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}UZ.isMDXComponent=!0;const qZ={toc:[]};function VZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}VZ.isMDXComponent=!0;const $Z={toc:[]};function HZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Z,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}HZ.isMDXComponent=!0;const JZ={toc:[]};function YZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}YZ.isMDXComponent=!0;const KZ={toc:[]};function QZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}QZ.isMDXComponent=!0;const tN={toc:[]};function eN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}eN.isMDXComponent=!0;const nN={toc:[]};function oN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}oN.isMDXComponent=!0;const sN={toc:[]};function rN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}rN.isMDXComponent=!0;const iN={toc:[]};function aN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}aN.isMDXComponent=!0;const pN={toc:[]};function cN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}cN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}dN.isMDXComponent=!0;const hN={toc:[]};function yN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}yN.isMDXComponent=!0;const fN={toc:[]};function kN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}kN.isMDXComponent=!0;const wN={toc:[]};function gN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}gN.isMDXComponent=!0;const MN={toc:[]};function DN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}DN.isMDXComponent=!0;const _N={toc:[]};function XN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_N,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}XN.isMDXComponent=!0;const xN={toc:[]};function vN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}vN.isMDXComponent=!0;const CN={toc:[]};function TN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}TN.isMDXComponent=!0;const bN={toc:[]};function LN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}LN.isMDXComponent=!0;const ZN={toc:[]};function NN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}NN.isMDXComponent=!0;const SN={toc:[]};function RN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}RN.isMDXComponent=!0;const EN={toc:[]};function zN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}zN.isMDXComponent=!0;const AN={toc:[]};function IN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}IN.isMDXComponent=!0;const PN={toc:[]};function FN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}FN.isMDXComponent=!0;const WN={toc:[]};function BN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}BN.isMDXComponent=!0;const GN={toc:[]};function ON(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}ON.isMDXComponent=!0;const jN={toc:[]};function UN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}UN.isMDXComponent=!0;const qN={toc:[]};function VN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}VN.isMDXComponent=!0;const $N={toc:[]};function HN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$N,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}HN.isMDXComponent=!0;const JN={toc:[]};function YN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}YN.isMDXComponent=!0;const KN={toc:[]};function QN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}QN.isMDXComponent=!0;const tS={toc:[]};function eS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}eS.isMDXComponent=!0;const nS={toc:[]};function oS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}oS.isMDXComponent=!0;const sS={toc:[]};function rS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}rS.isMDXComponent=!0;const iS={toc:[]};function aS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}aS.isMDXComponent=!0;const pS={toc:[]};function cS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}cS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}dS.isMDXComponent=!0;const hS={toc:[]};function yS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"overrides ",(0,i.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}yS.isMDXComponent=!0;const fS={toc:[]};function kS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}kS.isMDXComponent=!0;const wS={toc:[]};function gS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}gS.isMDXComponent=!0;const MS={toc:[]};function DS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}DS.isMDXComponent=!0;const _S={toc:[]};function XS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_S,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}XS.isMDXComponent=!0;const xS={toc:[]};function vS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}vS.isMDXComponent=!0;const CS={toc:[]};function TS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}TS.isMDXComponent=!0;const bS={toc:[]};function LS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Address to Iconify API for the requested Icon."))}LS.isMDXComponent=!0;const ZS={toc:[]};function NS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create the URL that will be used as the Image source"))}NS.isMDXComponent=!0;const SS={toc:[]};function RS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}RS.isMDXComponent=!0;const ES={toc:[]};function zS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ES,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}zS.isMDXComponent=!0;const AS={toc:[]};function IS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}IS.isMDXComponent=!0;const PS={toc:[]};function FS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}FS.isMDXComponent=!0;const WS={toc:[]};function BS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}BS.isMDXComponent=!0;const GS={toc:[]};function OS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}OS.isMDXComponent=!0;const jS={toc:[]};function US(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}US.isMDXComponent=!0;const qS={toc:[]};function VS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}VS.isMDXComponent=!0;const $S={toc:[]};function HS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$S,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}HS.isMDXComponent=!0;const JS={toc:[]};function YS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}YS.isMDXComponent=!0;const KS={toc:[]};function QS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}QS.isMDXComponent=!0;const tR={toc:[]};function eR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}eR.isMDXComponent=!0;const nR={toc:[]};function oR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}oR.isMDXComponent=!0;const sR={toc:[]};function rR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}rR.isMDXComponent=!0;const iR={toc:[]};function aR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}aR.isMDXComponent=!0;const pR={toc:[]};function cR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}cR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}dR.isMDXComponent=!0;const hR={toc:[]};function yR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}yR.isMDXComponent=!0;const fR={toc:[]};function kR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}kR.isMDXComponent=!0;const wR={toc:[]};function gR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}gR.isMDXComponent=!0;const MR={toc:[]};function DR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}DR.isMDXComponent=!0;const _R={toc:[]};function XR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_R,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}XR.isMDXComponent=!0;const xR={toc:[]};function vR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}vR.isMDXComponent=!0;const CR={toc:[]};function TR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}TR.isMDXComponent=!0;const bR={toc:[]};function LR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}LR.isMDXComponent=!0;const ZR={toc:[]};function NR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}NR.isMDXComponent=!0;const SR={toc:[]};function RR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}RR.isMDXComponent=!0;const ER={toc:[]};function zR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ER,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}zR.isMDXComponent=!0;const AR={toc:[]};function IR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}IR.isMDXComponent=!0;const PR={toc:[]};function FR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}FR.isMDXComponent=!0;const WR={toc:[]};function BR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}BR.isMDXComponent=!0;const GR={toc:[]};function OR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}OR.isMDXComponent=!0;const jR={toc:[]};function UR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}UR.isMDXComponent=!0;const qR={toc:[]};function VR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}VR.isMDXComponent=!0;const $R={toc:[]};function HR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$R,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}HR.isMDXComponent=!0;const JR={toc:[]};function YR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}YR.isMDXComponent=!0;const KR={toc:[]};function QR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}QR.isMDXComponent=!0;const tE={toc:[]};function eE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}eE.isMDXComponent=!0;const nE={toc:[]};function oE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}oE.isMDXComponent=!0;const sE={toc:[]};function rE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}rE.isMDXComponent=!0;const iE={toc:[]};function aE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}aE.isMDXComponent=!0;const pE={toc:[]};function cE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}cE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}dE.isMDXComponent=!0;const hE={toc:[]};function yE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}yE.isMDXComponent=!0;const fE={toc:[]};function kE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}kE.isMDXComponent=!0;const wE={toc:[]};function gE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}gE.isMDXComponent=!0;const ME={toc:[]};function DE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ME,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}DE.isMDXComponent=!0;const _E={toc:[]};function XE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_E,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}XE.isMDXComponent=!0;const xE={toc:[]};function vE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}vE.isMDXComponent=!0;const CE={toc:[]};function TE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}TE.isMDXComponent=!0;const bE={toc:[]};function LE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}LE.isMDXComponent=!0;const ZE={toc:[]};function NE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}NE.isMDXComponent=!0;const SE={toc:[]};function RE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}RE.isMDXComponent=!0;const EE={toc:[]};function zE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}zE.isMDXComponent=!0;const AE={toc:[]};function IE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}IE.isMDXComponent=!0;const PE={toc:[]};function FE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}FE.isMDXComponent=!0;const WE={toc:[]};function BE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}BE.isMDXComponent=!0;const GE={toc:[]};function OE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}OE.isMDXComponent=!0;const jE={toc:[]};function UE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given position."))}UE.isMDXComponent=!0;const qE={toc:[]};function VE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The position in local space at which to sample the color."))}VE.isMDXComponent=!0;const $E={toc:[]};function HE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$E,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given pixel."))}HE.isMDXComponent=!0;const JE={toc:[]};function YE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The pixel's position."))}YE.isMDXComponent=!0;const KE={toc:[]};function QE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}QE.isMDXComponent=!0;const tz={toc:[]};function ez(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}ez.isMDXComponent=!0;const nz={toc:[]};function oz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}oz.isMDXComponent=!0;const sz={toc:[]};function rz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}rz.isMDXComponent=!0;const iz={toc:[]};function az(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}az.isMDXComponent=!0;const pz={toc:[]};function cz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}cz.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}dz.isMDXComponent=!0;const hz={toc:[]};function yz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}yz.isMDXComponent=!0;const fz={toc:[]};function kz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}kz.isMDXComponent=!0;const wz={toc:[]};function gz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}gz.isMDXComponent=!0;const Mz={toc:[]};function Dz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}Dz.isMDXComponent=!0;const _z={toc:[]};function Xz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_z,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Xz.isMDXComponent=!0;const xz={toc:[]};function vz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}vz.isMDXComponent=!0;const Cz={toc:[]};function Tz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Tz.isMDXComponent=!0;const bz={toc:[]};function Lz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Lz.isMDXComponent=!0;const Zz={toc:[]};function Nz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}Nz.isMDXComponent=!0;const Sz={toc:[]};function Rz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Rz.isMDXComponent=!0;const Ez={toc:[]};function zz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ez,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}zz.isMDXComponent=!0;const Az={toc:[]};function Iz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Az,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}Iz.isMDXComponent=!0;const Pz={toc:[]};function Fz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Fz.isMDXComponent=!0;const Wz={toc:[]};function Bz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Bz.isMDXComponent=!0;const Gz={toc:[]};function Oz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Oz.isMDXComponent=!0;const jz={toc:[]};function Uz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Uz.isMDXComponent=!0;const qz={toc:[]};function Vz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Vz.isMDXComponent=!0;const $z={toc:[]};function Hz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$z,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Hz.isMDXComponent=!0;const Jz={toc:[]};function Yz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Yz.isMDXComponent=!0;const Kz={toc:[]};function Qz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Qz.isMDXComponent=!0;const tA={toc:[]};function eA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}eA.isMDXComponent=!0;const nA={toc:[]};function oA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}oA.isMDXComponent=!0;const sA={toc:[]};function rA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}rA.isMDXComponent=!0;const iA={toc:[]};function aA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}aA.isMDXComponent=!0;const pA={toc:[]};function cA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}cA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}dA.isMDXComponent=!0;const hA={toc:[]};function yA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}yA.isMDXComponent=!0;const fA={toc:[]};function kA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}kA.isMDXComponent=!0;const wA={toc:[]};function gA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}gA.isMDXComponent=!0;const MA={toc:[]};function DA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}DA.isMDXComponent=!0;const _A={toc:[]};function XA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_A,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}XA.isMDXComponent=!0;const xA={toc:[]};function vA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}vA.isMDXComponent=!0;const CA={toc:[]};function TA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}TA.isMDXComponent=!0;const bA={toc:[]};function LA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}LA.isMDXComponent=!0;const ZA={toc:[]};function NA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}NA.isMDXComponent=!0;const SA={toc:[]};function RA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}RA.isMDXComponent=!0;const EA={toc:[]};function zA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}zA.isMDXComponent=!0;const AA={toc:[]};function IA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}IA.isMDXComponent=!0;const PA={toc:[]};function FA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}FA.isMDXComponent=!0;const WA={toc:[]};function BA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}BA.isMDXComponent=!0;const GA={toc:[]};function OA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}OA.isMDXComponent=!0;const jA={toc:[]};function UA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}UA.isMDXComponent=!0;const qA={toc:[]};function VA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}VA.isMDXComponent=!0;const $A={toc:[]};function HA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$A,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}HA.isMDXComponent=!0;const JA={toc:[]};function YA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}YA.isMDXComponent=!0;const KA={toc:[]};function QA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}QA.isMDXComponent=!0;const tI={toc:[]};function eI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}eI.isMDXComponent=!0;const nI={toc:[]};function oI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}oI.isMDXComponent=!0;const sI={toc:[]};function rI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}rI.isMDXComponent=!0;const iI={toc:[]};function aI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}aI.isMDXComponent=!0;const pI={toc:[]};function cI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}cI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}dI.isMDXComponent=!0;const hI={toc:[]};function yI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}yI.isMDXComponent=!0;const fI={toc:[]};function kI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}kI.isMDXComponent=!0;const wI={toc:[]};function gI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}gI.isMDXComponent=!0;const MI={toc:[]};function DI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}DI.isMDXComponent=!0;const _I={toc:[]};function XI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_I,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}XI.isMDXComponent=!0;const xI={toc:[]};function vI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}vI.isMDXComponent=!0;const CI={toc:[]};function TI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}TI.isMDXComponent=!0;const bI={toc:[]};function LI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}LI.isMDXComponent=!0;const ZI={toc:[]};function NI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}NI.isMDXComponent=!0;const SI={toc:[]};function RI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}RI.isMDXComponent=!0;const EI={toc:[]};function zI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}zI.isMDXComponent=!0;const AI={toc:[]};function II(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}II.isMDXComponent=!0;const PI={toc:[]};function FI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}FI.isMDXComponent=!0;const WI={toc:[]};function BI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}BI.isMDXComponent=!0;const GI={toc:[]};function OI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}OI.isMDXComponent=!0;const jI={toc:[]};function UI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}UI.isMDXComponent=!0;const qI={toc:[]};function VI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}VI.isMDXComponent=!0;const $I={toc:[]};function HI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$I,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}HI.isMDXComponent=!0;const JI={toc:[]};function YI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}YI.isMDXComponent=!0;const KI={toc:[]};function QI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}QI.isMDXComponent=!0;const tP={toc:[]};function eP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}eP.isMDXComponent=!0;const nP={toc:[]};function oP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}oP.isMDXComponent=!0;const sP={toc:[]};function rP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}rP.isMDXComponent=!0;const iP={toc:[]};function aP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}aP.isMDXComponent=!0;const pP={toc:[]};function cP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}cP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}dP.isMDXComponent=!0;const hP={toc:[]};function yP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}yP.isMDXComponent=!0;const fP={toc:[]};function kP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}kP.isMDXComponent=!0;const wP={toc:[]};function gP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}gP.isMDXComponent=!0;const MP={toc:[]};function DP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}DP.isMDXComponent=!0;const _P={toc:[]};function XP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_P,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}XP.isMDXComponent=!0;const xP={toc:[]};function vP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}vP.isMDXComponent=!0;const CP={toc:[]};function TP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}TP.isMDXComponent=!0;const bP={toc:[]};function LP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}LP.isMDXComponent=!0;const ZP={toc:[]};function NP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}NP.isMDXComponent=!0;const SP={toc:[]};function RP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}RP.isMDXComponent=!0;const EP={toc:[]};function zP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}zP.isMDXComponent=!0;const AP={toc:[]};function IP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}IP.isMDXComponent=!0;const PP={toc:[]};function FP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}FP.isMDXComponent=!0;const WP={toc:[]};function BP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}BP.isMDXComponent=!0;const GP={toc:[]};function OP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}OP.isMDXComponent=!0;const jP={toc:[]};function UP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}UP.isMDXComponent=!0;const qP={toc:[]};function VP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}VP.isMDXComponent=!0;const $P={toc:[]};function HP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$P,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}HP.isMDXComponent=!0;const JP={toc:[]};function YP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}YP.isMDXComponent=!0;const KP={toc:[]};function QP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}QP.isMDXComponent=!0;const tF={toc:[]};function eF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}eF.isMDXComponent=!0;const nF={toc:[]};function oF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}oF.isMDXComponent=!0;const sF={toc:[]};function rF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}rF.isMDXComponent=!0;const iF={toc:[]};function aF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}aF.isMDXComponent=!0;const pF={toc:[]};function cF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}cF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}dF.isMDXComponent=!0;const hF={toc:[]};function yF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}yF.isMDXComponent=!0;const fF={toc:[]};function kF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}kF.isMDXComponent=!0;const wF={toc:[]};function gF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}gF.isMDXComponent=!0;const MF={toc:[]};function DF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}DF.isMDXComponent=!0;const _F={toc:[]};function XF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_F,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}XF.isMDXComponent=!0;const xF={toc:[]};function vF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}vF.isMDXComponent=!0;const CF={toc:[]};function TF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}TF.isMDXComponent=!0;const bF={toc:[]};function LF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}LF.isMDXComponent=!0;const ZF={toc:[]};function NF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}NF.isMDXComponent=!0;const SF={toc:[]};function RF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}RF.isMDXComponent=!0;const EF={toc:[]};function zF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}zF.isMDXComponent=!0;const AF={toc:[]};function IF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given position."))}IF.isMDXComponent=!0;const PF={toc:[]};function FF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The position in local space at which to sample the color."))}FF.isMDXComponent=!0;const WF={toc:[]};function BF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given pixel."))}BF.isMDXComponent=!0;const GF={toc:[]};function OF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The pixel's position."))}OF.isMDXComponent=!0;const jF={toc:[]};function UF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}UF.isMDXComponent=!0;const qF={toc:[]};function VF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}VF.isMDXComponent=!0;const $F={toc:[]};function HF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$F,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}HF.isMDXComponent=!0;const JF={toc:[]};function YF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}YF.isMDXComponent=!0;const KF={toc:[]};function QF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}QF.isMDXComponent=!0;const tW={toc:[]};function eW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}eW.isMDXComponent=!0;const nW={toc:[]};function oW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}oW.isMDXComponent=!0;const sW={toc:[]};function rW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}rW.isMDXComponent=!0;const iW={toc:[]};function aW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}aW.isMDXComponent=!0;const pW={toc:[]};function cW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}cW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}dW.isMDXComponent=!0;const hW={toc:[]};function yW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}yW.isMDXComponent=!0;const fW={toc:[]};function kW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}kW.isMDXComponent=!0;const wW={toc:[]};function gW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}gW.isMDXComponent=!0;const MW={toc:[]};function DW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}DW.isMDXComponent=!0;const _W={toc:[]};function XW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_W,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}XW.isMDXComponent=!0;const xW={toc:[]};function vW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}vW.isMDXComponent=!0;const CW={toc:[]};function TW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}TW.isMDXComponent=!0;const bW={toc:[]};function LW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}LW.isMDXComponent=!0;const ZW={toc:[]};function NW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}NW.isMDXComponent=!0;const SW={toc:[]};function RW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}RW.isMDXComponent=!0;const EW={toc:[]};function zW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}zW.isMDXComponent=!0;const AW={toc:[]};function IW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}IW.isMDXComponent=!0;const PW={toc:[]};function FW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}FW.isMDXComponent=!0;const WW={toc:[]};function BW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}BW.isMDXComponent=!0;const GW={toc:[]};function OW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}OW.isMDXComponent=!0;const jW={toc:[]};function UW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}UW.isMDXComponent=!0;const qW={toc:[]};function VW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}VW.isMDXComponent=!0;const $W={toc:[]};function HW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$W,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}HW.isMDXComponent=!0;const JW={toc:[]};function YW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}YW.isMDXComponent=!0;const KW={toc:[]};function QW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}QW.isMDXComponent=!0;const tB={toc:[]};function eB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}eB.isMDXComponent=!0;const nB={toc:[]};function oB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}oB.isMDXComponent=!0;const sB={toc:[]};function rB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}rB.isMDXComponent=!0;const iB={toc:[]};function aB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}aB.isMDXComponent=!0;const pB={toc:[]};function cB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}cB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}dB.isMDXComponent=!0;const hB={toc:[]};function yB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}yB.isMDXComponent=!0;const fB={toc:[]};function kB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}kB.isMDXComponent=!0;const wB={toc:[]};function gB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}gB.isMDXComponent=!0;const MB={toc:[]};function DB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}DB.isMDXComponent=!0;const _B={toc:[]};function XB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_B,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}XB.isMDXComponent=!0;const xB={toc:[]};function vB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}vB.isMDXComponent=!0;const CB={toc:[]};function TB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}TB.isMDXComponent=!0;const bB={toc:[]};function LB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}LB.isMDXComponent=!0;const ZB={toc:[]};function NB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}NB.isMDXComponent=!0;const SB={toc:[]};function RB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}RB.isMDXComponent=!0;const EB={toc:[]};function zB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}zB.isMDXComponent=!0;const AB={toc:[]};function IB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}IB.isMDXComponent=!0;const PB={toc:[]};function FB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}FB.isMDXComponent=!0;const WB={toc:[]};function BB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}BB.isMDXComponent=!0;const GB={toc:[]};function OB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}OB.isMDXComponent=!0;const jB={toc:[]};function UB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}UB.isMDXComponent=!0;const qB={toc:[]};function VB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}VB.isMDXComponent=!0;const $B={toc:[]};function HB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$B,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}HB.isMDXComponent=!0;const JB={toc:[]};function YB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}YB.isMDXComponent=!0;const KB={toc:[]};function QB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}QB.isMDXComponent=!0;const tG={toc:[]};function eG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}eG.isMDXComponent=!0;const nG={toc:[]};function oG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}oG.isMDXComponent=!0;const sG={toc:[]};function rG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}rG.isMDXComponent=!0;const iG={toc:[]};function aG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}aG.isMDXComponent=!0;const pG={toc:[]};function cG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}cG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}dG.isMDXComponent=!0;const hG={toc:[]};function yG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}yG.isMDXComponent=!0;const fG={toc:[]};function kG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}kG.isMDXComponent=!0;const wG={toc:[]};function gG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}gG.isMDXComponent=!0;const MG={toc:[]};function DG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}DG.isMDXComponent=!0;const _G={toc:[]};function XG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_G,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}XG.isMDXComponent=!0;const xG={toc:[]};function vG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}vG.isMDXComponent=!0;const CG={toc:[]};function TG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}TG.isMDXComponent=!0;const bG={toc:[]};function LG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}LG.isMDXComponent=!0;const ZG={toc:[]};function NG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}NG.isMDXComponent=!0;const SG={toc:[]};function RG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}RG.isMDXComponent=!0;const EG={toc:[]};function zG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}zG.isMDXComponent=!0;const AG={toc:[]};function IG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}IG.isMDXComponent=!0;const PG={toc:[]};function FG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}FG.isMDXComponent=!0;const WG={toc:[]};function BG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}BG.isMDXComponent=!0;const GG={toc:[]};function OG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}OG.isMDXComponent=!0;const jG={toc:[]};function UG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}UG.isMDXComponent=!0;const qG={toc:[]};function VG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}VG.isMDXComponent=!0;const $G={toc:[]};function HG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$G,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}HG.isMDXComponent=!0;const JG={toc:[]};function YG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}YG.isMDXComponent=!0;const KG={toc:[]};function QG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}QG.isMDXComponent=!0;const tO={toc:[]};function eO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}eO.isMDXComponent=!0;const nO={toc:[]};function oO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}oO.isMDXComponent=!0;const sO={toc:[]};function rO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}rO.isMDXComponent=!0;const iO={toc:[]};function aO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}aO.isMDXComponent=!0;const pO={toc:[]};function cO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}cO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}dO.isMDXComponent=!0;const hO={toc:[]};function yO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}yO.isMDXComponent=!0;const fO={toc:[]};function kO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}kO.isMDXComponent=!0;const wO={toc:[]};function gO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}gO.isMDXComponent=!0;const MO={toc:[]};function DO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}DO.isMDXComponent=!0;const _O={toc:[]};function XO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_O,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}XO.isMDXComponent=!0;const xO={toc:[]};function vO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}vO.isMDXComponent=!0;const CO={toc:[]};function TO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}TO.isMDXComponent=!0;const bO={toc:[]};function LO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}LO.isMDXComponent=!0;const ZO={toc:[]};function NO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}NO.isMDXComponent=!0;const SO={toc:[]};function RO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}RO.isMDXComponent=!0;const EO={toc:[]};function zO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}zO.isMDXComponent=!0;const AO={toc:[]};function IO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}IO.isMDXComponent=!0;const PO={toc:[]};function FO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}FO.isMDXComponent=!0;const WO={toc:[]};function BO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}BO.isMDXComponent=!0;const GO={toc:[]};function OO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}OO.isMDXComponent=!0;const jO={toc:[]};function UO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}UO.isMDXComponent=!0;const qO={toc:[]};function VO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}VO.isMDXComponent=!0;const $O={toc:[]};function HO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$O,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}HO.isMDXComponent=!0;const JO={toc:[]};function YO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}YO.isMDXComponent=!0;const KO={toc:[]};function QO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}QO.isMDXComponent=!0;const tj={toc:[]};function ej(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ej.isMDXComponent=!0;const nj={toc:[]};function oj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}oj.isMDXComponent=!0;const sj={toc:[]};function rj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}rj.isMDXComponent=!0;const ij={toc:[]};function aj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ij,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}aj.isMDXComponent=!0;const pj={toc:[]};function cj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}cj.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}dj.isMDXComponent=!0;const hj={toc:[]};function yj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}yj.isMDXComponent=!0;const fj={toc:[]};function kj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}kj.isMDXComponent=!0;const wj={toc:[]};function gj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}gj.isMDXComponent=!0;const Mj={toc:[]};function Dj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}Dj.isMDXComponent=!0;const _j={toc:[]};function Xj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_j,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}Xj.isMDXComponent=!0;const xj={toc:[]};function vj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}vj.isMDXComponent=!0;const Cj={toc:[]};function Tj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Tj.isMDXComponent=!0;const bj={toc:[]};function Lj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}Lj.isMDXComponent=!0;const Zj={toc:[]};function Nj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}Nj.isMDXComponent=!0;const Sj={toc:[]};function Rj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}Rj.isMDXComponent=!0;const Ej={toc:[]};function zj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ej,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}zj.isMDXComponent=!0;const Aj={toc:[]};function Ij(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Aj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Ij.isMDXComponent=!0;const Pj={toc:[]};function Fj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}Fj.isMDXComponent=!0;const Wj={toc:[]};function Bj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Bj.isMDXComponent=!0;const Gj={toc:[]};function Oj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}Oj.isMDXComponent=!0;const jj={toc:[]};function Uj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Uj.isMDXComponent=!0;const qj={toc:[]};function Vj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Vj.isMDXComponent=!0;const $j={toc:[]};function Hj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$j,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}Hj.isMDXComponent=!0;const Jj={toc:[]};function Yj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Yj.isMDXComponent=!0;const Kj={toc:[]};function Qj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}Qj.isMDXComponent=!0;const tU={toc:[]};function eU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}eU.isMDXComponent=!0;const nU={toc:[]};function oU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}oU.isMDXComponent=!0;const sU={toc:[]};function rU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}rU.isMDXComponent=!0;const iU={toc:[]};function aU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}aU.isMDXComponent=!0;const pU={toc:[]};function cU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}cU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}dU.isMDXComponent=!0;const hU={toc:[]};function yU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}yU.isMDXComponent=!0;const fU={toc:[]};function kU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}kU.isMDXComponent=!0;const wU={toc:[]};function gU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}gU.isMDXComponent=!0;const MU={toc:[]};function DU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}DU.isMDXComponent=!0;const _U={toc:[]};function XU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_U,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}XU.isMDXComponent=!0;const xU={toc:[]};function vU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}vU.isMDXComponent=!0;const CU={toc:[]};function TU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}TU.isMDXComponent=!0;const bU={toc:[]};function LU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}LU.isMDXComponent=!0;const ZU={toc:[]};function NU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}NU.isMDXComponent=!0;const SU={toc:[]};function RU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}RU.isMDXComponent=!0;const EU={toc:[]};function zU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}zU.isMDXComponent=!0;const AU={toc:[]};function IU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}IU.isMDXComponent=!0;const PU={toc:[]};function FU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}FU.isMDXComponent=!0;const WU={toc:[]};function BU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}BU.isMDXComponent=!0;const GU={toc:[]};function OU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}OU.isMDXComponent=!0;const jU={toc:[]};function UU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}UU.isMDXComponent=!0;const qU={toc:[]};function VU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}VU.isMDXComponent=!0;const $U={toc:[]};function HU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$U,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}HU.isMDXComponent=!0;const JU={toc:[]};function YU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}YU.isMDXComponent=!0;const KU={toc:[]};function QU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}QU.isMDXComponent=!0;const tq={toc:[]};function eq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}eq.isMDXComponent=!0;const nq={toc:[]};function oq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}oq.isMDXComponent=!0;const sq={toc:[]};function rq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}rq.isMDXComponent=!0;const iq={toc:[]};function aq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}aq.isMDXComponent=!0;const pq={toc:[]};function cq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}cq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}dq.isMDXComponent=!0;const hq={toc:[]};function yq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}yq.isMDXComponent=!0;const fq={toc:[]};function kq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}kq.isMDXComponent=!0;const wq={toc:[]};function gq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}gq.isMDXComponent=!0;const Mq={toc:[]};function Dq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}Dq.isMDXComponent=!0;const _q={toc:[]};function Xq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_q,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}Xq.isMDXComponent=!0;const xq={toc:[]};function vq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}vq.isMDXComponent=!0;const Cq={toc:[]};function Tq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Tq.isMDXComponent=!0;const bq={toc:[]};function Lq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Lq.isMDXComponent=!0;const Zq={toc:[]};function Nq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Nq.isMDXComponent=!0;const Sq={toc:[]};function Rq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Rq.isMDXComponent=!0;const Eq={toc:[]};function zq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Eq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}zq.isMDXComponent=!0;const Aq={toc:[]};function Iq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Aq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Iq.isMDXComponent=!0;const Pq={toc:[]};function Fq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}Fq.isMDXComponent=!0;const Wq={toc:[]};function Bq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Bq.isMDXComponent=!0;const Gq={toc:[]};function Oq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Oq.isMDXComponent=!0;const jq={toc:[]};function Uq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Uq.isMDXComponent=!0;const qq={toc:[]};function Vq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}Vq.isMDXComponent=!0;const $q={toc:[]};function Hq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$q,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Hq.isMDXComponent=!0;const Jq={toc:[]};function Yq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Yq.isMDXComponent=!0;const Kq={toc:[]};function Qq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Qq.isMDXComponent=!0;const tV={toc:[]};function eV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}eV.isMDXComponent=!0;const nV={toc:[]};function oV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}oV.isMDXComponent=!0;const sV={toc:[]};function rV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}rV.isMDXComponent=!0;const iV={toc:[]};function aV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}aV.isMDXComponent=!0;const pV={toc:[]};function cV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}cV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}dV.isMDXComponent=!0;const hV={toc:[]};function yV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}yV.isMDXComponent=!0;const fV={toc:[]};function kV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}kV.isMDXComponent=!0;const wV={toc:[]};function gV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}gV.isMDXComponent=!0;const MV={toc:[]};function DV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}DV.isMDXComponent=!0;const _V={toc:[]};function XV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_V,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}XV.isMDXComponent=!0;const xV={toc:[]};function vV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}vV.isMDXComponent=!0;const CV={toc:[]};function TV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}TV.isMDXComponent=!0;const bV={toc:[]};function LV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}LV.isMDXComponent=!0;const ZV={toc:[]};function NV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}NV.isMDXComponent=!0;const SV={toc:[]};function RV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}RV.isMDXComponent=!0;const EV={toc:[]};function zV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}zV.isMDXComponent=!0;const AV={toc:[]};function IV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}IV.isMDXComponent=!0;const PV={toc:[]};function FV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}FV.isMDXComponent=!0;const WV={toc:[]};function BV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}BV.isMDXComponent=!0;const GV={toc:[]};function OV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}OV.isMDXComponent=!0;const jV={toc:[]};function UV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}UV.isMDXComponent=!0;const qV={toc:[]};function VV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}VV.isMDXComponent=!0;const $V={toc:[]};function HV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$V,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}HV.isMDXComponent=!0;const JV={toc:[]};function YV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}YV.isMDXComponent=!0;const KV={toc:[]};function QV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}QV.isMDXComponent=!0;const t$={toc:[]};function e$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}e$.isMDXComponent=!0;const n$={toc:[]};function o$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}o$.isMDXComponent=!0;const s$={toc:[]};function r$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}r$.isMDXComponent=!0;const i$={toc:[]};function a$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}a$.isMDXComponent=!0;const p$={toc:[]};function c$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},p$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}c$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}d$.isMDXComponent=!0;const h$={toc:[]};function y$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}y$.isMDXComponent=!0;const f$={toc:[]};function k$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}k$.isMDXComponent=!0;const w$={toc:[]};function g$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}g$.isMDXComponent=!0;const M$={toc:[]};function D$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}D$.isMDXComponent=!0;const _$={toc:[]};function X$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}X$.isMDXComponent=!0;const x$={toc:[]};function v$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}v$.isMDXComponent=!0;const C$={toc:[]};function T$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}T$.isMDXComponent=!0;const b$={toc:[]};function L$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}L$.isMDXComponent=!0;const Z$={toc:[]};function N$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}N$.isMDXComponent=!0;const S$={toc:[]};function R$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}R$.isMDXComponent=!0;const E$={toc:[]};function z$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}z$.isMDXComponent=!0;const A$={toc:[]};function I$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},A$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}I$.isMDXComponent=!0;const P$={toc:[]};function F$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},P$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}F$.isMDXComponent=!0;const W$={toc:[]};function B$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}B$.isMDXComponent=!0;const G$={toc:[]};function O$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}O$.isMDXComponent=!0;const j$={toc:[]};function U$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}U$.isMDXComponent=!0;const q$={toc:[]};function V$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}V$.isMDXComponent=!0;const $$={toc:[]};function H$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}H$.isMDXComponent=!0;const J$={toc:[]};function Y$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Y$.isMDXComponent=!0;const K$={toc:[]};function Q$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Q$.isMDXComponent=!0;const tH={toc:[]};function eH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}eH.isMDXComponent=!0;const nH={toc:[]};function oH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}oH.isMDXComponent=!0;const sH={toc:[]};function rH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}rH.isMDXComponent=!0;const iH={toc:[]};function aH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}aH.isMDXComponent=!0;const pH={toc:[]};function cH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}cH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}dH.isMDXComponent=!0;const hH={toc:[]};function yH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}yH.isMDXComponent=!0;const fH={toc:[]};function kH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}kH.isMDXComponent=!0;const wH={toc:[]};function gH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}gH.isMDXComponent=!0;const MH={toc:[]};function DH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}DH.isMDXComponent=!0;const _H={toc:[]};function XH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_H,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}XH.isMDXComponent=!0;const xH={toc:[]};function vH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}vH.isMDXComponent=!0;const CH={toc:[]};function TH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}TH.isMDXComponent=!0;const bH={toc:[]};function LH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}LH.isMDXComponent=!0;const ZH={toc:[]};function NH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}NH.isMDXComponent=!0;const SH={toc:[]};function RH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}RH.isMDXComponent=!0;const EH={toc:[]};function zH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}zH.isMDXComponent=!0;const AH={toc:[]};function IH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}IH.isMDXComponent=!0;const PH={toc:[]};function FH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}FH.isMDXComponent=!0;const WH={toc:[]};function BH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}BH.isMDXComponent=!0;const GH={toc:[]};function OH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}OH.isMDXComponent=!0;const jH={toc:[]};function UH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}UH.isMDXComponent=!0;const qH={toc:[]};function VH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}VH.isMDXComponent=!0;const $H={toc:[]};function HH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$H,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}HH.isMDXComponent=!0;const JH={toc:[]};function YH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}YH.isMDXComponent=!0;const KH={toc:[]};function QH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}QH.isMDXComponent=!0;const tJ={toc:[]};function eJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}eJ.isMDXComponent=!0;const nJ={toc:[]};function oJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}oJ.isMDXComponent=!0;const sJ={toc:[]};function rJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}rJ.isMDXComponent=!0;const iJ={toc:[]};function aJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}aJ.isMDXComponent=!0;const pJ={toc:[]};function cJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}cJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function yJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}yJ.isMDXComponent=!0;const fJ={toc:[]};function kJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}kJ.isMDXComponent=!0;const wJ={toc:[]};function gJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}gJ.isMDXComponent=!0;const MJ={toc:[]};function DJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}DJ.isMDXComponent=!0;const _J={toc:[]};function XJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_J,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}XJ.isMDXComponent=!0;const xJ={toc:[]};function vJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}vJ.isMDXComponent=!0;const CJ={toc:[]};function TJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}TJ.isMDXComponent=!0;const bJ={toc:[]};function LJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}LJ.isMDXComponent=!0;const ZJ={toc:[]};function NJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}NJ.isMDXComponent=!0;const SJ={toc:[]};function RJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}RJ.isMDXComponent=!0;const EJ={toc:[]};function zJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}zJ.isMDXComponent=!0;const AJ={toc:[]};function IJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}IJ.isMDXComponent=!0;const PJ={toc:[]};function FJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}FJ.isMDXComponent=!0;const WJ={toc:[]};function BJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}BJ.isMDXComponent=!0;const GJ={toc:[]};function OJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}OJ.isMDXComponent=!0;const jJ={toc:[]};function UJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}UJ.isMDXComponent=!0;const qJ={toc:[]};function VJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}VJ.isMDXComponent=!0;const $J={toc:[]};function HJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$J,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}HJ.isMDXComponent=!0;const JJ={toc:[]};function YJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}YJ.isMDXComponent=!0;const KJ={toc:[]};function QJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}QJ.isMDXComponent=!0;const tY={toc:[]};function eY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}eY.isMDXComponent=!0;const nY={toc:[]};function oY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}oY.isMDXComponent=!0;const sY={toc:[]};function rY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}rY.isMDXComponent=!0;const iY={toc:[]};function aY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}aY.isMDXComponent=!0;const pY={toc:[]};function cY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}cY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}dY.isMDXComponent=!0;const hY={toc:[]};function yY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}yY.isMDXComponent=!0;const fY={toc:[]};function kY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}kY.isMDXComponent=!0;const wY={toc:[]};function gY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}gY.isMDXComponent=!0;const MY={toc:[]};function DY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}DY.isMDXComponent=!0;const _Y={toc:[]};function XY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_Y,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}XY.isMDXComponent=!0;const xY={toc:[]};function vY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}vY.isMDXComponent=!0;const CY={toc:[]};function TY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}TY.isMDXComponent=!0;const bY={toc:[]};function LY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}LY.isMDXComponent=!0;const ZY={toc:[]};function NY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}NY.isMDXComponent=!0;const SY={toc:[]};function RY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}RY.isMDXComponent=!0;const EY={toc:[]};function zY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}zY.isMDXComponent=!0;const AY={toc:[]};function IY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}IY.isMDXComponent=!0;const PY={toc:[]};function FY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}FY.isMDXComponent=!0;const WY={toc:[]};function BY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}BY.isMDXComponent=!0;const GY={toc:[]};function OY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}OY.isMDXComponent=!0;const jY={toc:[]};function UY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}UY.isMDXComponent=!0;const qY={toc:[]};function VY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}VY.isMDXComponent=!0;const $Y={toc:[]};function HY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Y,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}HY.isMDXComponent=!0;const JY={toc:[]};function YY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}YY.isMDXComponent=!0;const KY={toc:[]};function QY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}QY.isMDXComponent=!0;const tK={toc:[]};function eK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}eK.isMDXComponent=!0;const nK={toc:[]};function oK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}oK.isMDXComponent=!0;const sK={toc:[]};function rK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}rK.isMDXComponent=!0;const iK={toc:[]};function aK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}aK.isMDXComponent=!0;const pK={toc:[]};function cK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}cK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}dK.isMDXComponent=!0;const hK={toc:[]};function yK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}yK.isMDXComponent=!0;const fK={toc:[]};function kK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}kK.isMDXComponent=!0;const wK={toc:[]};function gK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}gK.isMDXComponent=!0;const MK={toc:[]};function DK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}DK.isMDXComponent=!0;const _K={toc:[]};function XK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_K,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}XK.isMDXComponent=!0;const xK={toc:[]};function vK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}vK.isMDXComponent=!0;const CK={toc:[]};function TK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}TK.isMDXComponent=!0;const bK={toc:[]};function LK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}LK.isMDXComponent=!0;const ZK={toc:[]};function NK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}NK.isMDXComponent=!0;const SK={toc:[]};function RK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}RK.isMDXComponent=!0;const EK={toc:[]};function zK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}zK.isMDXComponent=!0;const AK={toc:[]};function IK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}IK.isMDXComponent=!0;const PK={toc:[]};function FK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}FK.isMDXComponent=!0;const WK={toc:[]};function BK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}BK.isMDXComponent=!0;const GK={toc:[]};function OK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}OK.isMDXComponent=!0;const jK={toc:[]};function UK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}UK.isMDXComponent=!0;const qK={toc:[]};function VK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}VK.isMDXComponent=!0;const $K={toc:[]};function HK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$K,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}HK.isMDXComponent=!0;const JK={toc:[]};function YK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}YK.isMDXComponent=!0;const KK={toc:[]};function QK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}QK.isMDXComponent=!0;const tQ={toc:[]};function eQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}eQ.isMDXComponent=!0;const nQ={toc:[]};function oQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}oQ.isMDXComponent=!0;const sQ={toc:[]};function rQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}rQ.isMDXComponent=!0;const iQ={toc:[]};function aQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}aQ.isMDXComponent=!0;const pQ={toc:[]};function cQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}cQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function yQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}yQ.isMDXComponent=!0;const fQ={toc:[]};function kQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}kQ.isMDXComponent=!0;const wQ={toc:[]};function gQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}gQ.isMDXComponent=!0;const MQ={toc:[]};function DQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}DQ.isMDXComponent=!0;const _Q={toc:[]};function XQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_Q,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}XQ.isMDXComponent=!0;const xQ={toc:[]};function vQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}vQ.isMDXComponent=!0;const CQ={toc:[]};function TQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}TQ.isMDXComponent=!0;const bQ={toc:[]};function LQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}LQ.isMDXComponent=!0;const ZQ={toc:[]};function NQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}NQ.isMDXComponent=!0;const SQ={toc:[]};function RQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}RQ.isMDXComponent=!0;const EQ={toc:[]};function zQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}zQ.isMDXComponent=!0;const AQ={toc:[]};function IQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}IQ.isMDXComponent=!0;const PQ={toc:[]};function FQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}FQ.isMDXComponent=!0;const WQ={toc:[]};function BQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}BQ.isMDXComponent=!0;const GQ={toc:[]};function OQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}OQ.isMDXComponent=!0;const jQ={toc:[]};function UQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}UQ.isMDXComponent=!0;const qQ={toc:[]};function VQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}VQ.isMDXComponent=!0;const $Q={toc:[]};function HQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Q,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}HQ.isMDXComponent=!0;const JQ={toc:[]};function YQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}YQ.isMDXComponent=!0;const KQ={toc:[]};function QQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}QQ.isMDXComponent=!0;const t0={toc:[]};function e0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}e0.isMDXComponent=!0;const n0={toc:[]};function o0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}o0.isMDXComponent=!0;const s0={toc:[]};function r0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}r0.isMDXComponent=!0;const i0={toc:[]};function a0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}a0.isMDXComponent=!0;const p0={toc:[]};function c0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},p0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}c0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}d0.isMDXComponent=!0;const h0={toc:[]};function y0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}y0.isMDXComponent=!0;const f0={toc:[]};function k0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}k0.isMDXComponent=!0;const w0={toc:[]};function g0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}g0.isMDXComponent=!0;const M0={toc:[]};function D0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}D0.isMDXComponent=!0;const _0={toc:[]};function X0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}X0.isMDXComponent=!0;const x0={toc:[]};function v0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}v0.isMDXComponent=!0;const C0={toc:[]};function T0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}T0.isMDXComponent=!0;const b0={toc:[]};function L0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}L0.isMDXComponent=!0;const Z0={toc:[]};function N0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}N0.isMDXComponent=!0;const S0={toc:[]};function R0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}R0.isMDXComponent=!0;const E0={toc:[]};function z0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}z0.isMDXComponent=!0;const A0={toc:[]};function I0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},A0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}I0.isMDXComponent=!0;const P0={toc:[]};function F0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},P0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}F0.isMDXComponent=!0;const W0={toc:[]};function B0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}B0.isMDXComponent=!0;const G0={toc:[]};function O0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}O0.isMDXComponent=!0;const j0={toc:[]};function U0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}U0.isMDXComponent=!0;const q0={toc:[]};function V0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}V0.isMDXComponent=!0;const $0={toc:[]};function H0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}H0.isMDXComponent=!0;const J0={toc:[]};function Y0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}Y0.isMDXComponent=!0;const K0={toc:[]};function Q0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Q0.isMDXComponent=!0;const t2={toc:[]};function e2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}e2.isMDXComponent=!0;const n2={toc:[]};function o2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}o2.isMDXComponent=!0;const s2={toc:[]};function r2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}r2.isMDXComponent=!0;const i2={toc:[]};function a2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}a2.isMDXComponent=!0;const p2={toc:[]};function c2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},p2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}c2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}d2.isMDXComponent=!0;const h2={toc:[]};function y2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}y2.isMDXComponent=!0;const f2={toc:[]};function k2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}k2.isMDXComponent=!0;const w2={toc:[]};function g2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}g2.isMDXComponent=!0;const M2={toc:[]};function D2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}D2.isMDXComponent=!0;const _2={toc:[]};function X2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}X2.isMDXComponent=!0;const x2={toc:[]};function v2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}v2.isMDXComponent=!0;const C2={toc:[]};function T2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}T2.isMDXComponent=!0;const b2={toc:[]};function L2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}L2.isMDXComponent=!0;const Z2={toc:[]};function N2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}N2.isMDXComponent=!0;const S2={toc:[]};function R2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,i.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,i.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticable if the number of sides is low, e.g. for a\ntriangle."))}R2.isMDXComponent=!0;const E2={toc:[]};function z2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A hexagon:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  sides={6}\n  size={300}\n  fill={'lightseagreen'}\n/>\n")),(0,i.kt)("p",null,"A pentagon outline:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  sides={5}\n  size={300}\n  stroke={'lightblue'}\n  lineWidth={8}\n/>\n")))}z2.isMDXComponent=!0;const A2={toc:[]};function I2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},A2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node for drawing regular polygons."))}I2.isMDXComponent=!0;const P2={toc:[]};function F2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},P2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}F2.isMDXComponent=!0;const W2={toc:[]};function B2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}B2.isMDXComponent=!0;const G2={toc:[]};function O2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}O2.isMDXComponent=!0;const j2={toc:[]};function U2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}U2.isMDXComponent=!0;const q2={toc:[]};function V2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}V2.isMDXComponent=!0;const $2={toc:[]};function H2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}H2.isMDXComponent=!0;const J2={toc:[]};function Y2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Y2.isMDXComponent=!0;const K2={toc:[]};function Q2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}Q2.isMDXComponent=!0;const t8={toc:[]};function e8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}e8.isMDXComponent=!0;const n8={toc:[]};function o8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}o8.isMDXComponent=!0;const s8={toc:[]};function r8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}r8.isMDXComponent=!0;const i8={toc:[]};function a8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}a8.isMDXComponent=!0;const p8={toc:[]};function c8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},p8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}c8.isMDXComponent=!0;const l8={toc:[]};function u8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"For example, a value of 6 creates a hexagon."))}u8.isMDXComponent=!0;const m8={toc:[]};function d8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}d8.isMDXComponent=!0;const h8={toc:[]};function y8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Sets the number of sides of the polygon."))}y8.isMDXComponent=!0;const f8={toc:[]};function k8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}k8.isMDXComponent=!0;const w8={toc:[]};function g8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}g8.isMDXComponent=!0;const M8={toc:[]};function D8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}D8.isMDXComponent=!0;const _8={toc:[]};function X8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}X8.isMDXComponent=!0;const x8={toc:[]};function v8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}v8.isMDXComponent=!0;const C8={toc:[]};function T8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}T8.isMDXComponent=!0;const b8={toc:[]};function L8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}L8.isMDXComponent=!0;const Z8={toc:[]};function N8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}N8.isMDXComponent=!0;const S8={toc:[]};function R8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}R8.isMDXComponent=!0;const E8={toc:[]};function z8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}z8.isMDXComponent=!0;const A8={toc:[]};function I8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},A8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}I8.isMDXComponent=!0;const P8={toc:[]};function F8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},P8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}F8.isMDXComponent=!0;const W8={toc:[]};function B8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}B8.isMDXComponent=!0;const G8={toc:[]};function O8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}O8.isMDXComponent=!0;const j8={toc:[]};function U8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}U8.isMDXComponent=!0;const q8={toc:[]};function V8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}V8.isMDXComponent=!0;const $8={toc:[]};function H8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}H8.isMDXComponent=!0;const J8={toc:[]};function Y8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}Y8.isMDXComponent=!0;const K8={toc:[]};function Q8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Q8.isMDXComponent=!0;const t1={toc:[]};function e1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}e1.isMDXComponent=!0;const n1={toc:[]};function o1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}o1.isMDXComponent=!0;const s1={toc:[]};function r1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}r1.isMDXComponent=!0;const i1={toc:[]};function a1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}a1.isMDXComponent=!0;const p1={toc:[]};function c1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},p1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}c1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}d1.isMDXComponent=!0;const h1={toc:[]};function y1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}y1.isMDXComponent=!0;const f1={toc:[]};function k1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}k1.isMDXComponent=!0;const w1={toc:[]};function g1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}g1.isMDXComponent=!0;const M1={toc:[]};function D1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}D1.isMDXComponent=!0;const _1={toc:[]};function X1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}X1.isMDXComponent=!0;const x1={toc:[]};function v1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}v1.isMDXComponent=!0;const C1={toc:[]};function T1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}T1.isMDXComponent=!0;const b1={toc:[]};function L1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}L1.isMDXComponent=!0;const Z1={toc:[]};function N1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}N1.isMDXComponent=!0;const S1={toc:[]};function R1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}R1.isMDXComponent=!0;const E1={toc:[]};function z1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}z1.isMDXComponent=!0;const A1={toc:[]};function I1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},A1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}I1.isMDXComponent=!0;const P1={toc:[]};function F1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},P1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}F1.isMDXComponent=!0;const W1={toc:[]};function B1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}B1.isMDXComponent=!0;const G1={toc:[]};function O1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}O1.isMDXComponent=!0;const j1={toc:[]};function U1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}U1.isMDXComponent=!0;const q1={toc:[]};function V1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}V1.isMDXComponent=!0;const $1={toc:[]};function H1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}H1.isMDXComponent=!0;const J1={toc:[]};function Y1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}Y1.isMDXComponent=!0;const K1={toc:[]};function Q1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Q1.isMDXComponent=!0;const t3={toc:[]};function e3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}e3.isMDXComponent=!0;const n3={toc:[]};function o3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}o3.isMDXComponent=!0;const s3={toc:[]};function r3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}r3.isMDXComponent=!0;const i3={toc:[]};function a3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}a3.isMDXComponent=!0;const p3={toc:[]};function c3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},p3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}c3.isMDXComponent=!0;const l3={toc:[]};function u3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}d3.isMDXComponent=!0;const h3={toc:[]};function y3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}y3.isMDXComponent=!0;const f3={toc:[]};function k3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}k3.isMDXComponent=!0;const w3={toc:[]};function g3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}g3.isMDXComponent=!0;const M3={toc:[]};function D3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}D3.isMDXComponent=!0;const _3={toc:[]};function X3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}X3.isMDXComponent=!0;const x3={toc:[]};function v3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}v3.isMDXComponent=!0;const C3={toc:[]};function T3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}T3.isMDXComponent=!0;const b3={toc:[]};function L3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}L3.isMDXComponent=!0;const Z3={toc:[]};function N3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}N3.isMDXComponent=!0;const S3={toc:[]};function R3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}R3.isMDXComponent=!0;const E3={toc:[]};function z3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}z3.isMDXComponent=!0;const A3={toc:[]};function I3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},A3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}I3.isMDXComponent=!0;const P3={toc:[]};function F3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},P3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}F3.isMDXComponent=!0;const W3={toc:[]};function B3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}B3.isMDXComponent=!0;const G3={toc:[]};function O3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}O3.isMDXComponent=!0;const j3={toc:[]};function U3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}U3.isMDXComponent=!0;const q3={toc:[]};function V3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}V3.isMDXComponent=!0;const $3={toc:[]};function H3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}H3.isMDXComponent=!0;const J3={toc:[]};function Y3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}Y3.isMDXComponent=!0;const K3={toc:[]};function Q3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Q3.isMDXComponent=!0;const t4={toc:[]};function e4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}e4.isMDXComponent=!0;const n4={toc:[]};function o4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}o4.isMDXComponent=!0;const s4={toc:[]};function r4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}r4.isMDXComponent=!0;const i4={toc:[]};function a4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}a4.isMDXComponent=!0;const p4={toc:[]};function c4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},p4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}c4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}d4.isMDXComponent=!0;const h4={toc:[]};function y4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}y4.isMDXComponent=!0;const f4={toc:[]};function k4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}k4.isMDXComponent=!0;const w4={toc:[]};function g4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}g4.isMDXComponent=!0;const M4={toc:[]};function D4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}D4.isMDXComponent=!0;const _4={toc:[]};function X4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}X4.isMDXComponent=!0;const x4={toc:[]};function v4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}v4.isMDXComponent=!0;const C4={toc:[]};function T4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}T4.isMDXComponent=!0;const b4={toc:[]};function L4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}L4.isMDXComponent=!0;const Z4={toc:[]};function N4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}N4.isMDXComponent=!0;const S4={toc:[]};function R4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}R4.isMDXComponent=!0;const E4={toc:[]};function z4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}z4.isMDXComponent=!0;const A4={toc:[]};function I4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},A4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}I4.isMDXComponent=!0;const P4={toc:[]};function F4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},P4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}F4.isMDXComponent=!0;const W4={toc:[]};function B4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}B4.isMDXComponent=!0;const G4={toc:[]};function O4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}O4.isMDXComponent=!0;const j4={toc:[]};function U4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}U4.isMDXComponent=!0;const q4={toc:[]};function V4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}V4.isMDXComponent=!0;const $4={toc:[]};function H4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}H4.isMDXComponent=!0;const J4={toc:[]};function Y4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Y4.isMDXComponent=!0;const K4={toc:[]};function Q4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Q4.isMDXComponent=!0;const t6={toc:[]};function e6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}e6.isMDXComponent=!0;const n6={toc:[]};function o6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}o6.isMDXComponent=!0;const s6={toc:[]};function r6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}r6.isMDXComponent=!0;const i6={toc:[]};function a6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}a6.isMDXComponent=!0;const p6={toc:[]};function c6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},p6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}c6.isMDXComponent=!0;const l6={toc:[]};function u6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}u6.isMDXComponent=!0;const m6={toc:[]};function d6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}d6.isMDXComponent=!0;const h6={toc:[]};function y6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}y6.isMDXComponent=!0;const f6={toc:[]};function k6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}k6.isMDXComponent=!0;const w6={toc:[]};function g6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}g6.isMDXComponent=!0;const M6={toc:[]};function D6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}D6.isMDXComponent=!0;const _6={toc:[]};function X6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}X6.isMDXComponent=!0;const x6={toc:[]};function v6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}v6.isMDXComponent=!0;const C6={toc:[]};function T6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}T6.isMDXComponent=!0;const b6={toc:[]};function L6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}L6.isMDXComponent=!0;const Z6={toc:[]};function N6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}N6.isMDXComponent=!0;const S6={toc:[]};function R6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}R6.isMDXComponent=!0;const E6={toc:[]};function z6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}z6.isMDXComponent=!0;const A6={toc:[]};function I6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},A6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}I6.isMDXComponent=!0;const P6={toc:[]};function F6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},P6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}F6.isMDXComponent=!0;const W6={toc:[]};function B6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}B6.isMDXComponent=!0;const G6={toc:[]};function O6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}O6.isMDXComponent=!0;const j6={toc:[]};function U6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}U6.isMDXComponent=!0;const q6={toc:[]};function V6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}V6.isMDXComponent=!0;const $6={toc:[]};function H6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}H6.isMDXComponent=!0;const J6={toc:[]};function Y6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Y6.isMDXComponent=!0;const K6={toc:[]};function Q6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}Q6.isMDXComponent=!0;const t5={toc:[]};function e5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}e5.isMDXComponent=!0;const n5={toc:[]};function o5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}o5.isMDXComponent=!0;const s5={toc:[]};function r5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}r5.isMDXComponent=!0;const i5={toc:[]};function a5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}a5.isMDXComponent=!0;const p5={toc:[]};function c5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},p5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}c5.isMDXComponent=!0;const l5={toc:[]};function u5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}u5.isMDXComponent=!0;const m5={toc:[]};function d5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}d5.isMDXComponent=!0;const h5={toc:[]};function y5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}y5.isMDXComponent=!0;const f5={toc:[]};function k5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}k5.isMDXComponent=!0;const w5={toc:[]};function g5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}g5.isMDXComponent=!0;const M5={toc:[]};function D5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}D5.isMDXComponent=!0;const _5={toc:[]};function X5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}X5.isMDXComponent=!0;const x5={toc:[]};function v5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}v5.isMDXComponent=!0;const C5={toc:[]};function T5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}T5.isMDXComponent=!0;const b5={toc:[]};function L5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}L5.isMDXComponent=!0;const Z5={toc:[]};function N5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}N5.isMDXComponent=!0;const S5={toc:[]};function R5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}R5.isMDXComponent=!0;const E5={toc:[]};function z5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}z5.isMDXComponent=!0;const A5={toc:[]};function I5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},A5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}I5.isMDXComponent=!0;const P5={toc:[]};function F5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},P5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}F5.isMDXComponent=!0;const W5={toc:[]};function B5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}B5.isMDXComponent=!0;const G5={toc:[]};function O5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}O5.isMDXComponent=!0;const j5={toc:[]};function U5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}U5.isMDXComponent=!0;const q5={toc:[]};function V5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}V5.isMDXComponent=!0;const $5={toc:[]};function H5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}H5.isMDXComponent=!0;const J5={toc:[]};function Y5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Y5.isMDXComponent=!0;const K5={toc:[]};function Q5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}Q5.isMDXComponent=!0;const t7={toc:[]};function e7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}e7.isMDXComponent=!0;const n7={toc:[]};function o7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}o7.isMDXComponent=!0;const s7={toc:[]};function r7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}r7.isMDXComponent=!0;const i7={toc:[]};function a7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}a7.isMDXComponent=!0;const p7={toc:[]};function c7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},p7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}c7.isMDXComponent=!0;const l7={toc:[]};function u7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}u7.isMDXComponent=!0;const m7={toc:[]};function d7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}d7.isMDXComponent=!0;const h7={toc:[]};function y7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}y7.isMDXComponent=!0;const f7={toc:[]};function k7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}k7.isMDXComponent=!0;const w7={toc:[]};function g7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}g7.isMDXComponent=!0;const M7={toc:[]};function D7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}D7.isMDXComponent=!0;const _7={toc:[]};function X7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}X7.isMDXComponent=!0;const x7={toc:[]};function v7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}v7.isMDXComponent=!0;const C7={toc:[]};function T7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}T7.isMDXComponent=!0;const b7={toc:[]};function L7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}L7.isMDXComponent=!0;const Z7={toc:[]};function N7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}N7.isMDXComponent=!0;const S7={toc:[]};function R7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}R7.isMDXComponent=!0;const E7={toc:[]};function z7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}z7.isMDXComponent=!0;const A7={toc:[]};function I7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},A7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}I7.isMDXComponent=!0;const P7={toc:[]};function F7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},P7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}F7.isMDXComponent=!0;const W7={toc:[]};function B7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}B7.isMDXComponent=!0;const G7={toc:[]};function O7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}O7.isMDXComponent=!0;const j7={toc:[]};function U7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}U7.isMDXComponent=!0;const q7={toc:[]};function V7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}V7.isMDXComponent=!0;const $7={toc:[]};function H7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}H7.isMDXComponent=!0;const J7={toc:[]};function Y7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Y7.isMDXComponent=!0;const K7={toc:[]};function Q7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Q7.isMDXComponent=!0;const t9={toc:[]};function e9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}e9.isMDXComponent=!0;const n9={toc:[]};function o9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}o9.isMDXComponent=!0;const s9={toc:[]};function r9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}r9.isMDXComponent=!0;const i9={toc:[]};function a9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}a9.isMDXComponent=!0;const p9={toc:[]};function c9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},p9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}c9.isMDXComponent=!0;const l9={toc:[]};function u9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}u9.isMDXComponent=!0;const m9={toc:[]};function d9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}d9.isMDXComponent=!0;const h9={toc:[]};function y9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}y9.isMDXComponent=!0;const f9={toc:[]};function k9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}k9.isMDXComponent=!0;const w9={toc:[]};function g9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}g9.isMDXComponent=!0;const M9={toc:[]};function D9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}D9.isMDXComponent=!0;const _9={toc:[]};function X9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}X9.isMDXComponent=!0;const x9={toc:[]};function v9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}v9.isMDXComponent=!0;const C9={toc:[]};function T9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}T9.isMDXComponent=!0;const b9={toc:[]};function L9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}L9.isMDXComponent=!0;const Z9={toc:[]};function N9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}N9.isMDXComponent=!0;const S9={toc:[]};function R9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}R9.isMDXComponent=!0;const E9={toc:[]};function z9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}z9.isMDXComponent=!0;const A9={toc:[]};function I9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},A9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}I9.isMDXComponent=!0;const P9={toc:[]};function F9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},P9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}F9.isMDXComponent=!0;const W9={toc:[]};function B9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}B9.isMDXComponent=!0;const G9={toc:[]};function O9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}O9.isMDXComponent=!0;const j9={toc:[]};function U9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}U9.isMDXComponent=!0;const q9={toc:[]};function V9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}V9.isMDXComponent=!0;const $9={toc:[]};function H9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}H9.isMDXComponent=!0;const J9={toc:[]};function Y9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Y9.isMDXComponent=!0;const K9={toc:[]};function Q9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Q9.isMDXComponent=!0;const ttt={toc:[]};function ett(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ttt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}ett.isMDXComponent=!0;const ntt={toc:[]};function ott(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ntt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}ott.isMDXComponent=!0;const stt={toc:[]};function rtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},stt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}rtt.isMDXComponent=!0;const itt={toc:[]};function att(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},itt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}att.isMDXComponent=!0;const ptt={toc:[]};function ctt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ptt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}ctt.isMDXComponent=!0;const ltt={toc:[]};function utt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ltt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}utt.isMDXComponent=!0;const mtt={toc:[]};function dtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}dtt.isMDXComponent=!0;const htt={toc:[]};function ytt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},htt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}ytt.isMDXComponent=!0;const ftt={toc:[]};function ktt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ftt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}ktt.isMDXComponent=!0;const wtt={toc:[]};function gtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}gtt.isMDXComponent=!0;const Mtt={toc:[]};function Dtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Dtt.isMDXComponent=!0;const _tt={toc:[]};function Xtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_tt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Xtt.isMDXComponent=!0;const xtt={toc:[]};function vtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}vtt.isMDXComponent=!0;const Ctt={toc:[]};function Ttt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ctt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}Ttt.isMDXComponent=!0;const btt={toc:[]};function Ltt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},btt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Ltt.isMDXComponent=!0;const Ztt={toc:[]};function Ntt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ztt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}Ntt.isMDXComponent=!0;const Stt={toc:[]};function Rtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Stt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Rtt.isMDXComponent=!0;const Ett={toc:[]};function ztt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ett,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ztt.isMDXComponent=!0;const Att={toc:[]};function Itt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Att,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Itt.isMDXComponent=!0;const Ptt={toc:[]};function Ftt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ptt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}Ftt.isMDXComponent=!0;const Wtt={toc:[]};function Btt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Btt.isMDXComponent=!0;const Gtt={toc:[]};function Ott(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Ott.isMDXComponent=!0;const jtt={toc:[]};function Utt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Utt.isMDXComponent=!0;const qtt={toc:[]};function Vtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Vtt.isMDXComponent=!0;const $tt={toc:[]};function Htt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$tt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}Htt.isMDXComponent=!0;const Jtt={toc:[]};function Ytt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Ytt.isMDXComponent=!0;const Ktt={toc:[]};function Qtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ktt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}Qtt.isMDXComponent=!0;const tet={toc:[]};function eet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}eet.isMDXComponent=!0;const net={toc:[]};function oet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},net,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}oet.isMDXComponent=!0;const set={toc:[]};function ret(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},set,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ret.isMDXComponent=!0;const iet={toc:[]};function aet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}aet.isMDXComponent=!0;const pet={toc:[]};function cet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}cet.isMDXComponent=!0;const uet={toc:[]};function met(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}met.isMDXComponent=!0;const det={toc:[]};function het(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},det,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}het.isMDXComponent=!0;const yet={toc:[]};function fet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}fet.isMDXComponent=!0;const ket={toc:[]};function wet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ket,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}wet.isMDXComponent=!0;const get={toc:[]};function Met(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},get,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}Met.isMDXComponent=!0;const Det={toc:[]};function _et(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Det,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}_et.isMDXComponent=!0;const Xet={toc:[]};function xet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}xet.isMDXComponent=!0;const vet={toc:[]};function Cet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Cet.isMDXComponent=!0;const Tet={toc:[]};function bet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}bet.isMDXComponent=!0;const Let={toc:[]};function Zet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Let,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Zet.isMDXComponent=!0;const Net={toc:[]};function Set(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Net,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}Set.isMDXComponent=!0;const Ret={toc:[]};function Eet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ret,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}Eet.isMDXComponent=!0;const zet={toc:[]};function Aet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Aet.isMDXComponent=!0;const Iet={toc:[]};function Pet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}Pet.isMDXComponent=!0;const Fet={toc:[]};function Wet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}Wet.isMDXComponent=!0;const Bet={toc:[]};function Get(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Get.isMDXComponent=!0;const Oet={toc:[]};function jet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}jet.isMDXComponent=!0;const Uet={toc:[]};function qet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}qet.isMDXComponent=!0;const Vet={toc:[]};function $et(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}$et.isMDXComponent=!0;const Het={toc:[]};function Jet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Het,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}Jet.isMDXComponent=!0;const Yet={toc:[]};function Ket(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Ket.isMDXComponent=!0;const Qet={toc:[]};function tnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}tnt.isMDXComponent=!0;const ent={toc:[]};function nnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ent,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}nnt.isMDXComponent=!0;const ont={toc:[]};function snt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ont,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}snt.isMDXComponent=!0;const rnt={toc:[]};function int(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}int.isMDXComponent=!0;const ant={toc:[]};function pnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ant,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}pnt.isMDXComponent=!0;const cnt={toc:[]};function lnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}lnt.isMDXComponent=!0;const unt={toc:[]};function mnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},unt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}mnt.isMDXComponent=!0;const dnt={toc:[]};function hnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}hnt.isMDXComponent=!0;const ynt={toc:[]};function fnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ynt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}fnt.isMDXComponent=!0;const knt={toc:[]};function wnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},knt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}wnt.isMDXComponent=!0;const gnt={toc:[]};function Mnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Mnt.isMDXComponent=!0;const Dnt={toc:[]};function _nt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}_nt.isMDXComponent=!0;const Xnt={toc:[]};function xnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}xnt.isMDXComponent=!0;const vnt={toc:[]};function Cnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}Cnt.isMDXComponent=!0;const Tnt={toc:[]};function bnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}bnt.isMDXComponent=!0;const Lnt={toc:[]};function Znt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Znt.isMDXComponent=!0;const Nnt={toc:[]};function Snt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Snt.isMDXComponent=!0;const Rnt={toc:[]};function Ent(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Ent.isMDXComponent=!0;const znt={toc:[]};function Ant(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},znt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Ant.isMDXComponent=!0;const Int={toc:[]};function Pnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Int,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}Pnt.isMDXComponent=!0;const Fnt={toc:[]};function Wnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}Wnt.isMDXComponent=!0;const Bnt={toc:[]};function Gnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}Gnt.isMDXComponent=!0;const Ont={toc:[]};function jnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ont,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}jnt.isMDXComponent=!0;const Unt={toc:[]};function qnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Unt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}qnt.isMDXComponent=!0;const Vnt={toc:[]};function $nt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}$nt.isMDXComponent=!0;const Hnt={toc:[]};function Jnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}Jnt.isMDXComponent=!0;const Ynt={toc:[]};function Knt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ynt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}Knt.isMDXComponent=!0;const Qnt={toc:[]};function tot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}tot.isMDXComponent=!0;const eot={toc:[]};function not(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}not.isMDXComponent=!0;const oot={toc:[]};function sot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}sot.isMDXComponent=!0;const rot={toc:[]};function iot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}iot.isMDXComponent=!0;const aot={toc:[]};function pot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}pot.isMDXComponent=!0;const cot={toc:[]};function lot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}lot.isMDXComponent=!0;const uot={toc:[]};function mot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}mot.isMDXComponent=!0;const dot={toc:[]};function hot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}hot.isMDXComponent=!0;const yot={toc:[]};function fot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}fot.isMDXComponent=!0;const kot={toc:[]};function wot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}wot.isMDXComponent=!0;const got={toc:[]};function Mot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},got,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}Mot.isMDXComponent=!0;const Dot={toc:[]};function _ot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}_ot.isMDXComponent=!0;const Xot={toc:[]};function xot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}xot.isMDXComponent=!0;const vot={toc:[]};function Cot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Cot.isMDXComponent=!0;const Tot={toc:[]};function bot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}bot.isMDXComponent=!0;const Lot={toc:[]};function Zot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Zot.isMDXComponent=!0;const Not={toc:[]};function Sot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Not,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Sot.isMDXComponent=!0;const Rot={toc:[]};function Eot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Eot.isMDXComponent=!0;const zot={toc:[]};function Aot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Aot.isMDXComponent=!0;const Iot={toc:[]};function Pot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Pot.isMDXComponent=!0;const Fot={toc:[]};function Wot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}Wot.isMDXComponent=!0;const Bot={toc:[]};function Got(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Got.isMDXComponent=!0;const Oot={toc:[]};function jot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}jot.isMDXComponent=!0;const Uot={toc:[]};function qot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}qot.isMDXComponent=!0;const Vot={toc:[]};function $ot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}$ot.isMDXComponent=!0;const Hot={toc:[]};function Jot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}Jot.isMDXComponent=!0;const Yot={toc:[]};function Kot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Kot.isMDXComponent=!0;const Qot={toc:[]};function tst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}tst.isMDXComponent=!0;const est={toc:[]};function nst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},est,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}nst.isMDXComponent=!0;const ost={toc:[]};function sst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ost,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}sst.isMDXComponent=!0;const rst={toc:[]};function ist(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}ist.isMDXComponent=!0;const ast={toc:[]};function pst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ast,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}pst.isMDXComponent=!0;const cst={toc:[]};function lst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}lst.isMDXComponent=!0;const ust={toc:[]};function mst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ust,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}mst.isMDXComponent=!0;const dst={toc:[]};function hst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}hst.isMDXComponent=!0;const yst={toc:[]};function fst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}fst.isMDXComponent=!0;const kst={toc:[]};function wst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}wst.isMDXComponent=!0;const gst={toc:[]};function Mst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}Mst.isMDXComponent=!0;const Dst={toc:[]};function _st(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}_st.isMDXComponent=!0;const Xst={toc:[]};function xst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}xst.isMDXComponent=!0;const vst={toc:[]};function Cst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Cst.isMDXComponent=!0;const Tst={toc:[]};function bst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}bst.isMDXComponent=!0;const Lst={toc:[]};function Zst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Zst.isMDXComponent=!0;const Nst={toc:[]};function Sst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Sst.isMDXComponent=!0;const Rst={toc:[]};function Est(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}Est.isMDXComponent=!0;const zst={toc:[]};function Ast(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Ast.isMDXComponent=!0;const Ist={toc:[]};function Pst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ist,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Pst.isMDXComponent=!0;const Fst={toc:[]};function Wst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}Wst.isMDXComponent=!0;const Bst={toc:[]};function Gst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}Gst.isMDXComponent=!0;const Ost={toc:[]};function jst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ost,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}jst.isMDXComponent=!0;const Ust={toc:[]};function qst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ust,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}qst.isMDXComponent=!0;const Vst={toc:[]};function $st(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}$st.isMDXComponent=!0;const Hst={toc:[]};function Jst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Jst.isMDXComponent=!0;const Yst={toc:[]};function Kst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Kst.isMDXComponent=!0;const Qst={toc:[]};function trt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}trt.isMDXComponent=!0;const ert={toc:[]};function nrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ert,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}nrt.isMDXComponent=!0;const ort={toc:[]};function srt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ort,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}srt.isMDXComponent=!0;const rrt={toc:[]};function irt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}irt.isMDXComponent=!0;const art={toc:[]};function prt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},art,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}prt.isMDXComponent=!0;const crt={toc:[]};function lrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},crt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lrt.isMDXComponent=!0;const urt={toc:[]};function mrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},urt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}mrt.isMDXComponent=!0;const drt={toc:[]};function hrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},drt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}hrt.isMDXComponent=!0;const yrt={toc:[]};function frt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}frt.isMDXComponent=!0;const krt={toc:[]};function wrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},krt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wrt.isMDXComponent=!0;const grt={toc:[]};function Mrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},grt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Mrt.isMDXComponent=!0;const Drt={toc:[]};function _rt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Drt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}_rt.isMDXComponent=!0;const Xrt={toc:[]};function xrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}xrt.isMDXComponent=!0;const vrt={toc:[]};function Crt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}Crt.isMDXComponent=!0;const Trt={toc:[]};function brt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Trt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}brt.isMDXComponent=!0;const Lrt={toc:[]};function Zrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}Zrt.isMDXComponent=!0;const Nrt={toc:[]};function Srt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Srt.isMDXComponent=!0;const Rrt={toc:[]};function Ert(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Ert.isMDXComponent=!0;const zrt={toc:[]};function Art(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}Art.isMDXComponent=!0;const Irt={toc:[]};function Prt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Irt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}Prt.isMDXComponent=!0;const Frt={toc:[]};function Wrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Frt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Wrt.isMDXComponent=!0;const Brt={toc:[]};function Grt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Brt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}Grt.isMDXComponent=!0;const Ort={toc:[]};function jrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ort,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}jrt.isMDXComponent=!0;const Urt={toc:[]};function qrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Urt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}qrt.isMDXComponent=!0;const Vrt={toc:[]};function $rt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}$rt.isMDXComponent=!0;const Hrt={toc:[]};function Jrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Jrt.isMDXComponent=!0;const Yrt={toc:[]};function Krt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Krt.isMDXComponent=!0;const Qrt={toc:[]};function tit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}tit.isMDXComponent=!0;const eit={toc:[]};function nit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}nit.isMDXComponent=!0;const oit={toc:[]};function sit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}sit.isMDXComponent=!0;const rit={toc:[]};function iit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}iit.isMDXComponent=!0;const ait={toc:[]};function pit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ait,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}pit.isMDXComponent=!0;const cit={toc:[]};function lit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}lit.isMDXComponent=!0;const uit={toc:[]};function mit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}mit.isMDXComponent=!0;const dit={toc:[]};function hit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}hit.isMDXComponent=!0;const yit={toc:[]};function fit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}fit.isMDXComponent=!0;const kit={toc:[]};function wit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}wit.isMDXComponent=!0;const git={toc:[]};function Mit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},git,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Mit.isMDXComponent=!0;const Dit={toc:[]};function _it(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}_it.isMDXComponent=!0;const Xit={toc:[]};function xit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}xit.isMDXComponent=!0;const vit={toc:[]};function Cit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}Cit.isMDXComponent=!0;const Tit={toc:[]};function bit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}bit.isMDXComponent=!0;const Lit={toc:[]};function Zit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}Zit.isMDXComponent=!0;const Nit={toc:[]};function Sit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Sit.isMDXComponent=!0;const Rit={toc:[]};function Eit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}Eit.isMDXComponent=!0;const zit={toc:[]};function Ait(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Ait.isMDXComponent=!0;const Iit={toc:[]};function Pit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}Pit.isMDXComponent=!0;const Fit={toc:[]};function Wit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Wit.isMDXComponent=!0;const Bit={toc:[]};function Git(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}Git.isMDXComponent=!0;const Oit={toc:[]};function jit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}jit.isMDXComponent=!0;const Uit={toc:[]};function qit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}qit.isMDXComponent=!0;const Vit={toc:[]};function $it(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}$it.isMDXComponent=!0;const Hit={toc:[]};function Jit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Jit.isMDXComponent=!0;const Yit={toc:[]};function Kit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}Kit.isMDXComponent=!0;const Qit={toc:[]};function tat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}tat.isMDXComponent=!0;const eat={toc:[]};function nat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}nat.isMDXComponent=!0;const oat={toc:[]};function sat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}sat.isMDXComponent=!0;const rat={toc:[]};function iat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}iat.isMDXComponent=!0;const aat={toc:[]};function pat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}pat.isMDXComponent=!0;const cat={toc:[]};function lat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}lat.isMDXComponent=!0;const uat={toc:[]};function mat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}mat.isMDXComponent=!0;const dat={toc:[]};function hat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}hat.isMDXComponent=!0;const yat={toc:[]};function fat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}fat.isMDXComponent=!0;const kat={toc:[]};function wat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}wat.isMDXComponent=!0;const gat={toc:[]};function Mat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}Mat.isMDXComponent=!0;const Dat={toc:[]};function _at(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}_at.isMDXComponent=!0;const Xat={toc:[]};function xat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}xat.isMDXComponent=!0;const vat={toc:[]};function Cat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}Cat.isMDXComponent=!0;const Tat={toc:[]};function bat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}bat.isMDXComponent=!0;const Lat={toc:[]};function Zat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}Zat.isMDXComponent=!0;const Nat={toc:[]};function Sat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Sat.isMDXComponent=!0;const Rat={toc:[]};function Eat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}Eat.isMDXComponent=!0;const zat={toc:[]};function Aat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Aat.isMDXComponent=!0;const Iat={toc:[]};function Pat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Pat.isMDXComponent=!0;const Fat={toc:[]};function Wat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}Wat.isMDXComponent=!0;const Bat={toc:[]};function Gat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Gat.isMDXComponent=!0;const Oat={toc:[]};function jat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}jat.isMDXComponent=!0;const Uat={toc:[]};function qat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}qat.isMDXComponent=!0;const Vat={toc:[]};function $at(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}$at.isMDXComponent=!0;const Hat={toc:[]};function Jat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Jat.isMDXComponent=!0;const Yat={toc:[]};function Kat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Kat.isMDXComponent=!0;const Qat={toc:[]};function tpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}tpt.isMDXComponent=!0;const ept={toc:[]};function npt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ept,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}npt.isMDXComponent=!0;const opt={toc:[]};function spt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},opt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}spt.isMDXComponent=!0;const rpt={toc:[]};function ipt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}ipt.isMDXComponent=!0;const apt={toc:[]};function ppt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},apt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}ppt.isMDXComponent=!0;const cpt={toc:[]};function lpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lpt.isMDXComponent=!0;const upt={toc:[]};function mpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},upt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}mpt.isMDXComponent=!0;const dpt={toc:[]};function hpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}hpt.isMDXComponent=!0;const ypt={toc:[]};function fpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ypt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}fpt.isMDXComponent=!0;const kpt={toc:[]};function wpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}wpt.isMDXComponent=!0;const gpt={toc:[]};function Mpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Mpt.isMDXComponent=!0;const Dpt={toc:[]};function _pt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}_pt.isMDXComponent=!0;const Xpt={toc:[]};function xpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}xpt.isMDXComponent=!0;const vpt={toc:[]};function Cpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Cpt.isMDXComponent=!0;const Tpt={toc:[]};function bpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}bpt.isMDXComponent=!0;const Lpt={toc:[]};function Zpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}Zpt.isMDXComponent=!0;const Npt={toc:[]};function Spt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Npt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Spt.isMDXComponent=!0;const Rpt={toc:[]};function Ept(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}Ept.isMDXComponent=!0;const zpt={toc:[]};function Apt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Apt.isMDXComponent=!0;const Ipt={toc:[]};function Ppt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ipt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}Ppt.isMDXComponent=!0;const Fpt={toc:[]};function Wpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Wpt.isMDXComponent=!0;const Bpt={toc:[]};function Gpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}Gpt.isMDXComponent=!0;const Opt={toc:[]};function jpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Opt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}jpt.isMDXComponent=!0;const Upt={toc:[]};function qpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Upt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}qpt.isMDXComponent=!0;const Vpt={toc:[]};function $pt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}$pt.isMDXComponent=!0;const Hpt={toc:[]};function Jpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Jpt.isMDXComponent=!0;const Ypt={toc:[]};function Kpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ypt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Kpt.isMDXComponent=!0;const Qpt={toc:[]};function tct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}tct.isMDXComponent=!0;const ect={toc:[]};function nct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ect,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}nct.isMDXComponent=!0;const oct={toc:[]};function sct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}sct.isMDXComponent=!0;const rct={toc:[]};function ict(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}ict.isMDXComponent=!0;const act={toc:[]};function pct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},act,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pct.isMDXComponent=!0;const cct={toc:[]};function lct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}lct.isMDXComponent=!0;const uct={toc:[]};function mct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}mct.isMDXComponent=!0;const dct={toc:[]};function hct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}hct.isMDXComponent=!0;const yct={toc:[]};function fct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}fct.isMDXComponent=!0;const kct={toc:[]};function wct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}wct.isMDXComponent=!0;const gct={toc:[]};function Mct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Mct.isMDXComponent=!0;const Dct={toc:[]};function _ct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}_ct.isMDXComponent=!0;const Xct={toc:[]};function xct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}xct.isMDXComponent=!0;const vct={toc:[]};function Cct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}Cct.isMDXComponent=!0;const Tct={toc:[]};function bct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}bct.isMDXComponent=!0;const Lct={toc:[]};function Zct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}Zct.isMDXComponent=!0;const Nct={toc:[]};function Sct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Sct.isMDXComponent=!0;const Rct={toc:[]};function Ect(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Ect.isMDXComponent=!0;const zct={toc:[]};function Act(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Act.isMDXComponent=!0;const Ict={toc:[]};function Pct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ict,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}Pct.isMDXComponent=!0;const Fct={toc:[]};function Wct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Wct.isMDXComponent=!0;const Bct={toc:[]};function Gct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Gct.isMDXComponent=!0;const Oct={toc:[]};function jct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}jct.isMDXComponent=!0;const Uct={toc:[]};function qct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}qct.isMDXComponent=!0;const Vct={toc:[]};function $ct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}$ct.isMDXComponent=!0;const Hct={toc:[]};function Jct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Jct.isMDXComponent=!0;const Yct={toc:[]};function Kct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}Kct.isMDXComponent=!0;const Qct={toc:[]};function tlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}tlt.isMDXComponent=!0;const elt={toc:[]};function nlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},elt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}nlt.isMDXComponent=!0;const olt={toc:[]};function slt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},olt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}slt.isMDXComponent=!0;const rlt={toc:[]};function ilt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}ilt.isMDXComponent=!0;const alt={toc:[]};function plt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},alt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}plt.isMDXComponent=!0;const clt={toc:[]};function llt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},clt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}llt.isMDXComponent=!0;const ult={toc:[]};function mlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ult,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}mlt.isMDXComponent=!0;const dlt={toc:[]};function hlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}hlt.isMDXComponent=!0;const ylt={toc:[]};function flt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ylt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}flt.isMDXComponent=!0;const klt={toc:[]};function wlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},klt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}wlt.isMDXComponent=!0;const glt={toc:[]};function Mlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},glt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}Mlt.isMDXComponent=!0;const Dlt={toc:[]};function _lt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}_lt.isMDXComponent=!0;const Xlt={toc:[]};function xlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}xlt.isMDXComponent=!0;const vlt={toc:[]};function Clt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Clt.isMDXComponent=!0;const Tlt={toc:[]};function blt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}blt.isMDXComponent=!0;const Llt={toc:[]};function Zlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Llt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Zlt.isMDXComponent=!0;const Nlt={toc:[]};function Slt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Slt.isMDXComponent=!0;const Rlt={toc:[]};function Elt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Elt.isMDXComponent=!0;const zlt={toc:[]};function Alt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}Alt.isMDXComponent=!0;const Ilt={toc:[]};function Plt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ilt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Plt.isMDXComponent=!0;const Flt={toc:[]};function Wlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Flt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Wlt.isMDXComponent=!0;const Blt={toc:[]};function Glt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Blt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Glt.isMDXComponent=!0;const Olt={toc:[]};function jlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Olt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}jlt.isMDXComponent=!0;const Ult={toc:[]};function qlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ult,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}qlt.isMDXComponent=!0;const Vlt={toc:[]};function $lt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}$lt.isMDXComponent=!0;const Hlt={toc:[]};function Jlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}Jlt.isMDXComponent=!0;const Ylt={toc:[]};function Klt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ylt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Klt.isMDXComponent=!0;const Qlt={toc:[]};function tut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}tut.isMDXComponent=!0;const eut={toc:[]};function nut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}nut.isMDXComponent=!0;const out={toc:[]};function sut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},out,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}sut.isMDXComponent=!0;const rut={toc:[]};function iut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}iut.isMDXComponent=!0;const aut={toc:[]};function put(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}put.isMDXComponent=!0;const cut={toc:[]};function lut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}lut.isMDXComponent=!0;const uut={toc:[]};function mut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}mut.isMDXComponent=!0;const dut={toc:[]};function hut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}hut.isMDXComponent=!0;const yut={toc:[]};function fut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}fut.isMDXComponent=!0;const kut={toc:[]};function wut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}wut.isMDXComponent=!0;const gut={toc:[]};function Mut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Mut.isMDXComponent=!0;const Dut={toc:[]};function _ut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}_ut.isMDXComponent=!0;const Xut={toc:[]};function xut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}xut.isMDXComponent=!0;const vut={toc:[]};function Cut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}Cut.isMDXComponent=!0;const Tut={toc:[]};function but(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}but.isMDXComponent=!0;const Lut={toc:[]};function Zut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Zut.isMDXComponent=!0;const Nut={toc:[]};function Sut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}Sut.isMDXComponent=!0;const Rut={toc:[]};function Eut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Eut.isMDXComponent=!0;const zut={toc:[]};function Aut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}Aut.isMDXComponent=!0;const Iut={toc:[]};function Put(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Put.isMDXComponent=!0;const Fut={toc:[]};function Wut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Wut.isMDXComponent=!0;const But={toc:[]};function Gut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},But,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Gut.isMDXComponent=!0;const Out={toc:[]};function jut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Out,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}jut.isMDXComponent=!0;const Uut={toc:[]};function qut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}qut.isMDXComponent=!0;const Vut={toc:[]};function $ut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}$ut.isMDXComponent=!0;const Hut={toc:[]};function Jut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}Jut.isMDXComponent=!0;const Yut={toc:[]};function Kut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}Kut.isMDXComponent=!0;const Qut={toc:[]};function tmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}tmt.isMDXComponent=!0;const emt={toc:[]};function nmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},emt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}nmt.isMDXComponent=!0;const omt={toc:[]};function smt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},omt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}smt.isMDXComponent=!0;const rmt={toc:[]};function imt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}imt.isMDXComponent=!0;const amt={toc:[]};function pmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},amt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}pmt.isMDXComponent=!0;const cmt={toc:[]};function lmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}lmt.isMDXComponent=!0;const umt={toc:[]};function mmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},umt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}mmt.isMDXComponent=!0;const dmt={toc:[]};function hmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}hmt.isMDXComponent=!0;const ymt={toc:[]};function fmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ymt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}fmt.isMDXComponent=!0;const kmt={toc:[]};function wmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}wmt.isMDXComponent=!0;const gmt={toc:[]};function Mmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Mmt.isMDXComponent=!0;const Dmt={toc:[]};function _mt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}_mt.isMDXComponent=!0;const Xmt={toc:[]};function xmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}xmt.isMDXComponent=!0;const vmt={toc:[]};function Cmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Cmt.isMDXComponent=!0;const Tmt={toc:[]};function bmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}bmt.isMDXComponent=!0;const Lmt={toc:[]};function Zmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}Zmt.isMDXComponent=!0;const Nmt={toc:[]};function Smt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Smt.isMDXComponent=!0;const Rmt={toc:[]};function Emt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Emt.isMDXComponent=!0;const zmt={toc:[]};function Amt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Amt.isMDXComponent=!0;const Imt={toc:[]};function Pmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Imt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Pmt.isMDXComponent=!0;const Fmt={toc:[]};function Wmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Wmt.isMDXComponent=!0;const Bmt={toc:[]};function Gmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Gmt.isMDXComponent=!0;const Omt={toc:[]};function jmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Omt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}jmt.isMDXComponent=!0;const Umt={toc:[]};function qmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Umt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}qmt.isMDXComponent=!0;const Vmt={toc:[]};function $mt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}$mt.isMDXComponent=!0;const Hmt={toc:[]};function Jmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}Jmt.isMDXComponent=!0;const Ymt={toc:[]};function Kmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ymt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Kmt.isMDXComponent=!0;const Qmt={toc:[]};function tdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}tdt.isMDXComponent=!0;const edt={toc:[]};function ndt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},edt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}ndt.isMDXComponent=!0;const odt={toc:[]};function sdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},odt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}sdt.isMDXComponent=!0;const rdt={toc:[]};function idt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}idt.isMDXComponent=!0;const adt={toc:[]};function pdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},adt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}pdt.isMDXComponent=!0;const cdt={toc:[]};function ldt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}ldt.isMDXComponent=!0;const udt={toc:[]};function mdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},udt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}mdt.isMDXComponent=!0;const ddt={toc:[]};function hdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ddt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}hdt.isMDXComponent=!0;const ydt={toc:[]};function fdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ydt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}fdt.isMDXComponent=!0;const kdt={toc:[]};function wdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}wdt.isMDXComponent=!0;const gdt={toc:[]};function Mdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Mdt.isMDXComponent=!0;const Ddt={toc:[]};function _dt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ddt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}_dt.isMDXComponent=!0;const Xdt={toc:[]};function xdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}xdt.isMDXComponent=!0;const vdt={toc:[]};function Cdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}Cdt.isMDXComponent=!0;const Tdt={toc:[]};function bdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}bdt.isMDXComponent=!0;const Ldt={toc:[]};function Zdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ldt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}Zdt.isMDXComponent=!0;const Ndt={toc:[]};function Sdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ndt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Sdt.isMDXComponent=!0;const Rdt={toc:[]};function Edt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Edt.isMDXComponent=!0;const zdt={toc:[]};function Adt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Adt.isMDXComponent=!0;const Idt={toc:[]};function Pdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Idt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}Pdt.isMDXComponent=!0;const Fdt={toc:[]};function Wdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Wdt.isMDXComponent=!0;const Bdt={toc:[]};function Gdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Gdt.isMDXComponent=!0;const Odt={toc:[]};function jdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Odt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}jdt.isMDXComponent=!0;const Udt={toc:[]};function qdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Udt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qdt.isMDXComponent=!0;const Vdt={toc:[]};function $dt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}$dt.isMDXComponent=!0;const Hdt={toc:[]};function Jdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}Jdt.isMDXComponent=!0;const Ydt={toc:[]};function Kdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ydt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}Kdt.isMDXComponent=!0;const Qdt={toc:[]};function tht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}tht.isMDXComponent=!0;const eht={toc:[]};function nht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}nht.isMDXComponent=!0;const oht={toc:[]};function sht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}sht.isMDXComponent=!0;const rht={toc:[]};function iht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}iht.isMDXComponent=!0;const aht={toc:[]};function pht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}pht.isMDXComponent=!0;const cht={toc:[]};function lht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}lht.isMDXComponent=!0;const uht={toc:[]};function mht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}mht.isMDXComponent=!0;const dht={toc:[]};function hht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}hht.isMDXComponent=!0;const yht={toc:[]};function fht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}fht.isMDXComponent=!0;const kht={toc:[]};function wht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}wht.isMDXComponent=!0;const ght={toc:[]};function Mht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ght,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Mht.isMDXComponent=!0;const Dht={toc:[]};function _ht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}_ht.isMDXComponent=!0;const Xht={toc:[]};function xht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}xht.isMDXComponent=!0;const vht={toc:[]};function Cht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Cht.isMDXComponent=!0;const Tht={toc:[]};function bht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}bht.isMDXComponent=!0;const Lht={toc:[]};function Zht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Zht.isMDXComponent=!0;const Nht={toc:[]};function Sht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}Sht.isMDXComponent=!0;const Rht={toc:[]};function Eht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Eht.isMDXComponent=!0;const zht={toc:[]};function Aht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}Aht.isMDXComponent=!0;const Iht={toc:[]};function Pht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}Pht.isMDXComponent=!0;const Fht={toc:[]};function Wht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}Wht.isMDXComponent=!0;const Bht={toc:[]};function Ght(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Ght.isMDXComponent=!0;const Oht={toc:[]};function jht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}jht.isMDXComponent=!0;const Uht={toc:[]};function qht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}qht.isMDXComponent=!0;const Vht={toc:[]};function $ht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}$ht.isMDXComponent=!0;const Hht={toc:[]};function Jht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Jht.isMDXComponent=!0;const Yht={toc:[]};function Kht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Kht.isMDXComponent=!0;const Qht={toc:[]};function tyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}tyt.isMDXComponent=!0;const eyt={toc:[]};function nyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}nyt.isMDXComponent=!0;const oyt={toc:[]};function syt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}syt.isMDXComponent=!0;const ryt={toc:[]};function iyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ryt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}iyt.isMDXComponent=!0;const ayt={toc:[]};function pyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ayt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}pyt.isMDXComponent=!0;const cyt={toc:[]};function lyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}lyt.isMDXComponent=!0;const uyt={toc:[]};function myt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}myt.isMDXComponent=!0;const dyt={toc:[]};function hyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}hyt.isMDXComponent=!0;const yyt={toc:[]};function fyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}fyt.isMDXComponent=!0;const kyt={toc:[]};function wyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}wyt.isMDXComponent=!0;const gyt={toc:[]};function Myt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}Myt.isMDXComponent=!0;const Dyt={toc:[]};function _yt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}_yt.isMDXComponent=!0;const Xyt={toc:[]};function xyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}xyt.isMDXComponent=!0;const vyt={toc:[]};function Cyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Cyt.isMDXComponent=!0;const Tyt={toc:[]};function byt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}byt.isMDXComponent=!0;const Lyt={toc:[]};function Zyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Zyt.isMDXComponent=!0;const Nyt={toc:[]};function Syt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}Syt.isMDXComponent=!0;const Ryt={toc:[]};function Eyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ryt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}Eyt.isMDXComponent=!0;const zyt={toc:[]};function Ayt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Ayt.isMDXComponent=!0;const Iyt={toc:[]};function Pyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}Pyt.isMDXComponent=!0;const Fyt={toc:[]};function Wyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Wyt.isMDXComponent=!0;const Byt={toc:[]};function Gyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Byt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Gyt.isMDXComponent=!0;const Oyt={toc:[]};function jyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}jyt.isMDXComponent=!0;const Uyt={toc:[]};function qyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}qyt.isMDXComponent=!0;const Vyt={toc:[]};function $yt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}$yt.isMDXComponent=!0;const Hyt={toc:[]};function Jyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Jyt.isMDXComponent=!0;const Yyt={toc:[]};function Kyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}Kyt.isMDXComponent=!0;const Qyt={toc:[]};function tft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}tft.isMDXComponent=!0;const eft={toc:[]};function nft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}nft.isMDXComponent=!0;const oft={toc:[]};function sft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}sft.isMDXComponent=!0;const rft={toc:[]};function ift(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}ift.isMDXComponent=!0;const aft={toc:[]};function pft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pft.isMDXComponent=!0;const cft={toc:[]};function lft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}lft.isMDXComponent=!0;const uft={toc:[]};function mft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}mft.isMDXComponent=!0;const dft={toc:[]};function hft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}hft.isMDXComponent=!0;const yft={toc:[]};function fft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}fft.isMDXComponent=!0;const kft={toc:[]};function wft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}wft.isMDXComponent=!0;const gft={toc:[]};function Mft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}Mft.isMDXComponent=!0;const Dft={toc:[]};function _ft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}_ft.isMDXComponent=!0;const Xft={toc:[]};function xft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}xft.isMDXComponent=!0;const vft={toc:[]};function Cft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Cft.isMDXComponent=!0;const Tft={toc:[]};function bft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}bft.isMDXComponent=!0;const Lft={toc:[]};function Zft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Zft.isMDXComponent=!0;const Nft={toc:[]};function Sft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}Sft.isMDXComponent=!0;const Rft={toc:[]};function Eft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}Eft.isMDXComponent=!0;const zft={toc:[]};function Aft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}Aft.isMDXComponent=!0;const Ift={toc:[]};function Pft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ift,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Pft.isMDXComponent=!0;const Fft={toc:[]};function Wft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Wft.isMDXComponent=!0;const Bft={toc:[]};function Gft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}Gft.isMDXComponent=!0;const Oft={toc:[]};function jft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}jft.isMDXComponent=!0;const Uft={toc:[]};function qft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}qft.isMDXComponent=!0;const Vft={toc:[]};function $ft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}$ft.isMDXComponent=!0;const Hft={toc:[]};function Jft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Jft.isMDXComponent=!0;const Yft={toc:[]};function Kft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}Kft.isMDXComponent=!0;const Qft={toc:[]};function tkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}tkt.isMDXComponent=!0;const ekt={toc:[]};function nkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ekt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}nkt.isMDXComponent=!0;const okt={toc:[]};function skt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},okt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}skt.isMDXComponent=!0;const rkt={toc:[]};function ikt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}ikt.isMDXComponent=!0;const akt={toc:[]};function pkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},akt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}pkt.isMDXComponent=!0;const ckt={toc:[]};function lkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ckt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}lkt.isMDXComponent=!0;const ukt={toc:[]};function mkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ukt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}mkt.isMDXComponent=!0;const dkt={toc:[]};function hkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}hkt.isMDXComponent=!0;const ykt={toc:[]};function fkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ykt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}fkt.isMDXComponent=!0;const kkt={toc:[]};function wkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}wkt.isMDXComponent=!0;const gkt={toc:[]};function Mkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Mkt.isMDXComponent=!0;const Dkt={toc:[]};function _kt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}_kt.isMDXComponent=!0;const Xkt={toc:[]};function xkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}xkt.isMDXComponent=!0;const vkt={toc:[]};function Ckt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Ckt.isMDXComponent=!0;const Tkt={toc:[]};function bkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}bkt.isMDXComponent=!0;const Lkt={toc:[]};function Zkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Zkt.isMDXComponent=!0;const Nkt={toc:[]};function Skt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Skt.isMDXComponent=!0;const Rkt={toc:[]};function Ekt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}Ekt.isMDXComponent=!0;const zkt={toc:[]};function Akt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Akt.isMDXComponent=!0;const Ikt={toc:[]};function Pkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ikt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}Pkt.isMDXComponent=!0;const Fkt={toc:[]};function Wkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Wkt.isMDXComponent=!0;const Bkt={toc:[]};function Gkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Gkt.isMDXComponent=!0;const Okt={toc:[]};function jkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Okt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}jkt.isMDXComponent=!0;const Ukt={toc:[]};function qkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ukt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}qkt.isMDXComponent=!0;const Vkt={toc:[]};function $kt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}$kt.isMDXComponent=!0;const Hkt={toc:[]};function Jkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Jkt.isMDXComponent=!0;const Ykt={toc:[]};function Kkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ykt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}Kkt.isMDXComponent=!0;const Qkt={toc:[]};function twt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}twt.isMDXComponent=!0;const ewt={toc:[]};function nwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ewt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}nwt.isMDXComponent=!0;const owt={toc:[]};function swt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},owt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}swt.isMDXComponent=!0;const rwt={toc:[]};function iwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}iwt.isMDXComponent=!0;const awt={toc:[]};function pwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},awt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}pwt.isMDXComponent=!0;const cwt={toc:[]};function lwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}lwt.isMDXComponent=!0;const uwt={toc:[]};function mwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}mwt.isMDXComponent=!0;const dwt={toc:[]};function hwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}hwt.isMDXComponent=!0;const ywt={toc:[]};function fwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ywt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}fwt.isMDXComponent=!0;const kwt={toc:[]};function wwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}wwt.isMDXComponent=!0;const gwt={toc:[]};function Mwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Mwt.isMDXComponent=!0;const Dwt={toc:[]};function _wt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}_wt.isMDXComponent=!0;const Xwt={toc:[]};function xwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}xwt.isMDXComponent=!0;const vwt={toc:[]};function Cwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Cwt.isMDXComponent=!0;const Twt={toc:[]};function bwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Twt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}bwt.isMDXComponent=!0;const Lwt={toc:[]};function Zwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Zwt.isMDXComponent=!0;const Nwt={toc:[]};function Swt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Swt.isMDXComponent=!0;const Rwt={toc:[]};function Ewt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}Ewt.isMDXComponent=!0;const zwt={toc:[]};function Awt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}Awt.isMDXComponent=!0;const Iwt={toc:[]};function Pwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}Pwt.isMDXComponent=!0;const Fwt={toc:[]};function Wwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Wwt.isMDXComponent=!0;const Bwt={toc:[]};function Gwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Gwt.isMDXComponent=!0;const Owt={toc:[]};function jwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Owt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}jwt.isMDXComponent=!0;const Uwt={toc:[]};function qwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}qwt.isMDXComponent=!0;const Vwt={toc:[]};function $wt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}$wt.isMDXComponent=!0;const Hwt={toc:[]};function Jwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Jwt.isMDXComponent=!0;const Ywt={toc:[]};function Kwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ywt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}Kwt.isMDXComponent=!0;const Qwt={toc:[]};function tgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}tgt.isMDXComponent=!0;const egt={toc:[]};function ngt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},egt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ngt.isMDXComponent=!0;const ogt={toc:[]};function sgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ogt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}sgt.isMDXComponent=!0;const rgt={toc:[]};function igt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}igt.isMDXComponent=!0;const agt={toc:[]};function pgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},agt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}pgt.isMDXComponent=!0;const cgt={toc:[]};function lgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}lgt.isMDXComponent=!0;const ugt={toc:[]};function mgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ugt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}mgt.isMDXComponent=!0;const dgt={toc:[]};function hgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}hgt.isMDXComponent=!0;const ygt={toc:[]};function fgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ygt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}fgt.isMDXComponent=!0;const kgt={toc:[]};function wgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}wgt.isMDXComponent=!0;const ggt={toc:[]};function Mgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ggt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}Mgt.isMDXComponent=!0;const Dgt={toc:[]};function _gt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}_gt.isMDXComponent=!0;const Xgt={toc:[]};function xgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the path of this circle should be closed."))}xgt.isMDXComponent=!0;const vgt={toc:[]};function Cgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property can be used together with ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,i.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Cgt.isMDXComponent=!0;const Tgt={toc:[]};function bgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ending angle in degrees for the circle sector."))}bgt.isMDXComponent=!0;const Lgt={toc:[]};function Zgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property can be used together with ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,i.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Zgt.isMDXComponent=!0;const Ngt={toc:[]};function Sgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ngt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The starting angle in degrees for the circle sector."))}Sgt.isMDXComponent=!0;const Rgt={toc:[]};function Egt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provide the color in one of the following formats:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"named color like ",(0,i.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,i.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}Egt.isMDXComponent=!0;const zgt={toc:[]};function Agt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The color of the icon"))}Agt.isMDXComponent=!0;const Igt={toc:[]};function Pgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Igt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Pgt.isMDXComponent=!0;const Fgt={toc:[]};function Wgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}Wgt.isMDXComponent=!0;const Bgt={toc:[]};function Ggt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"You can find identifiers on ",(0,i.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}Ggt.isMDXComponent=!0;const Ogt={toc:[]};function jgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ogt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The identifier of the icon."))}jgt.isMDXComponent=!0;const Ugt={toc:[]};function qgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ugt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}qgt.isMDXComponent=!0;const Vgt={toc:[]};function $gt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}$gt.isMDXComponent=!0;const Hgt={toc:[]};function Jgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Jgt.isMDXComponent=!0;const Ygt={toc:[]};function Kgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ygt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}Kgt.isMDXComponent=!0;const Qgt={toc:[]};function tMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}tMt.isMDXComponent=!0;const eMt={toc:[]};function nMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}nMt.isMDXComponent=!0;const oMt={toc:[]};function sMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}sMt.isMDXComponent=!0;const rMt={toc:[]};function iMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}iMt.isMDXComponent=!0;const aMt={toc:[]};function pMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}pMt.isMDXComponent=!0;const cMt={toc:[]};function lMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}lMt.isMDXComponent=!0;const uMt={toc:[]};function mMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"For example, a value of 6 creates a hexagon."))}mMt.isMDXComponent=!0;const dMt={toc:[]};function hMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Sets the number of sides of the polygon."))}hMt.isMDXComponent=!0;const yMt={toc:[]};function fMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}fMt.isMDXComponent=!0;const kMt={toc:[]};function wMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}wMt.isMDXComponent=!0;const gMt={toc:[]};function MMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}MMt.isMDXComponent=!0;const DMt={toc:[]};function _Mt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}_Mt.isMDXComponent=!0;const XMt={toc:[]};function xMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}xMt.isMDXComponent=!0;const vMt={toc:[]};function CMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}CMt.isMDXComponent=!0;const TMt={toc:[]};function bMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}bMt.isMDXComponent=!0;const LMt={toc:[]};function ZMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}ZMt.isMDXComponent=!0;const NMt={toc:[]};function SMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}SMt.isMDXComponent=!0;const RMt={toc:[]};function EMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the signal is currently using its initial value."))}EMt.isMDXComponent=!0;const zMt={toc:[]};function AMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,i.kt)("p",null,"This method can be used to create copies of signals."))}AMt.isMDXComponent=!0;const IMt={toc:[]};function PMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}PMt.isMDXComponent=!0;const FMt={toc:[]};function WMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the raw value of this signal."))}WMt.isMDXComponent=!0;const BMt={toc:[]};function GMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}GMt.isMDXComponent=!0;const OMt={toc:[]};function jMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}jMt.isMDXComponent=!0;const UMt={toc:[]};function qMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}qMt.isMDXComponent=!0;const VMt={toc:[]};function $Mt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}$Mt.isMDXComponent=!0;const HMt={toc:[]};function JMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Compute the current value of the signal and immediately set it."))}JMt.isMDXComponent=!0;const YMt={toc:[]};function KMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,i.kt)("p",null,"By default, any property is cloneable."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}KMt.isMDXComponent=!0;const QMt={toc:[]};function tDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}tDt.isMDXComponent=!0;const eDt={toc:[]};function nDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a cloneable property decorator."))}nDt.isMDXComponent=!0;const oDt={toc:[]};function sDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the property should be cloneable."))}sDt.isMDXComponent=!0;const rDt={toc:[]};function iDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}iDt.isMDXComponent=!0;const aDt={toc:[]};function pDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}pDt.isMDXComponent=!0;const cDt={toc:[]};function lDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a compound property decorator."))}lDt.isMDXComponent=!0;const uDt={toc:[]};function mDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}mDt.isMDXComponent=!0;const dDt={toc:[]};function hDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,i.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,i.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}hDt.isMDXComponent=!0;const yDt={toc:[]};function fDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a computed method decorator."))}fDt.isMDXComponent=!0;const kDt={toc:[]};function wDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator specifies the initial value of a property."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}wDt.isMDXComponent=!0;const gDt={toc:[]};function MDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}MDt.isMDXComponent=!0;const DDt={toc:[]};function _Dt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an initial signal value decorator."))}_Dt.isMDXComponent=!0;const XDt={toc:[]};function xDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The initial value of the property."))}xDt.isMDXComponent=!0;const vDt={toc:[]};function CDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,i.kt)("p",null,"By default, any property is inspectable."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}CDt.isMDXComponent=!0;const TDt={toc:[]};function bDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}bDt.isMDXComponent=!0;const LDt={toc:[]};function ZDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an inspectable property decorator."))}ZDt.isMDXComponent=!0;const NDt={toc:[]};function SDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the property should be inspectable."))}SDt.isMDXComponent=!0;const RDt={toc:[]};function EDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}EDt.isMDXComponent=!0;const zDt={toc:[]};function ADt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}ADt.isMDXComponent=!0;const IDt={toc:[]};function PDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a signal interpolation function decorator."))}PDt.isMDXComponent=!0;const FDt={toc:[]};function WDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The interpolation function for the property."))}WDt.isMDXComponent=!0;const BDt={toc:[]};function GDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,i.kt)("p",null,"If the wrapper class has a method called ",(0,i.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}GDt.isMDXComponent=!0;const ODt={toc:[]};function jDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ODt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}jDt.isMDXComponent=!0;const UDt={toc:[]};function qDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a signal parser decorator."))}qDt.isMDXComponent=!0;const VDt={toc:[]};function $Dt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The wrapper class for the property."))}$Dt.isMDXComponent=!0;const HDt={toc:[]};function JDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator turns the given property into a signal."),(0,i.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}JDt.isMDXComponent=!0;const YDt={toc:[]};function KDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}KDt.isMDXComponent=!0;const QDt={toc:[]};function t_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a signal decorator."))}t_t.isMDXComponent=!0;const e_t={toc:[]};function n_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},e_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,i.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,i.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,i.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,i.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}n_t.isMDXComponent=!0;const o_t={toc:[]};function s_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},o_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}s_t.isMDXComponent=!0;const r_t={toc:[]};function i_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},r_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a signal wrapper decorator."))}i_t.isMDXComponent=!0;const a_t={toc:[]};function p_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The wrapper class for the property."))}p_t.isMDXComponent=!0;const c_t={toc:[]};function l_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},c_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A unified abstraction for all CSS filters."))}l_t.isMDXComponent=!0;const u_t={toc:[]};function m_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},u_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the desired length is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}m_t.isMDXComponent=!0;const d_t={toc:[]};function h_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},d_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}h_t.isMDXComponent=!0;const y_t={toc:[]};function f_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},y_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value can be either:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'"))))}f_t.isMDXComponent=!0;const k_t={toc:[]};function w_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},k_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents a length used by most layout properties."))}w_t.isMDXComponent=!0;const g_t={toc:[]};function M_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},g_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,i.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}M_t.isMDXComponent=!0;const D_t={toc:[]};function __t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},D_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,i.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}__t.isMDXComponent=!0;const X_t={toc:[]};function x_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},X_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter in pixels."))}x_t.isMDXComponent=!0;const v_t={toc:[]};function C_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},v_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,i.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}C_t.isMDXComponent=!0;const T_t={toc:[]};function b_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},T_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}b_t.isMDXComponent=!0;const L_t={toc:[]};function Z_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},L_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,i.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}Z_t.isMDXComponent=!0;const N_t={toc:[]};function S_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},N_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}S_t.isMDXComponent=!0;const R_t={toc:[]};function E_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},R_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,i.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}E_t.isMDXComponent=!0;const z_t={toc:[]};function A_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}A_t.isMDXComponent=!0;const I_t={toc:[]};function P_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,i.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}P_t.isMDXComponent=!0;const F_t={toc:[]};function W_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},F_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter in degrees."))}W_t.isMDXComponent=!0;const B_t={toc:[]};function G_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},B_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,i.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}G_t.isMDXComponent=!0;const O_t={toc:[]};function j_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},O_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}j_t.isMDXComponent=!0;const U_t={toc:[]};function q_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},U_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,i.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}q_t.isMDXComponent=!0;const V_t={toc:[]};function $_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},V_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}$_t.isMDXComponent=!0;const H_t={toc:[]};function J_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,i.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}J_t.isMDXComponent=!0;const Y_t={toc:[]};function K_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Y_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}K_t.isMDXComponent=!0;const Q_t={toc:[]};function tXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Q_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}tXt.isMDXComponent=!0;const eXt={toc:[]};function nXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Invoke the given callback in the context of this scene."))}nXt.isMDXComponent=!0;const oXt={toc:[]};function sXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The callback to invoke."))}sXt.isMDXComponent=!0;const rXt={toc:[]};function iXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the view."),(0,i.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,i.kt)("p",null,"Can modify the state of the view."))}function aXt(t){let{id:e}=t;const n=o[e]??s.Fragment;return s.createElement(n,null)}iXt.isMDXComponent=!0},79322:(t,e,n)=>{"use strict";n.d(e,{Z:()=>m});var o=n(2784),s=n(62296),r=n(28698);const i="toggle_S_IX",a="collapsed_wdUB",p="collapse_TjTN",c="inverse_g6vW",l="clearFix_HQ1T";var u=n(6277);function m(t){let{comment:e,full:n=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@remarks"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(s.Z,{id:null==e?void 0:e.summaryId}),o.createElement(s.Z,{id:null==r?void 0:r.contentId}),n&&o.createElement(d,{comment:e}))}function d(t){let{comment:e}=t;const[n,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return(null==e||null==(t=e.blockTags)?void 0:t.filter((t=>{let{tag:e}=t;return"@example"===e})))??[]}),[e]),h=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@defaultValue"===e}))}),[e]),y=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@deprecated"===e}))}),[e]),f=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@see"===e}))}),[e]);return o.createElement(o.Fragment,null,d.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(i,n&&a),onClick:t=>{t.preventDefault(),m(!n)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:n},o.createElement("div",{className:p},d.map((t=>o.createElement(s.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,c)})),h&&o.createElement(o.Fragment,null,"Default Value:"," ",o.createElement("code",null,h.content.map((t=>t.text)).join(""))),y&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(s.Z,{id:y.contentId})),f&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(s.Z,{id:f.contentId})))}},31930:(t,e,n)=>{"use strict";n.d(e,{Z:()=>Gt});var o=n(2784),s=n(37390),r=n(66835),i=n(80068),a=n(6277),p=n(68569);const c={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=n(7896);function u(t){let{width:e=24,height:n=24,...s}=t;return o.createElement("svg",(0,l.Z)({width:e,height:n,"aria-hidden":"true",viewBox:"0 0 24 24"},s),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:e,highlight:n,onClick:s,link:l}=t;const m=(0,r.F)(),d=(0,i.s2)();return o.createElement("div",{className:(0,a.Z)(p.Z.codeBlockContent,c.codeBlock,n&&c.highlight,s&&c.pointer)},o.createElement("pre",{onClick:s,onKeyDown:t=>{"Enter"===t.key&&(null==s||s())},tabIndex:0,ref:m.codeBlockRef,className:(0,a.Z)(p.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:p.Z.codeBlockLines,style:d},e)),l&&o.createElement("div",{className:p.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=n(39318);function h(t){let{children:e}=t;return o.createElement(d.Z,{as:"div",className:(0,a.Z)(c.codeBlockContainer,"language-typescript")},e)}var y=n(89817);function f(t){let{children:e,type:n,to:s,id:r,tooltip:a}=t;const p=(0,i.Ld)(n);return s?o.createElement(y.Z,(0,l.Z)({id:r,to:s,"data-tooltip":a},p),e):o.createElement("span",(0,l.Z)({id:r},p),e)}let k,w;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(k||(k={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(w||(w={}));const g={[k.None]:c.none,[k.Angle]:c.angle,[k.Curly]:c.curly,[k.Square]:c.square,[k.Parentheses]:c.parentheses};function M(t){let{children:e,type:n,separator:s=w.Comma}=t;return o.createElement("span",{className:(0,a.Z)(c.list,g[n??k.None])},o.createElement("span",{className:(0,a.Z)(c.elements,s!==w.Comma&&c.left)},(Array.isArray(e)?e:[e]).flatMap(((t,e)=>o.createElement("span",{"data-separator":s,key:e,className:c.element},t)))))}var D=n(88617);function _(t){var e;let{type:n}=t;const s=(0,D.RU)(n.project),r=null==s?void 0:s[n.id],i=n.externalUrl??(0,D.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(f,{to:i,type:i?"class-name":"constant",tooltip:!0},n.name),!(null==(e=n.typeArguments)||!e.length)&&o.createElement(M,{type:k.Angle},n.typeArguments.map(((t,e)=>o.createElement(F,{key:e,type:t})))))}function X(t){let{type:e}=t;return o.createElement(f,{type:"keyword"},e.name)}function x(t){let{type:e}=t;return e.elements?o.createElement(M,{type:k.Square},e.elements.map(((t,e)=>o.createElement(F,{key:e,type:t})))):o.createElement(o.Fragment,null,"[]")}function v(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(F,{type:e.elementType}),"[]")}function C(t){let{type:e}=t;return o.createElement(M,{type:k.Parentheses,separator:w.Pipe},e.types.map(((t,e)=>o.createElement(F,{key:e,type:t}))))}function T(t){let{type:e}=t;const[n,s]=(0,o.useMemo)((()=>{if(null===e.value)return["null","keyword"];switch(typeof e.value){case"object":return[(e.value.negative?"-":"")+e.value.value,"number"];case"boolean":return[e.value,"keyword"];case"number":return[e.value,"number"];case"string":return[`'${e.value}'`,"string"];default:return[e.value,"constant"]}}),[e.value]);return o.createElement(f,{type:s},n)}function b(t){let{type:e}=t;return e.asserts?o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"asserts "),o.createElement(f,null,e.name," ")):o.createElement(o.Fragment,null,o.createElement(f,null,e.name," "),o.createElement(f,{type:"keyword"},"is "),o.createElement(F,{type:e.targetType}))}function L(t){let{type:e}=t;const n=(0,D.in)();return o.createElement(J,{reflection:n(e.declaration)})}function Z(t){let{type:e}=t;return o.createElement(M,{type:k.Parentheses,separator:w.Ampersand},e.types.map(((t,e)=>o.createElement(F,{key:e,type:t}))))}function N(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(f,{type:"string"},"`",e.head),e.tail.map(((t,e)=>{let[n,s]=t;return o.createElement(o.Fragment,null,"${",o.createElement(F,{key:e,type:n}),"}",o.createElement(f,{type:"string"},s))})),o.createElement(f,{type:"string"},"`"))}function S(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"typeof "),o.createElement(F,{type:e.queryType}))}function R(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(F,{type:e.checkType}),o.createElement(f,{type:"keyword"}," extends "),o.createElement(F,{type:e.extendsType})," ? ",o.createElement(F,{type:e.trueType})," : ",o.createElement(F,{type:e.falseType}))}function E(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"infer "),o.createElement(f,{type:"constant"},e.name))}function z(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(F,{type:e.objectType}),"[",o.createElement(F,{type:e.indexType}),"]")}function A(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},e.operator," "),o.createElement(F,{type:e.target}))}function I(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(M,{type:k.Curly},o.createElement(o.Fragment,null,"[",o.createElement(f,{type:"class"},e.parameter),o.createElement(f,{type:"keyword"}," in "),o.createElement(F,{type:e.parameterType}),"]: ",o.createElement(F,{type:e.templateType}))))}function P(t){let{type:e}=t;return o.createElement(o.Fragment,null,e.name,": ",o.createElement(F,{type:e.element}))}function F(t){const e=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return A;case"conditional":return R;case"reflection":return L;case"query":return S;case"named-tuple-member":return P;case"union":return C;case"intrinsic":return X;case"literal":return T;case"reference":return _;case"predicate":return b;case"tuple":return x;case"array":return v;case"intersection":return Z;case"inferred":return E;case"mapped":return I;case"template-literal":return N;case"indexedAccess":return z}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(e,t)}function W(t){let{flags:e,explicitAccessModifier:n}=t;const s=[];return null!=e&&e.isAbstract&&s.push("abstract"),null!=e&&e.isStatic&&s.push("static"),null!=e&&e.isConst&&s.push("const"),null!=e&&e.isReadonly&&s.push("readonly"),null!=e&&e.isPrivate&&s.push("private"),null!=e&&e.isProtected&&s.push("protected"),(null==e||!e.isPublic)&&(!n||null!=e&&e.isProtected||null!=e&&e.isPrivate)||s.push("public"),o.createElement(o.Fragment,null,s.map((t=>o.createElement(f,{key:t,type:"keyword"},t," "))))}function B(t){let{reflection:e}=t;const n="__namedParameters"===e.name?"{...}":e.name;return o.createElement(o.Fragment,null,o.createElement(W,{flags:e.flags}),e.flags.isRest&&"...",o.createElement(f,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"plain"},n),e.flags.isOptional&&"?",": ",e.type&&o.createElement(F,{type:e.type}),e.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(f,{type:"plain"},e.defaultValue)))}function G(t){let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(W,{flags:e.flags}),e.varianceModifier&&o.createElement(f,{type:"keyword"},e.varianceModifier," "),o.createElement(f,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"class-name"},e.name),e.type&&o.createElement(o.Fragment,null," extends ",o.createElement(F,{type:e.type})),e.default&&o.createElement(o.Fragment,null," = ",o.createElement(F,{type:e.default})))}function O(t){var e,n;let{reflection:r,flags:i}=t;const a=(0,D.in)(),p="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(W,{flags:i??r.flags,explicitAccessModifier:!p}),r.kind===s.W.GetSignature&&o.createElement(f,{type:"keyword"},"get "),r.kind===s.W.SetSignature&&o.createElement(f,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(f,{to:r.overwrites.externalUrl??(0,D.Gr)(a(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===s.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(f,{to:"#",type:"keyword"},"new")," ",o.createElement(f,{type:"plain"},r.type.name)):p?"":o.createElement(f,{type:"function"},r.name),!(null==(e=r.typeParameter)||!e.length)&&o.createElement(M,{type:k.Angle},r.typeParameter.map((t=>o.createElement(G,{key:t.id,reflection:a(t)})))),null!=(n=r.parameters)&&n.length?o.createElement(M,{type:k.Parentheses},r.parameters.map((t=>o.createElement(B,{key:t,reflection:a(t)})))):"()",r.type&&o.createElement(o.Fragment,null,p?" => ":": ",o.createElement(F,{type:r.type})))}function j(t){let{reflection:e}=t;return o.createElement(B,{reflection:e})}const U={[s.W.Namespace]:"namespace",[s.W.Enum]:"enum",[s.W.Class]:"class",[s.W.Interface]:"interface"};function q(t){var e,n,s;let{reflection:r}=t;const i=(0,D.in)();return o.createElement(o.Fragment,null,o.createElement(W,{flags:r.flags}),o.createElement(f,{type:"keyword"},U[r.kind]," "),o.createElement(f,{type:"class-name"},r.name),!(null==(e=r.typeParameters)||!e.length)&&o.createElement(M,{type:k.Angle},r.typeParameters.map((t=>o.createElement(G,{key:t.id,reflection:i(t)}))))," ",!(null==(n=r.extendedTypes)||!n.length)&&o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"extends "),o.createElement(M,null,r.extendedTypes.map(((t,e)=>o.createElement(F,{key:e,type:t}))))),!(null==(s=r.implementedTypes)||!s.length)&&o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"implements "),o.createElement(M,null,r.implementedTypes.map(((t,e)=>o.createElement(F,{key:e,type:t}))))))}function V(t){let{reflection:e}=t;const n=(0,D.in)();return o.createElement(o.Fragment,null,o.createElement(W,{flags:e.flags}),o.createElement(f,{type:"keyword"},"type "),o.createElement(f,{type:"class-name"},e.name),e.typeParameters&&o.createElement(M,{type:k.Angle},e.typeParameters.map((t=>o.createElement(G,{key:t.id,reflection:n(t)}))))," = ",o.createElement(F,{type:e.type}))}function $(t){let{reflection:e}=t;const n=(0,D.in)();return e.signatures?o.createElement(O,{reflection:e.signatures[0]}):e.children?o.createElement(M,{type:k.Curly},e.children.map((t=>o.createElement(J,{key:t.id,reflection:n(t)})))):o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"unknown"))}function H(t){var e;let{reflection:n}=t;const s=(null==(e=n.signatures)?void 0:e[0])??n.getSignature??n.setSignature??n.indexSignature;return o.createElement(O,{reflection:s})}function J(t){let{reflection:e}=t;const n=(0,o.useMemo)((()=>{switch(e.kind){case s.W.Project:case s.W.Module:case s.W.EnumMember:case s.W.Variable:case s.W.Function:break;case s.W.Namespace:case s.W.Enum:case s.W.Class:case s.W.Interface:return q;case s.W.Constructor:return O;case s.W.Property:return j;case s.W.Method:return H;case s.W.CallSignature:case s.W.IndexSignature:case s.W.ConstructorSignature:case s.W.Parameter:break;case s.W.TypeLiteral:return $;case s.W.TypeParameter:return G;case s.W.Accessor:case s.W.GetSignature:case s.W.SetSignature:case s.W.ObjectLiteral:break;case s.W.TypeAlias:return V;case s.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.id]);return o.createElement(n,{reflection:e})}function Y(t){let{children:e}=t;const n=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!n.current)return;const t=n.current.closest("pre");if(t.scrollWidth>t.clientWidth){const e=Array.from(n.current.querySelectorAll(`.${c.elements}`)).sort(((t,e)=>function(t,e){return t>e?1:t<e?-1:0}(e.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&e.length>0;)e.shift().classList.add(c.wrap)}})),o.createElement(o.Fragment,null,e&&o.createElement("span",{ref:n,className:(0,a.Z)(c.line,"token-line")},e),o.createElement("br",null))}var K=n(79322),Q=n(62296);function tt(t){let{parameters:e}=t;const n=(0,D.in)(),s=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=s&&s.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,s.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(G,{reflection:t})),o.createElement(Q.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{parameters:e}=t;const n=(0,D.in)(),s=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=s&&s.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,s.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(B,{reflection:t})),o.createElement(Q.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{signatures:e,flags:n,source:s}=t;const r=(0,D.in)(),i=(0,o.useMemo)((()=>e.map(r)),[e]),[a,p]=(0,o.useState)(i[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,i.map((t=>o.createElement(m,{link:null==s?void 0:s.url,key:t.id,highlight:e.length>1&&t.id===a.id,onClick:e.length>1?()=>p(t):void 0},o.createElement(Y,null,o.createElement(O,{reflection:t,flags:n})))))),o.createElement(K.Z,{comment:a.comment}),o.createElement(tt,{parameters:a.typeParameter}),o.createElement(et,{parameters:a.parameters}))}var ot=n(57708);function st(t){let{width:e=24,height:n=24,...s}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},s),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",it="filters_z1iC",at="icon_ROIU";function pt(){const t=(0,o.useRef)(null),[e,n]=(0,o.useState)(!1),[s,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const e=e=>{t.current&&!t.current.contains(e.target)&&n(!1)};return document.addEventListener("mousedown",e),document.addEventListener("touchstart",e),()=>{document.removeEventListener("mousedown",e),document.removeEventListener("touchstart",e)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,a.Z)("dropdown dropdown--right margin-bottom--md",e&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),n(!e)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),n(!e))}},"Filters",o.createElement(st,{className:at})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,a.Z)("dropdown__link",s.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:s.private,onChange:t=>{r({...s,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&n(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,a.Z)("dropdown__link",s.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:s.inherited,onChange:t=>{r({...s,inherited:t.target.checked})}}),"Inherited members")))))}function ct(t){let{children:e,kind:n}=t;return n===s.W.Class||n===s.W.Interface?o.createElement("div",{className:(0,a.Z)("row",rt)},o.createElement("div",{className:(0,a.Z)("col",it)},o.createElement(pt,null)),o.createElement("div",{className:"col"},e)):o.createElement(o.Fragment,null,e)}var lt=n(53181),ut=n(83851),mt=n(24126),dt=n(32424),ht=n(42244),yt=n(24155);function ft(t){return function(t){return o.Children.map(t,(t=>{if((0,o.isValidElement)(t)&&"value"in t.props)return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(t).map((t=>{let{props:{value:e,label:n,attributes:o,default:s}}=t;return{value:e,label:n,attributes:o,default:s}}))}function kt(t){const{values:e,children:n}=t;return(0,o.useMemo)((()=>{const t=e??ft(n);return function(t){const e=(0,ht.l)(t,((t,e)=>t.value===e.value));if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[e,n])}function wt(t){let{value:e,tabValues:n}=t;return n.some((t=>t.value===e))}function gt(t){let{queryString:e=!1,groupId:n}=t;const s=(0,lt.k6)(),r=function(t){let{queryString:e=!1,groupId:n}=t;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,dt._X)(r),(0,o.useCallback)((t=>{if(!r)return;const e=new URLSearchParams(s.location.search);e.set(r,t),s.replace({...s.location,search:e.toString()})}),[r,s])]}function Mt(t){const{defaultValue:e,queryString:n=!1,groupId:s}=t,r=kt(t),[i,a]=(0,o.useState)((()=>function(t){let{defaultValue:e,tabValues:n}=t;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!wt({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const o=n.find((t=>t.default))??n[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:e,tabValues:r}))),[p,c]=gt({queryString:n,groupId:s}),[l,u]=function(t){let{groupId:e}=t;const n=function(t){return t?`docusaurus.tab.${t}`:null}(e),[s,r]=(0,yt.Nk)(n);return[s,(0,o.useCallback)((t=>{n&&r.set(t)}),[n,r])]}({groupId:s}),m=(()=>{const t=p??l;return wt({value:t,tabValues:r})?t:null})();(0,o.useLayoutEffect)((()=>{m&&a(m)}),[m]);return{selectedValue:i,selectValue:(0,o.useCallback)((t=>{if(!wt({value:t,tabValues:r}))throw new Error(`Can't select invalid tab value=${t}`);a(t),c(t),u(t)}),[c,u,r]),tabValues:r}}var Dt=n(89741);const _t="tabList_M0Dn",Xt="tabItem_ysIP";function xt(t){let{className:e,block:n,selectedValue:s,selectValue:r,tabValues:i}=t;const p=[],{blockElementScrollPositionUntilNextRender:c}=(0,mt.o5)(),u=t=>{const e=t.currentTarget,n=p.indexOf(e),o=i[n].value;o!==s&&(c(e),r(o))},m=t=>{var e;let n=null;switch(t.key){case"Enter":u(t);break;case"ArrowRight":{const e=p.indexOf(t.currentTarget)+1;n=p[e]??p[0];break}case"ArrowLeft":{const e=p.indexOf(t.currentTarget)-1;n=p[e]??p[p.length-1];break}}null==(e=n)||e.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":n},e)},i.map((t=>{let{value:e,label:n,attributes:r}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:s===e?0:-1,"aria-selected":s===e,key:e,ref:t=>p.push(t),onKeyDown:m,onClick:u},r,{className:(0,a.Z)("tabs__item",Xt,null==r?void 0:r.className,{"tabs__item--active":s===e})}),n??e)})))}function vt(t){let{lazy:e,children:n,selectedValue:s}=t;if(n=Array.isArray(n)?n:[n],e){const t=n.find((t=>t.props.value===s));return t?(0,o.cloneElement)(t,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},n.map(((t,e)=>(0,o.cloneElement)(t,{key:e,hidden:t.props.value!==s}))))}function Ct(t){const e=Mt(t);return o.createElement("div",{className:(0,a.Z)("tabs-container",_t)},o.createElement(xt,(0,l.Z)({},t,e)),o.createElement(vt,(0,l.Z)({},t,e)))}function Tt(t){const e=(0,Dt.Z)();return o.createElement(Ct,(0,l.Z)({key:String(e)},t))}const bt="tabItem_OMyP";function Lt(t){let{children:e,hidden:n,className:s}=t;return o.createElement("div",{role:"tabpanel",className:(0,a.Z)(bt,s),hidden:n},e)}function Zt(t){let{group:e}=t;return"Constructors"===e.title&&0===e.external.length&&1===e.nested.length?o.createElement(Gt,{reflection:e.nested[0]}):o.createElement(o.Fragment,null,e.external.length>0&&o.createElement("ul",null,e.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(_,{type:t})))))),e.nested.length>0&&e.nested.map(((t,e)=>o.createElement(o.Fragment,{key:t.id},e>0&&o.createElement("hr",null),o.createElement(Gt,{reflection:t})))))}function Nt(t){let{group:e,project:n}=t;const s=(0,lt.TH)(),r=(0,D.RU)(n),i=s.hash.split("-")[0].slice(1),[a]=(0,ot.mN)(),p=(0,o.useMemo)((()=>(e.categories??[e]).map((t=>function(t,e,n){const o=[],s=[],r=[];for(const i of t.children){const t=e[i];t&&(0,ot.It)(n,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):s.push(t))}if(o.length>0||s.length>0)return{title:t.title,external:o,nested:s,anchors:r}}(t,r,a))).filter((t=>!!t))),[e,r,a]);return(0,o.useEffect)((()=>{if(1===p.length)return;const t=s.hash.split("-")[0].slice(1);for(const e of p)if(e.anchors.includes(t))return}),[s.hash,p]),0===p.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h2",id:e.title},e.title),p.length>1?o.createElement(Tt,{groupId:e.title},p.map((t=>o.createElement(Lt,{default:t.anchors.includes(i),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(Zt,{group:t}))))):o.createElement(Zt,{group:p[0]}))}function St(t){var e,n,s,r,i;let{reflection:a}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(e=a.sources)||null==(n=e[0])?void 0:n.url},o.createElement(Y,null,o.createElement(J,{reflection:a})))),o.createElement(ct,{kind:a.kind},o.createElement(K.Z,{comment:a.comment})),o.createElement(tt,{parameters:a.typeParameters}),(null==(s=a.implementedBy)?void 0:s.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,a.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(_,{type:t}))))))),(null==(r=a.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,a.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(_,{type:t}))))))),a.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:a.signatures})),null==(i=a.groups)?void 0:i.map((t=>o.createElement(Nt,{group:t,key:t.title,project:a.project}))))}function Rt(t){var e;let{reflection:n,headless:s}=t;const r=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!s&&(n.hasOwnPage?o.createElement("h1",null,n.name):o.createElement(ut.Z,{as:"h3",id:n.anchor},o.createElement("code",null,n.name))),o.createElement(nt,{signatures:r,flags:n.flags,source:null==(e=n.sources)?void 0:e[0]}),n.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(_,{type:n.inheritedFrom}))),n.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(_,{type:n.overwrites}))))}function Et(t){var e,n;let{reflection:s,headless:r}=t;return o.createElement(o.Fragment,null,!r&&(s.hasOwnPage?o.createElement("h1",null,s.name):o.createElement(ut.Z,{as:"h3",id:s.anchor},o.createElement("code",null,s.name))),o.createElement(h,null,o.createElement(m,{link:null==(e=s.sources)||null==(n=e[0])?void 0:n.url},o.createElement(Y,null,o.createElement(j,{reflection:s})))),o.createElement(K.Z,{comment:s.comment}),s.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(_,{type:s.inheritedFrom}))))}function zt(t){var e,n,s;let{reflection:r}=t;const i=(0,D.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(e=r.sources)||null==(n=e[0])?void 0:n.url},o.createElement(Y,null,o.createElement(J,{reflection:r})))),o.createElement(K.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:r.signatures})),null==(s=r.groups)?void 0:s.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>i[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Gt,{key:t.id,reflection:t})))))))}var At=n(78128);function It(t){var e;let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(At.Z,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),o.createElement(ct,{kind:n.kind},o.createElement(K.Z,{comment:n.comment})),null==(e=n.groups)?void 0:e.map((t=>o.createElement(Nt,{group:t,key:t.title,project:n.project}))))}const Pt="cardContainer_ybwo",Ft="cardTitle_Ehd1",Wt="cardDescription_b6wr";function Bt(t){let{reflection:e}=t;const n=(0,D.RU)(e.project),s=e.groups[0].children.map((t=>n[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,a.Z)("row")},s.map((t=>{var e;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(y.Z,{href:t.href,className:(0,a.Z)("card padding--lg",Pt)},o.createElement("h2",{className:(0,a.Z)("text--truncate",Ft)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,a.Z)("text--truncate",Wt)},(null==(e=t.comment)?void 0:e.summaryText)??"\xa0")))}))))}function Gt(t){let{reflection:e,headless:n=!1}=t;const r=(0,o.useMemo)((()=>{switch(e.kind){case s.W.Project:return Bt;case s.W.Module:return It;case s.W.Namespace:case s.W.Enum:case s.W.Class:case s.W.Interface:return St;case s.W.Function:case s.W.Accessor:case s.W.Constructor:case s.W.Method:return Rt;case s.W.Variable:case s.W.Property:case s.W.EnumMember:return Et;case s.W.CallSignature:case s.W.IndexSignature:case s.W.ConstructorSignature:case s.W.Parameter:case s.W.TypeLiteral:case s.W.TypeParameter:case s.W.GetSignature:case s.W.SetSignature:case s.W.ObjectLiteral:break;case s.W.TypeAlias:return zt;case s.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.kind]);return o.createElement(r,{reflection:e,headless:n})}},37390:(t,e,n)=>{"use strict";let o;n.d(e,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},45573:(t,e,n)=>{"use strict";n.d(e,{Z:()=>ge});var o={};n.r(o),n.d(o,{Circle:()=>y,Grid:()=>E,Icon:()=>N,Img:()=>b,Latex:()=>j,Layout:()=>U.A,Line:()=>Q,Node:()=>tt.N,Polygon:()=>nt,Rect:()=>D.U,Shape:()=>m.b,Txt:()=>it,Video:()=>lt,View2D:()=>ot.h});var s={};n.r(s),n.d(s,{all:()=>ut.$,any:()=>yt,chain:()=>kt,delay:()=>_t,every:()=>Xt,loop:()=>xt,noop:()=>vt,run:()=>Ct.K,sequence:()=>Tt,waitFor:()=>Dt,waitUntil:()=>Mt});var r={};n.r(r),n.d(r,{DetailedError:()=>Rt.t,Semaphore:()=>It.L,beginSlide:()=>bt,capitalize:()=>Lt.k,createRef:()=>Wt,debug:()=>Nt,deprecate:()=>St,endPlayback:()=>gt.Mh,endScene:()=>X.ug,endThread:()=>at.kw,errorToLog:()=>Et.d,finishScene:()=>X.vl,getContext:()=>zt.f,isProxyEnabled:()=>v,makeRef:()=>Bt,makeRefs:()=>Gt,range:()=>At.w,startPlayback:()=>gt.wA,startScene:()=>X.DO,startThread:()=>at.h$,useContext:()=>jt,useContextAfter:()=>Ut,useDuration:()=>wt,useLogger:()=>X.wL,usePlayback:()=>gt.te,useRandom:()=>Ft,useScene:()=>X.$r,useThread:()=>at.nn,useTime:()=>Ot,viaProxy:()=>x});var i={};n.r(i),n.d(i,{CompoundSignalContext:()=>qt.N,ComputedContext:()=>Vt.h,DEFAULT:()=>Kt.T,DependencyContext:()=>_.k,SignalContext:()=>Yt.V,createComputed:()=>$t.D,createComputedAsync:()=>Jt,createSignal:()=>Ht.g,isReactive:()=>q.P});var a={};n.r(a),n.d(a,{BBox:()=>k.b,Center:()=>ee.M5,Color:()=>g.Color,Direction:()=>ee.Nm,EPSILON:()=>Qt.Ib,Matrix2D:()=>te,Origin:()=>ee.aP,Spacing:()=>ne.K,Vector2:()=>w.F,flipOrigin:()=>ee.lk,isType:()=>oe,originToOffset:()=>ee.WS,transformAngle:()=>Qt.$H,transformScalar:()=>Qt.X6});var p={};n.r(p),n.d(p,{BeatSpring:()=>pe,BounceSpring:()=>le,JumpSpring:()=>me,PlopSpring:()=>ce,SmoothSpring:()=>he,StrikeSpring:()=>de,SwingSpring:()=>ue,arcLerp:()=>V.Vz,clamp:()=>V.uZ,clampRemap:()=>V.vl,cos:()=>se.mC,createEaseInBack:()=>se.j$,createEaseInBounce:()=>se.jv,createEaseInElastic:()=>se.qS,createEaseInOutBack:()=>se.Bl,createEaseInOutBounce:()=>se.Ij,createEaseInOutElastic:()=>se.du,createEaseOutBack:()=>se.lj,createEaseOutBounce:()=>se.zk,createEaseOutElastic:()=>se.Kx,deepLerp:()=>V.o0,easeInBack:()=>se.Yw,easeInBounce:()=>se.SJ,easeInCirc:()=>se.Mg,easeInCubic:()=>se.Q9,easeInElastic:()=>se.eE,easeInExpo:()=>se.e_,easeInOutBack:()=>se.BH,easeInOutBounce:()=>se.en,easeInOutCirc:()=>se.Ge,easeInOutCubic:()=>se.qb,easeInOutElastic:()=>se.cv,easeInOutExpo:()=>se.hN,easeInOutQuad:()=>se.to,easeInOutQuart:()=>se.J7,easeInOutQuint:()=>se.rz,easeInOutSine:()=>se.Fs,easeInQuad:()=>se.FG,easeInQuart:()=>se.g4,easeInQuint:()=>se.n5,easeInSine:()=>se.N1,easeOutBack:()=>se.UE,easeOutBounce:()=>se.C6,easeOutCirc:()=>se.ei,easeOutCubic:()=>se.w2,easeOutElastic:()=>se.sK,easeOutExpo:()=>se.ad,easeOutQuad:()=>se.hl,easeOutQuart:()=>se.Y3,easeOutQuint:()=>se.pl,easeOutSine:()=>se.vh,linear:()=>se.GE,makeSpring:()=>ae,map:()=>V.UI,remap:()=>V.a2,sin:()=>se.O$,spring:()=>ie,textLerp:()=>V.JC,tween:()=>re.i});var c={};n.r(c),n.d(c,{Thread:()=>ke.j,cancel:()=>ye,getTaskName:()=>fe.z,isPromisable:()=>ft.x,isPromise:()=>we.t,isThreadGenerator:()=>ft.R,join:()=>mt.v,setTaskName:()=>fe.i,threads:()=>we.C});var l=n(15914);const u=Symbol.for("@motion-canvas/2d/fragment");var m=n(13730),d=n(93091),h=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class y extends m.b{constructor(t){super(t)}getPath(){return this.createPath()}getRipplePath(){return this.createPath(this.rippleSize())}createPath(t){void 0===t&&(t=0);const e=new Path2D,n=this.startAngle()/180*Math.PI,o=this.endAngle()/180*Math.PI,s=this.size().scale(.5),r=this.closed();return r&&e.moveTo(0,0),e.ellipse(0,0,s.x+t,s.y+t,0,n,o),r&&e.closePath(),e}}h([(0,d.nn)(0),(0,d.td)()],y.prototype,"startAngle",void 0),h([(0,d.nn)(360),(0,d.td)()],y.prototype,"endAngle",void 0),h([(0,d.nn)(!1),(0,d.td)()],y.prototype,"closed",void 0);var f=n(46350),k=n(23357),w=n(29797),g=n(5392),M=n(11258),D=n(15498),_=n(76062),X=n(3163);function x(t){if(!v())return t;if(t.startsWith("/cors-proxy/"))return t;const e=new URL(window.location.toString());try{const n=new URL(t,e);if(!n.protocol.startsWith("http"))return t;if(e.host===n.host)return t;if(!function(t){const e=function(){if("true"!==(void 0).VITEST&&C)return[...C];const t=(v(),[]);return C=t,[...C]}();if(0===e.length)return!0;for(const n of e)if(n.toLowerCase().trim()===t)return!0;return!1}(n.host))return t}catch(n){return t}return`/cors-proxy/${encodeURIComponent(t)}`}function v(){return!1}let C;var T=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class b extends D.U{constructor(t){super(t)}desiredSize(){const t=super.desiredSize();if(null===t.x&&null===t.y){const t=this.image();return{x:t.naturalWidth,y:t.naturalHeight}}return t}image(){const t=x(this.src());if(b.pool[t])return b.pool[t];const e=document.createElement("img");return e.crossOrigin="anonymous",e.src=t,e.complete||_.k.collectPromise(new Promise(((t,n)=>{e.addEventListener("load",t),e.addEventListener("error",n)}))),b.pool[t]=e,e}imageCanvas(){const t=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});if(!t)throw new Error("Could not create an image canvas");return t}filledImageCanvas(){const t=this.imageCanvas(),e=this.image();return t.canvas.width=e.naturalWidth,t.canvas.height=e.naturalHeight,t.imageSmoothingEnabled=this.smoothing(),t.drawImage(e,0,0),t}draw(t){this.drawShape(t),this.clip()&&t.clip(this.getPath());const e=this.alpha();if(e>0){const n=k.b.fromSizeCentered(this.computedSize());t.save(),e<1&&(t.globalAlpha*=e),t.imageSmoothingEnabled=this.smoothing(),(0,M.AE)(t,this.image(),n),t.restore()}this.drawChildren(t)}applyFlex(){super.applyFlex();const t=this.image();this.element.style.aspectRatio=(this.ratio()??t.naturalWidth/t.naturalHeight).toString()}getColorAtPoint(t){const e=this.image(),n=this.computedSize(),o=new w.F(e.naturalWidth,e.naturalHeight),s=new w.F(t).add(this.computedSize().scale(.5)).mul(o.div(n).safe);return this.getPixelColor(s)}getPixelColor(t){const e=this.filledImageCanvas(),n=new w.F(t),o=e.getImageData(n.x,n.y,1,1).data;return new g.Color({r:o[0],g:o[1],b:o[2],a:o[3]/255})}collectAsyncResources(){super.collectAsyncResources(),this.image()}}b.pool={},T([(0,d.td)()],b.prototype,"src",void 0),T([(0,d.nn)(1),(0,d.td)()],b.prototype,"alpha",void 0),T([(0,d.nn)(!0),(0,d.td)()],b.prototype,"smoothing",void 0),T([(0,f.F)()],b.prototype,"image",null),T([(0,f.F)()],b.prototype,"imageCanvas",null),T([(0,f.F)()],b.prototype,"filledImageCanvas",null);var L=n(43595),Z=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class N extends b{constructor(t){super(t)}svgUrl(){return`https://api.iconify.design/${this.icon().replace(":","/")}.svg?color=${encodeURIComponent(this.color().hex())}`}getSrc(){return this.svgUrl()}setSrc(){(0,X.wL)().warn("The Icon Component does not accept setting the `src`. If you need access to `src`, use '<Img/>` instead.")}}Z([(0,d.td)()],N.prototype,"icon",void 0),Z([(0,d.nn)("white"),(0,L.j)()],N.prototype,"color",void 0),Z([(0,f.F)()],N.prototype,"svgUrl",null);var S=n(88104),R=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class E extends m.b{constructor(t){super(t)}drawShape(t){t.save(),this.applyStyle(t),this.drawRipple(t);const e=this.spacing(),n=this.computedSize().scale(.5),o=n.div(e).floored;for(let s=-o.x;s<=o.x;s++)t.beginPath(),t.moveTo(e.x*s,-n.height),t.lineTo(e.x*s,n.height),t.stroke();for(let s=-o.y;s<=o.y;s++)t.beginPath(),t.moveTo(-n.width,e.y*s),t.lineTo(n.width,e.y*s),t.stroke();t.restore()}}R([(0,d.nn)(80),(0,S.y)("spacing")],E.prototype,"spacing",void 0);var z=n(98911),A=n(2322),I=n(64238),P=n(81962),F=n(86226),W=n(50099),B=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};const G=(0,F.liteAdaptor)();(0,W.Q)(G);const O=z.mathjax.document("",{InputJax:new A.TeX({packages:P.b}),OutputJax:new I.SVG({fontCache:"local"})});class j extends b{constructor(t){super(t),this.imageElement=document.createElement("img")}image(){const t=`${this.tex()}::${JSON.stringify(this.options())}`;if(j.svgContentsPool[t])return this.imageElement.src=j.svgContentsPool[t],this.imageElement;const e=this.tex(),n=G.innerHTML(O.convert(e,this.options()));if(n.includes("data-mjx-error")){const t=n.match(/data-mjx-error="(.*?)"/);t&&t.length>0&&(0,X.wL)().error(`Invalid MathJax: ${t[1]}`)}const o=`data:image/svg+xml;base64,${btoa(`<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n${n}`)}`;j.svgContentsPool[t]=o;const s=document.createElement("img");return s.src=o,s.src=o,s.complete||_.k.collectPromise(new Promise(((t,e)=>{s.addEventListener("load",t),s.addEventListener("error",e)}))),s}}j.svgContentsPool={},B([(0,d.nn)({}),(0,d.td)()],j.prototype,"options",void 0),B([(0,d.td)()],j.prototype,"tex",void 0);var U=n(70989),q=n(93214),V=n(13170);class ${}class H extends ${constructor(t,e){super(),this.from=t,this.to=e,this.vector=e.sub(t),this.length=this.vector.magnitude,this.tangent=this.vector.perpendicular.normalized.safe}get arcLength(){return this.length}draw(t,e,n,o){void 0===e&&(e=0),void 0===n&&(n=1),void 0===o&&(o=!1);const s=this.from.add(this.vector.scale(e)),r=this.from.add(this.vector.scale(n));return o&&(0,M.Ao)(t,s),(0,M.kZ)(t,r),[s,this.tangent.flipped,r,this.tangent]}getPoint(t){return[this.from.add(this.vector.scale(t)),this.tangent.flipped]}}class J extends ${constructor(t,e,n,o,s){super(),this.center=t,this.radius=e,this.from=n,this.to=o,this.counter=s,this.angle=Math.acos((0,V.uZ)(-1,1,n.dot(o))),this.length=Math.abs(this.angle*e)}get arcLength(){return this.length}draw(t,e,n){const o=this.counter?-1:1,s=this.from.radians+e*this.angle*o,r=this.to.radians-(1-n)*this.angle*o;Math.abs(e-n)>1e-4&&t.arc(this.center.x,this.center.y,this.radius,s,r,this.counter);const i=w.F.fromRadians(s),a=w.F.fromRadians(r);return[this.center.add(i.scale(this.radius)),this.counter?i:i.flipped,this.center.add(a.scale(this.radius)),this.counter?a.flipped:a]}getPoint(t){const e=this.counter?-1:1,n=this.from.radians+t*this.angle*e,o=w.F.fromRadians(n);return[this.center.add(o.scale(this.radius)),this.counter?o:o.flipped]}}function Y(t,e){const n=(0,V.uZ)(0,t.arcLength,e);let o=0;for(const s of t.segments){const t=o;if(o+=s.arcLength,o>=n){const e=(n-t)/s.arcLength,[o,r]=s.getPoint((0,V.uZ)(0,1,e));return{position:o,tangent:r}}}return{position:w.F.zero,tangent:w.F.up}}var K=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class Q extends m.b{desiredSize(){return this.childrenBBox().size}constructor(t){super(t),void 0===t.children&&void 0===t.points&&(0,X.wL)().warn({message:"No points specified for the line",remarks:'<p>The line won&#39;t be visible unless you specify at least two points:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span>\n  stroke=<span class="hljs-string">&quot;#fff&quot;</span>\n  lineWidth={<span class="hljs-number">8</span>}\n  points={[\n    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],\n  ]}\n/&gt;\n</code></pre>\n<p>Alternatively, you can define the points using the children:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>\n&lt;/<span class="hljs-title class_">Line</span>&gt;\n</code></pre>\n<p>If you did this intentionally, and want to disable this message, set the\n<code>points</code> property to <code>null</code>:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>} points={<span class="hljs-literal">null</span>} /&gt;\n</code></pre>\n',inspect:this.key})}childrenBBox(){const t=this.points(),e=t?t.map((t=>new w.F((0,q.P)(t)?t():t))):this.children().filter((t=>!(t instanceof U.A)||t.isLayoutRoot())).map((t=>t.position()));return k.b.fromPoints(...e)}parsedPoints(){const t=this.points();return t?t.map((t=>new w.F((0,q.P)(t)?t():t))):this.children().map((t=>t.position()))}profile(){return function(t,e,n){const o={arcLength:0,segments:[],minSin:1};if(0===t.length)return o;if(n){const e=t[0].add(t[t.length-1]).scale(.5);t.unshift(e),t.push(e)}let s=t[0];for(let i=2;i<t.length;i++){const n=t[i-2],r=t[i-1],a=t[i],p=n.sub(r),c=a.sub(r),l=p.normalized.safe,u=c.normalized.safe,m=Math.acos((0,V.uZ)(-1,1,l.dot(u))),d=Math.tan(m/2),h=Math.sin(m/2),y=Math.min(e,d*p.magnitude*(2===i?1:.5),d*c.magnitude*(i===t.length-1?1:.5)),f=0===h?0:y/h,k=0===d?0:y/d,w=l.add(u).scale(.5).normalized.safe.scale(f).add(r),g=l.perpendicular.dot(u)<0,M=new H(s,r.add(l.scale(k))),D=new J(w,y,l.perpendicular.scale(g?1:-1),u.perpendicular.scale(g?-1:1),g);o.segments.push(M),o.segments.push(D),o.arcLength+=M.arcLength,o.arcLength+=D.arcLength,o.minSin=Math.min(o.minSin,Math.abs(h)),s=r.add(u.scale(k))}const r=new H(s,t[t.length-1]);return o.segments.push(r),o.arcLength+=r.arcLength,o}(this.parsedPoints(),this.radius(),this.closed())}percentageToDistance(t){const{arcLength:e}=this.profile(),n=this.startOffset();return n+(e-n-this.endOffset())*t}curveDrawingInfo(){const t=new Path2D,e=this.profile();let n=this.percentageToDistance(this.start()),o=this.percentageToDistance(this.end());n>o&&([n,o]=[o,n]);const s=o-n,r=Math.min(s/2,this.arrowSize());this.startArrow()&&(n+=r/2),this.endArrow()&&(o-=r/2);let i=0,a=null,p=null,c=null,l=null;for(const u of e.segments){const e=i;if(i+=u.arcLength,i<n)continue;const s=(n-e)/u.arcLength,r=(o-e)/u.arcLength,m=(0,V.uZ)(0,1,s),d=(0,V.uZ)(0,1,r),[h,y,f,k]=u.draw(t,m,d,null===a);if(null===a&&(a=h,p=y),c=f,l=k,i>o)break}return{startPoint:a??w.F.zero,startTangent:p??w.F.up,endPoint:c??w.F.zero,endTangent:l??w.F.up,arrowSize:r,path:t,startOffset:n}}getPointAtDistance(t){return Y(this.profile(),t+this.startOffset())}getPointAtPercentage(t){return Y(this.profile(),this.percentageToDistance(t))}applyStyle(t){super.applyStyle(t);const{arcLength:e}=this.profile();t.lineDashOffset-=e/2}getComputedLayout(){const t=super.getComputedLayout();return t.position=t.position.sub(this.childrenBBox().center),t}getPath(){return this.curveDrawingInfo().path}getCacheBBox(){const t=this.childrenBBox(),e=this.arrowSize(),n=this.lineWidth(),o=this.radius(),s=this.lineJoin(),r=this.lineCap();let i=.5;if(0===o&&"miter"===s){const{minSin:t}=this.profile();t>0&&(i=Math.max(i,.5/t))}return"square"===r&&(i=Math.max(i,.70715)),t.expand(Math.max(0,e,n*i))}drawShape(t){super.drawShape(t);const{startPoint:e,startTangent:n,endPoint:o,endTangent:s,arrowSize:r}=this.curveDrawingInfo();r<.001||(t.save(),t.beginPath(),this.endArrow()&&this.drawArrow(t,o,s,r),this.startArrow()&&this.drawArrow(t,e,n,r),t.fillStyle=(0,M.ho)(this.stroke(),t),t.closePath(),t.fill(),t.restore())}drawArrow(t,e,n,o){const s=n.perpendicular,r=e.add(s.scale(-o/2));(0,M.Ao)(t,r),(0,M.kZ)(t,r.add(s.add(n).scale(o))),(0,M.kZ)(t,r.add(s.sub(n).scale(o))),(0,M.kZ)(t,r),t.closePath()}drawOverlay(t,e){const n=this.childrenBBox().transformCorners(e),o=this.computedSize().mul(this.offset()).scale(.5).transformAsPoint(e);t.fillStyle="white",t.strokeStyle="black",t.lineWidth=1;const s=new Path2D,r=this.parsedPoints().map((t=>t.transformAsPoint(e)));if(r.length>0){(0,M.Ao)(s,r[0]);for(const e of r)(0,M.kZ)(s,e),t.beginPath(),(0,M.Nb)(t,e,4),t.closePath(),t.fill(),t.stroke()}t.strokeStyle="white",t.stroke(s);t.beginPath(),(0,M.kZ)(t,o.addY(-8)),(0,M.kZ)(t,o.addY(8)),(0,M.kZ)(t,o),(0,M.kZ)(t,o.addX(-8)),t.arc(o.x,o.y,8,0,2*Math.PI),t.stroke(),t.beginPath(),(0,M.pS)(t,n),t.closePath(),t.stroke()}}K([(0,d.nn)(0),(0,d.td)()],Q.prototype,"radius",void 0),K([(0,d.nn)(!1),(0,d.td)()],Q.prototype,"closed",void 0),K([(0,d.nn)(0),(0,d.td)()],Q.prototype,"start",void 0),K([(0,d.nn)(0),(0,d.td)()],Q.prototype,"startOffset",void 0),K([(0,d.nn)(!1),(0,d.td)()],Q.prototype,"startArrow",void 0),K([(0,d.nn)(1),(0,d.td)()],Q.prototype,"end",void 0),K([(0,d.nn)(0),(0,d.td)()],Q.prototype,"endOffset",void 0),K([(0,d.nn)(!1),(0,d.td)()],Q.prototype,"endArrow",void 0),K([(0,d.nn)(24),(0,d.td)()],Q.prototype,"arrowSize",void 0),K([(0,d.nn)(null),(0,d.td)()],Q.prototype,"points",void 0),K([(0,f.F)()],Q.prototype,"childrenBBox",null),K([(0,f.F)()],Q.prototype,"parsedPoints",null),K([(0,f.F)()],Q.prototype,"profile",null),K([(0,f.F)()],Q.prototype,"curveDrawingInfo",null);var tt=n(20092),et=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class nt extends m.b{constructor(t){super(t)}getPath(){const t=new Path2D,e=this.sides(),n=k.b.fromSizeCentered(this.size());return(0,M.is)(t,n,e),t}getRipplePath(){const t=new Path2D,e=this.sides(),n=this.rippleSize(),o=k.b.fromSizeCentered(this.size()).expand(n);return(0,M.is)(t,o,e),t}}et([(0,d.nn)(6),(0,d.td)()],nt.prototype,"sides",void 0);var ot=n(70419),st=n(79116),rt=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class it extends m.b{constructor(t){let{children:e,...n}=t;super(n),e&&this.text(e)}draw(t){this.requestFontUpdate(),this.applyStyle(t),this.applyText(t),t.font=this.styles.font,"letterSpacing"in t&&(t.letterSpacing=`${this.letterSpacing()}px`);const e=this.element.getBoundingClientRect(),{width:n,height:o}=this.size(),s=document.createRange();let r="";const i=new k.b;for(const a of this.element.childNodes){if(!a.textContent)continue;s.selectNodeContents(a);const p=s.getBoundingClientRect(),c=n/-2+p.left-e.left,l=o/-2+p.top-e.top;i.y===l?(i.width+=p.width,r+=a.textContent):(this.drawText(t,r,i),i.x=c,i.y=l,i.width=p.width,i.height=p.height,r=a.textContent)}this.drawText(t,r,i)}drawText(t,e,n){const o=n.y+n.height/2;t.save(),t.textBaseline="middle",this.lineWidth()<=0?t.fillText(e,n.x,o):this.strokeFirst()?(t.strokeText(e,n.x,o),t.fillText(e,n.x,o)):(t.fillText(e,n.x,o),t.strokeText(e,n.x,o)),t.restore()}formattedText(){return it.formatter.innerText=this.text(),it.formatter.innerText}updateLayout(){this.applyFont(),this.applyFlex(),this.justifyContent.isInitial()&&(this.element.style.justifyContent=this.styles.getPropertyValue("text-align"));if("nowrap"!==this.styles.whiteSpace&&"pre"!==this.styles.whiteSpace)if(this.element.innerText="",it.segmenter)for(const t of it.segmenter.segment(this.formattedText()))this.element.appendChild(document.createTextNode(t.segment));else for(const t of this.formattedText().split(""))this.element.appendChild(document.createTextNode(t));else if("pre"===this.styles.whiteSpace){this.element.innerText="";for(const t of this.text().split("\n"))this.element.appendChild(document.createTextNode(t+"\n"))}else this.element.innerText=this.formattedText()}}rt([(0,d.nn)(""),(0,d.JI)(V.JC),(0,d.td)()],it.prototype,"text",void 0),rt([(0,f.F)()],it.prototype,"formattedText",null),rt([(0,st.V)((()=>{const t=document.createElement("div");return ot.h.shadowRoot.append(t),t}))],it,"formatter",void 0),rt([(0,st.V)((()=>{try{return new Intl.Segmenter(void 0,{granularity:"grapheme"})}catch(t){return null}}))],it,"segmenter",void 0);var at=n(56632),pt=n(88733),ct=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class lt extends D.U{constructor(t){super(t),this.lastTime=-1}isPlaying(){return this.playing()}getCurrentTime(){return this.time()}getDuration(){return this.video().duration}desiredSize(){const t=super.desiredSize();if(null===t.x&&null===t.y){const t=this.video();return{x:t.videoWidth,y:t.videoHeight}}return t}completion(){return this.clampTime(this.time())/this.video().duration}video(){const t=this.src(),e=`${this.key}/${t}`;if(lt.pool[e])return lt.pool[e];const n=document.createElement("video");return n.src=t,n.readyState<2&&_.k.collectPromise(new Promise((t=>{const e=()=>{t(),n.removeEventListener("canplay",e)};n.addEventListener("canplay",e)}))),lt.pool[e]=n,n}seekedVideo(){const t=this.video(),e=this.clampTime(this.time());return t.paused||t.pause(),this.lastTime===e||this.setCurrentTime(e),t}fastSeekedVideo(){const t=this.video(),e=this.clampTime(this.time());if(this.lastTime===e)return t;const n=this.playing()&&e<t.duration;return n?t.paused&&_.k.collectPromise(t.play()):t.paused||t.pause(),Math.abs(t.currentTime-e)>.2?this.setCurrentTime(e):n||(t.currentTime=e),t}draw(t){this.drawShape(t),this.clip()&&t.clip(this.getPath());const e=this.alpha();if(e>0){const n=this.view().playbackState()===pt.q.Playing?this.fastSeekedVideo():this.seekedVideo(),o=k.b.fromSizeCentered(this.computedSize());t.save(),e<1&&(t.globalAlpha*=e),t.imageSmoothingEnabled=this.smoothing(),(0,M.AE)(t,n,o),t.restore()}this.drawChildren(t)}applyFlex(){super.applyFlex();const t=this.video();this.element.style.aspectRatio=(this.ratio()??t.videoWidth/t.videoHeight).toString()}setCurrentTime(t){const e=this.video();e.readyState<2||(e.currentTime=t,this.lastTime=t,e.seeking&&_.k.collectPromise(new Promise((t=>{const n=()=>{t(),e.removeEventListener("seeked",n)};e.addEventListener("seeked",n)}))))}play(){const t=(0,at.nn)().time,e=t()-this.time();this.playing(!0),this.time((()=>this.clampTime(t()-e)))}pause(){this.playing(!1),this.time.save(),this.video().pause()}seek(t){const e=this.playing();this.time(this.clampTime(t)),e?this.play():this.pause()}clampTime(t){return(0,V.uZ)(0,this.video().duration,t)}collectAsyncResources(){super.collectAsyncResources(),this.seekedVideo()}}lt.pool={},ct([(0,d.td)()],lt.prototype,"src",void 0),ct([(0,d.nn)(1),(0,d.td)()],lt.prototype,"alpha",void 0),ct([(0,d.nn)(!0),(0,d.td)()],lt.prototype,"smoothing",void 0),ct([(0,d.nn)(0),(0,d.td)()],lt.prototype,"time",void 0),ct([(0,d.nn)(!1),(0,d.td)()],lt.prototype,"playing",void 0),ct([(0,f.F)()],lt.prototype,"completion",null),ct([(0,f.F)()],lt.prototype,"video",null),ct([(0,f.F)()],lt.prototype,"seekedVideo",null),ct([(0,f.F)()],lt.prototype,"fastSeekedVideo",null);var ut=n(5376),mt=n(51284),dt=n(42075),ht=n(67292);function*yt(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];for(const o of e)yield o;yield*(0,mt.v)(!1,...e)}(0,dt.G)(yt,(0,ht.C)());var ft=n(80638);function*kt(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];for(const o of e)(0,ft.R)(o)?yield*o:o()}function wt(t){const e=(0,X.$r)(),n=(0,at.nn)();return e.timeEvents.register(t,n.time())}(0,dt.G)(kt,(0,ht.C)());var gt=n(97715);function*Mt(t,e){yield*Dt(wt(t)),e&&(yield*e)}function*Dt(t,e){void 0===t&&(t=0);const n=(0,at.nn)(),o=(0,gt.te)().framesToSeconds(1),s=n.time()+t;for(;s-o>n.fixed;)yield;n.time(s),e&&(yield*e)}function*_t(t,e){yield*Dt(t),(0,ft.R)(e)?yield*e:e()}function Xt(t,e){let n=!1;function*o(){const o=(0,gt.te)();let s=0,r=0;for(e(r),n=!0;;)s>=o.secondsToFrames(t)?(s=0,r++,e(r),n=!0):n=!1,s++,yield}return(0,dt.G)(o,(0,ht.C)("every")),{runner:o(),setInterval(e){t=e,n=!1},setCallback(t){e=t,n=!1},*sync(){for(;!n;)yield}}}function*xt(t,e){for(let n=0;n<t;n++){const t=e(n);t?yield*t:yield}}function*vt(){}(0,dt.G)(Mt,(0,ht.C)()),(0,dt.G)(Dt,(0,ht.C)()),(0,dt.G)(_t,(0,ht.C)()),(0,dt.G)(xt,(0,ht.C)()),(0,dt.G)(vt,(0,ht.C)());var Ct=n(77396);function*Tt(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),o=1;o<e;o++)n[o-1]=arguments[o];for(const s of n)yield s,yield*Dt(t);yield*(0,mt.v)(...n)}function*bt(t){const{slides:e}=(0,X.$r)(),n=(0,at.nn)();for(e.register(t,n.fixed),yield;e.shouldWait(t);)yield}(0,dt.G)(Tt,(0,ht.C)());var Lt=n(15688);function Zt(t){switch(typeof t){case"string":return t;case"undefined":return"undefined";default:return Number.isNaN(t)?"NaN":JSON.stringify(t)}}function Nt(t){const e={message:Zt(t)};t&&"object"==typeof t&&(e.object=t),(0,X.wL)().debug(e)}function St(t,e,n){return function(){(0,X.wL)().warn({message:e,remarks:n,stack:(new Error).stack});for(var o=arguments.length,s=new Array(o),r=0;r<o;r++)s[r]=arguments[r];return t.apply(this,s)}}var Rt=n(49111),Et=n(90031),zt=n(1119),At=n(37762),It=n(15649),Pt=n(11726);function Ft(t,e){return void 0===e&&(e=!0),"number"==typeof t?new Pt.k(e?t:t+(0,X.$r)().meta.seed.get()):(0,X.$r)().random}function Wt(){let t;return e=>{if(void 0===e)return t;t=e}}function Bt(t,e){return n=>{t[e]=n}}function Gt(){return{}}function Ot(){return(0,at.nn)().time()}function jt(t){return(0,X.$r)().lifecycleEvents.onBeginRender.subscribe(t)}function Ut(t){return(0,X.$r)().lifecycleEvents.onFinishRender.subscribe(t)}var qt=n(46096),Vt=n(81865),$t=n(73662),Ht=n(97140);function Jt(t,e){let n;void 0===e&&(e=null);const o=(0,Ht.g)(t);return(0,$t.D)((()=>{const t=o();var s;n&&n.promise===t||(n=Vt.h.collectPromise(t,(null==(s=n)?void 0:s.value)??e));return n.value}))}var Yt=n(16249),Kt=n(60771);g.Color.symbol=g.Color.prototype.symbol=Symbol.for("@motion-canvas/core/types/Color"),g.Color.lerp=g.Color.prototype.lerp=function(t,e,n,o){void 0===o&&(o="lch"),"string"==typeof t&&(t=new g.Color(t)),"string"==typeof e&&(e=new g.Color(e));const s=t instanceof g.Color,r=e instanceof g.Color;return s||(t=r?e.alpha(0):new g.Color("rgba(0, 0, 0, 0)")),r||(e=s?t.alpha(0):new g.Color("rgba(0, 0, 0, 0)")),(0,g.mix)(t,e,n,o)},g.Color.createLerp=g.Color.prototype.createLerp=t=>(e,n,o)=>g.Color.lerp(e,n,o,t),g.Color.createSignal=function(t,e){void 0===e&&(e=g.Color.lerp);const n=new Yt.V(t,e);return n.setParser((t=>new g.Color(t))),n.toSignal()},g.Color.prototype.toSymbol=()=>g.Color.symbol,g.Color.prototype.serialize=function(){return this.css()},g.Color.prototype.lerp=function(t,e,n){return g.Color.lerp(this,t,e,n)};var Qt=n(74741);class te{static fromRotation(t){return te.identity.rotate(t)}static fromTranslation(t){return te.identity.translate(new w.F(t))}static fromScaling(t){return te.identity.scale(new w.F(t))}get x(){return new w.F(this.values[0],this.values[1])}get y(){return new w.F(this.values[2],this.values[3])}get scaleX(){return this.values[0]}set scaleX(t){this.values[0]=this.x.normalized.scale(t).x}set scaleY(t){this.values[3]=this.y.normalized.scale(t).y}get scaleY(){return this.values[3]}set translateX(t){this.values[4]=t}get translateX(){return this.values[4]}set translateY(t){this.values[5]=t}get translateY(){return this.values[5]}set rotation(t){const e=this.rotate(t-this.rotation);this.values[0]=e.values[0],this.values[1]=e.values[1],this.values[2]=e.values[2],this.values[3]=e.values[3]}get rotation(){return 180*Math.atan2(this.values[1],this.values[0])/Math.PI}set translation(t){const e=new w.F(t);this.values[4]=e.x,this.values[5]=e.y}get translation(){return new w.F(this.values[4],this.values[5])}set scaling(t){const e=new w.F(t),n=new w.F(this.values[0],this.values[1]).normalized,o=new w.F(this.values[2],this.values[3]).normalized;this.values[0]=n.x*e.x,this.values[1]=n.y*e.y,this.values[2]=o.x*e.x,this.values[3]=o.y*e.y}get scaling(){return new w.F(this.values[0],this.values[3])}get inverse(){const t=this.values[0],e=this.values[1],n=this.values[2],o=this.values[3],s=this.values[4],r=this.values[5];let i=t*o-e*n;return i?(i=1/i,new te(o*i,-e*i,-n*i,t*i,(n*r-o*s)*i,(e*s-t*r)*i)):null}get determinant(){return this.values[0]*this.values[3]-this.values[1]*this.values[2]}get domMatrix(){return new DOMMatrix([this.values[0],this.values[1],this.values[2],this.values[3],this.values[4],this.values[5]])}constructor(t,e,n,o,s,r){if(this.values=new Float32Array(6),0===arguments.length)return void(this.values=new Float32Array([1,0,0,1,0,0]));if(6===arguments.length)return this.values[0]=t,this.values[1]=e,this.values[2]=n,this.values[3]=o,this.values[4]=s,void(this.values[5]=r);if(t instanceof te)return void(this.values=t.values);if(Array.isArray(t)){if(2===t.length)return this.values[0]=t[0],this.values[1]=t[1],this.values[2]=e[0],this.values[3]=e[1],this.values[4]=n[0],void(this.values[5]=n[1]);if(3===t.length){const e=new w.F(t[0]),n=new w.F(t[1]),o=new w.F(t[2]);return this.values[0]=e.x,this.values[1]=e.y,this.values[2]=n.x,this.values[3]=n.y,this.values[4]=o.x,void(this.values[5]=o.y)}return this.values[0]=t[0],this.values[1]=t[1],this.values[2]=t[2],this.values[3]=t[3],this.values[4]=t[4],void(this.values[5]=t[5])}const i=new w.F(t),a=new w.F(e),p=new w.F(n);this.values[0]=i.x,this.values[1]=i.y,this.values[2]=a.x,this.values[3]=a.y,this.values[4]=p.x,this.values[5]=p.y}column(t){return new w.F(this.values[2*t],this.values[2*t+1])}row(t){return[this.values[t],this.values[t+2],this.values[t+4]]}mul(t){const e=this.values[0],n=this.values[1],o=this.values[2],s=this.values[3],r=this.values[4],i=this.values[5],a=t.values[0],p=t.values[1],c=t.values[2],l=t.values[3],u=t.values[4],m=t.values[5];return new te(e*a+o*p,n*a+s*p,e*c+o*l,n*c+s*l,e*u+o*m+r,n*u+s*m+i)}rotate(t,e){void 0===e&&(e=!0),e&&(t=t*Math.PI/180);const n=this.values[0],o=this.values[1],s=this.values[2],r=this.values[3],i=this.values[4],a=this.values[5],p=Math.sin(t),c=Math.cos(t);return new te(n*c+s*p,o*c+r*p,n*-p+s*c,o*-p+r*c,i,a)}scale(t){const e=new w.F(t);return new te(this.values[0]*e.x,this.values[1]*e.x,this.values[2]*e.y,this.values[3]*e.y,this.values[4],this.values[5])}mulScalar(t){return new te(this.values[0]*t,this.values[1]*t,this.values[2]*t,this.values[3]*t,this.values[4]*t,this.values[5]*t)}translate(t){const e=new w.F(t);return new te(this.values[0],this.values[1],this.values[2],this.values[3],this.values[0]*e.x+this.values[2]*e.y+this.values[4],this.values[1]*e.x+this.values[3]*e.y+this.values[5])}add(t){return new te(this.values[0]+t.values[0],this.values[1]+t.values[1],this.values[2]+t.values[2],this.values[3]+t.values[3],this.values[4]+t.values[4],this.values[5]+t.values[5])}sub(t){return new te(this.values[0]-t.values[0],this.values[1]-t.values[1],this.values[2]-t.values[2],this.values[3]-t.values[3],this.values[4]-t.values[4],this.values[5]-t.values[5])}equals(t,e){return void 0===e&&(e=Qt.Ib),Math.abs(this.values[0]-t.values[0])<=e&&Math.abs(this.values[1]-t.values[1])<=e&&Math.abs(this.values[2]-t.values[2])<=e&&Math.abs(this.values[3]-t.values[3])<=e&&Math.abs(this.values[4]-t.values[4])<=e&&Math.abs(this.values[5]-t.values[5])<=e}exactlyEquals(t){return this.values[0]===t.values[0]&&this.values[1]===t.values[1]&&this.values[2]===t.values[2]&&this.values[3]===t.values[3]&&this.values[4]===t.values[4]&&this.values[5]===t.values[5]}}te.identity=new te(1,0,0,1,0,0),te.zero=new te(0,0,0,0,0,0);var ee=n(98378),ne=n(43188);function oe(t){return t&&"object"==typeof t&&"toSymbol"in t}var se=n(97074),re=n(74534);function*ie(t,e,n,o,s,r){const i="number"==typeof o?o:.001;r="number"==typeof o?r:s;const a=(t,e)=>{"function"==typeof o?o(t,e):"function"==typeof s&&s(t,e)};if((t=t??{mass:.05,stiffness:10,damping:.5}).mass<=0)return void(0,X.wL)().error(new Error("Spring mass must be greater than 0."));if(t.stiffness<0)return void(0,X.wL)().error(new Error("Spring stiffness must be greater or equal to 0."));if(t.damping<0)return void(0,X.wL)().error(new Error("Spring damping must be greater or equal to 0."));const p=(0,at.nn)();let c=e,l=t.initialVelocity??0;const u=e=>{if(null===t)return;const o=c-n,s=-t.stiffness*o-t.damping*l;l+=s/t.mass*e,c+=l*e},m=1/120;a(e,0);const d=p.time();let h=d,y=!1;for(;!y;){for(;h<p.fixed;){const t=p.fixed-h;if(m>t?(u(t),h=p.fixed):(u(m),h+=m),Math.abs(n-c)<i&&Math.abs(l)<i){p.time(h),y=!0;break}}y||(a(c,p.fixed-d),yield)}a(n,p.fixed-d),null==r||r(n,p.fixed-d)}function ae(t,e,n,o){return{mass:t,stiffness:e,damping:n,initialVelocity:o}}(0,dt.G)(ie,(0,ht.C)());const pe=ae(.13,5.7,1.2,10),ce=ae(.2,20,.68,0),le=ae(.08,4.75,.05,0),ue=ae(.39,19.85,2.82,0),me=ae(.04,10,.7,8),de=ae(.03,20,.9,4.8),he=ae(.16,15.35,1.88,0);function ye(){const t=(0,at.nn)();for(var e=arguments.length,n=new Array(e),o=0;o<e;o++)n[o]=arguments[o];for(const s of n){const e=t.children.find((t=>t.runner===s));e&&!e.canceled&&(e.cancel(),e.time(t.time()))}}var fe=n(75168),ke=n(50580),we=n(5881);const ge={...o,...s,...r,...i,...a,...p,...c,_jsx:function(t,e){const{ref:n,children:o,...s}=e,r=Array.isArray(o)?o.flat():o;if(t===u)return r;if(null!=(i=t.prototype)&&i.isClass){const e=new t({...s,children:r});return null==n||n(e),e}return t({...s,ref:n,children:r});var i},makeScene2D:l.r}},53487:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{v:()=>transform});var _babel_standalone__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(87243),_babel_standalone__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(_babel_standalone__WEBPACK_IMPORTED_MODULE_0__),_site_src_components_Fiddle_runtime__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(45573);function transform(code){try{const result=_babel_standalone__WEBPACK_IMPORTED_MODULE_0__.transform(code,{filename:"fiddle.tsx",presets:["typescript",["react",{runtime:"automatic",importSource:"@motion-canvas/2d/lib"}]],plugins:["mc"]});eval(result.code)}catch(e){return e}return null}_babel_standalone__WEBPACK_IMPORTED_MODULE_0__.registerPlugin("mc",(t=>{let{types:e}=t;return{visitor:{Program(t){t.node.body.unshift(e.variableDeclaration("const",[e.variableDeclarator(e.objectPattern(Object.keys(_site_src_components_Fiddle_runtime__WEBPACK_IMPORTED_MODULE_1__.Z).map((t=>e.objectProperty(e.identifier(t),e.identifier(t),!1,!0)))),e.memberExpression(e.identifier("window"),e.identifier("mc")))]))},ImportDeclaration(t){t.remove()},ExportDefaultDeclaration(t){t.replaceWith(t.node.declaration)}}}}))},70532:(t,e,n)=>{"use strict";n.d(e,{Z:()=>l});var o=n(2784),s=n(89741);const r="tooltip_lI6R",i="active_DOSD";var a=n(6277),p=n(88617),c=n(79322);function l(t){let{children:e}=t;const n=(0,s.Z)(),l=(0,p.rG)(),[u,m]=(0,o.useState)(!1),[d,h]=(0,o.useState)(null),y=(0,o.useRef)(),f=(0,o.useRef)(),k=(0,o.useRef)(),w=(0,o.useCallback)((()=>{if(!f.current||!k.current)return;const t=f.current.getBoundingClientRect();let e=window.innerWidth-t.left-496;e<0&&(e=0),k.current.style.right=`${e}px`,k.current.style.top=`${t.bottom}px`}),[]);return(0,o.useEffect)((()=>{if(!n)return;const t=t=>{var e,n,o;if(!t.target.href||null==(e=y.current)||!e.contains(t.target)||null!=(n=k.current)&&n.contains(t.target))return;const s=new URL(t.target.href,document.baseURI);if(s.pathname===window.location.pathname)return;const r=l(s.pathname+s.hash);null!=r&&null!=(o=r.comment)&&o.summary&&(f.current=t.target,m(!0),h(r.comment),w())},e=t=>{t.target===f.current&&m(!1)};return document.addEventListener("mouseenter",t,!0),document.addEventListener("focus",t,!0),document.addEventListener("mouseleave",e,!0),document.addEventListener("blur",e,!0),document.addEventListener("scroll",w),()=>{document.removeEventListener("mouseenter",t,!0),document.removeEventListener("focus",t,!0),document.removeEventListener("mouseleave",e,!0),document.removeEventListener("blur",e,!0),document.removeEventListener("scroll",w)}}),[n]),(0,o.useEffect)((()=>{w()})),o.createElement("div",{ref:y},e,o.createElement("div",{ref:k,className:(0,a.Z)(r,"padding--md margin-horiz--md",u&&i)},d&&o.createElement(c.Z,{comment:d,full:!1})))}},88617:(t,e,n)=>{"use strict";n.d(e,{Gr:()=>c,RU:()=>i,gs:()=>r,in:()=>a,rG:()=>p});var o=n(2784);const s=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:e,lookup:n,urlLookup:r}=t;return o.createElement(s.Provider,{value:{lookup:n,urlLookup:r}},e)}function i(t){const{lookup:e}=(0,o.useContext)(s);return e[t]}function a(){const{lookup:t}=(0,o.useContext)(s);return e=>{if("number"==typeof(null==e?void 0:e.project))return t[e.project][e.id]}}function p(){const{urlLookup:t,lookup:e}=(0,o.useContext)(s);return n=>{var o;const s=t[n];return s?(null==(o=e[s.projectId])?void 0:o[s.id])??null:null}}function c(t){if(t)return t.href}},80068:(t,e,n)=>{"use strict";n.d(e,{Ld:()=>a,Y0:()=>i,s2:()=>p});var o=n(2784),s=n(50822);const r=o.createContext(null);function i(t){let{children:e}=t;const n=(0,s.p)(),i=(0,o.useMemo)((()=>function(t,e){const{plain:n}=t,o=Object.create(null),s=t.styles.reduce(((t,n)=>{const{languages:o,style:s}=n;return o&&!o.includes(e)||n.types.forEach((e=>{t[e]={...t[e],...s}})),t}),o);return s.root=n,s.plain={...n,backgroundColor:null},s}(n,"typescript")),[n]);return o.createElement(r.Provider,{value:i},e)}function a(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return{className:`token ${t}`,style:e[t]??e.plain}}function p(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return e[t]??e.plain}},57708:(t,e,n)=>{"use strict";n.d(e,{It:()=>m,Wy:()=>l,mN:()=>u});var o=n(2784),s=n(31263),r=n(89741);const i="api-filters",a=s.Z.canUseDOM?localStorage.getItem(i):null,p=a?JSON.parse(a):{inherited:!0,private:!1},c=o.createContext([p,()=>{}]);function l(t){let{children:e}=t;const[n,s]=(0,o.useState)(p),a=(0,r.Z)();return o.createElement(c.Provider,{value:[n,t=>{a&&localStorage.setItem(i,JSON.stringify(t)),s(t)}]},e)}function u(){return(0,o.useContext)(c)}function m(t,e){var n,o;const s=(null==(n=e.flags)?void 0:n.isPrivate)||(null==(o=e.flags)?void 0:o.isProtected);if(!t.private&&s)return!1;const r=!!e.inheritedFrom;return!(!t.inherited&&r)}},26047:(t,e,n)=>{"use strict";n.d(e,{Z:()=>u});var o=n(7896),s=n(2784),r=n(59055);const i="icon_Fw4I";function a(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),s.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"}))}function p(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),s.createElement("path",{d:"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"}))}function c(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),s.createElement("path",{d:"M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"}))}function l(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),s.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"}))}function u(t){const e=(0,s.useMemo)((()=>{switch(t.type){case"tip":return l;case"caution":return p;case"danger":return c;default:return a}}),[t.type]);return s.createElement(s.Fragment,null,s.createElement(r.Z,(0,o.Z)({icon:s.createElement(e,{className:i})},t)))}},94141:(t,e,n)=>{"use strict";n.d(e,{Z:()=>a});var o=n(7896),s=n(2784),r=n(6277);const i="iconEdit_N_05";function a(t){let{className:e,...n}=t;return s.createElement("svg",(0,o.Z)({fill:"currentColor",width:"24px",height:"24px",viewBox:"0 0 24 24",className:(0,r.Z)(i,e),"aria-hidden":"true"},n),s.createElement("path",{d:"M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"}))}},44648:(t,e,n)=>{"use strict";n.d(e,{Z:()=>r});var o=n(7896),s=n(2784);function r(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",style:{width:16,height:16,marginTop:"0.1rem"}},t),s.createElement("path",{d:"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z",fill:"currentColor"}))}},57501:(t,e,n)=>{"use strict";n.d(e,{Z:()=>ot});var o=n(2784),s=n(52203),r=n(18888),i=n(35565),a=n(99387),p=n(77120),c=n(53947),l=n(86253);const u=p.Qf.define([{tag:l.pJ.comment,color:"var(--hl-comment)"},{tag:l.pJ.docComment,color:"var(--hl-comment)"},{tag:l.pJ.blockComment,color:"var(--hl-comment)"},{tag:l.pJ.keyword,color:"var(--hl-keyword)"},{tag:l.pJ.number,color:"var(--hl-number)"},{tag:l.pJ.inserted,color:"var(--hl-number)"},{tag:l.pJ.constant(l.pJ.propertyName),color:"var(--hl-constant)"},{tag:l.pJ.attributeName,color:"var(--hl-variable)"},{tag:l.pJ.variableName,color:"var(--hl-variable)"},{tag:l.pJ.propertyName,color:"var(--hl-variable)"},{tag:l.pJ.deleted,color:"var(--hl-string)"},{tag:l.pJ.string,color:"var(--hl-string)"},{tag:l.pJ.attributeValue,color:"var(--hl-string)"},{tag:l.pJ.tagName,color:"var(--hl-tag)"},{tag:l.pJ.typeName,color:"var(--hl-tag)"},{tag:l.pJ.punctuation,color:"var(--hl-punctuation)"},{tag:l.pJ.operator,color:"var(--hl-punctuation)"},{tag:l.pJ.function(l.pJ.variableName),color:"var(--hl-function)"},{tag:l.pJ.function(l.pJ.propertyName),color:"var(--hl-function)"},{tag:l.pJ.className,color:"var(--hl-class)"},{tag:l.pJ.character,color:"var(--hl-char)"}]),m=i.tk.theme({"&":{fontSize:"var(--ifm-code-font-size)",lineHeight:"21.04px",fontFamily:"var(--ifm-font-family-monospace)",color:"var(--hl-color)",backgroundColor:"var(--hl-background)"},"&.cm-focused .cm-cursor":{borderLeftColor:"var(--hl-color)"},"&.cm-focused":{outline:"none"},".cm-gutters":{backgroundColor:"var(--hl-background)",color:"var(--ifm-color-secondary-darkest)",borderRight:"1px solid var(--ifm-background-color)"},"& .cm-lineNumbers .cm-gutterElement":{paddingLeft:"var(--ifm-pre-padding)"},".cm-activeLineGutter":{backgroundColor:"var(--ifm-code-active-color)"},".cm-scroller":{fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",paddingTop:"var(--ifm-pre-padding)",paddingBottom:"var(--ifm-pre-padding)"},".cm-content":{padding:"0"},"& .cm-line":{paddingRight:"var(--ifm-pre-padding)"},"& .cm-selectionBackground, &.cm-focused .cm-selectionBackground, ::selection":{backgroundColor:"var(--ifm-code-selection-color)"},".cm-activeLine":{backgroundColor:"var(--ifm-code-active-color)"},".cm-selectionMatch":{backgroundColor:"var(--ifm-code-selection-color)"},".cm-foldPlaceholder":{backgroundColor:"var(--ifm-code-selection-color)",borderColor:"var(--ifm-color-emphasis-300)"},".cm-tooltip":{backgroundColor:"var(--ifm-background-surface-color)"}});var d=n(78128);function h(t){const[e,n]=(0,o.useState)(null==t?void 0:t.current);return(0,o.useEffect)((()=>t&&t.subscribe(n)),[t]),e}function y(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M6 6h2v12H6zm3.5 6l8.5 6V6z"}))}function f(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"}))}function k(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M8 5v14l11-7z"}))}function w(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M6 19h4V5H6v14zm8-14v14h4V5h-4z"}))}var g=n(45573);const M=Object.entries(g.Z).map((t=>{let[e,n]=t;return{label:e,type:"function"==typeof n?(o=n,o.prototype&&o.prototype.constructor.name?"class":"function"):"variable"};var o}));var D,_=n(96881);!function(t){t.Error="error",t.Warn="warn",t.Info="info",t.Http="http",t.Verbose="verbose",t.Debug="debug",t.Silly="silly"}(D||(D={}));class X{constructor(){this.logged=new _.p,this.history=[],this.profilers={}}get onLogged(){return this.logged.subscribable}log(t){this.logged.dispatch(t),this.history.push(t)}error(t){this.logLevel(D.Error,t)}warn(t){this.logLevel(D.Warn,t)}info(t){this.logLevel(D.Info,t)}http(t){this.logLevel(D.Http,t)}verbose(t){this.logLevel(D.Verbose,t)}debug(t){this.logLevel(D.Debug,t)}silly(t){this.logLevel(D.Silly,t)}logLevel(t,e){const n="string"==typeof e?{message:e}:e;n.level=t,this.log(n)}profile(t,e){const n=performance.now();if(this.profilers[t]){const o=this.profilers[t];delete this.profilers[t];const s=e??{message:t};return s.level??(s.level=D.Debug),s.durationMs=n-o,void this.log(s)}this.profilers[t]=n}}var x=n(82344),v=n(92673),C=n(5392);class T extends x.C{parse(t){return null===t?null:new C.Color(t)}serialize(){var t;return(null==(t=this.value.current)?void 0:t.serialize())??null}}var b=n(74741),L=n(13170);class Z extends x.C{parse(t){return this.parseRange(1/0,t[0],t[1]??1/0)}update(t,e,n,o){this.value.current=this.parseRange(n/o-b.Ib,t/o-b.Ib,e/o-b.Ib)}parseRange(t,e,n){return void 0===e&&(e=this.value.current[0]),void 0===n&&(n=this.value.current[1]),(e=(0,L.uZ)(0,t,e))>(n=(0,L.uZ)(0,t,n??1/0))&&([e,n]=[n,e]),n>=t&&(n=1/0),[e,n]}}var N=n(29797);class S extends x.C{parse(t){return new N.F(t)}serialize(){return this.value.current.serialize()}}class R extends v.v{constructor(){super("project",{version:new x.C("version",1),shared:new v.v("shared",{background:new T("background",null),range:new Z("range",[0,1/0]),size:new S("size",new N.F(1920,1080)),audioOffset:new x.C("audioOffset",0)}),preview:new v.v("preview",{fps:new x.C("fps",30),resolutionScale:new x.C("scale",1)}),rendering:new v.v("rendering",{fps:new x.C("fps",60),resolutionScale:new x.C("scale",2),colorSpace:new x.C("color space","srgb"),fileType:new x.C("file type","image/png"),quality:new x.C("quality",1),groupByScene:new x.C("group by scene",!1)})})}getFullPreviewSettings(){return{...this.shared.get(),...this.preview.get()}}getFullRenderingSettings(){return{...this.shared.get(),...this.rendering.get()}}}var E=n(2672),z=n(9989),A=n(15914),I=n(1323);let P=null,F=null,W=null,B=null,G=null,O=null;function j(t,e){var n;if(t!==G)return P||(window.mc={...g.Z,makeScene2D:t=>(F.config=t,F.onReplaced.current=F,F)},F=(0,A.r)((function*(){yield})),F.onReplaced=new I.G(F),P={name:"fiddle",logger:new X,meta:new R,scenes:[F]},P.meta.shared.size.set([960,240]),W=new E.J(P,{size:P.meta.shared.size.get()}),B=new z.H,B.configure({size:P.meta.shared.size.get()}),W.onRender.subscribe((async()=>{await B.render(W.playback.currentScene,W.playback.previousScene)})),W.onRecalculated.subscribe((()=>{var t;B.finalBuffer.parentElement!==O&&(null==(t=O)||t.append(B.finalBuffer),G(W))}))),null==(n=O)||n.removeChild(B.finalBuffer),null==G||G(null),G=t,O=e,W.activate(),W.requestReset(),W}const U="root_icgl",q="progress_HsLC",V="controls_R4ai",$="section_UscS",H="icon_brRG",J="error_N64d",Y="editor_xQGp",K="source_Dq6N",Q="preview_C9cZ",tt="button_ESGX";var et=n(53487);function nt(t){let{children:e}=t;const[n,s]=(0,o.useState)(null),l=(0,o.useRef)(null),g=(0,o.useRef)(),D=(0,o.useRef)(),[_,X]=(0,o.useState)(null),x=h(null==n?void 0:n.onDurationChanged),v=h(null==n?void 0:n.onFrameChanged),C=h(null==n?void 0:n.onStateChanged),[T,b]=(0,o.useState)(null),[L,Z]=(0,o.useState)(null),[N,S]=(0,o.useState)(null),R=function(t,e){if(void 0===e&&(e=!0),null!=L&&L.eq(t))return;j(s,D.current);const n=(0,et.v)(t.sliceString(0));var o;X(n),n||(Z(t),e&&D.current.animate((void 0===o&&(o=4),[{boxShadow:"0 0 0px 0 #ccc inset",easing:"cubic-bezier(0.33, 1, 0.68, 1)"},{boxShadow:`0 0 0px ${o}px #ccc inset`,easing:"cubic-bezier(0.32, 0, 0.67, 0)"},{boxShadow:"0 0 0px 0 #ccc inset"}]),{duration:300}))};return(0,o.useEffect)((()=>{l.current=new i.tk({extensions:[r.Xy,i.$f.of([c.oc,{key:"Mod-s",preventDefault:!0,run:t=>(R(t.state.doc),!0)}]),i.tk.updateListener.of((t=>{b(t.state.doc),X(null)})),a.Lz.data.of({autocomplete:t=>{if("String"===(0,p.qz)(t.state).resolveInner(t.pos,-1).name)return;const e=t.matchBefore(/\w*/);return e.from!=e.to||t.explicit?{from:e.from,options:M}:null}}),(0,a.eJ)({jsx:!0,typescript:!0}),(0,p.nF)(u),m],parent:g.current,doc:e}),S(l.current.state);var t,n;return(t=s,n=D.current,G?null:j(t,n))&&R(l.current.state.doc,!1),()=>{!function(t){G===t&&P&&(W.deactivate(),G=null,O=null,B.finalBuffer.remove())}(s),l.current.destroy()}}),[]),o.createElement("div",{className:U},o.createElement("div",{className:Q,ref:D},!n&&o.createElement("div",null,"Press play to preview the animation")),o.createElement("div",{className:q,style:{width:n?v/x*100+"%":0}}),o.createElement("div",{className:V},o.createElement("div",{className:$},L&&!(null!=T&&T.eq(L))&&o.createElement("button",{onClick:()=>R(l.current.state.doc),className:tt},o.createElement("kbd",null,"CTRL"),o.createElement("kbd",null,"S"),o.createElement("small",null,"Update preview"))),o.createElement("div",{className:$},o.createElement("button",{className:H,onClick:()=>null==n?void 0:n.requestPreviousFrame()},o.createElement(y,null)),o.createElement("button",{className:H,onClick:()=>{if(n)L||R(l.current.state.doc),n.togglePlayback();else{const t=j(s,D.current);R(l.current.state.doc),t.togglePlayback(!0)}}},!n||((null==C?void 0:C.paused)??1)?o.createElement(k,null):o.createElement(w,null)),o.createElement("button",{className:H,onClick:()=>null==n?void 0:n.requestNextFrame()},o.createElement(f,null))),o.createElement("div",{className:$},(N&&!(null!=T&&T.eq(N.doc))||L&&!(null!=T&&T.eq(L)))&&o.createElement("button",{className:tt,onClick:()=>{l.current.setState(N),R(N.doc),b(N.doc)}},o.createElement("small",null,"Reset example")))),_&&o.createElement("pre",{className:J},_.message),o.createElement("div",{className:Y,ref:g},o.createElement(d.Z,{className:K,language:"tsx"},e+"\n")))}const ot={...s.Z,pre:function(t){var e,n;return(0,o.isValidElement)(t.children)&&null!=(e=t.children.props)&&e.editor?o.createElement(nt,null,t.children.props.children):o.createElement(d.Z,(0,o.isValidElement)(t.children)&&"code"===(null==(n=t.children.props)?void 0:n.originalType)?t.children.props:{...t})}}},47733:(t,e,n)=>{"use strict";n.d(e,{Z:()=>a});var o=n(7896),s=n(2784),r=n(77287);const i="root_ZAv1";function a(t){const e=s.Children.toArray(t.children),n=e.find((t=>{var e;return s.isValidElement(t)&&"summary"===(null==(e=t.props)?void 0:e.mdxType)})),a=s.createElement(s.Fragment,null,e.filter((t=>t!==n)));return s.createElement(s.Fragment,null,s.createElement(r.P,(0,o.Z)({},t,{summary:n,className:i}),a))}},46155:(t,e,n)=>{var o={"./locale":99394,"./locale.js":99394};function s(t){var e=r(t);return n(e)}function r(t){if(!n.o(o,t)){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}return o[t]}s.keys=function(){return Object.keys(o)},s.resolve=r,t.exports=s,s.id=46155}}]);
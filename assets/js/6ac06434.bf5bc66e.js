"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[5997],{30876:(t,n,e)=>{e.d(n,{Zo:()=>l,kt:()=>h});var o=e(2784);function p(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function s(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,o)}return e}function r(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?s(Object(e),!0).forEach((function(n){p(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):s(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function c(t,n){if(null==t)return{};var e,o,p=function(t,n){if(null==t)return{};var e,o,p={},s=Object.keys(t);for(o=0;o<s.length;o++)e=s[o],n.indexOf(e)>=0||(p[e]=t[e]);return p}(t,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(o=0;o<s.length;o++)e=s[o],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(p[e]=t[e])}return p}var a=o.createContext({}),i=function(t){var n=o.useContext(a),e=n;return t&&(e="function"==typeof t?t(n):r(r({},n),t)),e},l=function(t){var n=i(t.components);return o.createElement(a.Provider,{value:n},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var n=t.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(t,n){var e=t.components,p=t.mdxType,s=t.originalType,a=t.parentName,l=c(t,["components","mdxType","originalType","parentName"]),u=i(e),d=p,h=u["".concat(a,".").concat(d)]||u[d]||m[d]||s;return e?o.createElement(h,r(r({ref:n},l),{},{components:e})):o.createElement(h,r({ref:n},l))}));function h(t,n){var e=arguments,p=n&&n.mdxType;if("string"==typeof t||p){var s=e.length,r=new Array(s);r[0]=d;var c={};for(var a in n)hasOwnProperty.call(n,a)&&(c[a]=n[a]);c.originalType=t,c[u]="string"==typeof t?t:p,r[1]=c;for(var i=2;i<s;i++)r[i]=e[i];return o.createElement.apply(null,r)}return o.createElement.apply(null,e)}d.displayName="MDXCreateElement"},83851:(t,n,e)=>{e.d(n,{Z:()=>u});var o=e(7896),p=e(2784),s=e(6277),r=e(1077),c=e(97683),a=e(89817);const i="anchorWithStickyNavbar_fF9Z",l="anchorWithHideOnScrollNavbar_Yh18";function u(t){let{as:n,id:e,...u}=t;const{navbar:{hideOnScroll:m}}=(0,c.L)();if("h1"===n||!e)return p.createElement(n,(0,o.Z)({},u,{id:void 0}));const d=(0,r.I)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:"string"==typeof u.children?u.children:e});return p.createElement(n,(0,o.Z)({},u,{className:(0,s.Z)("anchor",m?l:i,u.className),id:e}),u.children,p.createElement(a.Z,{className:"hash-link",to:`#${e}`,"aria-label":d,title:d},"\u200b"))}},82009:(t,n,e)=>{e.d(n,{Z:()=>r});var o=e(2784),p=e(6277);const s="tabItem_OMyP";function r(t){let{children:n,hidden:e,className:r}=t;return o.createElement("div",{role:"tabpanel",className:(0,p.Z)(s,r),hidden:e},n)}},77336:(t,n,e)=>{e.d(n,{Z:()=>X});var o=e(7896),p=e(2784),s=e(6277),r=e(24126),c=e(53181),a=e(32424),i=e(42244),l=e(24155);function u(t){return function(t){return p.Children.map(t,(t=>{if((0,p.isValidElement)(t)&&"value"in t.props)return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(t).map((t=>{let{props:{value:n,label:e,attributes:o,default:p}}=t;return{value:n,label:e,attributes:o,default:p}}))}function m(t){const{values:n,children:e}=t;return(0,p.useMemo)((()=>{const t=n??u(e);return function(t){const n=(0,i.l)(t,((t,n)=>t.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[n,e])}function d(t){let{value:n,tabValues:e}=t;return e.some((t=>t.value===n))}function h(t){let{queryString:n=!1,groupId:e}=t;const o=(0,c.k6)(),s=function(t){let{queryString:n=!1,groupId:e}=t;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!e)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return e??null}({queryString:n,groupId:e});return[(0,a._X)(s),(0,p.useCallback)((t=>{if(!s)return;const n=new URLSearchParams(o.location.search);n.set(s,t),o.replace({...o.location,search:n.toString()})}),[s,o])]}function k(t){const{defaultValue:n,queryString:e=!1,groupId:o}=t,s=m(t),[r,c]=(0,p.useState)((()=>function(t){let{defaultValue:n,tabValues:e}=t;if(0===e.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!d({value:n,tabValues:e}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${e.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const o=e.find((t=>t.default))??e[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:n,tabValues:s}))),[a,i]=h({queryString:e,groupId:o}),[u,k]=function(t){let{groupId:n}=t;const e=function(t){return t?`docusaurus.tab.${t}`:null}(n),[o,s]=(0,l.Nk)(e);return[o,(0,p.useCallback)((t=>{e&&s.set(t)}),[e,s])]}({groupId:o}),y=(()=>{const t=a??u;return d({value:t,tabValues:s})?t:null})();(0,p.useLayoutEffect)((()=>{y&&c(y)}),[y]);return{selectedValue:r,selectValue:(0,p.useCallback)((t=>{if(!d({value:t,tabValues:s}))throw new Error(`Can't select invalid tab value=${t}`);c(t),i(t),k(t)}),[i,k,s]),tabValues:s}}var y=e(89741);const f="tabList_M0Dn",M="tabItem_ysIP";function w(t){let{className:n,block:e,selectedValue:c,selectValue:a,tabValues:i}=t;const l=[],{blockElementScrollPositionUntilNextRender:u}=(0,r.o5)(),m=t=>{const n=t.currentTarget,e=l.indexOf(n),o=i[e].value;o!==c&&(u(n),a(o))},d=t=>{var n;let e=null;switch(t.key){case"Enter":m(t);break;case"ArrowRight":{const n=l.indexOf(t.currentTarget)+1;e=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(t.currentTarget)-1;e=l[n]??l[l.length-1];break}}null==(n=e)||n.focus()};return p.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":e},n)},i.map((t=>{let{value:n,label:e,attributes:r}=t;return p.createElement("li",(0,o.Z)({role:"tab",tabIndex:c===n?0:-1,"aria-selected":c===n,key:n,ref:t=>l.push(t),onKeyDown:d,onClick:m},r,{className:(0,s.Z)("tabs__item",M,null==r?void 0:r.className,{"tabs__item--active":c===n})}),e??n)})))}function D(t){let{lazy:n,children:e,selectedValue:o}=t;if(e=Array.isArray(e)?e:[e],n){const t=e.find((t=>t.props.value===o));return t?(0,p.cloneElement)(t,{className:"margin-top--md"}):null}return p.createElement("div",{className:"margin-top--md"},e.map(((t,n)=>(0,p.cloneElement)(t,{key:n,hidden:t.props.value!==o}))))}function _(t){const n=k(t);return p.createElement("div",{className:(0,s.Z)("tabs-container",f)},p.createElement(w,(0,o.Z)({},t,n)),p.createElement(D,(0,o.Z)({},t,n)))}function X(t){const n=(0,y.Z)();return p.createElement(_,(0,o.Z)({key:String(n)},t))}},52665:(t,n,e)=>{e.d(n,{Z:()=>k});var o=e(2784);const p="container_lQCo",s="small_As57",r="banner_A4QS",c="player_tELG",a="link_BTzN",i="icon_wSGd";var l=e(7896);function u(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0},p),o.createElement("path",{d:"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z",fill:"currentColor"}))}var m=e(89817),d=e(6277);function h(t){let{name:n}=t;const e=`https://github.com/motion-canvas/motion-canvas/blob/main/packages/examples/src/scenes/${n}.tsx`;return o.createElement(m.Z,{to:e,className:(0,d.Z)("padding--sm",a)},o.createElement("span",null,"View source code"),o.createElement(u,{className:i}))}function k(t){let{name:n,banner:e,small:a,link:i}=t;return o.createElement("div",{className:(0,d.Z)(p,e&&r,a&&s)},o.createElement("motion-canvas-player",{class:c,src:`/examples/${n}.js`,auto:e}),o.createElement(h,{name:i||n}))}e(31263).Z.canUseDOM&&e.e(5483).then(e.bind(e,85483))},42072:(t,n,e)=>{e.d(n,{Z:()=>r});var o=e(2784),p=e(88617),s=e(62830);function r(t){let{url:n}=t;const e=(0,p.rG)()(n);return o.createElement(s.Z,{reflection:e,headless:!0})}},97219:(t,n,e)=>{e.d(n,{Z:()=>cSt});var o={};e.r(o),e.d(o,{content_0_0:()=>a,content_0_10:()=>M,content_0_100:()=>tn,content_0_1000:()=>Pf,content_0_1002:()=>Bf,content_0_1004:()=>Uf,content_0_1006:()=>Vf,content_0_1008:()=>Of,content_0_1010:()=>$f,content_0_1012:()=>Yf,content_0_1014:()=>Qf,content_0_1016:()=>nM,content_0_1018:()=>oM,content_0_102:()=>en,content_0_1020:()=>sM,content_0_1022:()=>cM,content_0_1024:()=>iM,content_0_1026:()=>uM,content_0_1028:()=>dM,content_0_1030:()=>kM,content_0_1032:()=>fM,content_0_1034:()=>wM,content_0_1036:()=>_M,content_0_1038:()=>gM,content_0_104:()=>pn,content_0_1040:()=>CM,content_0_1042:()=>vM,content_0_1044:()=>LM,content_0_1046:()=>NM,content_0_1048:()=>RM,content_0_1050:()=>SM,content_0_1052:()=>IM,content_0_1054:()=>PM,content_0_1056:()=>BM,content_0_1058:()=>UM,content_0_106:()=>rn,content_0_1060:()=>VM,content_0_1062:()=>OM,content_0_1064:()=>$M,content_0_108:()=>an,content_0_110:()=>un,content_0_112:()=>dn,content_0_114:()=>kn,content_0_116:()=>fn,content_0_118:()=>wn,content_0_12:()=>D,content_0_120:()=>_n,content_0_122:()=>gn,content_0_124:()=>Cn,content_0_126:()=>vn,content_0_128:()=>Ln,content_0_130:()=>Nn,content_0_132:()=>Rn,content_0_134:()=>Sn,content_0_136:()=>In,content_0_138:()=>Pn,content_0_14:()=>X,content_0_140:()=>Bn,content_0_142:()=>Un,content_0_144:()=>Vn,content_0_146:()=>On,content_0_148:()=>$n,content_0_150:()=>Yn,content_0_152:()=>Qn,content_0_154:()=>ne,content_0_156:()=>oe,content_0_158:()=>se,content_0_16:()=>x,content_0_160:()=>ce,content_0_162:()=>ie,content_0_164:()=>ue,content_0_166:()=>de,content_0_168:()=>ke,content_0_170:()=>fe,content_0_172:()=>we,content_0_174:()=>_e,content_0_176:()=>ge,content_0_178:()=>Ce,content_0_18:()=>T,content_0_180:()=>ve,content_0_182:()=>Le,content_0_184:()=>Ne,content_0_186:()=>Re,content_0_188:()=>Se,content_0_190:()=>Ie,content_0_192:()=>Pe,content_0_194:()=>Be,content_0_196:()=>Ue,content_0_198:()=>Ve,content_0_2:()=>l,content_0_20:()=>b,content_0_200:()=>Oe,content_0_202:()=>$e,content_0_204:()=>Ye,content_0_206:()=>Qe,content_0_208:()=>no,content_0_210:()=>oo,content_0_212:()=>so,content_0_214:()=>co,content_0_216:()=>io,content_0_218:()=>uo,content_0_22:()=>Z,content_0_220:()=>ho,content_0_222:()=>yo,content_0_224:()=>Mo,content_0_226:()=>Do,content_0_228:()=>Xo,content_0_230:()=>xo,content_0_232:()=>To,content_0_234:()=>bo,content_0_236:()=>Zo,content_0_238:()=>Ao,content_0_24:()=>A,content_0_240:()=>Eo,content_0_242:()=>zo,content_0_244:()=>Wo,content_0_246:()=>Go,content_0_248:()=>Fo,content_0_250:()=>qo,content_0_252:()=>jo,content_0_254:()=>Ho,content_0_256:()=>Ko,content_0_258:()=>Jo,content_0_26:()=>E,content_0_260:()=>tp,content_0_262:()=>ep,content_0_264:()=>pp,content_0_266:()=>rp,content_0_268:()=>ap,content_0_270:()=>lp,content_0_272:()=>mp,content_0_274:()=>hp,content_0_276:()=>yp,content_0_278:()=>Mp,content_0_28:()=>z,content_0_280:()=>Dp,content_0_282:()=>Xp,content_0_284:()=>xp,content_0_286:()=>Tp,content_0_288:()=>bp,content_0_290:()=>Zp,content_0_292:()=>Ap,content_0_294:()=>Ep,content_0_296:()=>zp,content_0_298:()=>Wp,content_0_30:()=>W,content_0_300:()=>Gp,content_0_302:()=>Fp,content_0_304:()=>qp,content_0_306:()=>jp,content_0_308:()=>Hp,content_0_310:()=>Kp,content_0_312:()=>Jp,content_0_314:()=>ts,content_0_316:()=>es,content_0_318:()=>ps,content_0_32:()=>G,content_0_320:()=>rs,content_0_322:()=>as,content_0_324:()=>ls,content_0_326:()=>ms,content_0_328:()=>hs,content_0_330:()=>ys,content_0_332:()=>Ms,content_0_334:()=>Ds,content_0_336:()=>Xs,content_0_338:()=>xs,content_0_34:()=>F,content_0_340:()=>Ts,content_0_342:()=>bs,content_0_344:()=>Zs,content_0_346:()=>As,content_0_348:()=>Es,content_0_350:()=>zs,content_0_352:()=>Ws,content_0_354:()=>Gs,content_0_356:()=>Fs,content_0_358:()=>qs,content_0_36:()=>q,content_0_360:()=>js,content_0_362:()=>Hs,content_0_364:()=>Ks,content_0_366:()=>Js,content_0_368:()=>tr,content_0_370:()=>er,content_0_372:()=>pr,content_0_374:()=>rr,content_0_376:()=>ar,content_0_378:()=>lr,content_0_38:()=>j,content_0_380:()=>mr,content_0_382:()=>hr,content_0_384:()=>yr,content_0_386:()=>Mr,content_0_388:()=>Dr,content_0_390:()=>Xr,content_0_392:()=>xr,content_0_394:()=>Tr,content_0_396:()=>br,content_0_398:()=>Zr,content_0_4:()=>m,content_0_40:()=>H,content_0_400:()=>Ar,content_0_402:()=>Er,content_0_404:()=>zr,content_0_406:()=>Wr,content_0_408:()=>Gr,content_0_410:()=>Fr,content_0_412:()=>qr,content_0_414:()=>jr,content_0_416:()=>Hr,content_0_418:()=>Kr,content_0_42:()=>K,content_0_420:()=>Jr,content_0_422:()=>tc,content_0_424:()=>ec,content_0_426:()=>pc,content_0_428:()=>rc,content_0_430:()=>ac,content_0_432:()=>lc,content_0_434:()=>mc,content_0_436:()=>hc,content_0_438:()=>yc,content_0_44:()=>J,content_0_440:()=>Mc,content_0_442:()=>Dc,content_0_444:()=>Xc,content_0_446:()=>xc,content_0_448:()=>Tc,content_0_450:()=>bc,content_0_452:()=>Zc,content_0_454:()=>Ac,content_0_456:()=>Ec,content_0_458:()=>zc,content_0_46:()=>tt,content_0_460:()=>Wc,content_0_462:()=>Gc,content_0_464:()=>Fc,content_0_466:()=>qc,content_0_468:()=>jc,content_0_470:()=>Hc,content_0_472:()=>Kc,content_0_474:()=>Jc,content_0_476:()=>ta,content_0_478:()=>ea,content_0_48:()=>et,content_0_480:()=>pa,content_0_482:()=>ra,content_0_484:()=>aa,content_0_486:()=>la,content_0_488:()=>ma,content_0_490:()=>ha,content_0_492:()=>ya,content_0_494:()=>Ma,content_0_496:()=>Da,content_0_498:()=>Xa,content_0_50:()=>pt,content_0_500:()=>xa,content_0_502:()=>Ta,content_0_504:()=>ba,content_0_506:()=>Za,content_0_508:()=>Aa,content_0_510:()=>Ea,content_0_512:()=>za,content_0_514:()=>Wa,content_0_516:()=>Ga,content_0_518:()=>Fa,content_0_52:()=>rt,content_0_520:()=>qa,content_0_522:()=>ja,content_0_524:()=>Ha,content_0_526:()=>Ka,content_0_528:()=>Ja,content_0_530:()=>ti,content_0_532:()=>ei,content_0_534:()=>pi,content_0_536:()=>ri,content_0_538:()=>ai,content_0_54:()=>at,content_0_540:()=>li,content_0_542:()=>mi,content_0_544:()=>hi,content_0_546:()=>yi,content_0_548:()=>Mi,content_0_550:()=>Di,content_0_552:()=>Xi,content_0_554:()=>xi,content_0_556:()=>Ti,content_0_558:()=>bi,content_0_56:()=>lt,content_0_560:()=>Zi,content_0_562:()=>Ai,content_0_564:()=>Ei,content_0_566:()=>zi,content_0_568:()=>Wi,content_0_570:()=>Gi,content_0_572:()=>Fi,content_0_574:()=>qi,content_0_576:()=>ji,content_0_578:()=>Hi,content_0_58:()=>mt,content_0_580:()=>Ki,content_0_582:()=>Ji,content_0_584:()=>tl,content_0_586:()=>el,content_0_588:()=>pl,content_0_590:()=>rl,content_0_592:()=>al,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>yl,content_0_602:()=>Ml,content_0_604:()=>Dl,content_0_606:()=>Xl,content_0_608:()=>xl,content_0_610:()=>Tl,content_0_612:()=>bl,content_0_614:()=>Zl,content_0_616:()=>Al,content_0_618:()=>El,content_0_62:()=>yt,content_0_620:()=>zl,content_0_622:()=>Wl,content_0_624:()=>Gl,content_0_626:()=>Fl,content_0_628:()=>ql,content_0_630:()=>jl,content_0_632:()=>Hl,content_0_634:()=>Kl,content_0_636:()=>Jl,content_0_638:()=>tu,content_0_64:()=>Mt,content_0_640:()=>eu,content_0_642:()=>pu,content_0_644:()=>ru,content_0_646:()=>au,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>yu,content_0_656:()=>Mu,content_0_658:()=>Du,content_0_66:()=>Dt,content_0_660:()=>Xu,content_0_662:()=>xu,content_0_664:()=>Tu,content_0_666:()=>bu,content_0_668:()=>Zu,content_0_670:()=>Au,content_0_672:()=>Eu,content_0_674:()=>zu,content_0_676:()=>Wu,content_0_678:()=>Gu,content_0_68:()=>Xt,content_0_680:()=>Fu,content_0_682:()=>qu,content_0_684:()=>ju,content_0_686:()=>Hu,content_0_688:()=>Ku,content_0_690:()=>Ju,content_0_692:()=>tm,content_0_694:()=>em,content_0_696:()=>pm,content_0_698:()=>rm,content_0_70:()=>xt,content_0_700:()=>am,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>ym,content_0_710:()=>Mm,content_0_712:()=>Dm,content_0_714:()=>Xm,content_0_716:()=>xm,content_0_718:()=>Tm,content_0_72:()=>Tt,content_0_720:()=>bm,content_0_722:()=>Zm,content_0_724:()=>Am,content_0_726:()=>Em,content_0_728:()=>zm,content_0_730:()=>Wm,content_0_732:()=>Gm,content_0_734:()=>Fm,content_0_736:()=>qm,content_0_738:()=>jm,content_0_74:()=>bt,content_0_740:()=>Hm,content_0_742:()=>Km,content_0_744:()=>Jm,content_0_746:()=>td,content_0_748:()=>ed,content_0_750:()=>pd,content_0_752:()=>rd,content_0_754:()=>ad,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>Zt,content_0_760:()=>hd,content_0_762:()=>yd,content_0_764:()=>Md,content_0_766:()=>Dd,content_0_768:()=>Xd,content_0_770:()=>xd,content_0_772:()=>Td,content_0_774:()=>bd,content_0_776:()=>Zd,content_0_778:()=>Ad,content_0_78:()=>At,content_0_780:()=>Ed,content_0_782:()=>zd,content_0_784:()=>Wd,content_0_786:()=>Gd,content_0_788:()=>Fd,content_0_790:()=>qd,content_0_792:()=>jd,content_0_794:()=>Hd,content_0_796:()=>Kd,content_0_798:()=>Jd,content_0_8:()=>y,content_0_80:()=>Et,content_0_800:()=>th,content_0_802:()=>eh,content_0_804:()=>ph,content_0_806:()=>rh,content_0_808:()=>ah,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>yh,content_0_818:()=>Mh,content_0_82:()=>zt,content_0_820:()=>Dh,content_0_822:()=>Xh,content_0_824:()=>xh,content_0_826:()=>Th,content_0_828:()=>bh,content_0_830:()=>Zh,content_0_832:()=>Ah,content_0_834:()=>Eh,content_0_836:()=>zh,content_0_838:()=>Wh,content_0_84:()=>Wt,content_0_840:()=>Gh,content_0_842:()=>Fh,content_0_844:()=>qh,content_0_846:()=>jh,content_0_848:()=>Hh,content_0_850:()=>Kh,content_0_852:()=>Jh,content_0_854:()=>tk,content_0_856:()=>ek,content_0_858:()=>pk,content_0_86:()=>Gt,content_0_860:()=>rk,content_0_862:()=>ak,content_0_864:()=>lk,content_0_866:()=>mk,content_0_868:()=>hk,content_0_870:()=>yk,content_0_872:()=>Mk,content_0_874:()=>Dk,content_0_876:()=>Xk,content_0_878:()=>xk,content_0_88:()=>Ft,content_0_880:()=>Tk,content_0_882:()=>bk,content_0_884:()=>Zk,content_0_886:()=>Ak,content_0_888:()=>Ek,content_0_890:()=>zk,content_0_892:()=>Wk,content_0_894:()=>Gk,content_0_896:()=>Fk,content_0_898:()=>qk,content_0_90:()=>qt,content_0_900:()=>jk,content_0_902:()=>Hk,content_0_904:()=>Kk,content_0_906:()=>Jk,content_0_908:()=>ty,content_0_910:()=>ey,content_0_912:()=>py,content_0_914:()=>ry,content_0_916:()=>ay,content_0_918:()=>ly,content_0_92:()=>jt,content_0_920:()=>my,content_0_922:()=>hy,content_0_924:()=>yy,content_0_926:()=>My,content_0_928:()=>Dy,content_0_930:()=>Xy,content_0_932:()=>xy,content_0_934:()=>Ty,content_0_936:()=>by,content_0_938:()=>Zy,content_0_94:()=>Ht,content_0_940:()=>Ay,content_0_942:()=>Ey,content_0_944:()=>zy,content_0_946:()=>Wy,content_0_948:()=>Gy,content_0_950:()=>Fy,content_0_952:()=>qy,content_0_954:()=>jy,content_0_956:()=>Hy,content_0_958:()=>Ky,content_0_96:()=>Kt,content_0_960:()=>Jy,content_0_962:()=>tf,content_0_964:()=>ef,content_0_966:()=>pf,content_0_968:()=>rf,content_0_970:()=>af,content_0_972:()=>uf,content_0_974:()=>df,content_0_976:()=>kf,content_0_978:()=>ff,content_0_98:()=>Jt,content_0_980:()=>wf,content_0_982:()=>_f,content_0_984:()=>gf,content_0_986:()=>Cf,content_0_988:()=>vf,content_0_990:()=>Lf,content_0_992:()=>Nf,content_0_994:()=>Rf,content_0_996:()=>Sf,content_0_998:()=>If,content_2251_0:()=>YM,content_2251_10:()=>cw,content_2251_100:()=>UD,content_2251_1000:()=>CI,content_2251_1002:()=>vI,content_2251_1004:()=>LI,content_2251_1006:()=>NI,content_2251_1008:()=>RI,content_2251_1010:()=>SI,content_2251_1012:()=>II,content_2251_1014:()=>PI,content_2251_1016:()=>BI,content_2251_1018:()=>UI,content_2251_102:()=>VD,content_2251_1020:()=>VI,content_2251_1022:()=>OI,content_2251_1024:()=>$I,content_2251_1026:()=>YI,content_2251_1028:()=>QI,content_2251_1030:()=>nW,content_2251_1032:()=>oW,content_2251_1034:()=>sW,content_2251_1036:()=>cW,content_2251_1038:()=>iW,content_2251_104:()=>OD,content_2251_1040:()=>uW,content_2251_1042:()=>dW,content_2251_1044:()=>kW,content_2251_1046:()=>fW,content_2251_1048:()=>wW,content_2251_1050:()=>_W,content_2251_1052:()=>gW,content_2251_1054:()=>CW,content_2251_1056:()=>vW,content_2251_1058:()=>LW,content_2251_106:()=>$D,content_2251_1060:()=>NW,content_2251_1062:()=>RW,content_2251_1064:()=>SW,content_2251_1066:()=>IW,content_2251_1068:()=>PW,content_2251_1070:()=>BW,content_2251_1072:()=>UW,content_2251_1074:()=>VW,content_2251_1076:()=>OW,content_2251_1078:()=>$W,content_2251_108:()=>YD,content_2251_1080:()=>YW,content_2251_1082:()=>QW,content_2251_1084:()=>nP,content_2251_1086:()=>oP,content_2251_1088:()=>sP,content_2251_1090:()=>cP,content_2251_1092:()=>iP,content_2251_1094:()=>uP,content_2251_1096:()=>dP,content_2251_1098:()=>kP,content_2251_110:()=>QD,content_2251_1100:()=>fP,content_2251_1102:()=>wP,content_2251_1104:()=>_P,content_2251_1106:()=>gP,content_2251_1108:()=>CP,content_2251_1110:()=>vP,content_2251_1112:()=>LP,content_2251_1114:()=>NP,content_2251_1116:()=>RP,content_2251_1118:()=>SP,content_2251_112:()=>n_,content_2251_1120:()=>IP,content_2251_1122:()=>PP,content_2251_1124:()=>BP,content_2251_1126:()=>UP,content_2251_1128:()=>VP,content_2251_1130:()=>OP,content_2251_1132:()=>$P,content_2251_1134:()=>YP,content_2251_1136:()=>QP,content_2251_1138:()=>nG,content_2251_114:()=>o_,content_2251_1140:()=>oG,content_2251_1142:()=>sG,content_2251_1144:()=>cG,content_2251_1146:()=>iG,content_2251_1148:()=>uG,content_2251_1150:()=>dG,content_2251_1152:()=>kG,content_2251_1154:()=>fG,content_2251_1156:()=>wG,content_2251_1158:()=>_G,content_2251_116:()=>s_,content_2251_1160:()=>gG,content_2251_1162:()=>CG,content_2251_1164:()=>vG,content_2251_1166:()=>LG,content_2251_1168:()=>NG,content_2251_1170:()=>RG,content_2251_1172:()=>SG,content_2251_1174:()=>IG,content_2251_1176:()=>PG,content_2251_1178:()=>BG,content_2251_118:()=>c_,content_2251_1180:()=>UG,content_2251_1182:()=>VG,content_2251_1184:()=>OG,content_2251_1186:()=>$G,content_2251_1188:()=>YG,content_2251_1190:()=>QG,content_2251_1192:()=>nB,content_2251_1194:()=>oB,content_2251_1196:()=>sB,content_2251_1198:()=>cB,content_2251_12:()=>iw,content_2251_120:()=>i_,content_2251_1200:()=>iB,content_2251_1202:()=>uB,content_2251_1204:()=>dB,content_2251_1206:()=>kB,content_2251_1208:()=>fB,content_2251_1210:()=>wB,content_2251_1212:()=>_B,content_2251_1214:()=>gB,content_2251_1216:()=>CB,content_2251_1218:()=>vB,content_2251_122:()=>u_,content_2251_1220:()=>LB,content_2251_1222:()=>NB,content_2251_1224:()=>RB,content_2251_1226:()=>SB,content_2251_1228:()=>IB,content_2251_1230:()=>PB,content_2251_1232:()=>BB,content_2251_1234:()=>UB,content_2251_1236:()=>VB,content_2251_1238:()=>OB,content_2251_124:()=>d_,content_2251_1240:()=>$B,content_2251_1242:()=>YB,content_2251_1244:()=>QB,content_2251_1246:()=>nF,content_2251_1248:()=>oF,content_2251_1250:()=>sF,content_2251_1252:()=>cF,content_2251_1254:()=>iF,content_2251_1256:()=>uF,content_2251_1258:()=>dF,content_2251_126:()=>k_,content_2251_1260:()=>kF,content_2251_1262:()=>fF,content_2251_1264:()=>wF,content_2251_1266:()=>_F,content_2251_1268:()=>gF,content_2251_1270:()=>CF,content_2251_1272:()=>vF,content_2251_1274:()=>LF,content_2251_1276:()=>NF,content_2251_1278:()=>RF,content_2251_128:()=>f_,content_2251_1280:()=>SF,content_2251_1282:()=>IF,content_2251_1284:()=>PF,content_2251_1286:()=>BF,content_2251_1288:()=>UF,content_2251_1290:()=>VF,content_2251_1292:()=>OF,content_2251_1294:()=>$F,content_2251_1296:()=>YF,content_2251_1298:()=>QF,content_2251_130:()=>w_,content_2251_1300:()=>nU,content_2251_1302:()=>oU,content_2251_1304:()=>sU,content_2251_1306:()=>cU,content_2251_1308:()=>iU,content_2251_1310:()=>uU,content_2251_1312:()=>dU,content_2251_1314:()=>kU,content_2251_1316:()=>fU,content_2251_1318:()=>wU,content_2251_132:()=>__,content_2251_1320:()=>_U,content_2251_1322:()=>gU,content_2251_1324:()=>CU,content_2251_1326:()=>vU,content_2251_1328:()=>LU,content_2251_1330:()=>NU,content_2251_1332:()=>RU,content_2251_1334:()=>SU,content_2251_1336:()=>IU,content_2251_1338:()=>PU,content_2251_134:()=>g_,content_2251_1340:()=>BU,content_2251_1342:()=>UU,content_2251_1344:()=>VU,content_2251_1346:()=>OU,content_2251_1348:()=>$U,content_2251_1350:()=>YU,content_2251_1352:()=>QU,content_2251_1354:()=>nq,content_2251_1356:()=>oq,content_2251_1358:()=>sq,content_2251_136:()=>C_,content_2251_1360:()=>cq,content_2251_1362:()=>iq,content_2251_1364:()=>uq,content_2251_1366:()=>dq,content_2251_1368:()=>kq,content_2251_1370:()=>fq,content_2251_1372:()=>wq,content_2251_1374:()=>_q,content_2251_1376:()=>gq,content_2251_1378:()=>Cq,content_2251_138:()=>v_,content_2251_1380:()=>vq,content_2251_1382:()=>Lq,content_2251_1384:()=>Nq,content_2251_1386:()=>Rq,content_2251_1388:()=>Sq,content_2251_1390:()=>Iq,content_2251_1392:()=>Pq,content_2251_1394:()=>Bq,content_2251_1396:()=>Uq,content_2251_1398:()=>Vq,content_2251_14:()=>uw,content_2251_140:()=>L_,content_2251_1400:()=>Oq,content_2251_1402:()=>$q,content_2251_1404:()=>Yq,content_2251_1406:()=>Qq,content_2251_1408:()=>nV,content_2251_1410:()=>oV,content_2251_1412:()=>sV,content_2251_1414:()=>cV,content_2251_1416:()=>iV,content_2251_1418:()=>uV,content_2251_142:()=>N_,content_2251_1420:()=>dV,content_2251_1422:()=>kV,content_2251_1424:()=>fV,content_2251_1426:()=>wV,content_2251_1428:()=>_V,content_2251_1430:()=>gV,content_2251_1432:()=>CV,content_2251_1434:()=>vV,content_2251_1436:()=>LV,content_2251_1438:()=>NV,content_2251_144:()=>R_,content_2251_1440:()=>RV,content_2251_1442:()=>SV,content_2251_1444:()=>IV,content_2251_1446:()=>PV,content_2251_1448:()=>BV,content_2251_1450:()=>UV,content_2251_1452:()=>VV,content_2251_1454:()=>OV,content_2251_1456:()=>$V,content_2251_1458:()=>YV,content_2251_146:()=>S_,content_2251_1460:()=>QV,content_2251_1462:()=>nj,content_2251_1464:()=>oj,content_2251_1466:()=>sj,content_2251_1468:()=>cj,content_2251_1470:()=>ij,content_2251_1472:()=>uj,content_2251_1474:()=>dj,content_2251_1476:()=>kj,content_2251_1478:()=>fj,content_2251_148:()=>I_,content_2251_1480:()=>wj,content_2251_1482:()=>_j,content_2251_1484:()=>gj,content_2251_1486:()=>Cj,content_2251_1488:()=>vj,content_2251_1490:()=>Lj,content_2251_1492:()=>Nj,content_2251_1494:()=>Rj,content_2251_1496:()=>Sj,content_2251_1498:()=>Ij,content_2251_150:()=>P_,content_2251_1500:()=>Pj,content_2251_1502:()=>Bj,content_2251_1504:()=>Uj,content_2251_1506:()=>Vj,content_2251_1508:()=>Oj,content_2251_1510:()=>$j,content_2251_1512:()=>Yj,content_2251_1514:()=>Qj,content_2251_1516:()=>nO,content_2251_1518:()=>oO,content_2251_152:()=>B_,content_2251_1520:()=>sO,content_2251_1522:()=>cO,content_2251_1524:()=>iO,content_2251_1526:()=>uO,content_2251_1528:()=>dO,content_2251_1530:()=>kO,content_2251_1532:()=>fO,content_2251_1534:()=>wO,content_2251_1536:()=>_O,content_2251_1538:()=>gO,content_2251_154:()=>U_,content_2251_1540:()=>CO,content_2251_1542:()=>vO,content_2251_1544:()=>LO,content_2251_1546:()=>NO,content_2251_1548:()=>RO,content_2251_1550:()=>SO,content_2251_1552:()=>IO,content_2251_1554:()=>PO,content_2251_1556:()=>BO,content_2251_1558:()=>UO,content_2251_156:()=>V_,content_2251_1560:()=>VO,content_2251_1562:()=>OO,content_2251_1564:()=>$O,content_2251_1566:()=>YO,content_2251_1568:()=>QO,content_2251_1570:()=>nH,content_2251_1572:()=>oH,content_2251_1574:()=>sH,content_2251_1576:()=>cH,content_2251_1578:()=>iH,content_2251_158:()=>O_,content_2251_1580:()=>uH,content_2251_1582:()=>dH,content_2251_1584:()=>kH,content_2251_1586:()=>fH,content_2251_1588:()=>wH,content_2251_1590:()=>_H,content_2251_1592:()=>gH,content_2251_1594:()=>CH,content_2251_1596:()=>vH,content_2251_1598:()=>LH,content_2251_16:()=>dw,content_2251_160:()=>$_,content_2251_1600:()=>NH,content_2251_1602:()=>RH,content_2251_1604:()=>SH,content_2251_1606:()=>IH,content_2251_1608:()=>PH,content_2251_1610:()=>BH,content_2251_1612:()=>UH,content_2251_1614:()=>VH,content_2251_1616:()=>OH,content_2251_1618:()=>$H,content_2251_162:()=>Y_,content_2251_1620:()=>YH,content_2251_1622:()=>QH,content_2251_1624:()=>n$,content_2251_1626:()=>o$,content_2251_1628:()=>s$,content_2251_1630:()=>c$,content_2251_1632:()=>i$,content_2251_1634:()=>u$,content_2251_1636:()=>d$,content_2251_1638:()=>k$,content_2251_164:()=>Q_,content_2251_1640:()=>f$,content_2251_1642:()=>w$,content_2251_1644:()=>_$,content_2251_1646:()=>g$,content_2251_1648:()=>C$,content_2251_1650:()=>v$,content_2251_1652:()=>L$,content_2251_1654:()=>N$,content_2251_1656:()=>R$,content_2251_1658:()=>S$,content_2251_166:()=>nX,content_2251_1660:()=>I$,content_2251_1662:()=>P$,content_2251_1664:()=>B$,content_2251_1666:()=>U$,content_2251_1668:()=>V$,content_2251_1670:()=>O$,content_2251_1672:()=>$$,content_2251_1674:()=>Y$,content_2251_1676:()=>Q$,content_2251_1678:()=>nK,content_2251_168:()=>oX,content_2251_1680:()=>oK,content_2251_1682:()=>sK,content_2251_1684:()=>cK,content_2251_1686:()=>iK,content_2251_1688:()=>uK,content_2251_1690:()=>dK,content_2251_1692:()=>kK,content_2251_1694:()=>fK,content_2251_1696:()=>wK,content_2251_1698:()=>_K,content_2251_170:()=>sX,content_2251_1700:()=>gK,content_2251_1702:()=>CK,content_2251_1704:()=>vK,content_2251_1706:()=>LK,content_2251_1708:()=>NK,content_2251_1710:()=>RK,content_2251_1712:()=>SK,content_2251_1714:()=>IK,content_2251_1716:()=>PK,content_2251_1718:()=>BK,content_2251_172:()=>cX,content_2251_1720:()=>UK,content_2251_1722:()=>VK,content_2251_1724:()=>OK,content_2251_1726:()=>$K,content_2251_1728:()=>YK,content_2251_1730:()=>QK,content_2251_1732:()=>nY,content_2251_1734:()=>oY,content_2251_1736:()=>sY,content_2251_1738:()=>cY,content_2251_174:()=>iX,content_2251_1740:()=>iY,content_2251_1742:()=>uY,content_2251_1744:()=>dY,content_2251_1746:()=>kY,content_2251_1748:()=>fY,content_2251_1750:()=>wY,content_2251_1752:()=>_Y,content_2251_1754:()=>gY,content_2251_1756:()=>CY,content_2251_1758:()=>vY,content_2251_176:()=>uX,content_2251_1760:()=>LY,content_2251_1762:()=>NY,content_2251_1764:()=>RY,content_2251_1766:()=>SY,content_2251_1768:()=>IY,content_2251_1770:()=>PY,content_2251_1772:()=>BY,content_2251_1774:()=>UY,content_2251_1776:()=>VY,content_2251_1778:()=>OY,content_2251_178:()=>dX,content_2251_1780:()=>$Y,content_2251_1782:()=>YY,content_2251_1784:()=>QY,content_2251_1786:()=>nJ,content_2251_1788:()=>oJ,content_2251_1790:()=>sJ,content_2251_1792:()=>cJ,content_2251_1794:()=>iJ,content_2251_1796:()=>uJ,content_2251_1798:()=>dJ,content_2251_18:()=>kw,content_2251_180:()=>kX,content_2251_1800:()=>kJ,content_2251_1802:()=>fJ,content_2251_1804:()=>wJ,content_2251_1806:()=>_J,content_2251_1808:()=>gJ,content_2251_1810:()=>CJ,content_2251_1812:()=>vJ,content_2251_1814:()=>LJ,content_2251_1816:()=>NJ,content_2251_1818:()=>RJ,content_2251_182:()=>fX,content_2251_1820:()=>SJ,content_2251_1822:()=>IJ,content_2251_1824:()=>PJ,content_2251_1826:()=>BJ,content_2251_1828:()=>UJ,content_2251_1830:()=>VJ,content_2251_1832:()=>OJ,content_2251_1834:()=>$J,content_2251_1836:()=>YJ,content_2251_1838:()=>QJ,content_2251_184:()=>wX,content_2251_1840:()=>nQ,content_2251_1842:()=>oQ,content_2251_1844:()=>sQ,content_2251_1846:()=>cQ,content_2251_1848:()=>iQ,content_2251_1850:()=>uQ,content_2251_1852:()=>dQ,content_2251_1854:()=>kQ,content_2251_1856:()=>fQ,content_2251_1858:()=>wQ,content_2251_186:()=>_X,content_2251_1860:()=>_Q,content_2251_1862:()=>gQ,content_2251_1864:()=>CQ,content_2251_1866:()=>vQ,content_2251_1868:()=>LQ,content_2251_1870:()=>NQ,content_2251_1872:()=>RQ,content_2251_1874:()=>SQ,content_2251_1876:()=>IQ,content_2251_1878:()=>PQ,content_2251_188:()=>gX,content_2251_1880:()=>BQ,content_2251_1882:()=>UQ,content_2251_1884:()=>VQ,content_2251_1886:()=>OQ,content_2251_1888:()=>$Q,content_2251_1890:()=>YQ,content_2251_1892:()=>QQ,content_2251_1894:()=>n0,content_2251_1896:()=>o0,content_2251_1898:()=>s0,content_2251_190:()=>CX,content_2251_1900:()=>c0,content_2251_1902:()=>i0,content_2251_1904:()=>u0,content_2251_1906:()=>d0,content_2251_1908:()=>k0,content_2251_1910:()=>f0,content_2251_1912:()=>w0,content_2251_1914:()=>_0,content_2251_1916:()=>g0,content_2251_1918:()=>C0,content_2251_192:()=>vX,content_2251_1920:()=>v0,content_2251_1922:()=>L0,content_2251_1924:()=>N0,content_2251_1926:()=>R0,content_2251_1928:()=>S0,content_2251_1930:()=>I0,content_2251_1932:()=>P0,content_2251_1934:()=>B0,content_2251_1936:()=>U0,content_2251_1938:()=>V0,content_2251_194:()=>LX,content_2251_1940:()=>O0,content_2251_1942:()=>$0,content_2251_1944:()=>Y0,content_2251_1946:()=>Q0,content_2251_1948:()=>n2,content_2251_1950:()=>o2,content_2251_1952:()=>s2,content_2251_1954:()=>c2,content_2251_1956:()=>i2,content_2251_1958:()=>u2,content_2251_196:()=>NX,content_2251_1960:()=>d2,content_2251_1962:()=>k2,content_2251_1964:()=>f2,content_2251_1966:()=>w2,content_2251_1968:()=>_2,content_2251_1970:()=>g2,content_2251_1972:()=>C2,content_2251_1974:()=>v2,content_2251_1976:()=>L2,content_2251_1978:()=>N2,content_2251_198:()=>RX,content_2251_1980:()=>R2,content_2251_1982:()=>S2,content_2251_1984:()=>I2,content_2251_1986:()=>P2,content_2251_1988:()=>B2,content_2251_1990:()=>U2,content_2251_1992:()=>V2,content_2251_1994:()=>O2,content_2251_1996:()=>$2,content_2251_1998:()=>Y2,content_2251_2:()=>QM,content_2251_20:()=>fw,content_2251_200:()=>SX,content_2251_2000:()=>Q2,content_2251_2002:()=>n1,content_2251_2004:()=>o1,content_2251_2006:()=>s1,content_2251_2008:()=>c1,content_2251_2010:()=>i1,content_2251_2012:()=>u1,content_2251_2014:()=>d1,content_2251_2016:()=>k1,content_2251_2018:()=>f1,content_2251_202:()=>IX,content_2251_2020:()=>w1,content_2251_2022:()=>_1,content_2251_2024:()=>g1,content_2251_2026:()=>C1,content_2251_2028:()=>v1,content_2251_2030:()=>L1,content_2251_2032:()=>N1,content_2251_2034:()=>R1,content_2251_2036:()=>S1,content_2251_2038:()=>I1,content_2251_204:()=>PX,content_2251_2040:()=>P1,content_2251_2042:()=>B1,content_2251_2044:()=>U1,content_2251_2046:()=>V1,content_2251_2048:()=>O1,content_2251_2050:()=>$1,content_2251_2052:()=>Y1,content_2251_2054:()=>Q1,content_2251_2056:()=>n5,content_2251_2058:()=>o5,content_2251_206:()=>BX,content_2251_2060:()=>s5,content_2251_2062:()=>c5,content_2251_2064:()=>i5,content_2251_2066:()=>u5,content_2251_2068:()=>d5,content_2251_2070:()=>k5,content_2251_2072:()=>f5,content_2251_2074:()=>w5,content_2251_2076:()=>_5,content_2251_2078:()=>g5,content_2251_208:()=>UX,content_2251_2080:()=>C5,content_2251_2082:()=>v5,content_2251_2084:()=>L5,content_2251_2086:()=>N5,content_2251_2088:()=>R5,content_2251_2090:()=>S5,content_2251_2092:()=>I5,content_2251_2094:()=>P5,content_2251_2096:()=>B5,content_2251_2098:()=>U5,content_2251_210:()=>VX,content_2251_2100:()=>V5,content_2251_2102:()=>O5,content_2251_2104:()=>$5,content_2251_2106:()=>Y5,content_2251_2108:()=>Q5,content_2251_2110:()=>n4,content_2251_2112:()=>o4,content_2251_2114:()=>s4,content_2251_2116:()=>c4,content_2251_2118:()=>i4,content_2251_212:()=>OX,content_2251_2120:()=>u4,content_2251_2122:()=>d4,content_2251_2124:()=>k4,content_2251_2126:()=>f4,content_2251_2128:()=>w4,content_2251_2130:()=>_4,content_2251_2132:()=>g4,content_2251_2134:()=>C4,content_2251_2136:()=>v4,content_2251_2138:()=>L4,content_2251_214:()=>$X,content_2251_2140:()=>N4,content_2251_2142:()=>R4,content_2251_2144:()=>S4,content_2251_2146:()=>I4,content_2251_2148:()=>P4,content_2251_2150:()=>B4,content_2251_2152:()=>U4,content_2251_2154:()=>V4,content_2251_2156:()=>O4,content_2251_2158:()=>$4,content_2251_216:()=>YX,content_2251_2160:()=>Y4,content_2251_2162:()=>Q4,content_2251_2164:()=>n3,content_2251_2166:()=>o3,content_2251_2168:()=>s3,content_2251_2170:()=>c3,content_2251_2172:()=>i3,content_2251_2174:()=>u3,content_2251_2176:()=>d3,content_2251_2178:()=>k3,content_2251_218:()=>QX,content_2251_2180:()=>f3,content_2251_2182:()=>w3,content_2251_2184:()=>_3,content_2251_2186:()=>g3,content_2251_2188:()=>C3,content_2251_2190:()=>v3,content_2251_2192:()=>L3,content_2251_2194:()=>N3,content_2251_2196:()=>R3,content_2251_2198:()=>S3,content_2251_22:()=>ww,content_2251_220:()=>ng,content_2251_2200:()=>I3,content_2251_2202:()=>P3,content_2251_2204:()=>B3,content_2251_2206:()=>U3,content_2251_2208:()=>V3,content_2251_2210:()=>O3,content_2251_2212:()=>$3,content_2251_2214:()=>Y3,content_2251_2216:()=>Q3,content_2251_2218:()=>n6,content_2251_222:()=>og,content_2251_2220:()=>o6,content_2251_2222:()=>s6,content_2251_2224:()=>c6,content_2251_2226:()=>i6,content_2251_2228:()=>u6,content_2251_2230:()=>d6,content_2251_2232:()=>k6,content_2251_2234:()=>f6,content_2251_2236:()=>w6,content_2251_2238:()=>_6,content_2251_224:()=>sg,content_2251_2240:()=>g6,content_2251_2242:()=>C6,content_2251_2244:()=>v6,content_2251_2246:()=>L6,content_2251_2248:()=>N6,content_2251_2250:()=>R6,content_2251_2252:()=>S6,content_2251_2254:()=>I6,content_2251_2256:()=>P6,content_2251_2258:()=>B6,content_2251_226:()=>cg,content_2251_2260:()=>U6,content_2251_2262:()=>V6,content_2251_2264:()=>O6,content_2251_2266:()=>$6,content_2251_2268:()=>Y6,content_2251_2270:()=>Q6,content_2251_2272:()=>n8,content_2251_2274:()=>o8,content_2251_2276:()=>s8,content_2251_2278:()=>c8,content_2251_228:()=>ig,content_2251_2280:()=>i8,content_2251_2282:()=>u8,content_2251_2284:()=>d8,content_2251_2286:()=>k8,content_2251_2288:()=>f8,content_2251_2290:()=>w8,content_2251_2292:()=>_8,content_2251_2294:()=>g8,content_2251_2296:()=>C8,content_2251_2298:()=>v8,content_2251_230:()=>ug,content_2251_2300:()=>L8,content_2251_2302:()=>N8,content_2251_2304:()=>R8,content_2251_2306:()=>S8,content_2251_2308:()=>I8,content_2251_2310:()=>P8,content_2251_2312:()=>B8,content_2251_2314:()=>U8,content_2251_2316:()=>V8,content_2251_2318:()=>O8,content_2251_232:()=>dg,content_2251_2320:()=>$8,content_2251_2322:()=>Y8,content_2251_2324:()=>Q8,content_2251_2326:()=>n7,content_2251_2328:()=>o7,content_2251_2330:()=>s7,content_2251_2332:()=>c7,content_2251_2334:()=>i7,content_2251_2336:()=>u7,content_2251_2338:()=>d7,content_2251_234:()=>kg,content_2251_2340:()=>k7,content_2251_2342:()=>f7,content_2251_2344:()=>w7,content_2251_2346:()=>_7,content_2251_2348:()=>g7,content_2251_2350:()=>C7,content_2251_2352:()=>v7,content_2251_2354:()=>L7,content_2251_2356:()=>N7,content_2251_2358:()=>R7,content_2251_236:()=>fg,content_2251_2360:()=>S7,content_2251_2362:()=>I7,content_2251_2364:()=>P7,content_2251_2366:()=>B7,content_2251_2368:()=>U7,content_2251_2370:()=>V7,content_2251_2372:()=>O7,content_2251_2374:()=>$7,content_2251_2376:()=>Y7,content_2251_2378:()=>Q7,content_2251_238:()=>wg,content_2251_2380:()=>n9,content_2251_2382:()=>o9,content_2251_2384:()=>s9,content_2251_2386:()=>c9,content_2251_2388:()=>i9,content_2251_2390:()=>u9,content_2251_2392:()=>d9,content_2251_2394:()=>k9,content_2251_2396:()=>f9,content_2251_2398:()=>w9,content_2251_24:()=>_w,content_2251_240:()=>_g,content_2251_2400:()=>_9,content_2251_2402:()=>g9,content_2251_2404:()=>C9,content_2251_2406:()=>v9,content_2251_2408:()=>L9,content_2251_2410:()=>N9,content_2251_2412:()=>R9,content_2251_2414:()=>S9,content_2251_2416:()=>I9,content_2251_2418:()=>P9,content_2251_242:()=>gg,content_2251_2420:()=>B9,content_2251_2422:()=>U9,content_2251_2424:()=>V9,content_2251_2426:()=>O9,content_2251_2428:()=>$9,content_2251_2430:()=>Y9,content_2251_2432:()=>Q9,content_2251_2434:()=>ntt,content_2251_2436:()=>ott,content_2251_2438:()=>stt,content_2251_244:()=>Cg,content_2251_2440:()=>ctt,content_2251_2442:()=>itt,content_2251_2444:()=>utt,content_2251_2446:()=>dtt,content_2251_2448:()=>ktt,content_2251_2450:()=>ftt,content_2251_2452:()=>wtt,content_2251_2454:()=>_tt,content_2251_2456:()=>gtt,content_2251_2458:()=>Ctt,content_2251_246:()=>vg,content_2251_2460:()=>vtt,content_2251_2462:()=>Ltt,content_2251_2464:()=>Ntt,content_2251_2466:()=>Rtt,content_2251_2468:()=>Stt,content_2251_2470:()=>Itt,content_2251_2472:()=>Ptt,content_2251_2474:()=>Btt,content_2251_2476:()=>Utt,content_2251_2478:()=>Vtt,content_2251_248:()=>Lg,content_2251_2480:()=>Ott,content_2251_2482:()=>$tt,content_2251_2484:()=>Ytt,content_2251_2486:()=>Qtt,content_2251_2488:()=>nnt,content_2251_2490:()=>ont,content_2251_2492:()=>snt,content_2251_2494:()=>cnt,content_2251_2496:()=>int,content_2251_2498:()=>unt,content_2251_250:()=>Ng,content_2251_2500:()=>dnt,content_2251_2502:()=>knt,content_2251_2504:()=>fnt,content_2251_2506:()=>wnt,content_2251_2508:()=>_nt,content_2251_2510:()=>gnt,content_2251_2512:()=>Cnt,content_2251_2514:()=>vnt,content_2251_2516:()=>Lnt,content_2251_2518:()=>Nnt,content_2251_252:()=>Rg,content_2251_2520:()=>Rnt,content_2251_2522:()=>Snt,content_2251_2524:()=>Int,content_2251_2526:()=>Pnt,content_2251_2528:()=>Bnt,content_2251_2530:()=>Unt,content_2251_2532:()=>Vnt,content_2251_2534:()=>Ont,content_2251_2536:()=>$nt,content_2251_2538:()=>Ynt,content_2251_254:()=>Sg,content_2251_2540:()=>Qnt,content_2251_2542:()=>net,content_2251_2544:()=>oet,content_2251_2546:()=>set,content_2251_2548:()=>cet,content_2251_2550:()=>iet,content_2251_2552:()=>met,content_2251_2554:()=>het,content_2251_2556:()=>yet,content_2251_2558:()=>Met,content_2251_256:()=>Ig,content_2251_2560:()=>Det,content_2251_2562:()=>Xet,content_2251_2564:()=>xet,content_2251_2566:()=>Tet,content_2251_2568:()=>bet,content_2251_2570:()=>Zet,content_2251_2572:()=>Aet,content_2251_2574:()=>Eet,content_2251_2576:()=>zet,content_2251_2578:()=>Wet,content_2251_258:()=>Pg,content_2251_2580:()=>Get,content_2251_2582:()=>Fet,content_2251_2584:()=>qet,content_2251_2586:()=>jet,content_2251_2588:()=>Het,content_2251_2590:()=>Ket,content_2251_2592:()=>Jet,content_2251_2594:()=>tot,content_2251_2596:()=>eot,content_2251_2598:()=>pot,content_2251_26:()=>gw,content_2251_260:()=>Bg,content_2251_2600:()=>rot,content_2251_2602:()=>aot,content_2251_2604:()=>lot,content_2251_2606:()=>mot,content_2251_2608:()=>hot,content_2251_2610:()=>yot,content_2251_2612:()=>Mot,content_2251_2614:()=>Dot,content_2251_2616:()=>Xot,content_2251_2618:()=>xot,content_2251_262:()=>Ug,content_2251_2620:()=>Tot,content_2251_2622:()=>bot,content_2251_2624:()=>Zot,content_2251_2626:()=>Aot,content_2251_2628:()=>Eot,content_2251_2630:()=>zot,content_2251_2632:()=>Wot,content_2251_2634:()=>Got,content_2251_2636:()=>Fot,content_2251_2638:()=>qot,content_2251_264:()=>Vg,content_2251_2640:()=>jot,content_2251_2642:()=>Hot,content_2251_2644:()=>Kot,content_2251_2646:()=>Jot,content_2251_2648:()=>tpt,content_2251_2650:()=>ept,content_2251_2652:()=>ppt,content_2251_2654:()=>rpt,content_2251_2656:()=>apt,content_2251_2658:()=>lpt,content_2251_266:()=>Og,content_2251_2660:()=>mpt,content_2251_2662:()=>hpt,content_2251_2664:()=>ypt,content_2251_2666:()=>Mpt,content_2251_2668:()=>Dpt,content_2251_2670:()=>Xpt,content_2251_2672:()=>xpt,content_2251_2674:()=>Tpt,content_2251_2676:()=>bpt,content_2251_2678:()=>Zpt,content_2251_268:()=>$g,content_2251_2680:()=>Apt,content_2251_2682:()=>Ept,content_2251_2684:()=>zpt,content_2251_2686:()=>Wpt,content_2251_2688:()=>Gpt,content_2251_2690:()=>Fpt,content_2251_2692:()=>qpt,content_2251_2694:()=>jpt,content_2251_2696:()=>Hpt,content_2251_2698:()=>Kpt,content_2251_270:()=>Yg,content_2251_2700:()=>Jpt,content_2251_2702:()=>tst,content_2251_2704:()=>est,content_2251_2706:()=>pst,content_2251_2708:()=>rst,content_2251_2710:()=>ast,content_2251_2712:()=>lst,content_2251_2714:()=>mst,content_2251_2716:()=>hst,content_2251_2718:()=>yst,content_2251_272:()=>Qg,content_2251_2720:()=>Mst,content_2251_2722:()=>Dst,content_2251_2724:()=>Xst,content_2251_2726:()=>xst,content_2251_2728:()=>Tst,content_2251_2730:()=>bst,content_2251_2732:()=>Zst,content_2251_2734:()=>Ast,content_2251_2736:()=>Est,content_2251_2738:()=>zst,content_2251_274:()=>nx,content_2251_2740:()=>Wst,content_2251_2742:()=>Gst,content_2251_2744:()=>Fst,content_2251_2746:()=>qst,content_2251_2748:()=>jst,content_2251_2750:()=>Hst,content_2251_2752:()=>Kst,content_2251_2754:()=>Jst,content_2251_2756:()=>trt,content_2251_2758:()=>ert,content_2251_276:()=>ox,content_2251_2760:()=>prt,content_2251_2762:()=>rrt,content_2251_2764:()=>art,content_2251_2766:()=>lrt,content_2251_2768:()=>mrt,content_2251_2770:()=>hrt,content_2251_2772:()=>yrt,content_2251_2774:()=>Mrt,content_2251_2776:()=>Drt,content_2251_2778:()=>Xrt,content_2251_278:()=>sx,content_2251_2780:()=>xrt,content_2251_2782:()=>Trt,content_2251_2784:()=>brt,content_2251_2786:()=>Zrt,content_2251_2788:()=>Art,content_2251_2790:()=>Ert,content_2251_2792:()=>zrt,content_2251_2794:()=>Wrt,content_2251_2796:()=>Grt,content_2251_2798:()=>Frt,content_2251_28:()=>Cw,content_2251_280:()=>cx,content_2251_2800:()=>qrt,content_2251_2802:()=>jrt,content_2251_2804:()=>Hrt,content_2251_2806:()=>Krt,content_2251_2808:()=>Jrt,content_2251_2810:()=>tct,content_2251_2812:()=>ect,content_2251_2814:()=>pct,content_2251_2816:()=>rct,content_2251_2818:()=>act,content_2251_282:()=>ix,content_2251_2820:()=>lct,content_2251_2822:()=>mct,content_2251_2824:()=>hct,content_2251_2826:()=>yct,content_2251_2828:()=>Mct,content_2251_2830:()=>Dct,content_2251_2832:()=>Xct,content_2251_2834:()=>xct,content_2251_2836:()=>Tct,content_2251_2838:()=>bct,content_2251_284:()=>ux,content_2251_2840:()=>Zct,content_2251_2842:()=>Act,content_2251_2844:()=>Ect,content_2251_2846:()=>zct,content_2251_2848:()=>Wct,content_2251_2850:()=>Gct,content_2251_2852:()=>Fct,content_2251_2854:()=>qct,content_2251_2856:()=>jct,content_2251_2858:()=>Hct,content_2251_286:()=>dx,content_2251_2860:()=>Kct,content_2251_2862:()=>Jct,content_2251_2864:()=>tat,content_2251_2866:()=>eat,content_2251_2868:()=>pat,content_2251_2870:()=>rat,content_2251_2872:()=>aat,content_2251_2874:()=>lat,content_2251_2876:()=>mat,content_2251_2878:()=>hat,content_2251_288:()=>kx,content_2251_2880:()=>yat,content_2251_2882:()=>Mat,content_2251_2884:()=>Dat,content_2251_2886:()=>Xat,content_2251_2888:()=>xat,content_2251_2890:()=>Tat,content_2251_2892:()=>bat,content_2251_2894:()=>Zat,content_2251_2896:()=>Aat,content_2251_2898:()=>Eat,content_2251_290:()=>fx,content_2251_2900:()=>zat,content_2251_2902:()=>Wat,content_2251_2904:()=>Gat,content_2251_2906:()=>Fat,content_2251_2908:()=>qat,content_2251_2910:()=>jat,content_2251_2912:()=>Hat,content_2251_2914:()=>Kat,content_2251_2916:()=>Jat,content_2251_2918:()=>tit,content_2251_292:()=>wx,content_2251_2920:()=>eit,content_2251_2922:()=>pit,content_2251_2924:()=>rit,content_2251_2926:()=>ait,content_2251_2928:()=>lit,content_2251_2930:()=>mit,content_2251_2932:()=>hit,content_2251_2934:()=>yit,content_2251_2936:()=>Mit,content_2251_2938:()=>Dit,content_2251_294:()=>_x,content_2251_2940:()=>Xit,content_2251_2942:()=>xit,content_2251_2944:()=>Tit,content_2251_2946:()=>bit,content_2251_2948:()=>Zit,content_2251_2950:()=>Ait,content_2251_2952:()=>Eit,content_2251_2954:()=>zit,content_2251_2956:()=>Wit,content_2251_2958:()=>Git,content_2251_296:()=>gx,content_2251_2960:()=>Fit,content_2251_2962:()=>qit,content_2251_2964:()=>jit,content_2251_2966:()=>Hit,content_2251_2968:()=>Kit,content_2251_2970:()=>Jit,content_2251_2972:()=>tlt,content_2251_2974:()=>elt,content_2251_2976:()=>plt,content_2251_2978:()=>rlt,content_2251_298:()=>Cx,content_2251_2980:()=>alt,content_2251_2982:()=>llt,content_2251_2984:()=>mlt,content_2251_2986:()=>hlt,content_2251_2988:()=>ylt,content_2251_2990:()=>Mlt,content_2251_2992:()=>Dlt,content_2251_2994:()=>Xlt,content_2251_2996:()=>xlt,content_2251_2998:()=>Tlt,content_2251_30:()=>vw,content_2251_300:()=>vx,content_2251_3000:()=>blt,content_2251_3002:()=>Zlt,content_2251_3004:()=>Alt,content_2251_3006:()=>Elt,content_2251_3008:()=>zlt,content_2251_3010:()=>Wlt,content_2251_3012:()=>Glt,content_2251_3014:()=>Flt,content_2251_3016:()=>qlt,content_2251_3018:()=>jlt,content_2251_302:()=>Lx,content_2251_3020:()=>Hlt,content_2251_3022:()=>Klt,content_2251_3024:()=>Jlt,content_2251_3026:()=>tut,content_2251_3028:()=>eut,content_2251_3030:()=>put,content_2251_3032:()=>rut,content_2251_3034:()=>aut,content_2251_3036:()=>lut,content_2251_3038:()=>mut,content_2251_304:()=>Nx,content_2251_3040:()=>hut,content_2251_3042:()=>yut,content_2251_3044:()=>Mut,content_2251_3046:()=>Dut,content_2251_3048:()=>Xut,content_2251_3050:()=>xut,content_2251_3052:()=>Tut,content_2251_3054:()=>but,content_2251_3056:()=>Zut,content_2251_3058:()=>Aut,content_2251_306:()=>Rx,content_2251_3060:()=>Eut,content_2251_3062:()=>zut,content_2251_3064:()=>Wut,content_2251_3066:()=>Gut,content_2251_3068:()=>Fut,content_2251_3070:()=>qut,content_2251_3072:()=>jut,content_2251_3074:()=>Hut,content_2251_3076:()=>Kut,content_2251_3078:()=>Jut,content_2251_308:()=>Sx,content_2251_3080:()=>tmt,content_2251_3082:()=>emt,content_2251_3084:()=>pmt,content_2251_3086:()=>rmt,content_2251_3088:()=>amt,content_2251_3090:()=>lmt,content_2251_3092:()=>mmt,content_2251_3094:()=>hmt,content_2251_3096:()=>ymt,content_2251_3098:()=>Mmt,content_2251_310:()=>Ix,content_2251_3100:()=>Dmt,content_2251_3102:()=>Xmt,content_2251_3104:()=>xmt,content_2251_3106:()=>Tmt,content_2251_3108:()=>bmt,content_2251_3110:()=>Zmt,content_2251_3112:()=>Amt,content_2251_3114:()=>Emt,content_2251_3116:()=>zmt,content_2251_3118:()=>Wmt,content_2251_312:()=>Px,content_2251_3120:()=>Gmt,content_2251_3122:()=>Fmt,content_2251_3124:()=>qmt,content_2251_3126:()=>jmt,content_2251_3128:()=>Hmt,content_2251_3130:()=>Kmt,content_2251_3132:()=>Jmt,content_2251_3134:()=>tdt,content_2251_3136:()=>edt,content_2251_3138:()=>pdt,content_2251_314:()=>Bx,content_2251_3140:()=>rdt,content_2251_3142:()=>adt,content_2251_3144:()=>ldt,content_2251_3146:()=>mdt,content_2251_3148:()=>hdt,content_2251_3150:()=>ydt,content_2251_3152:()=>Mdt,content_2251_3154:()=>Ddt,content_2251_3156:()=>Xdt,content_2251_3158:()=>xdt,content_2251_316:()=>Ux,content_2251_3160:()=>Tdt,content_2251_3162:()=>bdt,content_2251_3164:()=>Zdt,content_2251_3166:()=>Adt,content_2251_3168:()=>Edt,content_2251_3170:()=>zdt,content_2251_3172:()=>Wdt,content_2251_3174:()=>Gdt,content_2251_3176:()=>Fdt,content_2251_3178:()=>qdt,content_2251_318:()=>Vx,content_2251_3180:()=>jdt,content_2251_3182:()=>Hdt,content_2251_3184:()=>Kdt,content_2251_3186:()=>Jdt,content_2251_3188:()=>tht,content_2251_3190:()=>eht,content_2251_3192:()=>pht,content_2251_3194:()=>rht,content_2251_3196:()=>aht,content_2251_3198:()=>lht,content_2251_32:()=>Lw,content_2251_320:()=>Ox,content_2251_3200:()=>mht,content_2251_3202:()=>hht,content_2251_3204:()=>yht,content_2251_3206:()=>Mht,content_2251_3208:()=>Dht,content_2251_3210:()=>Xht,content_2251_3212:()=>xht,content_2251_3214:()=>Tht,content_2251_3216:()=>bht,content_2251_3218:()=>Zht,content_2251_322:()=>$x,content_2251_3220:()=>Aht,content_2251_3222:()=>Eht,content_2251_3224:()=>zht,content_2251_3226:()=>Wht,content_2251_3228:()=>Ght,content_2251_3230:()=>Fht,content_2251_3232:()=>qht,content_2251_3234:()=>jht,content_2251_3236:()=>Hht,content_2251_3238:()=>Kht,content_2251_324:()=>Yx,content_2251_3240:()=>Jht,content_2251_3242:()=>tkt,content_2251_3244:()=>ekt,content_2251_3246:()=>pkt,content_2251_3248:()=>rkt,content_2251_3250:()=>akt,content_2251_3252:()=>lkt,content_2251_3254:()=>mkt,content_2251_3256:()=>hkt,content_2251_3258:()=>ykt,content_2251_326:()=>Qx,content_2251_3260:()=>Mkt,content_2251_3262:()=>Dkt,content_2251_3264:()=>Xkt,content_2251_3266:()=>xkt,content_2251_3268:()=>Tkt,content_2251_3270:()=>bkt,content_2251_3272:()=>Zkt,content_2251_3274:()=>Akt,content_2251_3276:()=>Ekt,content_2251_3278:()=>zkt,content_2251_328:()=>nC,content_2251_3280:()=>Wkt,content_2251_3282:()=>Gkt,content_2251_3284:()=>Fkt,content_2251_3286:()=>qkt,content_2251_3288:()=>jkt,content_2251_3290:()=>Hkt,content_2251_3292:()=>Kkt,content_2251_3294:()=>Jkt,content_2251_3296:()=>tyt,content_2251_3298:()=>eyt,content_2251_330:()=>oC,content_2251_3300:()=>pyt,content_2251_3302:()=>ryt,content_2251_3304:()=>ayt,content_2251_3306:()=>lyt,content_2251_3308:()=>myt,content_2251_3310:()=>hyt,content_2251_3312:()=>yyt,content_2251_3314:()=>Myt,content_2251_3316:()=>Dyt,content_2251_3318:()=>Xyt,content_2251_332:()=>sC,content_2251_3320:()=>xyt,content_2251_3322:()=>Tyt,content_2251_3324:()=>byt,content_2251_3326:()=>Zyt,content_2251_3328:()=>Ayt,content_2251_3330:()=>Eyt,content_2251_3332:()=>zyt,content_2251_3334:()=>Wyt,content_2251_3336:()=>Gyt,content_2251_3338:()=>Fyt,content_2251_334:()=>cC,content_2251_3340:()=>qyt,content_2251_3342:()=>jyt,content_2251_3344:()=>Hyt,content_2251_3346:()=>Kyt,content_2251_3348:()=>Jyt,content_2251_3350:()=>tft,content_2251_3352:()=>eft,content_2251_3354:()=>pft,content_2251_3356:()=>rft,content_2251_3358:()=>aft,content_2251_336:()=>iC,content_2251_3360:()=>lft,content_2251_3362:()=>mft,content_2251_3364:()=>hft,content_2251_3366:()=>yft,content_2251_3368:()=>Mft,content_2251_3370:()=>Dft,content_2251_3372:()=>Xft,content_2251_3374:()=>xft,content_2251_3376:()=>Tft,content_2251_3378:()=>bft,content_2251_338:()=>uC,content_2251_3380:()=>Zft,content_2251_3382:()=>Aft,content_2251_3384:()=>Eft,content_2251_3386:()=>zft,content_2251_3388:()=>Wft,content_2251_3390:()=>Gft,content_2251_3392:()=>Fft,content_2251_3394:()=>qft,content_2251_3396:()=>jft,content_2251_3398:()=>Hft,content_2251_34:()=>Nw,content_2251_340:()=>dC,content_2251_3400:()=>Kft,content_2251_3402:()=>Jft,content_2251_3404:()=>tMt,content_2251_3406:()=>eMt,content_2251_3408:()=>pMt,content_2251_3410:()=>rMt,content_2251_3412:()=>aMt,content_2251_3414:()=>lMt,content_2251_3416:()=>mMt,content_2251_3418:()=>hMt,content_2251_342:()=>kC,content_2251_3420:()=>yMt,content_2251_3422:()=>MMt,content_2251_3424:()=>DMt,content_2251_3426:()=>XMt,content_2251_3428:()=>xMt,content_2251_3430:()=>TMt,content_2251_3432:()=>bMt,content_2251_3434:()=>ZMt,content_2251_3436:()=>AMt,content_2251_3438:()=>EMt,content_2251_344:()=>fC,content_2251_3440:()=>zMt,content_2251_3442:()=>WMt,content_2251_3444:()=>GMt,content_2251_3446:()=>FMt,content_2251_3448:()=>qMt,content_2251_3450:()=>jMt,content_2251_3452:()=>HMt,content_2251_3454:()=>KMt,content_2251_3456:()=>JMt,content_2251_3458:()=>twt,content_2251_346:()=>wC,content_2251_3460:()=>ewt,content_2251_3462:()=>pwt,content_2251_3464:()=>rwt,content_2251_3466:()=>awt,content_2251_3468:()=>lwt,content_2251_3470:()=>mwt,content_2251_3472:()=>hwt,content_2251_3474:()=>ywt,content_2251_3476:()=>Mwt,content_2251_3478:()=>Dwt,content_2251_348:()=>_C,content_2251_3480:()=>Xwt,content_2251_3482:()=>xwt,content_2251_3484:()=>Twt,content_2251_3486:()=>bwt,content_2251_3488:()=>Zwt,content_2251_3490:()=>Awt,content_2251_3492:()=>Ewt,content_2251_3494:()=>zwt,content_2251_3496:()=>Wwt,content_2251_3498:()=>Gwt,content_2251_350:()=>gC,content_2251_3500:()=>Fwt,content_2251_3502:()=>qwt,content_2251_3504:()=>jwt,content_2251_3506:()=>Hwt,content_2251_3508:()=>Kwt,content_2251_3510:()=>Jwt,content_2251_3512:()=>tDt,content_2251_3514:()=>eDt,content_2251_3516:()=>pDt,content_2251_3518:()=>rDt,content_2251_352:()=>CC,content_2251_3520:()=>aDt,content_2251_3522:()=>lDt,content_2251_3524:()=>mDt,content_2251_3526:()=>hDt,content_2251_3528:()=>yDt,content_2251_3530:()=>MDt,content_2251_3532:()=>DDt,content_2251_3534:()=>XDt,content_2251_3536:()=>xDt,content_2251_3538:()=>TDt,content_2251_354:()=>vC,content_2251_3540:()=>bDt,content_2251_3542:()=>ZDt,content_2251_3544:()=>ADt,content_2251_3546:()=>EDt,content_2251_3548:()=>zDt,content_2251_3550:()=>WDt,content_2251_3552:()=>GDt,content_2251_3554:()=>FDt,content_2251_3556:()=>qDt,content_2251_3558:()=>jDt,content_2251_356:()=>LC,content_2251_3560:()=>HDt,content_2251_3562:()=>KDt,content_2251_3564:()=>JDt,content_2251_3566:()=>t_t,content_2251_3568:()=>e_t,content_2251_3570:()=>p_t,content_2251_3572:()=>r_t,content_2251_3574:()=>a_t,content_2251_3576:()=>l_t,content_2251_3578:()=>m_t,content_2251_358:()=>NC,content_2251_3580:()=>h_t,content_2251_3582:()=>y_t,content_2251_3584:()=>M_t,content_2251_3586:()=>D_t,content_2251_3588:()=>X_t,content_2251_3590:()=>x_t,content_2251_3592:()=>T_t,content_2251_3594:()=>b_t,content_2251_3596:()=>Z_t,content_2251_3598:()=>A_t,content_2251_36:()=>Rw,content_2251_360:()=>RC,content_2251_3600:()=>E_t,content_2251_3602:()=>z_t,content_2251_3604:()=>W_t,content_2251_3606:()=>G_t,content_2251_3608:()=>F_t,content_2251_3610:()=>q_t,content_2251_3612:()=>j_t,content_2251_3614:()=>H_t,content_2251_3616:()=>K_t,content_2251_3618:()=>J_t,content_2251_362:()=>SC,content_2251_3620:()=>tXt,content_2251_3622:()=>eXt,content_2251_3624:()=>pXt,content_2251_3626:()=>rXt,content_2251_3628:()=>aXt,content_2251_3630:()=>lXt,content_2251_3632:()=>mXt,content_2251_3634:()=>hXt,content_2251_3636:()=>yXt,content_2251_3638:()=>MXt,content_2251_364:()=>IC,content_2251_3640:()=>DXt,content_2251_3642:()=>XXt,content_2251_3644:()=>xXt,content_2251_3646:()=>TXt,content_2251_3648:()=>bXt,content_2251_3650:()=>ZXt,content_2251_3652:()=>AXt,content_2251_3654:()=>EXt,content_2251_3656:()=>zXt,content_2251_3658:()=>WXt,content_2251_366:()=>PC,content_2251_3660:()=>GXt,content_2251_3662:()=>FXt,content_2251_3664:()=>qXt,content_2251_3666:()=>jXt,content_2251_3668:()=>HXt,content_2251_3670:()=>KXt,content_2251_3672:()=>JXt,content_2251_3674:()=>tgt,content_2251_3676:()=>egt,content_2251_3678:()=>pgt,content_2251_368:()=>BC,content_2251_3680:()=>rgt,content_2251_3682:()=>agt,content_2251_3684:()=>lgt,content_2251_3686:()=>mgt,content_2251_3688:()=>hgt,content_2251_3690:()=>ygt,content_2251_3692:()=>Mgt,content_2251_3694:()=>Dgt,content_2251_3696:()=>Xgt,content_2251_3698:()=>xgt,content_2251_370:()=>UC,content_2251_3700:()=>Tgt,content_2251_3702:()=>bgt,content_2251_3704:()=>Zgt,content_2251_3706:()=>Agt,content_2251_3708:()=>Egt,content_2251_3710:()=>zgt,content_2251_3712:()=>Wgt,content_2251_3714:()=>Ggt,content_2251_3716:()=>Fgt,content_2251_3718:()=>qgt,content_2251_372:()=>VC,content_2251_3720:()=>jgt,content_2251_3722:()=>Hgt,content_2251_3724:()=>Kgt,content_2251_3726:()=>Jgt,content_2251_3728:()=>txt,content_2251_3730:()=>ext,content_2251_3732:()=>pxt,content_2251_3734:()=>rxt,content_2251_3736:()=>axt,content_2251_3738:()=>lxt,content_2251_374:()=>OC,content_2251_3740:()=>mxt,content_2251_3742:()=>hxt,content_2251_3744:()=>yxt,content_2251_3746:()=>Mxt,content_2251_3748:()=>Dxt,content_2251_3750:()=>Xxt,content_2251_3752:()=>xxt,content_2251_3754:()=>Txt,content_2251_3756:()=>bxt,content_2251_3758:()=>Zxt,content_2251_376:()=>$C,content_2251_3760:()=>Axt,content_2251_3762:()=>Ext,content_2251_3764:()=>zxt,content_2251_3766:()=>Wxt,content_2251_3768:()=>Gxt,content_2251_3770:()=>Fxt,content_2251_3772:()=>qxt,content_2251_3774:()=>jxt,content_2251_3776:()=>Hxt,content_2251_3778:()=>Kxt,content_2251_378:()=>YC,content_2251_3780:()=>Jxt,content_2251_3782:()=>tCt,content_2251_3784:()=>eCt,content_2251_3786:()=>pCt,content_2251_3788:()=>rCt,content_2251_3790:()=>aCt,content_2251_3792:()=>lCt,content_2251_3794:()=>mCt,content_2251_3796:()=>hCt,content_2251_3798:()=>yCt,content_2251_38:()=>Sw,content_2251_380:()=>QC,content_2251_3800:()=>MCt,content_2251_3802:()=>DCt,content_2251_3804:()=>XCt,content_2251_3806:()=>xCt,content_2251_3808:()=>TCt,content_2251_3810:()=>bCt,content_2251_3812:()=>ZCt,content_2251_3814:()=>ACt,content_2251_3816:()=>ECt,content_2251_3818:()=>zCt,content_2251_382:()=>nT,content_2251_3820:()=>WCt,content_2251_3822:()=>GCt,content_2251_3824:()=>FCt,content_2251_3826:()=>qCt,content_2251_3828:()=>jCt,content_2251_3830:()=>HCt,content_2251_3832:()=>KCt,content_2251_3834:()=>JCt,content_2251_3836:()=>tTt,content_2251_3838:()=>eTt,content_2251_384:()=>oT,content_2251_3840:()=>pTt,content_2251_3842:()=>rTt,content_2251_3844:()=>aTt,content_2251_3846:()=>lTt,content_2251_3848:()=>mTt,content_2251_3850:()=>hTt,content_2251_3852:()=>yTt,content_2251_3854:()=>MTt,content_2251_3856:()=>DTt,content_2251_3858:()=>XTt,content_2251_386:()=>sT,content_2251_3860:()=>xTt,content_2251_3862:()=>TTt,content_2251_3864:()=>bTt,content_2251_3866:()=>ZTt,content_2251_3868:()=>ATt,content_2251_3870:()=>ETt,content_2251_3872:()=>zTt,content_2251_3874:()=>WTt,content_2251_3876:()=>GTt,content_2251_3878:()=>FTt,content_2251_388:()=>cT,content_2251_3880:()=>qTt,content_2251_3882:()=>jTt,content_2251_3884:()=>HTt,content_2251_3886:()=>KTt,content_2251_3888:()=>JTt,content_2251_3890:()=>tvt,content_2251_3892:()=>evt,content_2251_3894:()=>pvt,content_2251_3896:()=>rvt,content_2251_3898:()=>avt,content_2251_390:()=>iT,content_2251_3900:()=>lvt,content_2251_3902:()=>mvt,content_2251_3904:()=>hvt,content_2251_3906:()=>yvt,content_2251_3908:()=>Mvt,content_2251_3910:()=>Dvt,content_2251_3912:()=>Xvt,content_2251_3914:()=>xvt,content_2251_3916:()=>Tvt,content_2251_3918:()=>bvt,content_2251_392:()=>uT,content_2251_3920:()=>Zvt,content_2251_3922:()=>Avt,content_2251_3924:()=>Evt,content_2251_3926:()=>zvt,content_2251_3928:()=>Wvt,content_2251_3930:()=>Gvt,content_2251_3932:()=>Fvt,content_2251_3934:()=>qvt,content_2251_3936:()=>jvt,content_2251_3938:()=>Hvt,content_2251_394:()=>dT,content_2251_3940:()=>Kvt,content_2251_3942:()=>Jvt,content_2251_3944:()=>tbt,content_2251_3946:()=>ebt,content_2251_3948:()=>pbt,content_2251_3950:()=>rbt,content_2251_3952:()=>abt,content_2251_3954:()=>lbt,content_2251_3956:()=>mbt,content_2251_3958:()=>hbt,content_2251_396:()=>kT,content_2251_3960:()=>ybt,content_2251_3962:()=>Mbt,content_2251_3964:()=>Dbt,content_2251_3966:()=>Xbt,content_2251_3968:()=>xbt,content_2251_3970:()=>Tbt,content_2251_3972:()=>bbt,content_2251_3974:()=>Zbt,content_2251_3976:()=>Abt,content_2251_3978:()=>Ebt,content_2251_398:()=>fT,content_2251_3980:()=>zbt,content_2251_3982:()=>Wbt,content_2251_3984:()=>Gbt,content_2251_3986:()=>Fbt,content_2251_3988:()=>qbt,content_2251_3990:()=>jbt,content_2251_3992:()=>Hbt,content_2251_3994:()=>Kbt,content_2251_3996:()=>Jbt,content_2251_3998:()=>tLt,content_2251_4:()=>nw,content_2251_40:()=>Iw,content_2251_400:()=>wT,content_2251_4000:()=>eLt,content_2251_4002:()=>pLt,content_2251_4004:()=>rLt,content_2251_4006:()=>aLt,content_2251_4008:()=>lLt,content_2251_4010:()=>mLt,content_2251_4012:()=>hLt,content_2251_4014:()=>yLt,content_2251_4016:()=>MLt,content_2251_4018:()=>DLt,content_2251_402:()=>_T,content_2251_4020:()=>XLt,content_2251_4022:()=>xLt,content_2251_4024:()=>TLt,content_2251_4026:()=>bLt,content_2251_4028:()=>ZLt,content_2251_4030:()=>ALt,content_2251_4032:()=>ELt,content_2251_4034:()=>zLt,content_2251_4036:()=>WLt,content_2251_4038:()=>GLt,content_2251_404:()=>gT,content_2251_4040:()=>FLt,content_2251_4042:()=>qLt,content_2251_4044:()=>jLt,content_2251_4046:()=>HLt,content_2251_4048:()=>KLt,content_2251_4050:()=>JLt,content_2251_4052:()=>tZt,content_2251_4054:()=>eZt,content_2251_4056:()=>pZt,content_2251_4058:()=>rZt,content_2251_406:()=>CT,content_2251_4060:()=>aZt,content_2251_4062:()=>lZt,content_2251_4064:()=>mZt,content_2251_4066:()=>hZt,content_2251_4068:()=>yZt,content_2251_4070:()=>MZt,content_2251_4072:()=>DZt,content_2251_4074:()=>XZt,content_2251_4076:()=>xZt,content_2251_4078:()=>TZt,content_2251_408:()=>vT,content_2251_4080:()=>bZt,content_2251_4082:()=>ZZt,content_2251_4084:()=>AZt,content_2251_4086:()=>EZt,content_2251_4088:()=>zZt,content_2251_4090:()=>WZt,content_2251_4092:()=>GZt,content_2251_4094:()=>FZt,content_2251_4096:()=>qZt,content_2251_4098:()=>jZt,content_2251_410:()=>LT,content_2251_4100:()=>HZt,content_2251_4102:()=>KZt,content_2251_4104:()=>JZt,content_2251_4106:()=>tNt,content_2251_4108:()=>eNt,content_2251_4110:()=>pNt,content_2251_4112:()=>rNt,content_2251_4114:()=>aNt,content_2251_4116:()=>lNt,content_2251_4118:()=>mNt,content_2251_412:()=>NT,content_2251_4120:()=>hNt,content_2251_4122:()=>yNt,content_2251_4124:()=>MNt,content_2251_4126:()=>DNt,content_2251_4128:()=>XNt,content_2251_4130:()=>xNt,content_2251_4132:()=>TNt,content_2251_4134:()=>bNt,content_2251_4136:()=>ZNt,content_2251_4138:()=>ANt,content_2251_414:()=>RT,content_2251_4140:()=>ENt,content_2251_4142:()=>zNt,content_2251_4144:()=>WNt,content_2251_4146:()=>GNt,content_2251_4148:()=>FNt,content_2251_4150:()=>qNt,content_2251_4152:()=>jNt,content_2251_4154:()=>HNt,content_2251_4156:()=>KNt,content_2251_4158:()=>JNt,content_2251_416:()=>ST,content_2251_4160:()=>tAt,content_2251_4162:()=>eAt,content_2251_4164:()=>pAt,content_2251_4166:()=>rAt,content_2251_4168:()=>aAt,content_2251_4170:()=>lAt,content_2251_4172:()=>mAt,content_2251_4174:()=>hAt,content_2251_4176:()=>yAt,content_2251_4178:()=>MAt,content_2251_418:()=>IT,content_2251_4180:()=>DAt,content_2251_4182:()=>XAt,content_2251_4184:()=>xAt,content_2251_4186:()=>TAt,content_2251_4188:()=>bAt,content_2251_4190:()=>ZAt,content_2251_4192:()=>AAt,content_2251_4194:()=>EAt,content_2251_4196:()=>zAt,content_2251_4198:()=>WAt,content_2251_42:()=>Pw,content_2251_420:()=>PT,content_2251_4200:()=>GAt,content_2251_4202:()=>FAt,content_2251_4204:()=>qAt,content_2251_4206:()=>jAt,content_2251_4208:()=>HAt,content_2251_4210:()=>KAt,content_2251_4212:()=>JAt,content_2251_4214:()=>tRt,content_2251_4216:()=>eRt,content_2251_4218:()=>pRt,content_2251_422:()=>BT,content_2251_4220:()=>rRt,content_2251_4222:()=>aRt,content_2251_4224:()=>lRt,content_2251_4226:()=>mRt,content_2251_4228:()=>hRt,content_2251_4230:()=>yRt,content_2251_4232:()=>MRt,content_2251_4234:()=>DRt,content_2251_4236:()=>XRt,content_2251_4238:()=>xRt,content_2251_424:()=>UT,content_2251_4240:()=>TRt,content_2251_4242:()=>bRt,content_2251_4244:()=>ZRt,content_2251_4246:()=>ARt,content_2251_4248:()=>ERt,content_2251_4250:()=>zRt,content_2251_4252:()=>WRt,content_2251_4254:()=>GRt,content_2251_4256:()=>FRt,content_2251_4258:()=>qRt,content_2251_426:()=>VT,content_2251_4260:()=>jRt,content_2251_4262:()=>HRt,content_2251_4264:()=>KRt,content_2251_4266:()=>JRt,content_2251_4268:()=>tEt,content_2251_4270:()=>eEt,content_2251_4272:()=>pEt,content_2251_4274:()=>rEt,content_2251_4276:()=>aEt,content_2251_4278:()=>lEt,content_2251_428:()=>OT,content_2251_4280:()=>mEt,content_2251_4282:()=>hEt,content_2251_4284:()=>yEt,content_2251_4286:()=>MEt,content_2251_4288:()=>DEt,content_2251_4290:()=>XEt,content_2251_4292:()=>xEt,content_2251_4294:()=>TEt,content_2251_4296:()=>bEt,content_2251_4298:()=>ZEt,content_2251_430:()=>$T,content_2251_4300:()=>AEt,content_2251_4302:()=>EEt,content_2251_4304:()=>zEt,content_2251_4306:()=>WEt,content_2251_4308:()=>GEt,content_2251_4310:()=>FEt,content_2251_4312:()=>qEt,content_2251_4314:()=>jEt,content_2251_4316:()=>HEt,content_2251_4318:()=>KEt,content_2251_432:()=>YT,content_2251_4320:()=>JEt,content_2251_4322:()=>tSt,content_2251_4324:()=>eSt,content_2251_4326:()=>pSt,content_2251_4328:()=>rSt,content_2251_434:()=>QT,content_2251_436:()=>nv,content_2251_438:()=>ov,content_2251_44:()=>Bw,content_2251_440:()=>sv,content_2251_442:()=>cv,content_2251_444:()=>iv,content_2251_446:()=>uv,content_2251_448:()=>dv,content_2251_450:()=>kv,content_2251_452:()=>fv,content_2251_454:()=>wv,content_2251_456:()=>_v,content_2251_458:()=>gv,content_2251_46:()=>Uw,content_2251_460:()=>Cv,content_2251_462:()=>vv,content_2251_464:()=>Lv,content_2251_466:()=>Nv,content_2251_468:()=>Rv,content_2251_470:()=>Sv,content_2251_472:()=>Iv,content_2251_474:()=>Pv,content_2251_476:()=>Bv,content_2251_478:()=>Uv,content_2251_48:()=>Vw,content_2251_480:()=>Vv,content_2251_482:()=>Ov,content_2251_484:()=>$v,content_2251_486:()=>Yv,content_2251_488:()=>Qv,content_2251_490:()=>nb,content_2251_492:()=>ob,content_2251_494:()=>sb,content_2251_496:()=>cb,content_2251_498:()=>ib,content_2251_50:()=>Ow,content_2251_500:()=>ub,content_2251_502:()=>db,content_2251_504:()=>kb,content_2251_506:()=>fb,content_2251_508:()=>wb,content_2251_510:()=>_b,content_2251_512:()=>gb,content_2251_514:()=>Cb,content_2251_516:()=>vb,content_2251_518:()=>Lb,content_2251_52:()=>$w,content_2251_520:()=>Nb,content_2251_522:()=>Rb,content_2251_524:()=>Sb,content_2251_526:()=>Ib,content_2251_528:()=>Pb,content_2251_530:()=>Bb,content_2251_532:()=>Ub,content_2251_534:()=>Vb,content_2251_536:()=>Ob,content_2251_538:()=>$b,content_2251_54:()=>Yw,content_2251_540:()=>Yb,content_2251_542:()=>Qb,content_2251_544:()=>nL,content_2251_546:()=>oL,content_2251_548:()=>sL,content_2251_550:()=>cL,content_2251_552:()=>iL,content_2251_554:()=>uL,content_2251_556:()=>dL,content_2251_558:()=>kL,content_2251_56:()=>Qw,content_2251_560:()=>fL,content_2251_562:()=>wL,content_2251_564:()=>_L,content_2251_566:()=>gL,content_2251_568:()=>CL,content_2251_570:()=>vL,content_2251_572:()=>LL,content_2251_574:()=>NL,content_2251_576:()=>RL,content_2251_578:()=>SL,content_2251_58:()=>nD,content_2251_580:()=>IL,content_2251_582:()=>PL,content_2251_584:()=>BL,content_2251_586:()=>UL,content_2251_588:()=>VL,content_2251_590:()=>OL,content_2251_592:()=>$L,content_2251_594:()=>YL,content_2251_596:()=>QL,content_2251_598:()=>nZ,content_2251_6:()=>ow,content_2251_60:()=>oD,content_2251_600:()=>oZ,content_2251_602:()=>sZ,content_2251_604:()=>cZ,content_2251_606:()=>iZ,content_2251_608:()=>uZ,content_2251_610:()=>dZ,content_2251_612:()=>kZ,content_2251_614:()=>fZ,content_2251_616:()=>wZ,content_2251_618:()=>_Z,content_2251_62:()=>sD,content_2251_620:()=>gZ,content_2251_622:()=>CZ,content_2251_624:()=>vZ,content_2251_626:()=>LZ,content_2251_628:()=>NZ,content_2251_630:()=>RZ,content_2251_632:()=>SZ,content_2251_634:()=>IZ,content_2251_636:()=>PZ,content_2251_638:()=>BZ,content_2251_64:()=>cD,content_2251_640:()=>UZ,content_2251_642:()=>VZ,content_2251_644:()=>OZ,content_2251_646:()=>$Z,content_2251_648:()=>YZ,content_2251_650:()=>QZ,content_2251_652:()=>nN,content_2251_654:()=>oN,content_2251_656:()=>sN,content_2251_658:()=>cN,content_2251_66:()=>iD,content_2251_660:()=>iN,content_2251_662:()=>uN,content_2251_664:()=>dN,content_2251_666:()=>kN,content_2251_668:()=>fN,content_2251_670:()=>wN,content_2251_672:()=>_N,content_2251_674:()=>gN,content_2251_676:()=>CN,content_2251_678:()=>vN,content_2251_68:()=>uD,content_2251_680:()=>LN,content_2251_682:()=>NN,content_2251_684:()=>RN,content_2251_686:()=>SN,content_2251_688:()=>IN,content_2251_690:()=>PN,content_2251_692:()=>BN,content_2251_694:()=>UN,content_2251_696:()=>VN,content_2251_698:()=>ON,content_2251_70:()=>dD,content_2251_700:()=>$N,content_2251_702:()=>YN,content_2251_704:()=>QN,content_2251_706:()=>nA,content_2251_708:()=>oA,content_2251_710:()=>sA,content_2251_712:()=>cA,content_2251_714:()=>iA,content_2251_716:()=>uA,content_2251_718:()=>dA,content_2251_72:()=>kD,content_2251_720:()=>kA,content_2251_722:()=>fA,content_2251_724:()=>wA,content_2251_726:()=>_A,content_2251_728:()=>gA,content_2251_730:()=>CA,content_2251_732:()=>vA,content_2251_734:()=>LA,content_2251_736:()=>NA,content_2251_738:()=>RA,content_2251_74:()=>fD,content_2251_740:()=>SA,content_2251_742:()=>IA,content_2251_744:()=>PA,content_2251_746:()=>BA,content_2251_748:()=>UA,content_2251_750:()=>VA,content_2251_752:()=>OA,content_2251_754:()=>$A,content_2251_756:()=>YA,content_2251_758:()=>QA,content_2251_76:()=>wD,content_2251_760:()=>nR,content_2251_762:()=>oR,content_2251_764:()=>sR,content_2251_766:()=>cR,content_2251_768:()=>iR,content_2251_770:()=>uR,content_2251_772:()=>dR,content_2251_774:()=>kR,content_2251_776:()=>fR,content_2251_778:()=>wR,content_2251_78:()=>_D,content_2251_780:()=>_R,content_2251_782:()=>gR,content_2251_784:()=>CR,content_2251_786:()=>vR,content_2251_788:()=>LR,content_2251_790:()=>NR,content_2251_792:()=>RR,content_2251_794:()=>SR,content_2251_796:()=>IR,content_2251_798:()=>PR,content_2251_8:()=>sw,content_2251_80:()=>gD,content_2251_800:()=>BR,content_2251_802:()=>UR,content_2251_804:()=>VR,content_2251_806:()=>OR,content_2251_808:()=>$R,content_2251_810:()=>YR,content_2251_812:()=>QR,content_2251_814:()=>nE,content_2251_816:()=>oE,content_2251_818:()=>sE,content_2251_82:()=>CD,content_2251_820:()=>cE,content_2251_822:()=>iE,content_2251_824:()=>uE,content_2251_826:()=>dE,content_2251_828:()=>kE,content_2251_830:()=>fE,content_2251_832:()=>wE,content_2251_834:()=>_E,content_2251_836:()=>gE,content_2251_838:()=>CE,content_2251_84:()=>vD,content_2251_840:()=>vE,content_2251_842:()=>LE,content_2251_844:()=>NE,content_2251_846:()=>RE,content_2251_848:()=>SE,content_2251_850:()=>IE,content_2251_852:()=>PE,content_2251_854:()=>BE,content_2251_856:()=>UE,content_2251_858:()=>VE,content_2251_86:()=>LD,content_2251_860:()=>OE,content_2251_862:()=>$E,content_2251_864:()=>YE,content_2251_866:()=>QE,content_2251_868:()=>nS,content_2251_870:()=>oS,content_2251_872:()=>sS,content_2251_874:()=>cS,content_2251_876:()=>iS,content_2251_878:()=>uS,content_2251_88:()=>ND,content_2251_880:()=>dS,content_2251_882:()=>kS,content_2251_884:()=>fS,content_2251_886:()=>wS,content_2251_888:()=>_S,content_2251_890:()=>gS,content_2251_892:()=>CS,content_2251_894:()=>vS,content_2251_896:()=>LS,content_2251_898:()=>NS,content_2251_90:()=>RD,content_2251_900:()=>RS,content_2251_902:()=>SS,content_2251_904:()=>IS,content_2251_906:()=>PS,content_2251_908:()=>BS,content_2251_910:()=>US,content_2251_912:()=>VS,content_2251_914:()=>OS,content_2251_916:()=>$S,content_2251_918:()=>YS,content_2251_92:()=>SD,content_2251_920:()=>QS,content_2251_922:()=>nz,content_2251_924:()=>oz,content_2251_926:()=>sz,content_2251_928:()=>cz,content_2251_930:()=>iz,content_2251_932:()=>uz,content_2251_934:()=>dz,content_2251_936:()=>kz,content_2251_938:()=>fz,content_2251_94:()=>ID,content_2251_940:()=>wz,content_2251_942:()=>_z,content_2251_944:()=>gz,content_2251_946:()=>Cz,content_2251_948:()=>vz,content_2251_950:()=>Lz,content_2251_952:()=>Nz,content_2251_954:()=>Rz,content_2251_956:()=>Sz,content_2251_958:()=>Iz,content_2251_96:()=>PD,content_2251_960:()=>Pz,content_2251_962:()=>Bz,content_2251_964:()=>Uz,content_2251_966:()=>Vz,content_2251_968:()=>Oz,content_2251_970:()=>$z,content_2251_972:()=>Yz,content_2251_974:()=>Qz,content_2251_976:()=>nI,content_2251_978:()=>oI,content_2251_98:()=>BD,content_2251_980:()=>sI,content_2251_982:()=>cI,content_2251_984:()=>iI,content_2251_986:()=>uI,content_2251_988:()=>dI,content_2251_990:()=>kI,content_2251_992:()=>fI,content_2251_994:()=>wI,content_2251_996:()=>_I,content_2251_998:()=>gI});var p=e(2784),s=e(7896),r=e(30876);const c={toc:[]};function a(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},c,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Property decorators."))}a.isMDXComponent=!0;const i={toc:[]};function l(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},i,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,r.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a lazy decorator."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},d,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A function that returns the value of this property."))}h.isMDXComponent=!0;const k={toc:[]};function y(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},k,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscriptions and triggering of events."))}y.isMDXComponent=!0;const f={toc:[]};function M(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},f,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,r.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}M.isMDXComponent=!0;const w={toc:[]};function D(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},w,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}D.isMDXComponent=!0;const _={toc:[]};function X(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Dispatches an asynchronous ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,r.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}X.isMDXComponent=!0;const g={toc:[]};function x(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},g,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe all subscribers from the event."))}x.isMDXComponent=!0;const C={toc:[]};function T(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},C,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A callback function that cancels the subscription."))}T.isMDXComponent=!0;const v={toc:[]};function b(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},v,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribe to the event."))}b.isMDXComponent=!0;const L={toc:[]};function Z(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},L,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to invoke when the event occurs."))}Z.isMDXComponent=!0;const N={toc:[]};function A(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},N,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe from the event."))}A.isMDXComponent=!0;const R={toc:[]};function E(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},R,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to unsubscribe."))}E.isMDXComponent=!0;const S={toc:[]};function z(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},S,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the argument passed to subscribers."))}z.isMDXComponent=!0;const I={toc:[]};function W(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},I,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}W.isMDXComponent=!0;const P={toc:[]};function G(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},P,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Dispatches a ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,r.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}G.isMDXComponent=!0;const B={toc:[]};function F(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},B,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe all subscribers from the event."))}F.isMDXComponent=!0;const U={toc:[]};function q(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},U,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A callback function that cancels the subscription."))}q.isMDXComponent=!0;const V={toc:[]};function j(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},V,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribe to the event."))}j.isMDXComponent=!0;const O={toc:[]};function H(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},O,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to invoke when the event occurs."))}H.isMDXComponent=!0;const $={toc:[]};function K(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe from the event."))}K.isMDXComponent=!0;const Y={toc:[]};function J(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Y,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to unsubscribe."))}J.isMDXComponent=!0;const Q={toc:[]};function tt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Q,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the value argument to subscribers."))}tt.isMDXComponent=!0;const nt={toc:[]};function et(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A base for dispatching ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,r.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}et.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe all subscribers from the event."))}pt.isMDXComponent=!0;const st={toc:[]};function rt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},st,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A callback function that cancels the subscription."))}rt.isMDXComponent=!0;const ct={toc:[]};function at(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribe to the event."))}at.isMDXComponent=!0;const it={toc:[]};function lt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},it,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to invoke when the event occurs."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe from the event."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to unsubscribe."))}ht.isMDXComponent=!0;const kt={toc:[]};function yt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the argument passed to subscribers."))}yt.isMDXComponent=!0;const ft={toc:[]};function Mt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the callback function."))}Mt.isMDXComponent=!0;const wt={toc:[]};function Dt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,r.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,r.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}Dt.isMDXComponent=!0;const _t={toc:[]};function Xt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}Xt.isMDXComponent=!0;const gt={toc:[]};function xt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Dispatches a ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,r.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}xt.isMDXComponent=!0;const Ct={toc:[]};function Tt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe all subscribers from the event."))}Tt.isMDXComponent=!0;const vt={toc:[]};function bt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Are subscribers being notified?"))}bt.isMDXComponent=!0;const Lt={toc:[]};function Zt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Notify all current and future subscribers."))}Zt.isMDXComponent=!0;const Nt={toc:[]};function At(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Stop notifying future subscribers."))}At.isMDXComponent=!0;const Rt={toc:[]};function Et(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A callback function that cancels the subscription."))}Et.isMDXComponent=!0;const St={toc:[]};function zt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},St,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribe to the event."))}zt.isMDXComponent=!0;const It={toc:[]};function Wt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},It,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to invoke when the event occurs."))}Wt.isMDXComponent=!0;const Pt={toc:[]};function Gt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe from the event."))}Gt.isMDXComponent=!0;const Bt={toc:[]};function Ft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to unsubscribe."))}Ft.isMDXComponent=!0;const Ut={toc:[]};function qt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}qt.isMDXComponent=!0;const Vt={toc:[]};function jt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Provides safe access to the public interface of ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,r.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}jt.isMDXComponent=!0;const Ot={toc:[]};function Ht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A callback function that cancels the subscription."))}Ht.isMDXComponent=!0;const $t={toc:[]};function Kt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribe to the event."))}Kt.isMDXComponent=!0;const Yt={toc:[]};function Jt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to invoke when the event occurs."))}Jt.isMDXComponent=!0;const Qt={toc:[]};function tn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe from the event."))}tn.isMDXComponent=!0;const nn={toc:[]};function en(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to unsubscribe."))}en.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},on,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the argument passed to subscribers."))}pn.isMDXComponent=!0;const sn={toc:[]};function rn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the callback function."))}rn.isMDXComponent=!0;const cn={toc:[]};function an(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ln,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Provides safe access to the public interface of ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,r.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the most recent value of this dispatcher."))}dn.isMDXComponent=!0;const hn={toc:[]};function kn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Callback function that cancels the subscription."))}kn.isMDXComponent=!0;const yn={toc:[]};function fn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribe to the event."),(0,r.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}fn.isMDXComponent=!0;const Mn={toc:[]};function wn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Mn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to invoke when the event occurs."))}wn.isMDXComponent=!0;const Dn={toc:[]};function _n(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Dn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}_n.isMDXComponent=!0;const Xn={toc:[]};function gn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Xn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Callback function that cancels the subscription."))}gn.isMDXComponent=!0;const xn={toc:[]};function Cn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribe to the event."),(0,r.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Cn.isMDXComponent=!0;const Tn={toc:[]};function vn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Tn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe from the event."))}vn.isMDXComponent=!0;const bn={toc:[]};function Ln(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to unsubscribe."))}Ln.isMDXComponent=!0;const Zn={toc:[]};function Nn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Zn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the value passed to subscribers."))}Nn.isMDXComponent=!0;const An={toc:[]};function Rn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},An,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}Rn.isMDXComponent=!0;const En={toc:[]};function Sn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},En,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Sn.isMDXComponent=!0;const zn={toc:[]};function In(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Dispatches a ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,r.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}In.isMDXComponent=!0;const Wn={toc:[]};function Pn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Wn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The initial value."))}Pn.isMDXComponent=!0;const Gn={toc:[]};function Bn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Gn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the most recent value of this dispatcher."))}Bn.isMDXComponent=!0;const Fn={toc:[]};function Un(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Fn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Setting the value will immediately notify all subscribers."))}Un.isMDXComponent=!0;const qn={toc:[]};function Vn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Set the current value of this dispatcher."))}Vn.isMDXComponent=!0;const jn={toc:[]};function On(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new value."))}On.isMDXComponent=!0;const Hn={toc:[]};function $n(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Hn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe all subscribers from the event."))}$n.isMDXComponent=!0;const Kn={toc:[]};function Yn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Kn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Callback function that cancels the subscription."))}Yn.isMDXComponent=!0;const Jn={toc:[]};function Qn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Jn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribe to the event."),(0,r.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Qn.isMDXComponent=!0;const te={toc:[]};function ne(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},te,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to invoke when the event occurs."))}ne.isMDXComponent=!0;const ee={toc:[]};function oe(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ee,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}oe.isMDXComponent=!0;const pe={toc:[]};function se(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pe,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe from the event."))}se.isMDXComponent=!0;const re={toc:[]};function ce(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},re,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to unsubscribe."))}ce.isMDXComponent=!0;const ae={toc:[]};function ie(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ae,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the value passed to subscribers."))}ie.isMDXComponent=!0;const le={toc:[]};function ue(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},le,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ue.isMDXComponent=!0;const me={toc:[]};function de(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},me,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Provides safe access to the public interface of ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,r.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}de.isMDXComponent=!0;const he={toc:[]};function ke(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},he,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the argument passed to subscribers."))}ke.isMDXComponent=!0;const ye={toc:[]};function fe(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ye,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}fe.isMDXComponent=!0;const Me={toc:[]};function we(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Me,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Provides safe access to the public interface of ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,r.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}we.isMDXComponent=!0;const De={toc:[]};function _e(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},De,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the argument passed to subscribers."))}_e.isMDXComponent=!0;const Xe={toc:[]};function ge(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Xe,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ge.isMDXComponent=!0;const xe={toc:[]};function Ce(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xe,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Provides safe access to the public interface of ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,r.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}Ce.isMDXComponent=!0;const Te={toc:[]};function ve(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Te,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}ve.isMDXComponent=!0;const be={toc:[]};function Le(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},be,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The amount of times the timer has ticked."))}Le.isMDXComponent=!0;const Ze={toc:[]};function Ne(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ze,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The generator responsible for running this timer."))}Ne.isMDXComponent=!0;const Ae={toc:[]};function Re(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ae,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait until the timer ticks."))}Re.isMDXComponent=!0;const Ee={toc:[]};function Se(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ee,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The current iteration index."))}Se.isMDXComponent=!0;const ze={toc:[]};function Ie(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ze,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Ie.isMDXComponent=!0;const We={toc:[]};function Pe(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},We,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Pe.isMDXComponent=!0;const Ge={toc:[]};function Be(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ge,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A list of tasks to run."))}Be.isMDXComponent=!0;const Fe={toc:[]};function Ue(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Fe,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Ue.isMDXComponent=!0;const qe={toc:[]};function Ve(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qe,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Ve.isMDXComponent=!0;const je={toc:[]};function Oe(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},je,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A list of tasks to run."))}Oe.isMDXComponent=!0;const He={toc:[]};function $e(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},He,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,r.kt)("p",null,"Note that the same animation can be written as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,r.kt)("p",null,"The reason ",(0,r.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}$e.isMDXComponent=!0;const Ke={toc:[]};function Ye(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ke,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Run tasks one after another."))}Ye.isMDXComponent=!0;const Je={toc:[]};function Qe(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Je,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A list of tasks to run."))}Qe.isMDXComponent=!0;const to={toc:[]};function no(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},to,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,r.kt)("p",null,"Note that the same animation can be written as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,r.kt)("p",null,"The reason ",(0,r.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}no.isMDXComponent=!0;const eo={toc:[]};function oo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}oo.isMDXComponent=!0;const po={toc:[]};function so(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},po,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The delay in seconds"))}so.isMDXComponent=!0;const ro={toc:[]};function co(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ro,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The task or callback to run after the delay."))}co.isMDXComponent=!0;const ao={toc:[]};function io(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ao,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}io.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Call the given callback every N seconds."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The interval between subsequent calls."))}ho.isMDXComponent=!0;const ko={toc:[]};function yo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ko,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The callback to be called."))}yo.isMDXComponent=!0;const fo={toc:[]};function Mo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Each time iteration waits until the previous one is completed."))}Mo.isMDXComponent=!0;const wo={toc:[]};function Do(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n});\n")))}Do.isMDXComponent=!0;const _o={toc:[]};function Xo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_o,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Run the given generator N times."))}Xo.isMDXComponent=!0;const go={toc:[]};function xo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},go,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The number of iterations."))}xo.isMDXComponent=!0;const Co={toc:[]};function To(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Co,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each iteration."))}To.isMDXComponent=!0;const vo={toc:[]};function bo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Do nothing."))}bo.isMDXComponent=!0;const Lo={toc:[]};function Zo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Zo.isMDXComponent=!0;const No={toc:[]};function Ao(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},No,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Turn the given generator function into a threadable generator."))}Ao.isMDXComponent=!0;const Ro={toc:[]};function Eo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ro,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A generator function or a factory that creates the generator."))}Eo.isMDXComponent=!0;const So={toc:[]};function zo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},So,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}zo.isMDXComponent=!0;const Io={toc:[]};function Wo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Io,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Turn the given generator function into a threadable generator."))}Wo.isMDXComponent=!0;const Po={toc:[]};function Go(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Po,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An optional name used when displaying this generator in the UI."))}Go.isMDXComponent=!0;const Bo={toc:[]};function Fo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A generator function or a factory that creates the generator."))}Fo.isMDXComponent=!0;const Uo={toc:[]};function qo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}qo.isMDXComponent=!0;const Vo={toc:[]};function jo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}jo.isMDXComponent=!0;const Oo={toc:[]};function Ho(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Oo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Start all tasks one after another with a constant delay between."))}Ho.isMDXComponent=!0;const $o={toc:[]};function Ko(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$o,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The delay between each of the tasks."))}Ko.isMDXComponent=!0;const Yo={toc:[]};function Jo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A list of tasks to be run in a sequence."))}Jo.isMDXComponent=!0;const Qo={toc:[]};function tp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}tp.isMDXComponent=!0;const np={toc:[]};function ep(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},np,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for the given amount of time."))}ep.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},op,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The relative time in seconds."))}pp.isMDXComponent=!0;const sp={toc:[]};function rp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An optional task to be run after the function completes."))}rp.isMDXComponent=!0;const cp={toc:[]};function ap(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}ap.isMDXComponent=!0;const ip={toc:[]};function lp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ip,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},up,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait until the given time event."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The name of the time event."))}hp.isMDXComponent=!0;const kp={toc:[]};function yp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An optional task to be run after the function completes."))}yp.isMDXComponent=!0;const fp={toc:[]};function Mp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Multi-media management."))}Mp.isMDXComponent=!0;const wp={toc:[]};function Dp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Dp.isMDXComponent=!0;const _p={toc:[]};function Xp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_p,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Pause/resume the audio."))}Xp.isMDXComponent=!0;const gp={toc:[]};function xp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the audio should be paused or resumed."))}xp.isMDXComponent=!0;const Cp={toc:[]};function Tp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The absolute biggest value from the peaks array."))}Tp.isMDXComponent=!0;const vp={toc:[]};function bp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The amount of samples taken."))}bp.isMDXComponent=!0;const Lp={toc:[]};function Zp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Zp.isMDXComponent=!0;const Np={toc:[]};function Ap(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Np,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Samples per seconds."))}Ap.isMDXComponent=!0;const Rp={toc:[]};function Ep(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Abstract scene representations and related utilities."))}Ep.isMDXComponent=!0;const Sp={toc:[]};function zp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Signifies the various stages of a ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,r.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}zp.isMDXComponent=!0;const Ip={toc:[]};function Wp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ip,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Occurs after a render ends."))}Wp.isMDXComponent=!0;const Pp={toc:[]};function Gp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}Gp.isMDXComponent=!0;const Bp={toc:[]};function Fp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,r.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,r.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}Fp.isMDXComponent=!0;const Up={toc:[]};function qp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Up,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,r.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,r.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}qp.isMDXComponent=!0;const Vp={toc:[]};function jp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Describes the state of a scene."))}jp.isMDXComponent=!0;const Op={toc:[]};function Hp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Op,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}Hp.isMDXComponent=!0;const $p={toc:[]};function Kp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$p,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The scene has finished transitioning in."))}Kp.isMDXComponent=!0;const Yp={toc:[]};function Jp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,r.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,r.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}Jp.isMDXComponent=!0;const Qp={toc:[]};function ts(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The scene is ready to transition out."))}ts.isMDXComponent=!0;const ns={toc:[]};function es(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ns,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Invoking ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,r.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}es.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},os,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The scene has finished."))}ps.isMDXComponent=!0;const ss={toc:[]};function rs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ss,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The scene has just been created/reset."))}rs.isMDXComponent=!0;const cs={toc:[]};function as(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The default implementation of the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,r.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,r.kt)("p",null,"Uses generators to control the animation."))}as.isMDXComponent=!0;const is={toc:[]};function ls(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},is,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Will be passed as the second argument to the constructor."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},us,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Name of the scene."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ds,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reference to the project."))}hs.isMDXComponent=!0;const ks={toc:[]};function ys(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ks,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,r.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}ys.isMDXComponent=!0;const fs={toc:[]};function Ms(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,r.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Ms.isMDXComponent=!0;const ws={toc:[]};function Ds(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ws,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The frame at which this scene starts."))}Ds.isMDXComponent=!0;const _s={toc:[]};function Xs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_s,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The frame at which this scene ends."))}Xs.isMDXComponent=!0;const gs={toc:[]};function xs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when the cached data changes."))}xs.isMDXComponent=!0;const Cs={toc:[]};function Ts(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered after scene is recalculated."))}Ts.isMDXComponent=!0;const vs={toc:[]};function bs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when the scene is reloaded."))}bs.isMDXComponent=!0;const Ls={toc:[]};function Zs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ls,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Zs.isMDXComponent=!0;const Ns={toc:[]};function As(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ns,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when the scene is reset."))}As.isMDXComponent=!0;const Rs={toc:[]};function Es(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when the main thread changes."))}Es.isMDXComponent=!0;const Ss={toc:[]};function zs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ss,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}zs.isMDXComponent=!0;const Is={toc:[]};function Ws(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Is,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Is this scene in the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,r.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Ws.isMDXComponent=!0;const Ps={toc:[]};function Gs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ps,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Enter the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,r.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Gs.isMDXComponent=!0;const Bs={toc:[]};function Fs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Enter the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,r.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}Fs.isMDXComponent=!0;const Us={toc:[]};function qs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Us,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Enter the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,r.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}qs.isMDXComponent=!0;const Vs={toc:[]};function js(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}js.isMDXComponent=!0;const Os={toc:[]};function Hs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Os,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Invoke the given callback in the context of this scene."))}Hs.isMDXComponent=!0;const $s={toc:[]};function Ks(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$s,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The callback to invoke."))}Ks.isMDXComponent=!0;const Ys={toc:[]};function Js(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ys,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the size of this scene."),(0,r.kt)("p",null,"Usually return ",(0,r.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}Js.isMDXComponent=!0;const Qs={toc:[]};function tr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Is this scene in the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,r.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}tr.isMDXComponent=!0;const nr={toc:[]};function er(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Is this scene cached?"),(0,r.kt)("p",null,"Used only by ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,r.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,r.kt)("p",null,"Should always return ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."))}er.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},or,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Is this scene in the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,r.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}pr.isMDXComponent=!0;const sr={toc:[]};function rr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Progress this scene one frame forward."))}rr.isMDXComponent=!0;const cr={toc:[]};function ar(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,r.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,r.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,r.kt)("p",null,"At the end of execution, this method should set ",(0,r.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,r.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,r.kt)("p",null,"Should trigger ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,r.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}ar.isMDXComponent=!0;const ir={toc:[]};function lr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ir,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Recalculate the scene."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ur,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,r.kt)("p",null,"Should trigger ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,r.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reload the scene."))}hr.isMDXComponent=!0;const kr={toc:[]};function yr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If present, an updated version of the description."))}yr.isMDXComponent=!0;const fr={toc:[]};function Mr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render the scene onto a canvas."))}Mr.isMDXComponent=!0;const wr={toc:[]};function Dr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to used when rendering."))}Dr.isMDXComponent=!0;const _r={toc:[]};function Xr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_r,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reset this scene to its initial state."))}Xr.isMDXComponent=!0;const gr={toc:[]};function xr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If present, the previous scene."))}xr.isMDXComponent=!0;const Cr={toc:[]};function Tr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the view."),(0,r.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,r.kt)("p",null,"Can modify the state of the view."))}Tr.isMDXComponent=!0;const vr={toc:[]};function br(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Lifecycle events for ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,r.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}br.isMDXComponent=!0;const Lr={toc:[]};function Zr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A random number generator based on\n",(0,r.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,r.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Zr.isMDXComponent=!0;const Nr={toc:[]};function Ar(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get an array filled with random floats in the given range."))}Ar.isMDXComponent=!0;const Rr={toc:[]};function Er(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The size of the array."))}Er.isMDXComponent=!0;const Sr={toc:[]};function zr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The start of the range."))}zr.isMDXComponent=!0;const Ir={toc:[]};function Wr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ir,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The end of the range."))}Wr.isMDXComponent=!0;const Pr={toc:[]};function Gr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get an array filled with random integers in the given range."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"}),(0,r.kt)("li",{parentName:"ul"})))}Gr.isMDXComponent=!0;const Br={toc:[]};function Fr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Br,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The size of the array."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"})))}Fr.isMDXComponent=!0;const Ur={toc:[]};function qr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ur,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The start of the range."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"})))}qr.isMDXComponent=!0;const Vr={toc:[]};function jr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The end of the range. Exclusive."))}jr.isMDXComponent=!0;const Or={toc:[]};function Hr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Or,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the next random float in the given range."))}Hr.isMDXComponent=!0;const $r={toc:[]};function Kr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$r,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The start of the range."))}Kr.isMDXComponent=!0;const Yr={toc:[]};function Jr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The end of the range."))}Jr.isMDXComponent=!0;const Qr={toc:[]};function tc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the next random integer in the given range."))}tc.isMDXComponent=!0;const nc={toc:[]};function ec(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The start of the range."))}ec.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The end of the range. Exclusive."))}pc.isMDXComponent=!0;const sc={toc:[]};function rc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a new independent generator."))}rc.isMDXComponent=!0;const cc={toc:[]};function ac(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get variable signal if exists or create signal if not"))}ac.isMDXComponent=!0;const ic={toc:[]};function lc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ic,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The name of the variable."))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get variable signal if exists or create signal if not"))}hc.isMDXComponent=!0;const kc={toc:[]};function yc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reset all stored signals."))}yc.isMDXComponent=!0;const fc={toc:[]};function Mc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update all signals with new project variable values."))}Mc.isMDXComponent=!0;const wc={toc:[]};function Dc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Describes cached information about the timing of a scene."))}Dc.isMDXComponent=!0;const _c={toc:[]};function Xc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_c,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Describes a complete scene together with the meta file."))}Xc.isMDXComponent=!0;const gc={toc:[]};function xc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Configuration object."))}xc.isMDXComponent=!0;const Cc={toc:[]};function Tc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The class used to instantiate the scene."))}Tc.isMDXComponent=!0;const vc={toc:[]};function bc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The stack trace at the moment of creation."))}bc.isMDXComponent=!0;const Lc={toc:[]};function Zc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the configuration object."))}Zc.isMDXComponent=!0;const Nc={toc:[]};function Ac(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Ac.isMDXComponent=!0;const Rc={toc:[]};function Ec(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}Ec.isMDXComponent=!0;const Sc={toc:[]};function zc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for the inspected element."))}zc.isMDXComponent=!0;const Ic={toc:[]};function Wc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ic,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The element for which to draw an overlay."))}Wc.isMDXComponent=!0;const Pc={toc:[]};function Gc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}Gc.isMDXComponent=!0;const Bc={toc:[]};function Fc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}Fc.isMDXComponent=!0;const Uc={toc:[]};function qc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}qc.isMDXComponent=!0;const Vc={toc:[]};function jc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return the attributes of the inspected element."))}jc.isMDXComponent=!0;const Oc={toc:[]};function Hc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Oc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The element to inspect."))}Hc.isMDXComponent=!0;const $c={toc:[]};function Kc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$c,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a possible element to inspect at a given position."))}Kc.isMDXComponent=!0;const Yc={toc:[]};function Jc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The x coordinate."))}Jc.isMDXComponent=!0;const Qc={toc:[]};function ta(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The y coordinate."))}ta.isMDXComponent=!0;const na={toc:[]};function ea(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},na,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}ea.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Check if the inspected element is still valid."))}pa.isMDXComponent=!0;const sa={toc:[]};function ra(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The element to validate."))}ra.isMDXComponent=!0;const ca={toc:[]};function aa(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ca,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,r.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}aa.isMDXComponent=!0;const ia={toc:[]};function la(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ia,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The main interface for scenes."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ua,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Will be passed as the second argument to the constructor."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},da,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Name of the scene."))}ha.isMDXComponent=!0;const ka={toc:[]};function ya(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ka,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reference to the project."))}ya.isMDXComponent=!0;const fa={toc:[]};function Ma(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,r.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Ma.isMDXComponent=!0;const wa={toc:[]};function Da(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,r.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Da.isMDXComponent=!0;const _a={toc:[]};function Xa(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_a,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The frame at which this scene starts."))}Xa.isMDXComponent=!0;const ga={toc:[]};function xa(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ga,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The frame at which this scene ends."))}xa.isMDXComponent=!0;const Ca={toc:[]};function Ta(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ca,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,r.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Ta.isMDXComponent=!0;const va={toc:[]};function ba(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},va,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when the cached data changes."))}ba.isMDXComponent=!0;const La={toc:[]};function Za(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},La,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered after scene is recalculated."))}Za.isMDXComponent=!0;const Na={toc:[]};function Aa(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Na,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when the scene is reloaded."))}Aa.isMDXComponent=!0;const Ra={toc:[]};function Ea(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ra,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Ea.isMDXComponent=!0;const Sa={toc:[]};function za(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when the scene is reset."))}za.isMDXComponent=!0;const Ia={toc:[]};function Wa(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ia,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Wa.isMDXComponent=!0;const Pa={toc:[]};function Ga(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Is this scene in the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,r.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Ga.isMDXComponent=!0;const Ba={toc:[]};function Fa(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ba,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Enter the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,r.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Fa.isMDXComponent=!0;const Ua={toc:[]};function qa(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ua,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Enter the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,r.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}qa.isMDXComponent=!0;const Va={toc:[]};function ja(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Va,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Enter the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,r.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}ja.isMDXComponent=!0;const Oa={toc:[]};function Ha(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Oa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the size of this scene."),(0,r.kt)("p",null,"Usually return ",(0,r.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}Ha.isMDXComponent=!0;const $a={toc:[]};function Ka(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$a,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Is this scene in the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,r.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}Ka.isMDXComponent=!0;const Ya={toc:[]};function Ja(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ya,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Is this scene cached?"),(0,r.kt)("p",null,"Used only by ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,r.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,r.kt)("p",null,"Should always return ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."))}Ja.isMDXComponent=!0;const Qa={toc:[]};function ti(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Is this scene in the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,r.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}ti.isMDXComponent=!0;const ni={toc:[]};function ei(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ni,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Progress this scene one frame forward."))}ei.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,r.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,r.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,r.kt)("p",null,"At the end of execution, this method should set ",(0,r.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,r.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,r.kt)("p",null,"Should trigger ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,r.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}pi.isMDXComponent=!0;const si={toc:[]};function ri(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},si,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Recalculate the scene."))}ri.isMDXComponent=!0;const ci={toc:[]};function ai(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ci,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,r.kt)("p",null,"Should trigger ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,r.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}ai.isMDXComponent=!0;const ii={toc:[]};function li(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ii,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reload the scene."))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ui,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If present, an updated version of the description."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},di,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render the scene onto a canvas."))}hi.isMDXComponent=!0;const ki={toc:[]};function yi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ki,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to used when rendering."))}yi.isMDXComponent=!0;const fi={toc:[]};function Mi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reset this scene to its initial state."))}Mi.isMDXComponent=!0;const wi={toc:[]};function Di(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If present, the previous scene."))}Di.isMDXComponent=!0;const _i={toc:[]};function Xi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_i,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the configuration object."))}Xi.isMDXComponent=!0;const gi={toc:[]};function xi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Each class implementing the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,r.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}xi.isMDXComponent=!0;const Ci={toc:[]};function Ti(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ci,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The constructor used when creating new scenes."))}Ti.isMDXComponent=!0;const vi={toc:[]};function bi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,r.kt)("inlineCode",{parentName:"a"},"config")),"."))}bi.isMDXComponent=!0;const Li={toc:[]};function Zi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Li,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Describes a scene exposed by scene files."))}Zi.isMDXComponent=!0;const Ni={toc:[]};function Ai(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ni,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Configuration object."))}Ai.isMDXComponent=!0;const Ri={toc:[]};function Ei(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ri,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The class used to instantiate the scene."))}Ei.isMDXComponent=!0;const Si={toc:[]};function zi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Si,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The stack trace at the moment of creation."))}zi.isMDXComponent=!0;const Ii={toc:[]};function Wi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ii,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the configuration object."))}Wi.isMDXComponent=!0;const Pi={toc:[]};function Gi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A part of the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,r.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}Gi.isMDXComponent=!0;const Bi={toc:[]};function Fi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the configuration object."))}Fi.isMDXComponent=!0;const Ui={toc:[]};function qi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ui,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}qi.isMDXComponent=!0;const Vi={toc:[]};function ji(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}ji.isMDXComponent=!0;const Oi={toc:[]};function Hi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Oi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when the main thread changes."))}Hi.isMDXComponent=!0;const $i={toc:[]};function Ki(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$i,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents attributes of an inspected element."))}Ki.isMDXComponent=!0;const Yi={toc:[]};function Ji(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}Ji.isMDXComponent=!0;const Qi={toc:[]};function tl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents an element to inspect."))}tl.isMDXComponent=!0;const nl={toc:[]};function el(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A runtime representation of the scene metadata."))}el.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ol,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a runtime representation of the scene metadata."))}pl.isMDXComponent=!0;const sl={toc:[]};function rl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}rl.isMDXComponent=!0;const cl={toc:[]};function al(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}al.isMDXComponent=!0;const il={toc:[]};function ll(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},il,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Check if the signal is currently using its initial value."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ul,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,r.kt)("p",null,"This method can be used to create copies of signals."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}hl.isMDXComponent=!0;const kl={toc:[]};function yl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the raw value of this signal."))}yl.isMDXComponent=!0;const fl={toc:[]};function Ml(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Ml.isMDXComponent=!0;const wl={toc:[]};function Dl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Dl.isMDXComponent=!0;const _l={toc:[]};function Xl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_l,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Xl.isMDXComponent=!0;const gl={toc:[]};function xl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}xl.isMDXComponent=!0;const Cl={toc:[]};function Tl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Tl.isMDXComponent=!0;const vl={toc:[]};function bl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}bl.isMDXComponent=!0;const Ll={toc:[]};function Zl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ll,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Check if the signal is currently using its initial value."))}Zl.isMDXComponent=!0;const Nl={toc:[]};function Al(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,r.kt)("p",null,"This method can be used to create copies of signals."))}Al.isMDXComponent=!0;const Rl={toc:[]};function El(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}El.isMDXComponent=!0;const Sl={toc:[]};function zl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the raw value of this signal."))}zl.isMDXComponent=!0;const Il={toc:[]};function Wl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Il,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Wl.isMDXComponent=!0;const Pl={toc:[]};function Gl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Gl.isMDXComponent=!0;const Bl={toc:[]};function Fl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Fl.isMDXComponent=!0;const Ul={toc:[]};function ql(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ul,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}ql.isMDXComponent=!0;const Vl={toc:[]};function jl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Compute the current value of the signal and immediately set it."))}jl.isMDXComponent=!0;const Ol={toc:[]};function Hl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ol,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Check if the signal is currently using its initial value."))}Hl.isMDXComponent=!0;const $l={toc:[]};function Kl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$l,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Kl.isMDXComponent=!0;const Yl={toc:[]};function Jl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Jl.isMDXComponent=!0;const Ql={toc:[]};function tu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ql,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Compute the current value of the signal and immediately set it."))}tu.isMDXComponent=!0;const nu={toc:[]};function eu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Thread management."))}eu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ou,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,r.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}pu.isMDXComponent=!0;const su={toc:[]};function ru(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},su,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A class representing an individual thread."))}ru.isMDXComponent=!0;const cu={toc:[]};function au(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The generator wrapped by this thread."))}au.isMDXComponent=!0;const iu={toc:[]};function lu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The generator wrapped by this thread."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Used by ",(0,r.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,r.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},du,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The current time of this thread."))}hu.isMDXComponent=!0;const ku={toc:[]};function yu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ku,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The next value to be passed to the wrapped generator."))}yu.isMDXComponent=!0;const fu={toc:[]};function Mu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}Mu.isMDXComponent=!0;const wu={toc:[]};function Du(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,r.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,r.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}Du.isMDXComponent=!0;const _u={toc:[]};function Xu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_u,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The fixed time of this thread."))}Xu.isMDXComponent=!0;const gu={toc:[]};function xu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Progress the wrapped generator once."))}xu.isMDXComponent=!0;const Cu={toc:[]};function Tu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the thread for the next update cycle."))}Tu.isMDXComponent=!0;const vu={toc:[]};function bu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The delta time of the next cycle."))}bu.isMDXComponent=!0;const Lu={toc:[]};function Zu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A generator function or a normal function that returns a generator."))}Zu.isMDXComponent=!0;const Nu={toc:[]};function Au(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,r.kt)("p",null,"Progress to the next frame:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,r.kt)("p",null,"Run another generator synchronously:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,r.kt)("p",null,"Run another generator concurrently:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,r.kt)("p",null,"Await a Promise:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}Au.isMDXComponent=!0;const Ru={toc:[]};function Eu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ru,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}Eu.isMDXComponent=!0;const Su={toc:[]};function zu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Su,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Cancel all listed tasks."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}zu.isMDXComponent=!0;const Iu={toc:[]};function Wu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Iu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A list of tasks to cancel."))}Wu.isMDXComponent=!0;const Pu={toc:[]};function Gu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}Gu.isMDXComponent=!0;const Bu={toc:[]};function Fu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A possible ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}Fu.isMDXComponent=!0;const Uu={toc:[]};function qu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Check if the given value is a ",(0,r.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,r.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}qu.isMDXComponent=!0;const Vu={toc:[]};function ju(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A possible thread ",(0,r.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,r.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}ju.isMDXComponent=!0;const Ou={toc:[]};function Hu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ou,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}Hu.isMDXComponent=!0;const $u={toc:[]};function Ku(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$u,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}Ku.isMDXComponent=!0;const Yu={toc:[]};function Ju(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A list of tasks to join."))}Ju.isMDXComponent=!0;const Qu={toc:[]};function tm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}tm.isMDXComponent=!0;const nm={toc:[]};function em(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Pause the current generator until listed tasks are finished."))}em.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},om,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}pm.isMDXComponent=!0;const sm={toc:[]};function rm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A list of tasks to join."))}rm.isMDXComponent=!0;const cm={toc:[]};function am(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"From the perspective of the external generator, ",(0,r.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,r.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}am.isMDXComponent=!0;const im={toc:[]};function lm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},im,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},um,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a context in which generators can be run concurrently."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A function that returns the generator to run."))}hm.isMDXComponent=!0;const km={toc:[]};function ym(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},km,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}ym.isMDXComponent=!0;const fm={toc:[]};function Mm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Transitions between scenes."))}Mm.isMDXComponent=!0;const wm={toc:[]};function Dm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Perform a transition that fades between the scenes."))}Dm.isMDXComponent=!0;const _m={toc:[]};function Xm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_m,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition."))}Xm.isMDXComponent=!0;const gm={toc:[]};function xm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}xm.isMDXComponent=!0;const Cm={toc:[]};function Tm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The direction in which to slide."))}Tm.isMDXComponent=!0;const vm={toc:[]};function bm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition."))}bm.isMDXComponent=!0;const Lm={toc:[]};function Zm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}Zm.isMDXComponent=!0;const Nm={toc:[]};function Am(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The callback to use before the current scene is rendered."))}Am.isMDXComponent=!0;const Rm={toc:[]};function Em(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The callback to use before the previous scene is rendered."))}Em.isMDXComponent=!0;const Sm={toc:[]};function zm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}zm.isMDXComponent=!0;const Im={toc:[]};function Wm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Im,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The area on which to zoom in."))}Wm.isMDXComponent=!0;const Pm={toc:[]};function Gm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition."))}Gm.isMDXComponent=!0;const Bm={toc:[]};function Fm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}Fm.isMDXComponent=!0;const Um={toc:[]};function qm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Um,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The area from which to zoom out."))}qm.isMDXComponent=!0;const Vm={toc:[]};function jm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition."))}jm.isMDXComponent=!0;const Om={toc:[]};function Hm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Om,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Interpolation and timing of tweens."))}Hm.isMDXComponent=!0;const $m={toc:[]};function Km(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$m,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Any old key that is missing in ",(0,r.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,r.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"})))}Km.isMDXComponent=!0;const Ym={toc:[]};function Jm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ym,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A value matching the structure of from and to."))}Jm.isMDXComponent=!0;const Qm={toc:[]};function td(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}td.isMDXComponent=!0;const nd={toc:[]};function ed(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The input to favor when value is 0."))}ed.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},od,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The input to favor when value is 1."))}pd.isMDXComponent=!0;const sd={toc:[]};function rd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}rd.isMDXComponent=!0;const cd={toc:[]};function ad(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A value matching the structure of from and to."))}ad.isMDXComponent=!0;const id={toc:[]};function ld(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},id,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ud,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The input to favor when value is 0."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The input to favor when value is 1."))}hd.isMDXComponent=!0;const kd={toc:[]};function yd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}yd.isMDXComponent=!0;const fd={toc:[]};function Md(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Complex types used in animations."))}Md.isMDXComponent=!0;const wd={toc:[]};function Dd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,r.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,r.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,r.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,r.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,r.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,r.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}Dd.isMDXComponent=!0;const _d={toc:[]};function Xd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_d,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the determinant of the matrix."))}Xd.isMDXComponent=!0;const gd={toc:[]};function xd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}xd.isMDXComponent=!0;const Cd={toc:[]};function Td(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}Td.isMDXComponent=!0;const vd={toc:[]};function bd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the inverse of the matrix."))}bd.isMDXComponent=!0;const Ld={toc:[]};function Zd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ld,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Zd.isMDXComponent=!0;const Nd={toc:[]};function Ad(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}Ad.isMDXComponent=!0;const Rd={toc:[]};function Ed(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the provided matrix to this matrix."))}Ed.isMDXComponent=!0;const Sd={toc:[]};function zd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The matrix to add"))}zd.isMDXComponent=!0;const Id={toc:[]};function Wd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Id,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}Wd.isMDXComponent=!0;const Pd={toc:[]};function Gd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}Gd.isMDXComponent=!0;const Bd={toc:[]};function Fd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index of the component vector to retrieve."))}Fd.isMDXComponent=!0;const Ud={toc:[]};function qd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ud,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}qd.isMDXComponent=!0;const Vd={toc:[]};function jd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}jd.isMDXComponent=!0;const Od={toc:[]};function Hd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Od,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}Hd.isMDXComponent=!0;const $d={toc:[]};function Kd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$d,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The matrix to multiply with"))}Kd.isMDXComponent=!0;const Yd={toc:[]};function Jd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}Jd.isMDXComponent=!0;const Qd={toc:[]};function th(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"})))}th.isMDXComponent=!0;const nh={toc:[]};function eh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value by which to scale each term"))}eh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}ph.isMDXComponent=!0;const sh={toc:[]};function rh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}rh.isMDXComponent=!0;const ch={toc:[]};function ah(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ch,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}ah.isMDXComponent=!0;const ih={toc:[]};function lh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ih,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The angle by which to rotate the matrix"))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}hh.isMDXComponent=!0;const kh={toc:[]};function yh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index of the row to retrieve."))}yh.isMDXComponent=!0;const fh={toc:[]};function Mh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If ",(0,r.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,r.kt)("p",null,"If ",(0,r.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,r.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Mh.isMDXComponent=!0;const wh={toc:[]};function Dh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}Dh.isMDXComponent=!0;const _h={toc:[]};function Xh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_h,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Scale the x and y component vectors of the matrix."))}Xh.isMDXComponent=!0;const gh={toc:[]};function xh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The factor by which to scale the matrix"))}xh.isMDXComponent=!0;const Ch={toc:[]};function Th(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ch,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Th.isMDXComponent=!0;const vh={toc:[]};function bh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}bh.isMDXComponent=!0;const Lh={toc:[]};function Zh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subtract the provided matrix from this matrix."))}Zh.isMDXComponent=!0;const Nh={toc:[]};function Ah(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The matrix to subract"))}Ah.isMDXComponent=!0;const Rh={toc:[]};function Eh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If ",(0,r.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,r.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Eh.isMDXComponent=!0;const Sh={toc:[]};function zh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}zh.isMDXComponent=!0;const Ih={toc:[]};function Wh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ih,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}Wh.isMDXComponent=!0;const Ph={toc:[]};function Gh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ph,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The vector by which to translate the matrix"))}Gh.isMDXComponent=!0;const Bh={toc:[]};function Fh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents a two-dimensional vector."))}Fh.isMDXComponent=!0;const Uh={toc:[]};function qh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}qh.isMDXComponent=!0;const Vh={toc:[]};function jh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}jh.isMDXComponent=!0;const Oh={toc:[]};function Hh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Oh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}Hh.isMDXComponent=!0;const $h={toc:[]};function Kh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$h,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,r.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}Kh.isMDXComponent=!0;const Yh={toc:[]};function Jh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Check if two vectors are equal to each other."))}Jh.isMDXComponent=!0;const Qh={toc:[]};function tk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The vector to compare."))}tk.isMDXComponent=!0;const nk={toc:[]};function ek(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The allowed error threshold when comparing the vectors."))}ek.isMDXComponent=!0;const ok={toc:[]};function pk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ok,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,r.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,r.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}pk.isMDXComponent=!0;const sk={toc:[]};function rk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Check if two vectors are exactly equal to each other."))}rk.isMDXComponent=!0;const ck={toc:[]};function ak(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ck,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The vector to compare."))}ak.isMDXComponent=!0;const ik={toc:[]};function lk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ik,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}lk.isMDXComponent=!0;const uk={toc:[]};function mk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}mk.isMDXComponent=!0;const dk={toc:[]};function hk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The x component of the vector."))}hk.isMDXComponent=!0;const kk={toc:[]};function yk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The y component of the vector."))}yk.isMDXComponent=!0;const fk={toc:[]};function Mk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}Mk.isMDXComponent=!0;const wk={toc:[]};function Dk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The x component of the vector."))}Dk.isMDXComponent=!0;const _k={toc:[]};function Xk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_k,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The y component of the vector."))}Xk.isMDXComponent=!0;const gk={toc:[]};function xk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}xk.isMDXComponent=!0;const Ck={toc:[]};function Tk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ck,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The unclipped RGB components."))}Tk.isMDXComponent=!0;const vk={toc:[]};function bk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}bk.isMDXComponent=!0;const Lk={toc:[]};function Zk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}Zk.isMDXComponent=!0;const Nk={toc:[]};function Ak(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Ak.isMDXComponent=!0;const Rk={toc:[]};function Ek(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}Ek.isMDXComponent=!0;const Sk={toc:[]};function zk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}zk.isMDXComponent=!0;const Ik={toc:[]};function Wk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ik,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}Wk.isMDXComponent=!0;const Pk={toc:[]};function Gk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}Gk.isMDXComponent=!0;const Bk={toc:[]};function Fk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Alias of ",(0,r.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}Fk.isMDXComponent=!0;const Uk={toc:[]};function qk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}qk.isMDXComponent=!0;const Vk={toc:[]};function jk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns an array with the ",(0,r.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}jk.isMDXComponent=!0;const Ok={toc:[]};function Hk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ok,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}Hk.isMDXComponent=!0;const $k={toc:[]};function Kk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$k,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns an array with the ",(0,r.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,r.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,r.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}Kk.isMDXComponent=!0;const Yk={toc:[]};function Jk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}Jk.isMDXComponent=!0;const Qk={toc:[]};function ty(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns an array with the ",(0,r.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,r.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,r.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}ty.isMDXComponent=!0;const ny={toc:[]};function ey(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ny,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}ey.isMDXComponent=!0;const oy={toc:[]};function py(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns an array with the ",(0,r.kt)("strong",{parentName:"p"},"L"),", ",(0,r.kt)("strong",{parentName:"p"},"a"),", and ",(0,r.kt)("strong",{parentName:"p"},"b")," components."))}py.isMDXComponent=!0;const sy={toc:[]};function ry(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}ry.isMDXComponent=!0;const cy={toc:[]};function ay(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns an array with the ",(0,r.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,r.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,r.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}ay.isMDXComponent=!0;const iy={toc:[]};function ly(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}ly.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}hy.isMDXComponent=!0;const ky={toc:[]};function yy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ky,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}yy.isMDXComponent=!0;const fy={toc:[]};function My(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get and set the color opacity."))}My.isMDXComponent=!0;const wy={toc:[]};function Dy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,r.kt)("code",null,"'rgb'")))}Dy.isMDXComponent=!0;const _y={toc:[]};function Xy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_y,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Similar to saturate, but the opposite direction."))}Xy.isMDXComponent=!0;const gy={toc:[]};function xy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"set"))}xy.isMDXComponent=!0;const Cy={toc:[]};function Ty(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns a single channel value.\nAlso"))}Ty.isMDXComponent=!0;const vy={toc:[]};function by(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}by.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ly,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get color as hexadecimal string."))}Zy.isMDXComponent=!0;const Ny={toc:[]};function Ay(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ny,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,r.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,r.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}Ay.isMDXComponent=!0;const Ry={toc:[]};function Ey(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ry,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,r.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}Ey.isMDXComponent=!0;const Sy={toc:[]};function zy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}zy.isMDXComponent=!0;const Iy={toc:[]};function Wy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Iy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}Wy.isMDXComponent=!0;const Py={toc:[]};function Gy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Py,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}Gy.isMDXComponent=!0;const By={toc:[]};function Fy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},By,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}Fy.isMDXComponent=!0;const Uy={toc:[]};function qy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}qy.isMDXComponent=!0;const Vy={toc:[]};function jy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}jy.isMDXComponent=!0;const Oy={toc:[]};function Hy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Oy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}Hy.isMDXComponent=!0;const $y={toc:[]};function Ky(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$y,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}Ky.isMDXComponent=!0;const Yy={toc:[]};function Jy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}Jy.isMDXComponent=!0;const Qy={toc:[]};function tf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}tf.isMDXComponent=!0;const nf={toc:[]};function ef(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Convert the given origin to a vector representing its offset."))}ef.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},of,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The origin to convert."))}pf.isMDXComponent=!0;const sf={toc:[]};function rf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"General utilities and helper functions."))}rf.isMDXComponent=!0;const cf={toc:[]};function af(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Optional override for formatting stack traces"))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create .stack property on a target object"))}df.isMDXComponent=!0;const hf={toc:[]};function kf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is a shortcut for calling ",(0,r.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}kf.isMDXComponent=!0;const yf={toc:[]};function ff(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}ff.isMDXComponent=!0;const Mf={toc:[]};function wf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Mf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Logs a debug message with an arbitrary payload."))}wf.isMDXComponent=!0;const Df={toc:[]};function _f(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Df,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The payload to log"))}_f.isMDXComponent=!0;const Xf={toc:[]};function gf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Xf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Mark the given function as deprecated."))}gf.isMDXComponent=!0;const xf={toc:[]};function Cf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The function to deprecate."))}Cf.isMDXComponent=!0;const Tf={toc:[]};function vf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Tf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The log message."))}vf.isMDXComponent=!0;const bf={toc:[]};function Lf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The optional log remarks."))}Lf.isMDXComponent=!0;const Zf={toc:[]};function Nf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Zf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}Nf.isMDXComponent=!0;const Af={toc:[]};function Rf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Af,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Mark the current scene as ready to transition out."))}Rf.isMDXComponent=!0;const Ef={toc:[]};function Sf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ef,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}Sf.isMDXComponent=!0;const zf={toc:[]};function If(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,r.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}If.isMDXComponent=!0;const Wf={toc:[]};function Pf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Wf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}Pf.isMDXComponent=!0;const Gf={toc:[]};function Bf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Gf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an array containing a range of numbers."))}Bf.isMDXComponent=!0;const Ff={toc:[]};function Uf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ff,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The length of the array."))}Uf.isMDXComponent=!0;const qf={toc:[]};function Vf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}Vf.isMDXComponent=!0;const jf={toc:[]};function Of(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an array containing a range of numbers."))}Of.isMDXComponent=!0;const Hf={toc:[]};function $f(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Hf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The start of the range."))}$f.isMDXComponent=!0;const Kf={toc:[]};function Yf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Kf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The end of the range. ",(0,r.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}Yf.isMDXComponent=!0;const Jf={toc:[]};function Qf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Jf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}Qf.isMDXComponent=!0;const tM={toc:[]};function nM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an array containing a range of numbers."))}nM.isMDXComponent=!0;const eM={toc:[]};function oM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The start of the range."))}oM.isMDXComponent=!0;const pM={toc:[]};function sM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The end of the range. ",(0,r.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}sM.isMDXComponent=!0;const rM={toc:[]};function cM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value by which to increment or decrement."))}cM.isMDXComponent=!0;const aM={toc:[]};function iM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}iM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The function that will be provided the context before render."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}dM.isMDXComponent=!0;const hM={toc:[]};function kM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The function that will be provided the context after render."))}kM.isMDXComponent=!0;const yM={toc:[]};function fM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}fM.isMDXComponent=!0;const MM={toc:[]};function wM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}wM.isMDXComponent=!0;const DM={toc:[]};function _M(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the event in seconds."))}_M.isMDXComponent=!0;const XM={toc:[]};function gM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Register a time event and get its duration in seconds."))}gM.isMDXComponent=!0;const xM={toc:[]};function CM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The name of the event."))}CM.isMDXComponent=!0;const TM={toc:[]};function vM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a reference to the playback status."))}vM.isMDXComponent=!0;const bM={toc:[]};function LM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the random number generator for the current scene."))}LM.isMDXComponent=!0;const ZM={toc:[]};function NM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the random number generator for the given seed."))}NM.isMDXComponent=!0;const AM={toc:[]};function RM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The seed for the generator."))}RM.isMDXComponent=!0;const EM={toc:[]};function SM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}SM.isMDXComponent=!0;const zM={toc:[]};function IM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a reference to the current scene."))}IM.isMDXComponent=!0;const WM={toc:[]};function PM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a reference to the current thread."))}PM.isMDXComponent=!0;const GM={toc:[]};function BM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,r.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,r.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}BM.isMDXComponent=!0;const FM={toc:[]};function UM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}UM.isMDXComponent=!0;const qM={toc:[]};function VM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the real time since the start of the animation."))}VM.isMDXComponent=!0;const jM={toc:[]};function OM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This rewrites a remote url like ",(0,r.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,r.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}OM.isMDXComponent=!0;const HM={toc:[]};function $M(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Route the given url through a local proxy."))}$M.isMDXComponent=!0;const KM={toc:[]};function YM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}YM.isMDXComponent=!0;const JM={toc:[]};function QM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A simple circle:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n/>\n")),(0,r.kt)("p",null,"An ellipse:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  width={300}\n  height={100}\n  fill={'lightseagreen'}\n/>\n")),(0,r.kt)("p",null,"A sector (pie chart):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  startAngle={30}\n  endAngle={270}\n  closed={true}\n/>\n")),(0,r.kt)("p",null,"An arc:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  startAngle={-90}\n  endAngle={90}\n/>\n")))}QM.isMDXComponent=!0;const tw={toc:[]};function nw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node for drawing circular shapes."))}nw.isMDXComponent=!0;const ew={toc:[]};function ow(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ew,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}ow.isMDXComponent=!0;const pw={toc:[]};function sw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}sw.isMDXComponent=!0;const rw={toc:[]};function cw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}cw.isMDXComponent=!0;const aw={toc:[]};function iw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}iw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}dw.isMDXComponent=!0;const hw={toc:[]};function kw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}kw.isMDXComponent=!0;const yw={toc:[]};function fw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A closed circle will look like a pie chart:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,r.kt)("p",null,"An open one will look like an arc:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}fw.isMDXComponent=!0;const Mw={toc:[]};function ww(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Mw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"false"))}ww.isMDXComponent=!0;const Dw={toc:[]};function _w(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Dw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the path of this circle should be closed."))}_w.isMDXComponent=!0;const Xw={toc:[]};function gw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Xw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This property can be used together with ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,r.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}gw.isMDXComponent=!0;const xw={toc:[]};function Cw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"360"))}Cw.isMDXComponent=!0;const Tw={toc:[]};function vw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Tw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The ending angle in degrees for the circle sector."))}vw.isMDXComponent=!0;const bw={toc:[]};function Lw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Lw.isMDXComponent=!0;const Zw={toc:[]};function Nw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Zw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}Nw.isMDXComponent=!0;const Aw={toc:[]};function Rw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Aw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Rw.isMDXComponent=!0;const Ew={toc:[]};function Sw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ew,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}Sw.isMDXComponent=!0;const zw={toc:[]};function Iw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Iw.isMDXComponent=!0;const Ww={toc:[]};function Pw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ww,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Pw.isMDXComponent=!0;const Gw={toc:[]};function Bw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Gw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Bw.isMDXComponent=!0;const Fw={toc:[]};function Uw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Fw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Uw.isMDXComponent=!0;const qw={toc:[]};function Vw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Vw.isMDXComponent=!0;const jw={toc:[]};function Ow(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}Ow.isMDXComponent=!0;const Hw={toc:[]};function $w(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Hw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This property can be used together with ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,r.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}$w.isMDXComponent=!0;const Kw={toc:[]};function Yw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Kw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"0"))}Yw.isMDXComponent=!0;const Jw={toc:[]};function Qw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Jw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The starting angle in degrees for the circle sector."))}Qw.isMDXComponent=!0;const tD={toc:[]};function nD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}nD.isMDXComponent=!0;const eD={toc:[]};function oD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}oD.isMDXComponent=!0;const pD={toc:[]};function sD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}sD.isMDXComponent=!0;const rD={toc:[]};function cD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}cD.isMDXComponent=!0;const aD={toc:[]};function iD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}iD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The state to apply to the node."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}dD.isMDXComponent=!0;const hD={toc:[]};function kD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}kD.isMDXComponent=!0;const yD={toc:[]};function fD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}fD.isMDXComponent=!0;const MD={toc:[]};function wD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}wD.isMDXComponent=!0;const DD={toc:[]};function _D(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}_D.isMDXComponent=!0;const XD={toc:[]};function gD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}gD.isMDXComponent=!0;const xD={toc:[]};function CD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}CD.isMDXComponent=!0;const TD={toc:[]};function vD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}vD.isMDXComponent=!0;const bD={toc:[]};function LD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the desired size of this node."))}LD.isMDXComponent=!0;const ZD={toc:[]};function ND(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}ND.isMDXComponent=!0;const AD={toc:[]};function RD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}RD.isMDXComponent=!0;const ED={toc:[]};function SD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ED,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}SD.isMDXComponent=!0;const zD={toc:[]};function ID(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}ID.isMDXComponent=!0;const WD={toc:[]};function PD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}PD.isMDXComponent=!0;const GD={toc:[]};function BD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}BD.isMDXComponent=!0;const FD={toc:[]};function UD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}UD.isMDXComponent=!0;const qD={toc:[]};function VD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}VD.isMDXComponent=!0;const jD={toc:[]};function OD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}OD.isMDXComponent=!0;const HD={toc:[]};function $D(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}$D.isMDXComponent=!0;const KD={toc:[]};function YD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}YD.isMDXComponent=!0;const JD={toc:[]};function QD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}QD.isMDXComponent=!0;const t_={toc:[]};function n_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},t_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}n_.isMDXComponent=!0;const e_={toc:[]};function o_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},e_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}o_.isMDXComponent=!0;const p_={toc:[]};function s_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},p_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return a snapshot of the node's current signal values."))}s_.isMDXComponent=!0;const r_={toc:[]};function c_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},r_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}c_.isMDXComponent=!0;const a_={toc:[]};function i_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},a_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}i_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},l_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},m_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}d_.isMDXComponent=!0;const h_={toc:[]};function k_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},h_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}k_.isMDXComponent=!0;const y_={toc:[]};function f_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},y_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}f_.isMDXComponent=!0;const M_={toc:[]};function w_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},M_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}w_.isMDXComponent=!0;const D_={toc:[]};function __(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},D_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}__.isMDXComponent=!0;const X_={toc:[]};function g_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},X_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}g_.isMDXComponent=!0;const x_={toc:[]};function C_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},x_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}C_.isMDXComponent=!0;const T_={toc:[]};function v_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},T_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}v_.isMDXComponent=!0;const b_={toc:[]};function L_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},b_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}L_.isMDXComponent=!0;const Z_={toc:[]};function N_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Z_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}N_.isMDXComponent=!0;const A_={toc:[]};function R_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},A_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}R_.isMDXComponent=!0;const E_={toc:[]};function S_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},E_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}S_.isMDXComponent=!0;const z_={toc:[]};function I_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},z_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}I_.isMDXComponent=!0;const W_={toc:[]};function P_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},W_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}P_.isMDXComponent=!0;const G_={toc:[]};function B_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},G_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}B_.isMDXComponent=!0;const F_={toc:[]};function U_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},F_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}U_.isMDXComponent=!0;const q_={toc:[]};function V_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},q_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node above the provided node in the parent's layout."))}V_.isMDXComponent=!0;const j_={toc:[]};function O_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},j_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}O_.isMDXComponent=!0;const H_={toc:[]};function $_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},H_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}$_.isMDXComponent=!0;const K_={toc:[]};function Y_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},K_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Y_.isMDXComponent=!0;const J_={toc:[]};function Q_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},J_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Q_.isMDXComponent=!0;const tX={toc:[]};function nX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}nX.isMDXComponent=!0;const eX={toc:[]};function oX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}oX.isMDXComponent=!0;const pX={toc:[]};function sX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}sX.isMDXComponent=!0;const rX={toc:[]};function cX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}cX.isMDXComponent=!0;const aX={toc:[]};function iX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}iX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}dX.isMDXComponent=!0;const hX={toc:[]};function kX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the provided position relative to its siblings."))}kX.isMDXComponent=!0;const yX={toc:[]};function fX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index to move the node to."))}fX.isMDXComponent=!0;const MX={toc:[]};function wX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}wX.isMDXComponent=!0;const DX={toc:[]};function _X(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}_X.isMDXComponent=!0;const XX={toc:[]};function gX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}gX.isMDXComponent=!0;const xX={toc:[]};function CX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}CX.isMDXComponent=!0;const TX={toc:[]};function vX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}vX.isMDXComponent=!0;const bX={toc:[]};function LX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}LX.isMDXComponent=!0;const ZX={toc:[]};function NX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}NX.isMDXComponent=!0;const AX={toc:[]};function RX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}RX.isMDXComponent=!0;const EX={toc:[]};function SX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}SX.isMDXComponent=!0;const zX={toc:[]};function IX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}IX.isMDXComponent=!0;const WX={toc:[]};function PX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}PX.isMDXComponent=!0;const GX={toc:[]};function BX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}BX.isMDXComponent=!0;const FX={toc:[]};function UX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}UX.isMDXComponent=!0;const qX={toc:[]};function VX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}VX.isMDXComponent=!0;const jX={toc:[]};function OX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}OX.isMDXComponent=!0;const HX={toc:[]};function $X(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}$X.isMDXComponent=!0;const KX={toc:[]};function YX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}YX.isMDXComponent=!0;const JX={toc:[]};function QX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}QX.isMDXComponent=!0;const tg={toc:[]};function ng(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}ng.isMDXComponent=!0;const eg={toc:[]};function og(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,r.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}og.isMDXComponent=!0;const pg={toc:[]};function sg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}sg.isMDXComponent=!0;const rg={toc:[]};function cg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Restore the node to its last saved state."))}cg.isMDXComponent=!0;const ag={toc:[]};function ig(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ag,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition"))}ig.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The timing function to use for the transition"))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,r.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}dg.isMDXComponent=!0;const hg={toc:[]};function kg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}kg.isMDXComponent=!0;const yg={toc:[]};function fg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}fg.isMDXComponent=!0;const Mg={toc:[]};function wg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Mg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}wg.isMDXComponent=!0;const Dg={toc:[]};function _g(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Dg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}_g.isMDXComponent=!0;const Xg={toc:[]};function gg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Xg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}gg.isMDXComponent=!0;const xg={toc:[]};function Cg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}Cg.isMDXComponent=!0;const Tg={toc:[]};function vg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Tg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}vg.isMDXComponent=!0;const bg={toc:[]};function Lg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Lg.isMDXComponent=!0;const Zg={toc:[]};function Ng(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Zg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Ng.isMDXComponent=!0;const Ag={toc:[]};function Rg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ag,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}Rg.isMDXComponent=!0;const Eg={toc:[]};function Sg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Eg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the same the bounding box returned by ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,r.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Sg.isMDXComponent=!0;const zg={toc:[]};function Ig(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Ig.isMDXComponent=!0;const Wg={toc:[]};function Pg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Wg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Pg.isMDXComponent=!0;const Gg={toc:[]};function Bg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Gg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Bg.isMDXComponent=!0;const Fg={toc:[]};function Ug(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Fg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}Ug.isMDXComponent=!0;const qg={toc:[]};function Vg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Vg.isMDXComponent=!0;const jg={toc:[]};function Og(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}Og.isMDXComponent=!0;const Hg={toc:[]};function $g(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Hg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}$g.isMDXComponent=!0;const Kg={toc:[]};function Yg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Kg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}Yg.isMDXComponent=!0;const Jg={toc:[]};function Qg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Jg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Qg.isMDXComponent=!0;const tx={toc:[]};function nx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}nx.isMDXComponent=!0;const ex={toc:[]};function ox(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ex,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}ox.isMDXComponent=!0;const px={toc:[]};function sx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},px,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}sx.isMDXComponent=!0;const rx={toc:[]};function cx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}cx.isMDXComponent=!0;const ax={toc:[]};function ix(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ax,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}ix.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}dx.isMDXComponent=!0;const hx={toc:[]};function kx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}kx.isMDXComponent=!0;const yx={toc:[]};function fx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}fx.isMDXComponent=!0;const Mx={toc:[]};function wx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Mx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}wx.isMDXComponent=!0;const Dx={toc:[]};function _x(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Dx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}_x.isMDXComponent=!0;const Xx={toc:[]};function gx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Xx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}gx.isMDXComponent=!0;const xx={toc:[]};function Cx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}Cx.isMDXComponent=!0;const Tx={toc:[]};function vx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Tx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}vx.isMDXComponent=!0;const bx={toc:[]};function Lx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Lx.isMDXComponent=!0;const Zx={toc:[]};function Nx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Zx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}Nx.isMDXComponent=!0;const Ax={toc:[]};function Rx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ax,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}Rx.isMDXComponent=!0;const Ex={toc:[]};function Sx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ex,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Sx.isMDXComponent=!0;const zx={toc:[]};function Ix(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The state to apply to the node."))}Ix.isMDXComponent=!0;const Wx={toc:[]};function Px(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Wx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Px.isMDXComponent=!0;const Gx={toc:[]};function Bx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Gx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Bx.isMDXComponent=!0;const Fx={toc:[]};function Ux(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Fx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}Ux.isMDXComponent=!0;const qx={toc:[]};function Vx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}Vx.isMDXComponent=!0;const jx={toc:[]};function Ox(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}Ox.isMDXComponent=!0;const Hx={toc:[]};function $x(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Hx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}$x.isMDXComponent=!0;const Kx={toc:[]};function Yx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Kx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}Yx.isMDXComponent=!0;const Jx={toc:[]};function Qx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Jx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Qx.isMDXComponent=!0;const tC={toc:[]};function nC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the desired size of this node."))}nC.isMDXComponent=!0;const eC={toc:[]};function oC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}oC.isMDXComponent=!0;const pC={toc:[]};function sC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}sC.isMDXComponent=!0;const rC={toc:[]};function cC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}cC.isMDXComponent=!0;const aC={toc:[]};function iC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}iC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dC.isMDXComponent=!0;const hC={toc:[]};function kC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}kC.isMDXComponent=!0;const yC={toc:[]};function fC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}fC.isMDXComponent=!0;const MC={toc:[]};function wC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}wC.isMDXComponent=!0;const DC={toc:[]};function _C(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}_C.isMDXComponent=!0;const XC={toc:[]};function gC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}gC.isMDXComponent=!0;const xC={toc:[]};function CC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}CC.isMDXComponent=!0;const TC={toc:[]};function vC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}vC.isMDXComponent=!0;const bC={toc:[]};function LC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}LC.isMDXComponent=!0;const ZC={toc:[]};function NC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return a snapshot of the node's current signal values."))}NC.isMDXComponent=!0;const AC={toc:[]};function RC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}RC.isMDXComponent=!0;const EC={toc:[]};function SC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}SC.isMDXComponent=!0;const zC={toc:[]};function IC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}IC.isMDXComponent=!0;const WC={toc:[]};function PC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}PC.isMDXComponent=!0;const GC={toc:[]};function BC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}BC.isMDXComponent=!0;const FC={toc:[]};function UC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}UC.isMDXComponent=!0;const qC={toc:[]};function VC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}VC.isMDXComponent=!0;const jC={toc:[]};function OC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}OC.isMDXComponent=!0;const HC={toc:[]};function $C(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}$C.isMDXComponent=!0;const KC={toc:[]};function YC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}YC.isMDXComponent=!0;const JC={toc:[]};function QC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}QC.isMDXComponent=!0;const tT={toc:[]};function nT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}nT.isMDXComponent=!0;const eT={toc:[]};function oT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}oT.isMDXComponent=!0;const pT={toc:[]};function sT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}sT.isMDXComponent=!0;const rT={toc:[]};function cT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}cT.isMDXComponent=!0;const aT={toc:[]};function iT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}iT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}dT.isMDXComponent=!0;const hT={toc:[]};function kT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}kT.isMDXComponent=!0;const yT={toc:[]};function fT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node above the provided node in the parent's layout."))}fT.isMDXComponent=!0;const MT={toc:[]};function wT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}wT.isMDXComponent=!0;const DT={toc:[]};function _T(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}_T.isMDXComponent=!0;const XT={toc:[]};function gT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}gT.isMDXComponent=!0;const xT={toc:[]};function CT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node below the provided node in the parent's layout."))}CT.isMDXComponent=!0;const TT={toc:[]};function vT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}vT.isMDXComponent=!0;const bT={toc:[]};function LT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}LT.isMDXComponent=!0;const ZT={toc:[]};function NT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}NT.isMDXComponent=!0;const AT={toc:[]};function RT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}RT.isMDXComponent=!0;const ET={toc:[]};function ST(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ET,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ST.isMDXComponent=!0;const zT={toc:[]};function IT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}IT.isMDXComponent=!0;const WT={toc:[]};function PT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}PT.isMDXComponent=!0;const GT={toc:[]};function BT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the provided position relative to its siblings."))}BT.isMDXComponent=!0;const FT={toc:[]};function UT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index to move the node to."))}UT.isMDXComponent=!0;const qT={toc:[]};function VT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}VT.isMDXComponent=!0;const jT={toc:[]};function OT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}OT.isMDXComponent=!0;const HT={toc:[]};function $T(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}$T.isMDXComponent=!0;const KT={toc:[]};function YT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}YT.isMDXComponent=!0;const JT={toc:[]};function QT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}QT.isMDXComponent=!0;const tv={toc:[]};function nv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}nv.isMDXComponent=!0;const ev={toc:[]};function ov(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ev,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ov.isMDXComponent=!0;const pv={toc:[]};function sv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}sv.isMDXComponent=!0;const rv={toc:[]};function cv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}cv.isMDXComponent=!0;const av={toc:[]};function iv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},av,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}iv.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}dv.isMDXComponent=!0;const hv={toc:[]};function kv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}kv.isMDXComponent=!0;const yv={toc:[]};function fv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}fv.isMDXComponent=!0;const Mv={toc:[]};function wv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Mv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}wv.isMDXComponent=!0;const Dv={toc:[]};function _v(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Dv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}_v.isMDXComponent=!0;const Xv={toc:[]};function gv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Xv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}gv.isMDXComponent=!0;const xv={toc:[]};function Cv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Cv.isMDXComponent=!0;const Tv={toc:[]};function vv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Tv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}vv.isMDXComponent=!0;const bv={toc:[]};function Lv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,r.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Lv.isMDXComponent=!0;const Zv={toc:[]};function Nv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Zv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Nv.isMDXComponent=!0;const Av={toc:[]};function Rv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Av,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Restore the node to its last saved state."))}Rv.isMDXComponent=!0;const Ev={toc:[]};function Sv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ev,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition"))}Sv.isMDXComponent=!0;const zv={toc:[]};function Iv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The timing function to use for the transition"))}Iv.isMDXComponent=!0;const Wv={toc:[]};function Pv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Wv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,r.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Pv.isMDXComponent=!0;const Gv={toc:[]};function Bv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Gv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Bv.isMDXComponent=!0;const Fv={toc:[]};function Uv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Fv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Uv.isMDXComponent=!0;const qv={toc:[]};function Vv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Vv.isMDXComponent=!0;const jv={toc:[]};function Ov(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}Ov.isMDXComponent=!0;const Hv={toc:[]};function $v(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Hv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}$v.isMDXComponent=!0;const Kv={toc:[]};function Yv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Kv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}Yv.isMDXComponent=!0;const Jv={toc:[]};function Qv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Jv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}Qv.isMDXComponent=!0;const tb={toc:[]};function nb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}nb.isMDXComponent=!0;const eb={toc:[]};function ob(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}ob.isMDXComponent=!0;const pb={toc:[]};function sb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}sb.isMDXComponent=!0;const rb={toc:[]};function cb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the same the bounding box returned by ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,r.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}cb.isMDXComponent=!0;const ab={toc:[]};function ib(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ab,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}ib.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}db.isMDXComponent=!0;const hb={toc:[]};function kb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}kb.isMDXComponent=!0;const yb={toc:[]};function fb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}fb.isMDXComponent=!0;const Mb={toc:[]};function wb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Mb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}wb.isMDXComponent=!0;const Db={toc:[]};function _b(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Db,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An Icon Component that provides an easy access to over 150k icons.\nSee ",(0,r.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}_b.isMDXComponent=!0;const Xb={toc:[]};function gb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Xb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}gb.isMDXComponent=!0;const xb={toc:[]};function Cb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}Cb.isMDXComponent=!0;const Tb={toc:[]};function vb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Tb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}vb.isMDXComponent=!0;const bb={toc:[]};function Lb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Lb.isMDXComponent=!0;const Zb={toc:[]};function Nb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Zb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}Nb.isMDXComponent=!0;const Ab={toc:[]};function Rb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ab,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}Rb.isMDXComponent=!0;const Eb={toc:[]};function Sb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Eb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Provide the color in one of the following formats:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"named color like ",(0,r.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,r.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,r.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,r.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,r.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}Sb.isMDXComponent=!0;const zb={toc:[]};function Ib(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"'white'"))}Ib.isMDXComponent=!0;const Wb={toc:[]};function Pb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Wb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The color of the icon"))}Pb.isMDXComponent=!0;const Gb={toc:[]};function Bb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Gb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default the ",(0,r.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Bb.isMDXComponent=!0;const Fb={toc:[]};function Ub(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Fb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Ub.isMDXComponent=!0;const qb={toc:[]};function Vb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Controls the sharpness of the corners. ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,r.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."))}Vb.isMDXComponent=!0;const jb={toc:[]};function Ob(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"You can find identifiers on ",(0,r.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}Ob.isMDXComponent=!0;const Hb={toc:[]};function $b(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Hb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The identifier of the icon."))}$b.isMDXComponent=!0;const Kb={toc:[]};function Yb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Kb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Yb.isMDXComponent=!0;const Jb={toc:[]};function Qb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Jb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}Qb.isMDXComponent=!0;const tL={toc:[]};function nL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}nL.isMDXComponent=!0;const eL={toc:[]};function oL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}oL.isMDXComponent=!0;const pL={toc:[]};function sL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}sL.isMDXComponent=!0;const rL={toc:[]};function cL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}cL.isMDXComponent=!0;const aL={toc:[]};function iL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}iL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}dL.isMDXComponent=!0;const hL={toc:[]};function kL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}kL.isMDXComponent=!0;const yL={toc:[]};function fL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,r.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}fL.isMDXComponent=!0;const ML={toc:[]};function wL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ML,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}wL.isMDXComponent=!0;const DL={toc:[]};function _L(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Will set the corner drawing method to smooth corners."))}_L.isMDXComponent=!0;const XL={toc:[]};function gL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}gL.isMDXComponent=!0;const xL={toc:[]};function CL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}CL.isMDXComponent=!0;const TL={toc:[]};function vL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}vL.isMDXComponent=!0;const bL={toc:[]};function LL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}LL.isMDXComponent=!0;const ZL={toc:[]};function NL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}NL.isMDXComponent=!0;const AL={toc:[]};function RL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The state to apply to the node."))}RL.isMDXComponent=!0;const EL={toc:[]};function SL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}SL.isMDXComponent=!0;const zL={toc:[]};function IL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}IL.isMDXComponent=!0;const WL={toc:[]};function PL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}PL.isMDXComponent=!0;const GL={toc:[]};function BL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}BL.isMDXComponent=!0;const FL={toc:[]};function UL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}UL.isMDXComponent=!0;const qL={toc:[]};function VL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}VL.isMDXComponent=!0;const jL={toc:[]};function OL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}OL.isMDXComponent=!0;const HL={toc:[]};function $L(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}$L.isMDXComponent=!0;const KL={toc:[]};function YL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the desired size of this node."))}YL.isMDXComponent=!0;const JL={toc:[]};function QL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}QL.isMDXComponent=!0;const tZ={toc:[]};function nZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}nZ.isMDXComponent=!0;const eZ={toc:[]};function oZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}oZ.isMDXComponent=!0;const pZ={toc:[]};function sZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}sZ.isMDXComponent=!0;const rZ={toc:[]};function cZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}cZ.isMDXComponent=!0;const aZ={toc:[]};function iZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}iZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function kZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}kZ.isMDXComponent=!0;const yZ={toc:[]};function fZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}fZ.isMDXComponent=!0;const MZ={toc:[]};function wZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wZ.isMDXComponent=!0;const DZ={toc:[]};function _Z(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}_Z.isMDXComponent=!0;const XZ={toc:[]};function gZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}gZ.isMDXComponent=!0;const xZ={toc:[]};function CZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get color of the image at the given position."))}CZ.isMDXComponent=!0;const TZ={toc:[]};function vZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The position in local space at which to sample the color."))}vZ.isMDXComponent=!0;const bZ={toc:[]};function LZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get color of the image at the given pixel."))}LZ.isMDXComponent=!0;const ZZ={toc:[]};function NZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The pixel's position."))}NZ.isMDXComponent=!0;const AZ={toc:[]};function RZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"overrides ",(0,r.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}RZ.isMDXComponent=!0;const EZ={toc:[]};function SZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}SZ.isMDXComponent=!0;const zZ={toc:[]};function IZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return a snapshot of the node's current signal values."))}IZ.isMDXComponent=!0;const WZ={toc:[]};function PZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}PZ.isMDXComponent=!0;const GZ={toc:[]};function BZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}BZ.isMDXComponent=!0;const FZ={toc:[]};function UZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}UZ.isMDXComponent=!0;const qZ={toc:[]};function VZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}VZ.isMDXComponent=!0;const jZ={toc:[]};function OZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}OZ.isMDXComponent=!0;const HZ={toc:[]};function $Z(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}$Z.isMDXComponent=!0;const KZ={toc:[]};function YZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}YZ.isMDXComponent=!0;const JZ={toc:[]};function QZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}QZ.isMDXComponent=!0;const tN={toc:[]};function nN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}nN.isMDXComponent=!0;const eN={toc:[]};function oN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}oN.isMDXComponent=!0;const pN={toc:[]};function sN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}sN.isMDXComponent=!0;const rN={toc:[]};function cN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}cN.isMDXComponent=!0;const aN={toc:[]};function iN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}iN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}dN.isMDXComponent=!0;const hN={toc:[]};function kN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}kN.isMDXComponent=!0;const yN={toc:[]};function fN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}fN.isMDXComponent=!0;const MN={toc:[]};function wN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}wN.isMDXComponent=!0;const DN={toc:[]};function _N(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}_N.isMDXComponent=!0;const XN={toc:[]};function gN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node above the provided node in the parent's layout."))}gN.isMDXComponent=!0;const xN={toc:[]};function CN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}CN.isMDXComponent=!0;const TN={toc:[]};function vN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}vN.isMDXComponent=!0;const bN={toc:[]};function LN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}LN.isMDXComponent=!0;const ZN={toc:[]};function NN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node below the provided node in the parent's layout."))}NN.isMDXComponent=!0;const AN={toc:[]};function RN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}RN.isMDXComponent=!0;const EN={toc:[]};function SN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}SN.isMDXComponent=!0;const zN={toc:[]};function IN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}IN.isMDXComponent=!0;const WN={toc:[]};function PN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}PN.isMDXComponent=!0;const GN={toc:[]};function BN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}BN.isMDXComponent=!0;const FN={toc:[]};function UN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}UN.isMDXComponent=!0;const qN={toc:[]};function VN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}VN.isMDXComponent=!0;const jN={toc:[]};function ON(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the provided position relative to its siblings."))}ON.isMDXComponent=!0;const HN={toc:[]};function $N(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index to move the node to."))}$N.isMDXComponent=!0;const KN={toc:[]};function YN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}YN.isMDXComponent=!0;const JN={toc:[]};function QN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}QN.isMDXComponent=!0;const tA={toc:[]};function nA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}nA.isMDXComponent=!0;const eA={toc:[]};function oA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}oA.isMDXComponent=!0;const pA={toc:[]};function sA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}sA.isMDXComponent=!0;const rA={toc:[]};function cA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}cA.isMDXComponent=!0;const aA={toc:[]};function iA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}iA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}dA.isMDXComponent=!0;const hA={toc:[]};function kA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}kA.isMDXComponent=!0;const yA={toc:[]};function fA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}fA.isMDXComponent=!0;const MA={toc:[]};function wA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}wA.isMDXComponent=!0;const DA={toc:[]};function _A(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}_A.isMDXComponent=!0;const XA={toc:[]};function gA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}gA.isMDXComponent=!0;const xA={toc:[]};function CA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}CA.isMDXComponent=!0;const TA={toc:[]};function vA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}vA.isMDXComponent=!0;const bA={toc:[]};function LA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}LA.isMDXComponent=!0;const ZA={toc:[]};function NA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}NA.isMDXComponent=!0;const AA={toc:[]};function RA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}RA.isMDXComponent=!0;const EA={toc:[]};function SA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,r.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}SA.isMDXComponent=!0;const zA={toc:[]};function IA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}IA.isMDXComponent=!0;const WA={toc:[]};function PA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Restore the node to its last saved state."))}PA.isMDXComponent=!0;const GA={toc:[]};function BA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition"))}BA.isMDXComponent=!0;const FA={toc:[]};function UA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The timing function to use for the transition"))}UA.isMDXComponent=!0;const qA={toc:[]};function VA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,r.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}VA.isMDXComponent=!0;const jA={toc:[]};function OA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}OA.isMDXComponent=!0;const HA={toc:[]};function $A(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"overrides ",(0,r.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}$A.isMDXComponent=!0;const KA={toc:[]};function YA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}YA.isMDXComponent=!0;const JA={toc:[]};function QA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}QA.isMDXComponent=!0;const tR={toc:[]};function nR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}nR.isMDXComponent=!0;const eR={toc:[]};function oR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}oR.isMDXComponent=!0;const pR={toc:[]};function sR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}sR.isMDXComponent=!0;const rR={toc:[]};function cR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}cR.isMDXComponent=!0;const aR={toc:[]};function iR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Address to Iconify API for the requested Icon."))}iR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create the URL that will be used as the Image source"))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}dR.isMDXComponent=!0;const hR={toc:[]};function kR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}kR.isMDXComponent=!0;const yR={toc:[]};function fR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}fR.isMDXComponent=!0;const MR={toc:[]};function wR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the same the bounding box returned by ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,r.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}wR.isMDXComponent=!0;const DR={toc:[]};function _R(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}_R.isMDXComponent=!0;const XR={toc:[]};function gR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}gR.isMDXComponent=!0;const xR={toc:[]};function CR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}CR.isMDXComponent=!0;const TR={toc:[]};function vR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}vR.isMDXComponent=!0;const bR={toc:[]};function LR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}LR.isMDXComponent=!0;const ZR={toc:[]};function NR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}NR.isMDXComponent=!0;const AR={toc:[]};function RR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}RR.isMDXComponent=!0;const ER={toc:[]};function SR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ER,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}SR.isMDXComponent=!0;const zR={toc:[]};function IR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}IR.isMDXComponent=!0;const WR={toc:[]};function PR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}PR.isMDXComponent=!0;const GR={toc:[]};function BR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}BR.isMDXComponent=!0;const FR={toc:[]};function UR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}UR.isMDXComponent=!0;const qR={toc:[]};function VR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default the ",(0,r.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}VR.isMDXComponent=!0;const jR={toc:[]};function OR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}OR.isMDXComponent=!0;const HR={toc:[]};function $R(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Controls the sharpness of the corners. ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,r.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."))}$R.isMDXComponent=!0;const KR={toc:[]};function YR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}YR.isMDXComponent=!0;const JR={toc:[]};function QR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}QR.isMDXComponent=!0;const tE={toc:[]};function nE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}nE.isMDXComponent=!0;const eE={toc:[]};function oE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}oE.isMDXComponent=!0;const pE={toc:[]};function sE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}sE.isMDXComponent=!0;const rE={toc:[]};function cE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}cE.isMDXComponent=!0;const aE={toc:[]};function iE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}iE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}dE.isMDXComponent=!0;const hE={toc:[]};function kE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}kE.isMDXComponent=!0;const yE={toc:[]};function fE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,r.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}fE.isMDXComponent=!0;const ME={toc:[]};function wE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ME,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}wE.isMDXComponent=!0;const DE={toc:[]};function _E(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Will set the corner drawing method to smooth corners."))}_E.isMDXComponent=!0;const XE={toc:[]};function gE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}gE.isMDXComponent=!0;const xE={toc:[]};function CE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}CE.isMDXComponent=!0;const TE={toc:[]};function vE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}vE.isMDXComponent=!0;const bE={toc:[]};function LE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}LE.isMDXComponent=!0;const ZE={toc:[]};function NE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}NE.isMDXComponent=!0;const AE={toc:[]};function RE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The state to apply to the node."))}RE.isMDXComponent=!0;const EE={toc:[]};function SE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}SE.isMDXComponent=!0;const zE={toc:[]};function IE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}IE.isMDXComponent=!0;const WE={toc:[]};function PE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}PE.isMDXComponent=!0;const GE={toc:[]};function BE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}BE.isMDXComponent=!0;const FE={toc:[]};function UE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}UE.isMDXComponent=!0;const qE={toc:[]};function VE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}VE.isMDXComponent=!0;const jE={toc:[]};function OE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}OE.isMDXComponent=!0;const HE={toc:[]};function $E(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}$E.isMDXComponent=!0;const KE={toc:[]};function YE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the desired size of this node."))}YE.isMDXComponent=!0;const JE={toc:[]};function QE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}QE.isMDXComponent=!0;const tS={toc:[]};function nS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}nS.isMDXComponent=!0;const eS={toc:[]};function oS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}oS.isMDXComponent=!0;const pS={toc:[]};function sS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}sS.isMDXComponent=!0;const rS={toc:[]};function cS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}cS.isMDXComponent=!0;const aS={toc:[]};function iS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}iS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}dS.isMDXComponent=!0;const hS={toc:[]};function kS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}kS.isMDXComponent=!0;const yS={toc:[]};function fS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}fS.isMDXComponent=!0;const MS={toc:[]};function wS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wS.isMDXComponent=!0;const DS={toc:[]};function _S(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}_S.isMDXComponent=!0;const XS={toc:[]};function gS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}gS.isMDXComponent=!0;const xS={toc:[]};function CS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get color of the image at the given position."))}CS.isMDXComponent=!0;const TS={toc:[]};function vS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The position in local space at which to sample the color."))}vS.isMDXComponent=!0;const bS={toc:[]};function LS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get color of the image at the given pixel."))}LS.isMDXComponent=!0;const ZS={toc:[]};function NS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The pixel's position."))}NS.isMDXComponent=!0;const AS={toc:[]};function RS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}RS.isMDXComponent=!0;const ES={toc:[]};function SS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ES,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return a snapshot of the node's current signal values."))}SS.isMDXComponent=!0;const zS={toc:[]};function IS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}IS.isMDXComponent=!0;const WS={toc:[]};function PS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}PS.isMDXComponent=!0;const GS={toc:[]};function BS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}BS.isMDXComponent=!0;const FS={toc:[]};function US(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}US.isMDXComponent=!0;const qS={toc:[]};function VS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}VS.isMDXComponent=!0;const jS={toc:[]};function OS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}OS.isMDXComponent=!0;const HS={toc:[]};function $S(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}$S.isMDXComponent=!0;const KS={toc:[]};function YS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}YS.isMDXComponent=!0;const JS={toc:[]};function QS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}QS.isMDXComponent=!0;const tz={toc:[]};function nz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}nz.isMDXComponent=!0;const ez={toc:[]};function oz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ez,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}oz.isMDXComponent=!0;const pz={toc:[]};function sz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}sz.isMDXComponent=!0;const rz={toc:[]};function cz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}cz.isMDXComponent=!0;const az={toc:[]};function iz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},az,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}iz.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dz.isMDXComponent=!0;const hz={toc:[]};function kz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}kz.isMDXComponent=!0;const yz={toc:[]};function fz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}fz.isMDXComponent=!0;const Mz={toc:[]};function wz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Mz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}wz.isMDXComponent=!0;const Dz={toc:[]};function _z(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Dz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node above the provided node in the parent's layout."))}_z.isMDXComponent=!0;const Xz={toc:[]};function gz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Xz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}gz.isMDXComponent=!0;const xz={toc:[]};function Cz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Cz.isMDXComponent=!0;const Tz={toc:[]};function vz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Tz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}vz.isMDXComponent=!0;const bz={toc:[]};function Lz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Lz.isMDXComponent=!0;const Zz={toc:[]};function Nz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Zz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}Nz.isMDXComponent=!0;const Az={toc:[]};function Rz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Az,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Rz.isMDXComponent=!0;const Ez={toc:[]};function Sz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ez,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Sz.isMDXComponent=!0;const zz={toc:[]};function Iz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}Iz.isMDXComponent=!0;const Wz={toc:[]};function Pz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Wz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Pz.isMDXComponent=!0;const Gz={toc:[]};function Bz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Gz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}Bz.isMDXComponent=!0;const Fz={toc:[]};function Uz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Fz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Uz.isMDXComponent=!0;const qz={toc:[]};function Vz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Vz.isMDXComponent=!0;const jz={toc:[]};function Oz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index to move the node to."))}Oz.isMDXComponent=!0;const Hz={toc:[]};function $z(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Hz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}$z.isMDXComponent=!0;const Kz={toc:[]};function Yz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Kz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Yz.isMDXComponent=!0;const Jz={toc:[]};function Qz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Jz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Qz.isMDXComponent=!0;const tI={toc:[]};function nI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}nI.isMDXComponent=!0;const eI={toc:[]};function oI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}oI.isMDXComponent=!0;const pI={toc:[]};function sI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}sI.isMDXComponent=!0;const rI={toc:[]};function cI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}cI.isMDXComponent=!0;const aI={toc:[]};function iI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}iI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}dI.isMDXComponent=!0;const hI={toc:[]};function kI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}kI.isMDXComponent=!0;const yI={toc:[]};function fI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}fI.isMDXComponent=!0;const MI={toc:[]};function wI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}wI.isMDXComponent=!0;const DI={toc:[]};function _I(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_I.isMDXComponent=!0;const XI={toc:[]};function gI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}gI.isMDXComponent=!0;const xI={toc:[]};function CI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}CI.isMDXComponent=!0;const TI={toc:[]};function vI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}vI.isMDXComponent=!0;const bI={toc:[]};function LI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}LI.isMDXComponent=!0;const ZI={toc:[]};function NI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}NI.isMDXComponent=!0;const AI={toc:[]};function RI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,r.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}RI.isMDXComponent=!0;const EI={toc:[]};function SI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}SI.isMDXComponent=!0;const zI={toc:[]};function II(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Restore the node to its last saved state."))}II.isMDXComponent=!0;const WI={toc:[]};function PI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition"))}PI.isMDXComponent=!0;const GI={toc:[]};function BI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The timing function to use for the transition"))}BI.isMDXComponent=!0;const FI={toc:[]};function UI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,r.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}UI.isMDXComponent=!0;const qI={toc:[]};function VI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}VI.isMDXComponent=!0;const jI={toc:[]};function OI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}OI.isMDXComponent=!0;const HI={toc:[]};function $I(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}$I.isMDXComponent=!0;const KI={toc:[]};function YI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}YI.isMDXComponent=!0;const JI={toc:[]};function QI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}QI.isMDXComponent=!0;const tW={toc:[]};function nW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}nW.isMDXComponent=!0;const eW={toc:[]};function oW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}oW.isMDXComponent=!0;const pW={toc:[]};function sW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}sW.isMDXComponent=!0;const rW={toc:[]};function cW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}cW.isMDXComponent=!0;const aW={toc:[]};function iW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}iW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the same the bounding box returned by ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,r.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}dW.isMDXComponent=!0;const hW={toc:[]};function kW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}kW.isMDXComponent=!0;const yW={toc:[]};function fW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}fW.isMDXComponent=!0;const MW={toc:[]};function wW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}wW.isMDXComponent=!0;const DW={toc:[]};function _W(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}_W.isMDXComponent=!0;const XW={toc:[]};function gW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}gW.isMDXComponent=!0;const xW={toc:[]};function CW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node representing a knot of a ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,r.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}CW.isMDXComponent=!0;const TW={toc:[]};function vW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}vW.isMDXComponent=!0;const bW={toc:[]};function LW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}LW.isMDXComponent=!0;const ZW={toc:[]};function NW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}NW.isMDXComponent=!0;const AW={toc:[]};function RW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}RW.isMDXComponent=!0;const EW={toc:[]};function SW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}SW.isMDXComponent=!0;const zW={toc:[]};function IW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}IW.isMDXComponent=!0;const WW={toc:[]};function PW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}PW.isMDXComponent=!0;const GW={toc:[]};function BW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"0"))}BW.isMDXComponent=!0;const FW={toc:[]};function UW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}UW.isMDXComponent=!0;const qW={toc:[]};function VW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,r.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,r.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,r.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,r.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,r.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}VW.isMDXComponent=!0;const jW={toc:[]};function OW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Mirrored position of the startHandle."))}OW.isMDXComponent=!0;const HW={toc:[]};function $W(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}$W.isMDXComponent=!0;const KW={toc:[]};function YW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}YW.isMDXComponent=!0;const JW={toc:[]};function QW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}QW.isMDXComponent=!0;const tP={toc:[]};function nP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}nP.isMDXComponent=!0;const eP={toc:[]};function oP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}oP.isMDXComponent=!0;const pP={toc:[]};function sP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}sP.isMDXComponent=!0;const rP={toc:[]};function cP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,r.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,r.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,r.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,r.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,r.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}cP.isMDXComponent=!0;const aP={toc:[]};function iP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Mirrored position of the endHandle."))}iP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}dP.isMDXComponent=!0;const hP={toc:[]};function kP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}kP.isMDXComponent=!0;const yP={toc:[]};function fP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}fP.isMDXComponent=!0;const MP={toc:[]};function wP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}wP.isMDXComponent=!0;const DP={toc:[]};function _P(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}_P.isMDXComponent=!0;const XP={toc:[]};function gP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The state to apply to the node."))}gP.isMDXComponent=!0;const xP={toc:[]};function CP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}CP.isMDXComponent=!0;const TP={toc:[]};function vP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}vP.isMDXComponent=!0;const bP={toc:[]};function LP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}LP.isMDXComponent=!0;const ZP={toc:[]};function NP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}NP.isMDXComponent=!0;const AP={toc:[]};function RP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}RP.isMDXComponent=!0;const EP={toc:[]};function SP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}SP.isMDXComponent=!0;const zP={toc:[]};function IP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}IP.isMDXComponent=!0;const WP={toc:[]};function PP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}PP.isMDXComponent=!0;const GP={toc:[]};function BP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}BP.isMDXComponent=!0;const FP={toc:[]};function UP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}UP.isMDXComponent=!0;const qP={toc:[]};function VP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}VP.isMDXComponent=!0;const jP={toc:[]};function OP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}OP.isMDXComponent=!0;const HP={toc:[]};function $P(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}$P.isMDXComponent=!0;const KP={toc:[]};function YP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}YP.isMDXComponent=!0;const JP={toc:[]};function QP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}QP.isMDXComponent=!0;const tG={toc:[]};function nG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}nG.isMDXComponent=!0;const eG={toc:[]};function oG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}oG.isMDXComponent=!0;const pG={toc:[]};function sG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}sG.isMDXComponent=!0;const rG={toc:[]};function cG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}cG.isMDXComponent=!0;const aG={toc:[]};function iG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}iG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return a snapshot of the node's current signal values."))}dG.isMDXComponent=!0;const hG={toc:[]};function kG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}kG.isMDXComponent=!0;const yG={toc:[]};function fG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}fG.isMDXComponent=!0;const MG={toc:[]};function wG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}wG.isMDXComponent=!0;const DG={toc:[]};function _G(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}_G.isMDXComponent=!0;const XG={toc:[]};function gG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}gG.isMDXComponent=!0;const xG={toc:[]};function CG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}CG.isMDXComponent=!0;const TG={toc:[]};function vG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}vG.isMDXComponent=!0;const bG={toc:[]};function LG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}LG.isMDXComponent=!0;const ZG={toc:[]};function NG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}NG.isMDXComponent=!0;const AG={toc:[]};function RG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}RG.isMDXComponent=!0;const EG={toc:[]};function SG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}SG.isMDXComponent=!0;const zG={toc:[]};function IG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}IG.isMDXComponent=!0;const WG={toc:[]};function PG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}PG.isMDXComponent=!0;const GG={toc:[]};function BG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}BG.isMDXComponent=!0;const FG={toc:[]};function UG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}UG.isMDXComponent=!0;const qG={toc:[]};function VG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}VG.isMDXComponent=!0;const jG={toc:[]};function OG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}OG.isMDXComponent=!0;const HG={toc:[]};function $G(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node above the provided node in the parent's layout."))}$G.isMDXComponent=!0;const KG={toc:[]};function YG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}YG.isMDXComponent=!0;const JG={toc:[]};function QG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}QG.isMDXComponent=!0;const tB={toc:[]};function nB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}nB.isMDXComponent=!0;const eB={toc:[]};function oB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node below the provided node in the parent's layout."))}oB.isMDXComponent=!0;const pB={toc:[]};function sB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}sB.isMDXComponent=!0;const rB={toc:[]};function cB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}cB.isMDXComponent=!0;const aB={toc:[]};function iB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}iB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}dB.isMDXComponent=!0;const hB={toc:[]};function kB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the provided position relative to its siblings."))}kB.isMDXComponent=!0;const yB={toc:[]};function fB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index to move the node to."))}fB.isMDXComponent=!0;const MB={toc:[]};function wB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}wB.isMDXComponent=!0;const DB={toc:[]};function _B(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}_B.isMDXComponent=!0;const XB={toc:[]};function gB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}gB.isMDXComponent=!0;const xB={toc:[]};function CB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}CB.isMDXComponent=!0;const TB={toc:[]};function vB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}vB.isMDXComponent=!0;const bB={toc:[]};function LB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}LB.isMDXComponent=!0;const ZB={toc:[]};function NB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}NB.isMDXComponent=!0;const AB={toc:[]};function RB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}RB.isMDXComponent=!0;const EB={toc:[]};function SB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}SB.isMDXComponent=!0;const zB={toc:[]};function IB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}IB.isMDXComponent=!0;const WB={toc:[]};function PB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}PB.isMDXComponent=!0;const GB={toc:[]};function BB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}BB.isMDXComponent=!0;const FB={toc:[]};function UB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}UB.isMDXComponent=!0;const qB={toc:[]};function VB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}VB.isMDXComponent=!0;const jB={toc:[]};function OB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}OB.isMDXComponent=!0;const HB={toc:[]};function $B(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}$B.isMDXComponent=!0;const KB={toc:[]};function YB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}YB.isMDXComponent=!0;const JB={toc:[]};function QB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,r.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}QB.isMDXComponent=!0;const tF={toc:[]};function nF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}nF.isMDXComponent=!0;const eF={toc:[]};function oF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Restore the node to its last saved state."))}oF.isMDXComponent=!0;const pF={toc:[]};function sF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition"))}sF.isMDXComponent=!0;const rF={toc:[]};function cF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The timing function to use for the transition"))}cF.isMDXComponent=!0;const aF={toc:[]};function iF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,r.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}iF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}dF.isMDXComponent=!0;const hF={toc:[]};function kF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}kF.isMDXComponent=!0;const yF={toc:[]};function fF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}fF.isMDXComponent=!0;const MF={toc:[]};function wF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}wF.isMDXComponent=!0;const DF={toc:[]};function _F(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}_F.isMDXComponent=!0;const XF={toc:[]};function gF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}gF.isMDXComponent=!0;const xF={toc:[]};function CF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}CF.isMDXComponent=!0;const TF={toc:[]};function vF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}vF.isMDXComponent=!0;const bF={toc:[]};function LF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the same the bounding box returned by ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,r.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}LF.isMDXComponent=!0;const ZF={toc:[]};function NF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}NF.isMDXComponent=!0;const AF={toc:[]};function RF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}RF.isMDXComponent=!0;const EF={toc:[]};function SF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}SF.isMDXComponent=!0;const zF={toc:[]};function IF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}IF.isMDXComponent=!0;const WF={toc:[]};function PF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}PF.isMDXComponent=!0;const GF={toc:[]};function BF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}BF.isMDXComponent=!0;const FF={toc:[]};function UF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}UF.isMDXComponent=!0;const qF={toc:[]};function VF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}VF.isMDXComponent=!0;const jF={toc:[]};function OF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}OF.isMDXComponent=!0;const HF={toc:[]};function $F(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}$F.isMDXComponent=!0;const KF={toc:[]};function YF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}YF.isMDXComponent=!0;const JF={toc:[]};function QF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}QF.isMDXComponent=!0;const tU={toc:[]};function nU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default the ",(0,r.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}nU.isMDXComponent=!0;const eU={toc:[]};function oU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}oU.isMDXComponent=!0;const pU={toc:[]};function sU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Controls the sharpness of the corners. ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,r.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."))}sU.isMDXComponent=!0;const rU={toc:[]};function cU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}cU.isMDXComponent=!0;const aU={toc:[]};function iU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}iU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}dU.isMDXComponent=!0;const hU={toc:[]};function kU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}kU.isMDXComponent=!0;const yU={toc:[]};function fU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}fU.isMDXComponent=!0;const MU={toc:[]};function wU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}wU.isMDXComponent=!0;const DU={toc:[]};function _U(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}_U.isMDXComponent=!0;const XU={toc:[]};function gU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}gU.isMDXComponent=!0;const xU={toc:[]};function CU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}CU.isMDXComponent=!0;const TU={toc:[]};function vU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,r.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}vU.isMDXComponent=!0;const bU={toc:[]};function LU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}LU.isMDXComponent=!0;const ZU={toc:[]};function NU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Will set the corner drawing method to smooth corners."))}NU.isMDXComponent=!0;const AU={toc:[]};function RU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}RU.isMDXComponent=!0;const EU={toc:[]};function SU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}SU.isMDXComponent=!0;const zU={toc:[]};function IU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}IU.isMDXComponent=!0;const WU={toc:[]};function PU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}PU.isMDXComponent=!0;const GU={toc:[]};function BU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}BU.isMDXComponent=!0;const FU={toc:[]};function UU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The state to apply to the node."))}UU.isMDXComponent=!0;const qU={toc:[]};function VU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}VU.isMDXComponent=!0;const jU={toc:[]};function OU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}OU.isMDXComponent=!0;const HU={toc:[]};function $U(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}$U.isMDXComponent=!0;const KU={toc:[]};function YU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}YU.isMDXComponent=!0;const JU={toc:[]};function QU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}QU.isMDXComponent=!0;const tq={toc:[]};function nq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}nq.isMDXComponent=!0;const eq={toc:[]};function oq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}oq.isMDXComponent=!0;const pq={toc:[]};function sq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}sq.isMDXComponent=!0;const rq={toc:[]};function cq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the desired size of this node."))}cq.isMDXComponent=!0;const aq={toc:[]};function iq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}iq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}dq.isMDXComponent=!0;const hq={toc:[]};function kq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}kq.isMDXComponent=!0;const yq={toc:[]};function fq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}fq.isMDXComponent=!0;const Mq={toc:[]};function wq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Mq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}wq.isMDXComponent=!0;const Dq={toc:[]};function _q(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Dq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}_q.isMDXComponent=!0;const Xq={toc:[]};function gq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Xq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}gq.isMDXComponent=!0;const xq={toc:[]};function Cq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}Cq.isMDXComponent=!0;const Tq={toc:[]};function vq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Tq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}vq.isMDXComponent=!0;const bq={toc:[]};function Lq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Lq.isMDXComponent=!0;const Zq={toc:[]};function Nq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Zq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}Nq.isMDXComponent=!0;const Aq={toc:[]};function Rq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Aq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Rq.isMDXComponent=!0;const Eq={toc:[]};function Sq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Eq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get color of the image at the given position."))}Sq.isMDXComponent=!0;const zq={toc:[]};function Iq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The position in local space at which to sample the color."))}Iq.isMDXComponent=!0;const Wq={toc:[]};function Pq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Wq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get color of the image at the given pixel."))}Pq.isMDXComponent=!0;const Gq={toc:[]};function Bq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Gq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The pixel's position."))}Bq.isMDXComponent=!0;const Fq={toc:[]};function Uq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Fq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Uq.isMDXComponent=!0;const qq={toc:[]};function Vq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return a snapshot of the node's current signal values."))}Vq.isMDXComponent=!0;const jq={toc:[]};function Oq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}Oq.isMDXComponent=!0;const Hq={toc:[]};function $q(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Hq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}$q.isMDXComponent=!0;const Kq={toc:[]};function Yq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Kq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Yq.isMDXComponent=!0;const Jq={toc:[]};function Qq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Jq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Qq.isMDXComponent=!0;const tV={toc:[]};function nV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}nV.isMDXComponent=!0;const eV={toc:[]};function oV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}oV.isMDXComponent=!0;const pV={toc:[]};function sV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}sV.isMDXComponent=!0;const rV={toc:[]};function cV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}cV.isMDXComponent=!0;const aV={toc:[]};function iV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}iV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}dV.isMDXComponent=!0;const hV={toc:[]};function kV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}kV.isMDXComponent=!0;const yV={toc:[]};function fV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}fV.isMDXComponent=!0;const MV={toc:[]};function wV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}wV.isMDXComponent=!0;const DV={toc:[]};function _V(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}_V.isMDXComponent=!0;const XV={toc:[]};function gV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}gV.isMDXComponent=!0;const xV={toc:[]};function CV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}CV.isMDXComponent=!0;const TV={toc:[]};function vV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}vV.isMDXComponent=!0;const bV={toc:[]};function LV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}LV.isMDXComponent=!0;const ZV={toc:[]};function NV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node above the provided node in the parent's layout."))}NV.isMDXComponent=!0;const AV={toc:[]};function RV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}RV.isMDXComponent=!0;const EV={toc:[]};function SV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}SV.isMDXComponent=!0;const zV={toc:[]};function IV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}IV.isMDXComponent=!0;const WV={toc:[]};function PV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node below the provided node in the parent's layout."))}PV.isMDXComponent=!0;const GV={toc:[]};function BV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}BV.isMDXComponent=!0;const FV={toc:[]};function UV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}UV.isMDXComponent=!0;const qV={toc:[]};function VV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}VV.isMDXComponent=!0;const jV={toc:[]};function OV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}OV.isMDXComponent=!0;const HV={toc:[]};function $V(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}$V.isMDXComponent=!0;const KV={toc:[]};function YV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}YV.isMDXComponent=!0;const JV={toc:[]};function QV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}QV.isMDXComponent=!0;const tj={toc:[]};function nj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the provided position relative to its siblings."))}nj.isMDXComponent=!0;const ej={toc:[]};function oj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ej,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index to move the node to."))}oj.isMDXComponent=!0;const pj={toc:[]};function sj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}sj.isMDXComponent=!0;const rj={toc:[]};function cj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}cj.isMDXComponent=!0;const aj={toc:[]};function ij(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}ij.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}dj.isMDXComponent=!0;const hj={toc:[]};function kj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}kj.isMDXComponent=!0;const yj={toc:[]};function fj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}fj.isMDXComponent=!0;const Mj={toc:[]};function wj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Mj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}wj.isMDXComponent=!0;const Dj={toc:[]};function _j(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Dj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}_j.isMDXComponent=!0;const Xj={toc:[]};function gj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Xj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}gj.isMDXComponent=!0;const xj={toc:[]};function Cj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}Cj.isMDXComponent=!0;const Tj={toc:[]};function vj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Tj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}vj.isMDXComponent=!0;const bj={toc:[]};function Lj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}Lj.isMDXComponent=!0;const Zj={toc:[]};function Nj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Zj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Nj.isMDXComponent=!0;const Aj={toc:[]};function Rj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Aj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Rj.isMDXComponent=!0;const Ej={toc:[]};function Sj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ej,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}Sj.isMDXComponent=!0;const zj={toc:[]};function Ij(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Ij.isMDXComponent=!0;const Wj={toc:[]};function Pj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Wj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Pj.isMDXComponent=!0;const Gj={toc:[]};function Bj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Gj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}Bj.isMDXComponent=!0;const Fj={toc:[]};function Uj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Fj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,r.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Uj.isMDXComponent=!0;const qj={toc:[]};function Vj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Vj.isMDXComponent=!0;const jj={toc:[]};function Oj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Restore the node to its last saved state."))}Oj.isMDXComponent=!0;const Hj={toc:[]};function $j(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Hj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition"))}$j.isMDXComponent=!0;const Kj={toc:[]};function Yj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Kj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The timing function to use for the transition"))}Yj.isMDXComponent=!0;const Jj={toc:[]};function Qj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Jj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,r.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Qj.isMDXComponent=!0;const tO={toc:[]};function nO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}nO.isMDXComponent=!0;const eO={toc:[]};function oO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}oO.isMDXComponent=!0;const pO={toc:[]};function sO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}sO.isMDXComponent=!0;const rO={toc:[]};function cO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}cO.isMDXComponent=!0;const aO={toc:[]};function iO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}iO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}dO.isMDXComponent=!0;const hO={toc:[]};function kO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}kO.isMDXComponent=!0;const yO={toc:[]};function fO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}fO.isMDXComponent=!0;const MO={toc:[]};function wO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}wO.isMDXComponent=!0;const DO={toc:[]};function _O(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the same the bounding box returned by ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,r.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}_O.isMDXComponent=!0;const XO={toc:[]};function gO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}gO.isMDXComponent=!0;const xO={toc:[]};function CO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}CO.isMDXComponent=!0;const TO={toc:[]};function vO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}vO.isMDXComponent=!0;const bO={toc:[]};function LO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}LO.isMDXComponent=!0;const ZO={toc:[]};function NO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}NO.isMDXComponent=!0;const AO={toc:[]};function RO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}RO.isMDXComponent=!0;const EO={toc:[]};function SO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}SO.isMDXComponent=!0;const zO={toc:[]};function IO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}IO.isMDXComponent=!0;const WO={toc:[]};function PO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}PO.isMDXComponent=!0;const GO={toc:[]};function BO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}BO.isMDXComponent=!0;const FO={toc:[]};function UO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}UO.isMDXComponent=!0;const qO={toc:[]};function VO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}VO.isMDXComponent=!0;const jO={toc:[]};function OO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}OO.isMDXComponent=!0;const HO={toc:[]};function $O(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}$O.isMDXComponent=!0;const KO={toc:[]};function YO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}YO.isMDXComponent=!0;const JO={toc:[]};function QO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}QO.isMDXComponent=!0;const tH={toc:[]};function nH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}nH.isMDXComponent=!0;const eH={toc:[]};function oH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}oH.isMDXComponent=!0;const pH={toc:[]};function sH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}sH.isMDXComponent=!0;const rH={toc:[]};function cH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}cH.isMDXComponent=!0;const aH={toc:[]};function iH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}iH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}dH.isMDXComponent=!0;const hH={toc:[]};function kH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}kH.isMDXComponent=!0;const yH={toc:[]};function fH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}fH.isMDXComponent=!0;const MH={toc:[]};function wH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}wH.isMDXComponent=!0;const DH={toc:[]};function _H(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}_H.isMDXComponent=!0;const XH={toc:[]};function gH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The state to apply to the node."))}gH.isMDXComponent=!0;const xH={toc:[]};function CH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}CH.isMDXComponent=!0;const TH={toc:[]};function vH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}vH.isMDXComponent=!0;const bH={toc:[]};function LH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}LH.isMDXComponent=!0;const ZH={toc:[]};function NH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}NH.isMDXComponent=!0;const AH={toc:[]};function RH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}RH.isMDXComponent=!0;const EH={toc:[]};function SH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}SH.isMDXComponent=!0;const zH={toc:[]};function IH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}IH.isMDXComponent=!0;const WH={toc:[]};function PH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}PH.isMDXComponent=!0;const GH={toc:[]};function BH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the desired size of this node."))}BH.isMDXComponent=!0;const FH={toc:[]};function UH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}UH.isMDXComponent=!0;const qH={toc:[]};function VH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}VH.isMDXComponent=!0;const jH={toc:[]};function OH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}OH.isMDXComponent=!0;const HH={toc:[]};function $H(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}$H.isMDXComponent=!0;const KH={toc:[]};function YH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}YH.isMDXComponent=!0;const JH={toc:[]};function QH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}QH.isMDXComponent=!0;const t$={toc:[]};function n$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},t$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}n$.isMDXComponent=!0;const e$={toc:[]};function o$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},e$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}o$.isMDXComponent=!0;const p$={toc:[]};function s$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},p$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}s$.isMDXComponent=!0;const r$={toc:[]};function c$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},r$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}c$.isMDXComponent=!0;const a$={toc:[]};function i$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},a$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}i$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},l$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},m$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}d$.isMDXComponent=!0;const h$={toc:[]};function k$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},h$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}k$.isMDXComponent=!0;const y$={toc:[]};function f$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},y$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return a snapshot of the node's current signal values."))}f$.isMDXComponent=!0;const M$={toc:[]};function w$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},M$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}w$.isMDXComponent=!0;const D$={toc:[]};function _$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},D$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}_$.isMDXComponent=!0;const X$={toc:[]};function g$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},X$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}g$.isMDXComponent=!0;const x$={toc:[]};function C$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},x$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}C$.isMDXComponent=!0;const T$={toc:[]};function v$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},T$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}v$.isMDXComponent=!0;const b$={toc:[]};function L$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},b$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}L$.isMDXComponent=!0;const Z$={toc:[]};function N$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Z$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}N$.isMDXComponent=!0;const A$={toc:[]};function R$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},A$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}R$.isMDXComponent=!0;const E$={toc:[]};function S$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},E$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}S$.isMDXComponent=!0;const z$={toc:[]};function I$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},z$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}I$.isMDXComponent=!0;const W$={toc:[]};function P$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},W$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}P$.isMDXComponent=!0;const G$={toc:[]};function B$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},G$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}B$.isMDXComponent=!0;const F$={toc:[]};function U$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},F$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}U$.isMDXComponent=!0;const q$={toc:[]};function V$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},q$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}V$.isMDXComponent=!0;const j$={toc:[]};function O$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},j$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}O$.isMDXComponent=!0;const H$={toc:[]};function $$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},H$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}$$.isMDXComponent=!0;const K$={toc:[]};function Y$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},K$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}Y$.isMDXComponent=!0;const J$={toc:[]};function Q$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},J$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}Q$.isMDXComponent=!0;const tK={toc:[]};function nK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}nK.isMDXComponent=!0;const eK={toc:[]};function oK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node above the provided node in the parent's layout."))}oK.isMDXComponent=!0;const pK={toc:[]};function sK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}sK.isMDXComponent=!0;const rK={toc:[]};function cK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}cK.isMDXComponent=!0;const aK={toc:[]};function iK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}iK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node below the provided node in the parent's layout."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}dK.isMDXComponent=!0;const hK={toc:[]};function kK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}kK.isMDXComponent=!0;const yK={toc:[]};function fK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}fK.isMDXComponent=!0;const MK={toc:[]};function wK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}wK.isMDXComponent=!0;const DK={toc:[]};function _K(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}_K.isMDXComponent=!0;const XK={toc:[]};function gK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}gK.isMDXComponent=!0;const xK={toc:[]};function CK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}CK.isMDXComponent=!0;const TK={toc:[]};function vK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the provided position relative to its siblings."))}vK.isMDXComponent=!0;const bK={toc:[]};function LK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index to move the node to."))}LK.isMDXComponent=!0;const ZK={toc:[]};function NK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}NK.isMDXComponent=!0;const AK={toc:[]};function RK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}RK.isMDXComponent=!0;const EK={toc:[]};function SK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}SK.isMDXComponent=!0;const zK={toc:[]};function IK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}IK.isMDXComponent=!0;const WK={toc:[]};function PK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}PK.isMDXComponent=!0;const GK={toc:[]};function BK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}BK.isMDXComponent=!0;const FK={toc:[]};function UK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}UK.isMDXComponent=!0;const qK={toc:[]};function VK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}VK.isMDXComponent=!0;const jK={toc:[]};function OK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}OK.isMDXComponent=!0;const HK={toc:[]};function $K(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}$K.isMDXComponent=!0;const KK={toc:[]};function YK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}YK.isMDXComponent=!0;const JK={toc:[]};function QK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}QK.isMDXComponent=!0;const tY={toc:[]};function nY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}nY.isMDXComponent=!0;const eY={toc:[]};function oY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}oY.isMDXComponent=!0;const pY={toc:[]};function sY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}sY.isMDXComponent=!0;const rY={toc:[]};function cY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}cY.isMDXComponent=!0;const aY={toc:[]};function iY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}iY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}dY.isMDXComponent=!0;const hY={toc:[]};function kY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,r.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}kY.isMDXComponent=!0;const yY={toc:[]};function fY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}fY.isMDXComponent=!0;const MY={toc:[]};function wY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Restore the node to its last saved state."))}wY.isMDXComponent=!0;const DY={toc:[]};function _Y(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition"))}_Y.isMDXComponent=!0;const XY={toc:[]};function gY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The timing function to use for the transition"))}gY.isMDXComponent=!0;const xY={toc:[]};function CY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,r.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}CY.isMDXComponent=!0;const TY={toc:[]};function vY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}vY.isMDXComponent=!0;const bY={toc:[]};function LY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}LY.isMDXComponent=!0;const ZY={toc:[]};function NY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}NY.isMDXComponent=!0;const AY={toc:[]};function RY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}RY.isMDXComponent=!0;const EY={toc:[]};function SY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}SY.isMDXComponent=!0;const zY={toc:[]};function IY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}IY.isMDXComponent=!0;const WY={toc:[]};function PY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}PY.isMDXComponent=!0;const GY={toc:[]};function BY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}BY.isMDXComponent=!0;const FY={toc:[]};function UY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}UY.isMDXComponent=!0;const qY={toc:[]};function VY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}VY.isMDXComponent=!0;const jY={toc:[]};function OY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the same the bounding box returned by ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,r.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}OY.isMDXComponent=!0;const HY={toc:[]};function $Y(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}$Y.isMDXComponent=!0;const KY={toc:[]};function YY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}YY.isMDXComponent=!0;const JY={toc:[]};function QY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}QY.isMDXComponent=!0;const tJ={toc:[]};function nJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}nJ.isMDXComponent=!0;const eJ={toc:[]};function oJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}oJ.isMDXComponent=!0;const pJ={toc:[]};function sJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}sJ.isMDXComponent=!0;const rJ={toc:[]};function cJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}cJ.isMDXComponent=!0;const aJ={toc:[]};function iJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}iJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function kJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}kJ.isMDXComponent=!0;const yJ={toc:[]};function fJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}fJ.isMDXComponent=!0;const MJ={toc:[]};function wJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}wJ.isMDXComponent=!0;const DJ={toc:[]};function _J(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}_J.isMDXComponent=!0;const XJ={toc:[]};function gJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}gJ.isMDXComponent=!0;const xJ={toc:[]};function CJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}CJ.isMDXComponent=!0;const TJ={toc:[]};function vJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}vJ.isMDXComponent=!0;const bJ={toc:[]};function LJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}LJ.isMDXComponent=!0;const ZJ={toc:[]};function NJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}NJ.isMDXComponent=!0;const AJ={toc:[]};function RJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}RJ.isMDXComponent=!0;const EJ={toc:[]};function SJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}SJ.isMDXComponent=!0;const zJ={toc:[]};function IJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}IJ.isMDXComponent=!0;const WJ={toc:[]};function PJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}PJ.isMDXComponent=!0;const GJ={toc:[]};function BJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}BJ.isMDXComponent=!0;const FJ={toc:[]};function UJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}UJ.isMDXComponent=!0;const qJ={toc:[]};function VJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}VJ.isMDXComponent=!0;const jJ={toc:[]};function OJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}OJ.isMDXComponent=!0;const HJ={toc:[]};function $J(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The state to apply to the node."))}$J.isMDXComponent=!0;const KJ={toc:[]};function YJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}YJ.isMDXComponent=!0;const JJ={toc:[]};function QJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}QJ.isMDXComponent=!0;const tQ={toc:[]};function nQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}nQ.isMDXComponent=!0;const eQ={toc:[]};function oQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}oQ.isMDXComponent=!0;const pQ={toc:[]};function sQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}sQ.isMDXComponent=!0;const rQ={toc:[]};function cQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}cQ.isMDXComponent=!0;const aQ={toc:[]};function iQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}iQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the desired size of this node."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function kQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}kQ.isMDXComponent=!0;const yQ={toc:[]};function fQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},yQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}fQ.isMDXComponent=!0;const MQ={toc:[]};function wQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},MQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}wQ.isMDXComponent=!0;const DQ={toc:[]};function _Q(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},DQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}_Q.isMDXComponent=!0;const XQ={toc:[]};function gQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},XQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}gQ.isMDXComponent=!0;const xQ={toc:[]};function CQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}CQ.isMDXComponent=!0;const TQ={toc:[]};function vQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},TQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}vQ.isMDXComponent=!0;const bQ={toc:[]};function LQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}LQ.isMDXComponent=!0;const ZQ={toc:[]};function NQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ZQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}NQ.isMDXComponent=!0;const AQ={toc:[]};function RQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},AQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}RQ.isMDXComponent=!0;const EQ={toc:[]};function SQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},EQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}SQ.isMDXComponent=!0;const zQ={toc:[]};function IQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},zQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}IQ.isMDXComponent=!0;const WQ={toc:[]};function PQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},WQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}PQ.isMDXComponent=!0;const GQ={toc:[]};function BQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},GQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}BQ.isMDXComponent=!0;const FQ={toc:[]};function UQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},FQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return a snapshot of the node's current signal values."))}UQ.isMDXComponent=!0;const qQ={toc:[]};function VQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}VQ.isMDXComponent=!0;const jQ={toc:[]};function OQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}OQ.isMDXComponent=!0;const HQ={toc:[]};function $Q(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},HQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}$Q.isMDXComponent=!0;const KQ={toc:[]};function YQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},KQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}YQ.isMDXComponent=!0;const JQ={toc:[]};function QQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},JQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}QQ.isMDXComponent=!0;const t0={toc:[]};function n0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},t0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}n0.isMDXComponent=!0;const e0={toc:[]};function o0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},e0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}o0.isMDXComponent=!0;const p0={toc:[]};function s0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},p0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}s0.isMDXComponent=!0;const r0={toc:[]};function c0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},r0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}c0.isMDXComponent=!0;const a0={toc:[]};function i0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},a0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}i0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},l0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},m0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}d0.isMDXComponent=!0;const h0={toc:[]};function k0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},h0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}k0.isMDXComponent=!0;const y0={toc:[]};function f0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},y0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}f0.isMDXComponent=!0;const M0={toc:[]};function w0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},M0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}w0.isMDXComponent=!0;const D0={toc:[]};function _0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},D0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}_0.isMDXComponent=!0;const X0={toc:[]};function g0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},X0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}g0.isMDXComponent=!0;const x0={toc:[]};function C0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},x0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}C0.isMDXComponent=!0;const T0={toc:[]};function v0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},T0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}v0.isMDXComponent=!0;const b0={toc:[]};function L0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},b0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node above the provided node in the parent's layout."))}L0.isMDXComponent=!0;const Z0={toc:[]};function N0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Z0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}N0.isMDXComponent=!0;const A0={toc:[]};function R0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},A0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}R0.isMDXComponent=!0;const E0={toc:[]};function S0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},E0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}S0.isMDXComponent=!0;const z0={toc:[]};function I0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},z0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node below the provided node in the parent's layout."))}I0.isMDXComponent=!0;const W0={toc:[]};function P0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},W0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}P0.isMDXComponent=!0;const G0={toc:[]};function B0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},G0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}B0.isMDXComponent=!0;const F0={toc:[]};function U0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},F0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}U0.isMDXComponent=!0;const q0={toc:[]};function V0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},q0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}V0.isMDXComponent=!0;const j0={toc:[]};function O0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},j0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}O0.isMDXComponent=!0;const H0={toc:[]};function $0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},H0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}$0.isMDXComponent=!0;const K0={toc:[]};function Y0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},K0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Y0.isMDXComponent=!0;const J0={toc:[]};function Q0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},J0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Q0.isMDXComponent=!0;const t2={toc:[]};function n2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},t2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index to move the node to."))}n2.isMDXComponent=!0;const e2={toc:[]};function o2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},e2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}o2.isMDXComponent=!0;const p2={toc:[]};function s2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},p2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}s2.isMDXComponent=!0;const r2={toc:[]};function c2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},r2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}c2.isMDXComponent=!0;const a2={toc:[]};function i2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},a2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}i2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},l2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},m2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}d2.isMDXComponent=!0;const h2={toc:[]};function k2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},h2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}k2.isMDXComponent=!0;const y2={toc:[]};function f2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},y2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}f2.isMDXComponent=!0;const M2={toc:[]};function w2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},M2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}w2.isMDXComponent=!0;const D2={toc:[]};function _2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},D2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}_2.isMDXComponent=!0;const X2={toc:[]};function g2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},X2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}g2.isMDXComponent=!0;const x2={toc:[]};function C2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},x2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}C2.isMDXComponent=!0;const T2={toc:[]};function v2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},T2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}v2.isMDXComponent=!0;const b2={toc:[]};function L2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},b2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}L2.isMDXComponent=!0;const Z2={toc:[]};function N2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Z2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}N2.isMDXComponent=!0;const A2={toc:[]};function R2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},A2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}R2.isMDXComponent=!0;const E2={toc:[]};function S2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},E2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}S2.isMDXComponent=!0;const z2={toc:[]};function I2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},z2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}I2.isMDXComponent=!0;const W2={toc:[]};function P2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},W2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}P2.isMDXComponent=!0;const G2={toc:[]};function B2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},G2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,r.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}B2.isMDXComponent=!0;const F2={toc:[]};function U2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},F2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}U2.isMDXComponent=!0;const q2={toc:[]};function V2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},q2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Restore the node to its last saved state."))}V2.isMDXComponent=!0;const j2={toc:[]};function O2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},j2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition"))}O2.isMDXComponent=!0;const H2={toc:[]};function $2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},H2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The timing function to use for the transition"))}$2.isMDXComponent=!0;const K2={toc:[]};function Y2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},K2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,r.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Y2.isMDXComponent=!0;const J2={toc:[]};function Q2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},J2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Q2.isMDXComponent=!0;const t1={toc:[]};function n1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},t1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}n1.isMDXComponent=!0;const e1={toc:[]};function o1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},e1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}o1.isMDXComponent=!0;const p1={toc:[]};function s1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},p1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}s1.isMDXComponent=!0;const r1={toc:[]};function c1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},r1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}c1.isMDXComponent=!0;const a1={toc:[]};function i1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},a1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}i1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},l1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},m1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}d1.isMDXComponent=!0;const h1={toc:[]};function k1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},h1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}k1.isMDXComponent=!0;const y1={toc:[]};function f1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},y1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}f1.isMDXComponent=!0;const M1={toc:[]};function w1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},M1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the same the bounding box returned by ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,r.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}w1.isMDXComponent=!0;const D1={toc:[]};function _1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},D1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}_1.isMDXComponent=!0;const X1={toc:[]};function g1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},X1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}g1.isMDXComponent=!0;const x1={toc:[]};function C1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},x1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}C1.isMDXComponent=!0;const T1={toc:[]};function v1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},T1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}v1.isMDXComponent=!0;const b1={toc:[]};function L1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},b1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}L1.isMDXComponent=!0;const Z1={toc:[]};function N1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Z1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}N1.isMDXComponent=!0;const A1={toc:[]};function R1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},A1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}R1.isMDXComponent=!0;const E1={toc:[]};function S1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},E1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}S1.isMDXComponent=!0;const z1={toc:[]};function I1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},z1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}I1.isMDXComponent=!0;const W1={toc:[]};function P1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},W1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}P1.isMDXComponent=!0;const G1={toc:[]};function B1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},G1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}B1.isMDXComponent=!0;const F1={toc:[]};function U1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},F1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}U1.isMDXComponent=!0;const q1={toc:[]};function V1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},q1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}V1.isMDXComponent=!0;const j1={toc:[]};function O1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},j1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}O1.isMDXComponent=!0;const H1={toc:[]};function $1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},H1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}$1.isMDXComponent=!0;const K1={toc:[]};function Y1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},K1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Y1.isMDXComponent=!0;const J1={toc:[]};function Q1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},J1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Q1.isMDXComponent=!0;const t5={toc:[]};function n5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},t5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}n5.isMDXComponent=!0;const e5={toc:[]};function o5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},e5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}o5.isMDXComponent=!0;const p5={toc:[]};function s5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},p5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}s5.isMDXComponent=!0;const r5={toc:[]};function c5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},r5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}c5.isMDXComponent=!0;const a5={toc:[]};function i5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},a5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}i5.isMDXComponent=!0;const l5={toc:[]};function u5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},l5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The state to apply to the node."))}u5.isMDXComponent=!0;const m5={toc:[]};function d5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},m5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}d5.isMDXComponent=!0;const h5={toc:[]};function k5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},h5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}k5.isMDXComponent=!0;const y5={toc:[]};function f5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},y5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}f5.isMDXComponent=!0;const M5={toc:[]};function w5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},M5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}w5.isMDXComponent=!0;const D5={toc:[]};function _5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},D5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}_5.isMDXComponent=!0;const X5={toc:[]};function g5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},X5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}g5.isMDXComponent=!0;const x5={toc:[]};function C5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},x5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}C5.isMDXComponent=!0;const T5={toc:[]};function v5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},T5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}v5.isMDXComponent=!0;const b5={toc:[]};function L5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},b5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}L5.isMDXComponent=!0;const Z5={toc:[]};function N5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Z5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}N5.isMDXComponent=!0;const A5={toc:[]};function R5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},A5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}R5.isMDXComponent=!0;const E5={toc:[]};function S5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},E5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}S5.isMDXComponent=!0;const z5={toc:[]};function I5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},z5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}I5.isMDXComponent=!0;const W5={toc:[]};function P5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},W5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}P5.isMDXComponent=!0;const G5={toc:[]};function B5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},G5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}B5.isMDXComponent=!0;const F5={toc:[]};function U5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},F5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}U5.isMDXComponent=!0;const q5={toc:[]};function V5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},q5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}V5.isMDXComponent=!0;const j5={toc:[]};function O5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},j5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}O5.isMDXComponent=!0;const H5={toc:[]};function $5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},H5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}$5.isMDXComponent=!0;const K5={toc:[]};function Y5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},K5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Y5.isMDXComponent=!0;const J5={toc:[]};function Q5(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},J5,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Q5.isMDXComponent=!0;const t4={toc:[]};function n4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},t4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return a snapshot of the node's current signal values."))}n4.isMDXComponent=!0;const e4={toc:[]};function o4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},e4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}o4.isMDXComponent=!0;const p4={toc:[]};function s4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},p4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}s4.isMDXComponent=!0;const r4={toc:[]};function c4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},r4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}c4.isMDXComponent=!0;const a4={toc:[]};function i4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},a4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}i4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},l4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},m4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}d4.isMDXComponent=!0;const h4={toc:[]};function k4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},h4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}k4.isMDXComponent=!0;const y4={toc:[]};function f4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},y4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}f4.isMDXComponent=!0;const M4={toc:[]};function w4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},M4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}w4.isMDXComponent=!0;const D4={toc:[]};function _4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},D4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}_4.isMDXComponent=!0;const X4={toc:[]};function g4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},X4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}g4.isMDXComponent=!0;const x4={toc:[]};function C4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},x4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}C4.isMDXComponent=!0;const T4={toc:[]};function v4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},T4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}v4.isMDXComponent=!0;const b4={toc:[]};function L4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},b4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}L4.isMDXComponent=!0;const Z4={toc:[]};function N4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Z4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}N4.isMDXComponent=!0;const A4={toc:[]};function R4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},A4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}R4.isMDXComponent=!0;const E4={toc:[]};function S4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},E4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}S4.isMDXComponent=!0;const z4={toc:[]};function I4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},z4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node above the provided node in the parent's layout."))}I4.isMDXComponent=!0;const W4={toc:[]};function P4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},W4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}P4.isMDXComponent=!0;const G4={toc:[]};function B4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},G4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}B4.isMDXComponent=!0;const F4={toc:[]};function U4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},F4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}U4.isMDXComponent=!0;const q4={toc:[]};function V4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},q4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node below the provided node in the parent's layout."))}V4.isMDXComponent=!0;const j4={toc:[]};function O4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},j4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}O4.isMDXComponent=!0;const H4={toc:[]};function $4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},H4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}$4.isMDXComponent=!0;const K4={toc:[]};function Y4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},K4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Y4.isMDXComponent=!0;const J4={toc:[]};function Q4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},J4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}Q4.isMDXComponent=!0;const t3={toc:[]};function n3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},t3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}n3.isMDXComponent=!0;const e3={toc:[]};function o3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},e3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the provided position relative to its siblings."))}o3.isMDXComponent=!0;const p3={toc:[]};function s3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},p3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index to move the node to."))}s3.isMDXComponent=!0;const r3={toc:[]};function c3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},r3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}c3.isMDXComponent=!0;const a3={toc:[]};function i3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},a3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}i3.isMDXComponent=!0;const l3={toc:[]};function u3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},l3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},m3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}d3.isMDXComponent=!0;const h3={toc:[]};function k3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},h3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}k3.isMDXComponent=!0;const y3={toc:[]};function f3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},y3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}f3.isMDXComponent=!0;const M3={toc:[]};function w3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},M3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}w3.isMDXComponent=!0;const D3={toc:[]};function _3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},D3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}_3.isMDXComponent=!0;const X3={toc:[]};function g3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},X3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}g3.isMDXComponent=!0;const x3={toc:[]};function C3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},x3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}C3.isMDXComponent=!0;const T3={toc:[]};function v3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},T3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}v3.isMDXComponent=!0;const b3={toc:[]};function L3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},b3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}L3.isMDXComponent=!0;const Z3={toc:[]};function N3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Z3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}N3.isMDXComponent=!0;const A3={toc:[]};function R3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},A3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}R3.isMDXComponent=!0;const E3={toc:[]};function S3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},E3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}S3.isMDXComponent=!0;const z3={toc:[]};function I3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},z3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}I3.isMDXComponent=!0;const W3={toc:[]};function P3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},W3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}P3.isMDXComponent=!0;const G3={toc:[]};function B3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},G3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,r.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}B3.isMDXComponent=!0;const F3={toc:[]};function U3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},F3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}U3.isMDXComponent=!0;const q3={toc:[]};function V3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},q3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Restore the node to its last saved state."))}V3.isMDXComponent=!0;const j3={toc:[]};function O3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},j3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition"))}O3.isMDXComponent=!0;const H3={toc:[]};function $3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},H3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The timing function to use for the transition"))}$3.isMDXComponent=!0;const K3={toc:[]};function Y3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},K3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,r.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Y3.isMDXComponent=!0;const J3={toc:[]};function Q3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},J3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Q3.isMDXComponent=!0;const t6={toc:[]};function n6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},t6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}n6.isMDXComponent=!0;const e6={toc:[]};function o6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},e6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}o6.isMDXComponent=!0;const p6={toc:[]};function s6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},p6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}s6.isMDXComponent=!0;const r6={toc:[]};function c6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},r6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}c6.isMDXComponent=!0;const a6={toc:[]};function i6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},a6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}i6.isMDXComponent=!0;const l6={toc:[]};function u6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},l6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}u6.isMDXComponent=!0;const m6={toc:[]};function d6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},m6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}d6.isMDXComponent=!0;const h6={toc:[]};function k6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},h6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}k6.isMDXComponent=!0;const y6={toc:[]};function f6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},y6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the same the bounding box returned by ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,r.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}f6.isMDXComponent=!0;const M6={toc:[]};function w6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},M6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}w6.isMDXComponent=!0;const D6={toc:[]};function _6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},D6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}_6.isMDXComponent=!0;const X6={toc:[]};function g6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},X6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}g6.isMDXComponent=!0;const x6={toc:[]};function C6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},x6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}C6.isMDXComponent=!0;const T6={toc:[]};function v6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},T6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}v6.isMDXComponent=!0;const b6={toc:[]};function L6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},b6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}L6.isMDXComponent=!0;const Z6={toc:[]};function N6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Z6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,r.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,r.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticable if the number of sides is low, e.g. for a\ntriangle."))}N6.isMDXComponent=!0;const A6={toc:[]};function R6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},A6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A hexagon:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  sides={6}\n  size={300}\n  fill={'lightseagreen'}\n/>\n")),(0,r.kt)("p",null,"A pentagon outline:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  sides={5}\n  size={300}\n  stroke={'lightblue'}\n  lineWidth={8}\n/>\n")))}R6.isMDXComponent=!0;const E6={toc:[]};function S6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},E6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node for drawing regular polygons."))}S6.isMDXComponent=!0;const z6={toc:[]};function I6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},z6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}I6.isMDXComponent=!0;const W6={toc:[]};function P6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},W6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}P6.isMDXComponent=!0;const G6={toc:[]};function B6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},G6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}B6.isMDXComponent=!0;const F6={toc:[]};function U6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},F6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}U6.isMDXComponent=!0;const q6={toc:[]};function V6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},q6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}V6.isMDXComponent=!0;const j6={toc:[]};function O6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},j6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}O6.isMDXComponent=!0;const H6={toc:[]};function $6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},H6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}$6.isMDXComponent=!0;const K6={toc:[]};function Y6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},K6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}Y6.isMDXComponent=!0;const J6={toc:[]};function Q6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},J6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Q6.isMDXComponent=!0;const t8={toc:[]};function n8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},t8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}n8.isMDXComponent=!0;const e8={toc:[]};function o8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},e8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}o8.isMDXComponent=!0;const p8={toc:[]};function s8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},p8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}s8.isMDXComponent=!0;const r8={toc:[]};function c8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},r8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}c8.isMDXComponent=!0;const a8={toc:[]};function i8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},a8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"For example, a value of 6 creates a hexagon."))}i8.isMDXComponent=!0;const l8={toc:[]};function u8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},l8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}u8.isMDXComponent=!0;const m8={toc:[]};function d8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},m8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Sets the number of sides of the polygon."))}d8.isMDXComponent=!0;const h8={toc:[]};function k8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},h8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}k8.isMDXComponent=!0;const y8={toc:[]};function f8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},y8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}f8.isMDXComponent=!0;const M8={toc:[]};function w8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},M8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}w8.isMDXComponent=!0;const D8={toc:[]};function _8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},D8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}_8.isMDXComponent=!0;const X8={toc:[]};function g8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},X8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}g8.isMDXComponent=!0;const x8={toc:[]};function C8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},x8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}C8.isMDXComponent=!0;const T8={toc:[]};function v8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},T8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}v8.isMDXComponent=!0;const b8={toc:[]};function L8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},b8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}L8.isMDXComponent=!0;const Z8={toc:[]};function N8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Z8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The state to apply to the node."))}N8.isMDXComponent=!0;const A8={toc:[]};function R8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},A8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}R8.isMDXComponent=!0;const E8={toc:[]};function S8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},E8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}S8.isMDXComponent=!0;const z8={toc:[]};function I8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},z8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}I8.isMDXComponent=!0;const W8={toc:[]};function P8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},W8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}P8.isMDXComponent=!0;const G8={toc:[]};function B8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},G8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}B8.isMDXComponent=!0;const F8={toc:[]};function U8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},F8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}U8.isMDXComponent=!0;const q8={toc:[]};function V8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},q8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}V8.isMDXComponent=!0;const j8={toc:[]};function O8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},j8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}O8.isMDXComponent=!0;const H8={toc:[]};function $8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},H8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the desired size of this node."))}$8.isMDXComponent=!0;const K8={toc:[]};function Y8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},K8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Y8.isMDXComponent=!0;const J8={toc:[]};function Q8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},J8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}Q8.isMDXComponent=!0;const t7={toc:[]};function n7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},t7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}n7.isMDXComponent=!0;const e7={toc:[]};function o7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},e7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}o7.isMDXComponent=!0;const p7={toc:[]};function s7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},p7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}s7.isMDXComponent=!0;const r7={toc:[]};function c7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},r7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}c7.isMDXComponent=!0;const a7={toc:[]};function i7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},a7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}i7.isMDXComponent=!0;const l7={toc:[]};function u7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},l7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}u7.isMDXComponent=!0;const m7={toc:[]};function d7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},m7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}d7.isMDXComponent=!0;const h7={toc:[]};function k7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},h7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}k7.isMDXComponent=!0;const y7={toc:[]};function f7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},y7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}f7.isMDXComponent=!0;const M7={toc:[]};function w7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},M7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}w7.isMDXComponent=!0;const D7={toc:[]};function _7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},D7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}_7.isMDXComponent=!0;const X7={toc:[]};function g7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},X7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}g7.isMDXComponent=!0;const x7={toc:[]};function C7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},x7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return a snapshot of the node's current signal values."))}C7.isMDXComponent=!0;const T7={toc:[]};function v7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},T7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}v7.isMDXComponent=!0;const b7={toc:[]};function L7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},b7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}L7.isMDXComponent=!0;const Z7={toc:[]};function N7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Z7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}N7.isMDXComponent=!0;const A7={toc:[]};function R7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},A7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}R7.isMDXComponent=!0;const E7={toc:[]};function S7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},E7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}S7.isMDXComponent=!0;const z7={toc:[]};function I7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},z7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}I7.isMDXComponent=!0;const W7={toc:[]};function P7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},W7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}P7.isMDXComponent=!0;const G7={toc:[]};function B7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},G7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}B7.isMDXComponent=!0;const F7={toc:[]};function U7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},F7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}U7.isMDXComponent=!0;const q7={toc:[]};function V7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},q7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}V7.isMDXComponent=!0;const j7={toc:[]};function O7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},j7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}O7.isMDXComponent=!0;const H7={toc:[]};function $7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},H7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}$7.isMDXComponent=!0;const K7={toc:[]};function Y7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},K7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Y7.isMDXComponent=!0;const J7={toc:[]};function Q7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},J7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Q7.isMDXComponent=!0;const t9={toc:[]};function n9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},t9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}n9.isMDXComponent=!0;const e9={toc:[]};function o9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},e9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}o9.isMDXComponent=!0;const p9={toc:[]};function s9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},p9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}s9.isMDXComponent=!0;const r9={toc:[]};function c9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},r9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}c9.isMDXComponent=!0;const a9={toc:[]};function i9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},a9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}i9.isMDXComponent=!0;const l9={toc:[]};function u9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},l9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node above the provided node in the parent's layout."))}u9.isMDXComponent=!0;const m9={toc:[]};function d9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},m9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}d9.isMDXComponent=!0;const h9={toc:[]};function k9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},h9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}k9.isMDXComponent=!0;const y9={toc:[]};function f9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},y9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}f9.isMDXComponent=!0;const M9={toc:[]};function w9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},M9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node below the provided node in the parent's layout."))}w9.isMDXComponent=!0;const D9={toc:[]};function _9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},D9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}_9.isMDXComponent=!0;const X9={toc:[]};function g9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},X9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}g9.isMDXComponent=!0;const x9={toc:[]};function C9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},x9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}C9.isMDXComponent=!0;const T9={toc:[]};function v9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},T9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}v9.isMDXComponent=!0;const b9={toc:[]};function L9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},b9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}L9.isMDXComponent=!0;const Z9={toc:[]};function N9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Z9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}N9.isMDXComponent=!0;const A9={toc:[]};function R9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},A9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}R9.isMDXComponent=!0;const E9={toc:[]};function S9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},E9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the provided position relative to its siblings."))}S9.isMDXComponent=!0;const z9={toc:[]};function I9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},z9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index to move the node to."))}I9.isMDXComponent=!0;const W9={toc:[]};function P9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},W9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}P9.isMDXComponent=!0;const G9={toc:[]};function B9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},G9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}B9.isMDXComponent=!0;const F9={toc:[]};function U9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},F9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}U9.isMDXComponent=!0;const q9={toc:[]};function V9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},q9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}V9.isMDXComponent=!0;const j9={toc:[]};function O9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},j9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}O9.isMDXComponent=!0;const H9={toc:[]};function $9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},H9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}$9.isMDXComponent=!0;const K9={toc:[]};function Y9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},K9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Y9.isMDXComponent=!0;const J9={toc:[]};function Q9(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},J9,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}Q9.isMDXComponent=!0;const ttt={toc:[]};function ntt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ttt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}ntt.isMDXComponent=!0;const ett={toc:[]};function ott(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ett,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}ott.isMDXComponent=!0;const ptt={toc:[]};function stt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ptt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}stt.isMDXComponent=!0;const rtt={toc:[]};function ctt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rtt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}ctt.isMDXComponent=!0;const att={toc:[]};function itt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},att,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}itt.isMDXComponent=!0;const ltt={toc:[]};function utt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ltt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}utt.isMDXComponent=!0;const mtt={toc:[]};function dtt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mtt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}dtt.isMDXComponent=!0;const htt={toc:[]};function ktt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},htt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}ktt.isMDXComponent=!0;const ytt={toc:[]};function ftt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ytt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}ftt.isMDXComponent=!0;const Mtt={toc:[]};function wtt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Mtt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}wtt.isMDXComponent=!0;const Dtt={toc:[]};function _tt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Dtt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}_tt.isMDXComponent=!0;const Xtt={toc:[]};function gtt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Xtt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,r.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}gtt.isMDXComponent=!0;const xtt={toc:[]};function Ctt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xtt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Ctt.isMDXComponent=!0;const Ttt={toc:[]};function vtt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ttt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Restore the node to its last saved state."))}vtt.isMDXComponent=!0;const btt={toc:[]};function Ltt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},btt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition"))}Ltt.isMDXComponent=!0;const Ztt={toc:[]};function Ntt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ztt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The timing function to use for the transition"))}Ntt.isMDXComponent=!0;const Att={toc:[]};function Rtt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Att,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,r.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Rtt.isMDXComponent=!0;const Ett={toc:[]};function Stt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ett,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Stt.isMDXComponent=!0;const ztt={toc:[]};function Itt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ztt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Itt.isMDXComponent=!0;const Wtt={toc:[]};function Ptt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Wtt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Ptt.isMDXComponent=!0;const Gtt={toc:[]};function Btt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Gtt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}Btt.isMDXComponent=!0;const Ftt={toc:[]};function Utt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ftt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Utt.isMDXComponent=!0;const qtt={toc:[]};function Vtt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qtt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}Vtt.isMDXComponent=!0;const jtt={toc:[]};function Ott(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jtt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}Ott.isMDXComponent=!0;const Htt={toc:[]};function $tt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Htt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}$tt.isMDXComponent=!0;const Ktt={toc:[]};function Ytt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ktt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Ytt.isMDXComponent=!0;const Jtt={toc:[]};function Qtt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Jtt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}Qtt.isMDXComponent=!0;const tnt={toc:[]};function nnt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the same the bounding box returned by ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,r.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}nnt.isMDXComponent=!0;const ent={toc:[]};function ont(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ent,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}ont.isMDXComponent=!0;const pnt={toc:[]};function snt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}snt.isMDXComponent=!0;const rnt={toc:[]};function cnt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},rnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}cnt.isMDXComponent=!0;const ant={toc:[]};function int(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ant,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}int.isMDXComponent=!0;const lnt={toc:[]};function unt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},lnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}unt.isMDXComponent=!0;const mnt={toc:[]};function dnt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},mnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}dnt.isMDXComponent=!0;const hnt={toc:[]};function knt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},hnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}knt.isMDXComponent=!0;const ynt={toc:[]};function fnt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ynt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}fnt.isMDXComponent=!0;const Mnt={toc:[]};function wnt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Mnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}wnt.isMDXComponent=!0;const Dnt={toc:[]};function _nt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Dnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}_nt.isMDXComponent=!0;const Xnt={toc:[]};function gnt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Xnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}gnt.isMDXComponent=!0;const xnt={toc:[]};function Cnt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},xnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}Cnt.isMDXComponent=!0;const Tnt={toc:[]};function vnt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Tnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default the ",(0,r.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}vnt.isMDXComponent=!0;const bnt={toc:[]};function Lnt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},bnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Lnt.isMDXComponent=!0;const Znt={toc:[]};function Nnt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Znt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Controls the sharpness of the corners. ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,r.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."))}Nnt.isMDXComponent=!0;const Ant={toc:[]};function Rnt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ant,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Rnt.isMDXComponent=!0;const Ent={toc:[]};function Snt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ent,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}Snt.isMDXComponent=!0;const znt={toc:[]};function Int(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},znt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Int.isMDXComponent=!0;const Wnt={toc:[]};function Pnt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Wnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}Pnt.isMDXComponent=!0;const Gnt={toc:[]};function Bnt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Gnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Bnt.isMDXComponent=!0;const Fnt={toc:[]};function Unt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Fnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Unt.isMDXComponent=!0;const qnt={toc:[]};function Vnt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},qnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Vnt.isMDXComponent=!0;const jnt={toc:[]};function Ont(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},jnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Ont.isMDXComponent=!0;const Hnt={toc:[]};function $nt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Hnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}$nt.isMDXComponent=!0;const Knt={toc:[]};function Ynt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Knt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}Ynt.isMDXComponent=!0;const Jnt={toc:[]};function Qnt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Jnt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,r.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Qnt.isMDXComponent=!0;const tet={toc:[]};function net(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},tet,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}net.isMDXComponent=!0;const eet={toc:[]};function oet(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},eet,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Will set the corner drawing method to smooth corners."))}oet.isMDXComponent=!0;const pet={toc:[]};function set(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},pet,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}set.isMDXComponent=!0;const ret={toc:[]};function cet(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ret,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}cet.isMDXComponent=!0;const aet={toc:[]};function iet(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},aet,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}iet.isMDXComponent=!0;const uet={toc:[]};function met(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uet,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}met.isMDXComponent=!0;const det={toc:[]};function het(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},det,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}het.isMDXComponent=!0;const ket={toc:[]};function yet(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ket,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The state to apply to the node."))}yet.isMDXComponent=!0;const fet={toc:[]};function Met(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fet,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Met.isMDXComponent=!0;const wet={toc:[]};function Det(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wet,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Det.isMDXComponent=!0;const _et={toc:[]};function Xet(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_et,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}Xet.isMDXComponent=!0;const get={toc:[]};function xet(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},get,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}xet.isMDXComponent=!0;const Cet={toc:[]};function Tet(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cet,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}Tet.isMDXComponent=!0;const vet={toc:[]};function bet(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vet,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}bet.isMDXComponent=!0;const Let={toc:[]};function Zet(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Let,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}Zet.isMDXComponent=!0;const Net={toc:[]};function Aet(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Net,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Aet.isMDXComponent=!0;const Ret={toc:[]};function Eet(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ret,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the desired size of this node."))}Eet.isMDXComponent=!0;const Set={toc:[]};function zet(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Set,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}zet.isMDXComponent=!0;const Iet={toc:[]};function Wet(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Iet,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}Wet.isMDXComponent=!0;const Pet={toc:[]};function Get(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pet,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Get.isMDXComponent=!0;const Bet={toc:[]};function Fet(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bet,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}Fet.isMDXComponent=!0;const Uet={toc:[]};function qet(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uet,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}qet.isMDXComponent=!0;const Vet={toc:[]};function jet(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vet,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}jet.isMDXComponent=!0;const Oet={toc:[]};function Het(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Oet,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}Het.isMDXComponent=!0;const $et={toc:[]};function Ket(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$et,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}Ket.isMDXComponent=!0;const Yet={toc:[]};function Jet(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yet,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}Jet.isMDXComponent=!0;const Qet={toc:[]};function tot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qet,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}tot.isMDXComponent=!0;const not={toc:[]};function eot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},not,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}eot.isMDXComponent=!0;const oot={toc:[]};function pot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}pot.isMDXComponent=!0;const sot={toc:[]};function rot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}rot.isMDXComponent=!0;const cot={toc:[]};function aot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}aot.isMDXComponent=!0;const iot={toc:[]};function lot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return a snapshot of the node's current signal values."))}lot.isMDXComponent=!0;const uot={toc:[]};function mot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}mot.isMDXComponent=!0;const dot={toc:[]};function hot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}hot.isMDXComponent=!0;const kot={toc:[]};function yot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}yot.isMDXComponent=!0;const fot={toc:[]};function Mot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Mot.isMDXComponent=!0;const wot={toc:[]};function Dot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}Dot.isMDXComponent=!0;const _ot={toc:[]};function Xot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_ot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}Xot.isMDXComponent=!0;const got={toc:[]};function xot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},got,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}xot.isMDXComponent=!0;const Cot={toc:[]};function Tot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}Tot.isMDXComponent=!0;const vot={toc:[]};function bot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}bot.isMDXComponent=!0;const Lot={toc:[]};function Zot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}Zot.isMDXComponent=!0;const Not={toc:[]};function Aot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Not,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Aot.isMDXComponent=!0;const Rot={toc:[]};function Eot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}Eot.isMDXComponent=!0;const Sot={toc:[]};function zot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}zot.isMDXComponent=!0;const Iot={toc:[]};function Wot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Iot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Wot.isMDXComponent=!0;const Pot={toc:[]};function Got(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}Got.isMDXComponent=!0;const Bot={toc:[]};function Fot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Fot.isMDXComponent=!0;const Uot={toc:[]};function qot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}qot.isMDXComponent=!0;const Vot={toc:[]};function jot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}jot.isMDXComponent=!0;const Oot={toc:[]};function Hot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Oot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Hot.isMDXComponent=!0;const $ot={toc:[]};function Kot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$ot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Kot.isMDXComponent=!0;const Yot={toc:[]};function Jot(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}Jot.isMDXComponent=!0;const Qot={toc:[]};function tpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}tpt.isMDXComponent=!0;const npt={toc:[]};function ept(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},npt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}ept.isMDXComponent=!0;const opt={toc:[]};function ppt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},opt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node below the provided node in the parent's layout."))}ppt.isMDXComponent=!0;const spt={toc:[]};function rpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},spt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}rpt.isMDXComponent=!0;const cpt={toc:[]};function apt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cpt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}apt.isMDXComponent=!0;const ipt={toc:[]};function lpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ipt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lpt.isMDXComponent=!0;const upt={toc:[]};function mpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},upt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}mpt.isMDXComponent=!0;const dpt={toc:[]};function hpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dpt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}hpt.isMDXComponent=!0;const kpt={toc:[]};function ypt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kpt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}ypt.isMDXComponent=!0;const fpt={toc:[]};function Mpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fpt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Mpt.isMDXComponent=!0;const wpt={toc:[]};function Dpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wpt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Dpt.isMDXComponent=!0;const _pt={toc:[]};function Xpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_pt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index to move the node to."))}Xpt.isMDXComponent=!0;const gpt={toc:[]};function xpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gpt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}xpt.isMDXComponent=!0;const Cpt={toc:[]};function Tpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cpt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Tpt.isMDXComponent=!0;const vpt={toc:[]};function bpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vpt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}bpt.isMDXComponent=!0;const Lpt={toc:[]};function Zpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lpt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}Zpt.isMDXComponent=!0;const Npt={toc:[]};function Apt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Npt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Apt.isMDXComponent=!0;const Rpt={toc:[]};function Ept(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rpt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}Ept.isMDXComponent=!0;const Spt={toc:[]};function zpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Spt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}zpt.isMDXComponent=!0;const Ipt={toc:[]};function Wpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ipt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}Wpt.isMDXComponent=!0;const Ppt={toc:[]};function Gpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ppt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}Gpt.isMDXComponent=!0;const Bpt={toc:[]};function Fpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bpt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}Fpt.isMDXComponent=!0;const Upt={toc:[]};function qpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Upt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}qpt.isMDXComponent=!0;const Vpt={toc:[]};function jpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vpt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}jpt.isMDXComponent=!0;const Opt={toc:[]};function Hpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Opt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}Hpt.isMDXComponent=!0;const $pt={toc:[]};function Kpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$pt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Kpt.isMDXComponent=!0;const Ypt={toc:[]};function Jpt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ypt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Jpt.isMDXComponent=!0;const Qpt={toc:[]};function tst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qpt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}tst.isMDXComponent=!0;const nst={toc:[]};function est(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}est.isMDXComponent=!0;const ost={toc:[]};function pst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ost,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}pst.isMDXComponent=!0;const sst={toc:[]};function rst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}rst.isMDXComponent=!0;const cst={toc:[]};function ast(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,r.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}ast.isMDXComponent=!0;const ist={toc:[]};function lst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ist,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}lst.isMDXComponent=!0;const ust={toc:[]};function mst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ust,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Restore the node to its last saved state."))}mst.isMDXComponent=!0;const dst={toc:[]};function hst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition"))}hst.isMDXComponent=!0;const kst={toc:[]};function yst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The timing function to use for the transition"))}yst.isMDXComponent=!0;const fst={toc:[]};function Mst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,r.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Mst.isMDXComponent=!0;const wst={toc:[]};function Dst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Dst.isMDXComponent=!0;const _st={toc:[]};function Xst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_st,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Xst.isMDXComponent=!0;const gst={toc:[]};function xst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}xst.isMDXComponent=!0;const Cst={toc:[]};function Tst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}Tst.isMDXComponent=!0;const vst={toc:[]};function bst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}bst.isMDXComponent=!0;const Lst={toc:[]};function Zst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}Zst.isMDXComponent=!0;const Nst={toc:[]};function Ast(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}Ast.isMDXComponent=!0;const Rst={toc:[]};function Est(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Est.isMDXComponent=!0;const Sst={toc:[]};function zst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}zst.isMDXComponent=!0;const Ist={toc:[]};function Wst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ist,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}Wst.isMDXComponent=!0;const Pst={toc:[]};function Gst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the same the bounding box returned by ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,r.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Gst.isMDXComponent=!0;const Bst={toc:[]};function Fst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Fst.isMDXComponent=!0;const Ust={toc:[]};function qst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ust,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}qst.isMDXComponent=!0;const Vst={toc:[]};function jst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}jst.isMDXComponent=!0;const Ost={toc:[]};function Hst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ost,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}Hst.isMDXComponent=!0;const $st={toc:[]};function Kst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$st,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Kst.isMDXComponent=!0;const Yst={toc:[]};function Jst(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}Jst.isMDXComponent=!0;const Qst={toc:[]};function trt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qst,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}trt.isMDXComponent=!0;const nrt={toc:[]};function ert(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nrt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}ert.isMDXComponent=!0;const ort={toc:[]};function prt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ort,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}prt.isMDXComponent=!0;const srt={toc:[]};function rrt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},srt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}rrt.isMDXComponent=!0;const crt={toc:[]};function art(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},crt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}art.isMDXComponent=!0;const irt={toc:[]};function lrt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},irt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}lrt.isMDXComponent=!0;const urt={toc:[]};function mrt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},urt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}mrt.isMDXComponent=!0;const drt={toc:[]};function hrt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},drt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}hrt.isMDXComponent=!0;const krt={toc:[]};function yrt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},krt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}yrt.isMDXComponent=!0;const frt={toc:[]};function Mrt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},frt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}Mrt.isMDXComponent=!0;const wrt={toc:[]};function Drt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wrt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Drt.isMDXComponent=!0;const _rt={toc:[]};function Xrt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_rt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Xrt.isMDXComponent=!0;const grt={toc:[]};function xrt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},grt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}xrt.isMDXComponent=!0;const Crt={toc:[]};function Trt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Crt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Trt.isMDXComponent=!0;const vrt={toc:[]};function brt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vrt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}brt.isMDXComponent=!0;const Lrt={toc:[]};function Zrt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lrt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}Zrt.isMDXComponent=!0;const Nrt={toc:[]};function Art(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nrt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}Art.isMDXComponent=!0;const Rrt={toc:[]};function Ert(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rrt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Ert.isMDXComponent=!0;const Srt={toc:[]};function zrt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Srt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}zrt.isMDXComponent=!0;const Irt={toc:[]};function Wrt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Irt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}Wrt.isMDXComponent=!0;const Prt={toc:[]};function Grt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Prt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Grt.isMDXComponent=!0;const Brt={toc:[]};function Frt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Brt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The state to apply to the node."))}Frt.isMDXComponent=!0;const Urt={toc:[]};function qrt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Urt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}qrt.isMDXComponent=!0;const Vrt={toc:[]};function jrt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vrt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}jrt.isMDXComponent=!0;const Ort={toc:[]};function Hrt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ort,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}Hrt.isMDXComponent=!0;const $rt={toc:[]};function Krt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$rt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}Krt.isMDXComponent=!0;const Yrt={toc:[]};function Jrt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yrt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}Jrt.isMDXComponent=!0;const Qrt={toc:[]};function tct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qrt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}tct.isMDXComponent=!0;const nct={toc:[]};function ect(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}ect.isMDXComponent=!0;const oct={toc:[]};function pct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}pct.isMDXComponent=!0;const sct={toc:[]};function rct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the desired size of this node."))}rct.isMDXComponent=!0;const cct={toc:[]};function act(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}act.isMDXComponent=!0;const ict={toc:[]};function lct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ict,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}lct.isMDXComponent=!0;const uct={toc:[]};function mct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}mct.isMDXComponent=!0;const dct={toc:[]};function hct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}hct.isMDXComponent=!0;const kct={toc:[]};function yct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}yct.isMDXComponent=!0;const fct={toc:[]};function Mct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Mct.isMDXComponent=!0;const wct={toc:[]};function Dct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}Dct.isMDXComponent=!0;const _ct={toc:[]};function Xct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_ct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}Xct.isMDXComponent=!0;const gct={toc:[]};function xct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}xct.isMDXComponent=!0;const Cct={toc:[]};function Tct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}Tct.isMDXComponent=!0;const vct={toc:[]};function bct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}bct.isMDXComponent=!0;const Lct={toc:[]};function Zct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}Zct.isMDXComponent=!0;const Nct={toc:[]};function Act(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Act.isMDXComponent=!0;const Rct={toc:[]};function Ect(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Ect.isMDXComponent=!0;const Sct={toc:[]};function zct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return a snapshot of the node's current signal values."))}zct.isMDXComponent=!0;const Ict={toc:[]};function Wct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ict,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}Wct.isMDXComponent=!0;const Pct={toc:[]};function Gct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}Gct.isMDXComponent=!0;const Bct={toc:[]};function Fct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Fct.isMDXComponent=!0;const Uct={toc:[]};function qct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}qct.isMDXComponent=!0;const Vct={toc:[]};function jct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}jct.isMDXComponent=!0;const Oct={toc:[]};function Hct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Oct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}Hct.isMDXComponent=!0;const $ct={toc:[]};function Kct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$ct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}Kct.isMDXComponent=!0;const Yct={toc:[]};function Jct(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}Jct.isMDXComponent=!0;const Qct={toc:[]};function tat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}tat.isMDXComponent=!0;const nat={toc:[]};function eat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}eat.isMDXComponent=!0;const oat={toc:[]};function pat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}pat.isMDXComponent=!0;const sat={toc:[]};function rat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}rat.isMDXComponent=!0;const cat={toc:[]};function aat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}aat.isMDXComponent=!0;const iat={toc:[]};function lat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}lat.isMDXComponent=!0;const uat={toc:[]};function mat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}mat.isMDXComponent=!0;const dat={toc:[]};function hat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}hat.isMDXComponent=!0;const kat={toc:[]};function yat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}yat.isMDXComponent=!0;const fat={toc:[]};function Mat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}Mat.isMDXComponent=!0;const wat={toc:[]};function Dat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Dat.isMDXComponent=!0;const _at={toc:[]};function Xat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_at,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Xat.isMDXComponent=!0;const gat={toc:[]};function xat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}xat.isMDXComponent=!0;const Cat={toc:[]};function Tat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Tat.isMDXComponent=!0;const vat={toc:[]};function bat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}bat.isMDXComponent=!0;const Lat={toc:[]};function Zat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Zat.isMDXComponent=!0;const Nat={toc:[]};function Aat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}Aat.isMDXComponent=!0;const Rat={toc:[]};function Eat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Eat.isMDXComponent=!0;const Sat={toc:[]};function zat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}zat.isMDXComponent=!0;const Iat={toc:[]};function Wat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Iat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}Wat.isMDXComponent=!0;const Pat={toc:[]};function Gat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Gat.isMDXComponent=!0;const Bat={toc:[]};function Fat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}Fat.isMDXComponent=!0;const Uat={toc:[]};function qat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}qat.isMDXComponent=!0;const Vat={toc:[]};function jat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the provided position relative to its siblings."))}jat.isMDXComponent=!0;const Oat={toc:[]};function Hat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Oat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index to move the node to."))}Hat.isMDXComponent=!0;const $at={toc:[]};function Kat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$at,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Kat.isMDXComponent=!0;const Yat={toc:[]};function Jat(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Jat.isMDXComponent=!0;const Qat={toc:[]};function tit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qat,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}tit.isMDXComponent=!0;const nit={toc:[]};function eit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}eit.isMDXComponent=!0;const oit={toc:[]};function pit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}pit.isMDXComponent=!0;const sit={toc:[]};function rit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}rit.isMDXComponent=!0;const cit={toc:[]};function ait(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ait.isMDXComponent=!0;const iit={toc:[]};function lit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}lit.isMDXComponent=!0;const uit={toc:[]};function mit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}mit.isMDXComponent=!0;const dit={toc:[]};function hit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}hit.isMDXComponent=!0;const kit={toc:[]};function yit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}yit.isMDXComponent=!0;const fit={toc:[]};function Mit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}Mit.isMDXComponent=!0;const wit={toc:[]};function Dit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}Dit.isMDXComponent=!0;const _it={toc:[]};function Xit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_it,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Xit.isMDXComponent=!0;const git={toc:[]};function xit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},git,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}xit.isMDXComponent=!0;const Cit={toc:[]};function Tit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}Tit.isMDXComponent=!0;const vit={toc:[]};function bit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}bit.isMDXComponent=!0;const Lit={toc:[]};function Zit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Zit.isMDXComponent=!0;const Nit={toc:[]};function Ait(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}Ait.isMDXComponent=!0;const Rit={toc:[]};function Eit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,r.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Eit.isMDXComponent=!0;const Sit={toc:[]};function zit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}zit.isMDXComponent=!0;const Iit={toc:[]};function Wit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Iit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Restore the node to its last saved state."))}Wit.isMDXComponent=!0;const Pit={toc:[]};function Git(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition"))}Git.isMDXComponent=!0;const Bit={toc:[]};function Fit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The timing function to use for the transition"))}Fit.isMDXComponent=!0;const Uit={toc:[]};function qit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,r.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}qit.isMDXComponent=!0;const Vit={toc:[]};function jit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}jit.isMDXComponent=!0;const Oit={toc:[]};function Hit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Oit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Hit.isMDXComponent=!0;const $it={toc:[]};function Kit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$it,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Kit.isMDXComponent=!0;const Yit={toc:[]};function Jit(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}Jit.isMDXComponent=!0;const Qit={toc:[]};function tlt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qit,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}tlt.isMDXComponent=!0;const nlt={toc:[]};function elt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nlt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}elt.isMDXComponent=!0;const olt={toc:[]};function plt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},olt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}plt.isMDXComponent=!0;const slt={toc:[]};function rlt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},slt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}rlt.isMDXComponent=!0;const clt={toc:[]};function alt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},clt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}alt.isMDXComponent=!0;const ilt={toc:[]};function llt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ilt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}llt.isMDXComponent=!0;const ult={toc:[]};function mlt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ult,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the same the bounding box returned by ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,r.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}mlt.isMDXComponent=!0;const dlt={toc:[]};function hlt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dlt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}hlt.isMDXComponent=!0;const klt={toc:[]};function ylt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},klt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}ylt.isMDXComponent=!0;const flt={toc:[]};function Mlt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},flt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Mlt.isMDXComponent=!0;const wlt={toc:[]};function Dlt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wlt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}Dlt.isMDXComponent=!0;const _lt={toc:[]};function Xlt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_lt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Xlt.isMDXComponent=!0;const glt={toc:[]};function xlt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},glt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}xlt.isMDXComponent=!0;const Clt={toc:[]};function Tlt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Clt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}Tlt.isMDXComponent=!0;const vlt={toc:[]};function blt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vlt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Defining knots using the ",(0,r.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,r.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,r.kt)("p",null,"Defining knots with ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,r.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}blt.isMDXComponent=!0;const Llt={toc:[]};function Zlt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Llt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node for drawing a smooth line through a number of points."))}Zlt.isMDXComponent=!0;const Nlt={toc:[]};function Alt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nlt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}Alt.isMDXComponent=!0;const Rlt={toc:[]};function Elt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rlt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}Elt.isMDXComponent=!0;const Slt={toc:[]};function zlt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Slt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}zlt.isMDXComponent=!0;const Ilt={toc:[]};function Wlt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ilt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Wlt.isMDXComponent=!0;const Plt={toc:[]};function Glt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Plt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}Glt.isMDXComponent=!0;const Blt={toc:[]};function Flt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Blt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}Flt.isMDXComponent=!0;const Ult={toc:[]};function qlt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ult,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}qlt.isMDXComponent=!0;const Vlt={toc:[]};function jlt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vlt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}jlt.isMDXComponent=!0;const Olt={toc:[]};function Hlt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Olt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Hlt.isMDXComponent=!0;const $lt={toc:[]};function Klt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$lt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}Klt.isMDXComponent=!0;const Ylt={toc:[]};function Jlt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ylt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Jlt.isMDXComponent=!0;const Qlt={toc:[]};function tut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qlt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}tut.isMDXComponent=!0;const nut={toc:[]};function eut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}eut.isMDXComponent=!0;const out={toc:[]};function put(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},out,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}put.isMDXComponent=!0;const sut={toc:[]};function rut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}rut.isMDXComponent=!0;const cut={toc:[]};function aut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}aut.isMDXComponent=!0;const iut={toc:[]};function lut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}lut.isMDXComponent=!0;const uut={toc:[]};function mut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"0.4"))}mut.isMDXComponent=!0;const dut={toc:[]};function hut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}hut.isMDXComponent=!0;const kut={toc:[]};function yut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}yut.isMDXComponent=!0;const fut={toc:[]};function Mut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Mut.isMDXComponent=!0;const wut={toc:[]};function Dut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}Dut.isMDXComponent=!0;const _ut={toc:[]};function Xut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_ut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}Xut.isMDXComponent=!0;const gut={toc:[]};function xut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}xut.isMDXComponent=!0;const Cut={toc:[]};function Tut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The state to apply to the node."))}Tut.isMDXComponent=!0;const vut={toc:[]};function but(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}but.isMDXComponent=!0;const Lut={toc:[]};function Zut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Zut.isMDXComponent=!0;const Nut={toc:[]};function Aut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}Aut.isMDXComponent=!0;const Rut={toc:[]};function Eut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}Eut.isMDXComponent=!0;const Sut={toc:[]};function zut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}zut.isMDXComponent=!0;const Iut={toc:[]};function Wut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Iut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Wut.isMDXComponent=!0;const Put={toc:[]};function Gut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Put,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}Gut.isMDXComponent=!0;const But={toc:[]};function Fut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},But,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Fut.isMDXComponent=!0;const Uut={toc:[]};function qut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the desired size of this node."))}qut.isMDXComponent=!0;const Vut={toc:[]};function jut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}jut.isMDXComponent=!0;const Out={toc:[]};function Hut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Out,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}Hut.isMDXComponent=!0;const $ut={toc:[]};function Kut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$ut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Kut.isMDXComponent=!0;const Yut={toc:[]};function Jut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}Jut.isMDXComponent=!0;const Qut={toc:[]};function tmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}tmt.isMDXComponent=!0;const nmt={toc:[]};function emt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nmt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}emt.isMDXComponent=!0;const omt={toc:[]};function pmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},omt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}pmt.isMDXComponent=!0;const smt={toc:[]};function rmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},smt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}rmt.isMDXComponent=!0;const cmt={toc:[]};function amt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cmt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}amt.isMDXComponent=!0;const imt={toc:[]};function lmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},imt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}lmt.isMDXComponent=!0;const umt={toc:[]};function mmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},umt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}mmt.isMDXComponent=!0;const dmt={toc:[]};function hmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dmt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}hmt.isMDXComponent=!0;const kmt={toc:[]};function ymt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kmt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}ymt.isMDXComponent=!0;const fmt={toc:[]};function Mmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fmt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Mmt.isMDXComponent=!0;const wmt={toc:[]};function Dmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wmt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return a snapshot of the node's current signal values."))}Dmt.isMDXComponent=!0;const _mt={toc:[]};function Xmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_mt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}Xmt.isMDXComponent=!0;const gmt={toc:[]};function xmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gmt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}xmt.isMDXComponent=!0;const Cmt={toc:[]};function Tmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cmt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Tmt.isMDXComponent=!0;const vmt={toc:[]};function bmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vmt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}bmt.isMDXComponent=!0;const Lmt={toc:[]};function Zmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lmt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}Zmt.isMDXComponent=!0;const Nmt={toc:[]};function Amt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nmt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}Amt.isMDXComponent=!0;const Rmt={toc:[]};function Emt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rmt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}Emt.isMDXComponent=!0;const Smt={toc:[]};function zmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Smt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}zmt.isMDXComponent=!0;const Imt={toc:[]};function Wmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Imt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Wmt.isMDXComponent=!0;const Pmt={toc:[]};function Gmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pmt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}Gmt.isMDXComponent=!0;const Bmt={toc:[]};function Fmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bmt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Fmt.isMDXComponent=!0;const Umt={toc:[]};function qmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Umt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}qmt.isMDXComponent=!0;const Vmt={toc:[]};function jmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vmt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}jmt.isMDXComponent=!0;const Omt={toc:[]};function Hmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Omt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Hmt.isMDXComponent=!0;const $mt={toc:[]};function Kmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$mt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}Kmt.isMDXComponent=!0;const Ymt={toc:[]};function Jmt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ymt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Jmt.isMDXComponent=!0;const Qmt={toc:[]};function tdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qmt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}tdt.isMDXComponent=!0;const ndt={toc:[]};function edt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ndt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}edt.isMDXComponent=!0;const odt={toc:[]};function pdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},odt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}pdt.isMDXComponent=!0;const sdt={toc:[]};function rdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sdt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node above the provided node in the parent's layout."))}rdt.isMDXComponent=!0;const cdt={toc:[]};function adt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cdt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}adt.isMDXComponent=!0;const idt={toc:[]};function ldt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},idt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}ldt.isMDXComponent=!0;const udt={toc:[]};function mdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},udt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}mdt.isMDXComponent=!0;const ddt={toc:[]};function hdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ddt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node below the provided node in the parent's layout."))}hdt.isMDXComponent=!0;const kdt={toc:[]};function ydt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kdt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}ydt.isMDXComponent=!0;const fdt={toc:[]};function Mdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fdt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Mdt.isMDXComponent=!0;const wdt={toc:[]};function Ddt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wdt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Ddt.isMDXComponent=!0;const _dt={toc:[]};function Xdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_dt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}Xdt.isMDXComponent=!0;const gdt={toc:[]};function xdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gdt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}xdt.isMDXComponent=!0;const Cdt={toc:[]};function Tdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cdt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}Tdt.isMDXComponent=!0;const vdt={toc:[]};function bdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vdt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}bdt.isMDXComponent=!0;const Ldt={toc:[]};function Zdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ldt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Zdt.isMDXComponent=!0;const Ndt={toc:[]};function Adt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ndt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index to move the node to."))}Adt.isMDXComponent=!0;const Rdt={toc:[]};function Edt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rdt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Edt.isMDXComponent=!0;const Sdt={toc:[]};function zdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sdt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}zdt.isMDXComponent=!0;const Idt={toc:[]};function Wdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Idt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Wdt.isMDXComponent=!0;const Pdt={toc:[]};function Gdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pdt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}Gdt.isMDXComponent=!0;const Bdt={toc:[]};function Fdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bdt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Fdt.isMDXComponent=!0;const Udt={toc:[]};function qdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Udt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}qdt.isMDXComponent=!0;const Vdt={toc:[]};function jdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vdt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}jdt.isMDXComponent=!0;const Odt={toc:[]};function Hdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Odt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}Hdt.isMDXComponent=!0;const $dt={toc:[]};function Kdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$dt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}Kdt.isMDXComponent=!0;const Ydt={toc:[]};function Jdt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ydt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}Jdt.isMDXComponent=!0;const Qdt={toc:[]};function tht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qdt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}tht.isMDXComponent=!0;const nht={toc:[]};function eht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}eht.isMDXComponent=!0;const oht={toc:[]};function pht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}pht.isMDXComponent=!0;const sht={toc:[]};function rht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}rht.isMDXComponent=!0;const cht={toc:[]};function aht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}aht.isMDXComponent=!0;const iht={toc:[]};function lht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}lht.isMDXComponent=!0;const uht={toc:[]};function mht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}mht.isMDXComponent=!0;const dht={toc:[]};function hht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}hht.isMDXComponent=!0;const kht={toc:[]};function yht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}yht.isMDXComponent=!0;const fht={toc:[]};function Mht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,r.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Mht.isMDXComponent=!0;const wht={toc:[]};function Dht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Dht.isMDXComponent=!0;const _ht={toc:[]};function Xht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_ht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Restore the node to its last saved state."))}Xht.isMDXComponent=!0;const ght={toc:[]};function xht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ght,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition"))}xht.isMDXComponent=!0;const Cht={toc:[]};function Tht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The timing function to use for the transition"))}Tht.isMDXComponent=!0;const vht={toc:[]};function bht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,r.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}bht.isMDXComponent=!0;const Lht={toc:[]};function Zht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Zht.isMDXComponent=!0;const Nht={toc:[]};function Aht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Aht.isMDXComponent=!0;const Rht={toc:[]};function Eht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Eht.isMDXComponent=!0;const Sht={toc:[]};function zht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}zht.isMDXComponent=!0;const Iht={toc:[]};function Wht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Iht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Wht.isMDXComponent=!0;const Pht={toc:[]};function Ght(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}Ght.isMDXComponent=!0;const Bht={toc:[]};function Fht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}Fht.isMDXComponent=!0;const Uht={toc:[]};function qht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}qht.isMDXComponent=!0;const Vht={toc:[]};function jht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}jht.isMDXComponent=!0;const Oht={toc:[]};function Hht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Oht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}Hht.isMDXComponent=!0;const $ht={toc:[]};function Kht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$ht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the same the bounding box returned by ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,r.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Kht.isMDXComponent=!0;const Yht={toc:[]};function Jht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Jht.isMDXComponent=!0;const Qht={toc:[]};function tkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}tkt.isMDXComponent=!0;const nkt={toc:[]};function ekt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nkt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}ekt.isMDXComponent=!0;const okt={toc:[]};function pkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},okt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}pkt.isMDXComponent=!0;const skt={toc:[]};function rkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},skt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}rkt.isMDXComponent=!0;const ckt={toc:[]};function akt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ckt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}akt.isMDXComponent=!0;const ikt={toc:[]};function lkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ikt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}lkt.isMDXComponent=!0;const ukt={toc:[]};function mkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ukt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}mkt.isMDXComponent=!0;const dkt={toc:[]};function hkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dkt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}hkt.isMDXComponent=!0;const kkt={toc:[]};function ykt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kkt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}ykt.isMDXComponent=!0;const fkt={toc:[]};function Mkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fkt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}Mkt.isMDXComponent=!0;const wkt={toc:[]};function Dkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wkt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}Dkt.isMDXComponent=!0;const _kt={toc:[]};function Xkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_kt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Xkt.isMDXComponent=!0;const gkt={toc:[]};function xkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gkt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}xkt.isMDXComponent=!0;const Ckt={toc:[]};function Tkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ckt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Tkt.isMDXComponent=!0;const vkt={toc:[]};function bkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vkt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}bkt.isMDXComponent=!0;const Lkt={toc:[]};function Zkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lkt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Zkt.isMDXComponent=!0;const Nkt={toc:[]};function Akt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nkt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Akt.isMDXComponent=!0;const Rkt={toc:[]};function Ekt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rkt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Ekt.isMDXComponent=!0;const Skt={toc:[]};function zkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Skt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}zkt.isMDXComponent=!0;const Ikt={toc:[]};function Wkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ikt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Wkt.isMDXComponent=!0;const Pkt={toc:[]};function Gkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pkt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}Gkt.isMDXComponent=!0;const Bkt={toc:[]};function Fkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bkt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}Fkt.isMDXComponent=!0;const Ukt={toc:[]};function qkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ukt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}qkt.isMDXComponent=!0;const Vkt={toc:[]};function jkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vkt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}jkt.isMDXComponent=!0;const Okt={toc:[]};function Hkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Okt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}Hkt.isMDXComponent=!0;const $kt={toc:[]};function Kkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$kt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Kkt.isMDXComponent=!0;const Ykt={toc:[]};function Jkt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ykt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The state to apply to the node."))}Jkt.isMDXComponent=!0;const Qkt={toc:[]};function tyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qkt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}tyt.isMDXComponent=!0;const nyt={toc:[]};function eyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}eyt.isMDXComponent=!0;const oyt={toc:[]};function pyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}pyt.isMDXComponent=!0;const syt={toc:[]};function ryt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},syt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}ryt.isMDXComponent=!0;const cyt={toc:[]};function ayt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}ayt.isMDXComponent=!0;const iyt={toc:[]};function lyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}lyt.isMDXComponent=!0;const uyt={toc:[]};function myt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}myt.isMDXComponent=!0;const dyt={toc:[]};function hyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}hyt.isMDXComponent=!0;const kyt={toc:[]};function yyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the desired size of this node."))}yyt.isMDXComponent=!0;const fyt={toc:[]};function Myt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Myt.isMDXComponent=!0;const wyt={toc:[]};function Dyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}Dyt.isMDXComponent=!0;const _yt={toc:[]};function Xyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_yt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Xyt.isMDXComponent=!0;const gyt={toc:[]};function xyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}xyt.isMDXComponent=!0;const Cyt={toc:[]};function Tyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}Tyt.isMDXComponent=!0;const vyt={toc:[]};function byt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}byt.isMDXComponent=!0;const Lyt={toc:[]};function Zyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}Zyt.isMDXComponent=!0;const Nyt={toc:[]};function Ayt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}Ayt.isMDXComponent=!0;const Ryt={toc:[]};function Eyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ryt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}Eyt.isMDXComponent=!0;const Syt={toc:[]};function zyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Syt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}zyt.isMDXComponent=!0;const Iyt={toc:[]};function Wyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Iyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Wyt.isMDXComponent=!0;const Pyt={toc:[]};function Gyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}Gyt.isMDXComponent=!0;const Byt={toc:[]};function Fyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Byt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Fyt.isMDXComponent=!0;const Uyt={toc:[]};function qyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}qyt.isMDXComponent=!0;const Vyt={toc:[]};function jyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return a snapshot of the node's current signal values."))}jyt.isMDXComponent=!0;const Oyt={toc:[]};function Hyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Oyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}Hyt.isMDXComponent=!0;const $yt={toc:[]};function Kyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$yt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}Kyt.isMDXComponent=!0;const Yyt={toc:[]};function Jyt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Jyt.isMDXComponent=!0;const Qyt={toc:[]};function tft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qyt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}tft.isMDXComponent=!0;const nft={toc:[]};function eft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}eft.isMDXComponent=!0;const oft={toc:[]};function pft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}pft.isMDXComponent=!0;const sft={toc:[]};function rft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}rft.isMDXComponent=!0;const cft={toc:[]};function aft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}aft.isMDXComponent=!0;const ift={toc:[]};function lft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ift,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}lft.isMDXComponent=!0;const uft={toc:[]};function mft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}mft.isMDXComponent=!0;const dft={toc:[]};function hft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}hft.isMDXComponent=!0;const kft={toc:[]};function yft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}yft.isMDXComponent=!0;const fft={toc:[]};function Mft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Mft.isMDXComponent=!0;const wft={toc:[]};function Dft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Dft.isMDXComponent=!0;const _ft={toc:[]};function Xft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_ft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}Xft.isMDXComponent=!0;const gft={toc:[]};function xft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}xft.isMDXComponent=!0;const Cft={toc:[]};function Tft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}Tft.isMDXComponent=!0;const vft={toc:[]};function bft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}bft.isMDXComponent=!0;const Lft={toc:[]};function Zft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Zft.isMDXComponent=!0;const Nft={toc:[]};function Aft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Aft.isMDXComponent=!0;const Rft={toc:[]};function Eft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}Eft.isMDXComponent=!0;const Sft={toc:[]};function zft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}zft.isMDXComponent=!0;const Ift={toc:[]};function Wft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ift,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Wft.isMDXComponent=!0;const Pft={toc:[]};function Gft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Gft.isMDXComponent=!0;const Bft={toc:[]};function Fft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}Fft.isMDXComponent=!0;const Uft={toc:[]};function qft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}qft.isMDXComponent=!0;const Vft={toc:[]};function jft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}jft.isMDXComponent=!0;const Oft={toc:[]};function Hft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Oft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}Hft.isMDXComponent=!0;const $ft={toc:[]};function Kft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$ft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Kft.isMDXComponent=!0;const Yft={toc:[]};function Jft(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}Jft.isMDXComponent=!0;const Qft={toc:[]};function tMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}tMt.isMDXComponent=!0;const nMt={toc:[]};function eMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the provided position relative to its siblings."))}eMt.isMDXComponent=!0;const oMt={toc:[]};function pMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index to move the node to."))}pMt.isMDXComponent=!0;const sMt={toc:[]};function rMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}rMt.isMDXComponent=!0;const cMt={toc:[]};function aMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}aMt.isMDXComponent=!0;const iMt={toc:[]};function lMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}lMt.isMDXComponent=!0;const uMt={toc:[]};function mMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}mMt.isMDXComponent=!0;const dMt={toc:[]};function hMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}hMt.isMDXComponent=!0;const kMt={toc:[]};function yMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}yMt.isMDXComponent=!0;const fMt={toc:[]};function MMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}MMt.isMDXComponent=!0;const wMt={toc:[]};function DMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}DMt.isMDXComponent=!0;const _Mt={toc:[]};function XMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_Mt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}XMt.isMDXComponent=!0;const gMt={toc:[]};function xMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}xMt.isMDXComponent=!0;const CMt={toc:[]};function TMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},CMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}TMt.isMDXComponent=!0;const vMt={toc:[]};function bMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}bMt.isMDXComponent=!0;const LMt={toc:[]};function ZMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},LMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}ZMt.isMDXComponent=!0;const NMt={toc:[]};function AMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},NMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}AMt.isMDXComponent=!0;const RMt={toc:[]};function EMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},RMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}EMt.isMDXComponent=!0;const SMt={toc:[]};function zMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},SMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}zMt.isMDXComponent=!0;const IMt={toc:[]};function WMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},IMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}WMt.isMDXComponent=!0;const PMt={toc:[]};function GMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},PMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}GMt.isMDXComponent=!0;const BMt={toc:[]};function FMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},BMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}FMt.isMDXComponent=!0;const UMt={toc:[]};function qMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},UMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,r.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qMt.isMDXComponent=!0;const VMt={toc:[]};function jMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},VMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}jMt.isMDXComponent=!0;const OMt={toc:[]};function HMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},OMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Restore the node to its last saved state."))}HMt.isMDXComponent=!0;const $Mt={toc:[]};function KMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$Mt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition"))}KMt.isMDXComponent=!0;const YMt={toc:[]};function JMt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},YMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The timing function to use for the transition"))}JMt.isMDXComponent=!0;const QMt={toc:[]};function twt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},QMt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,r.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}twt.isMDXComponent=!0;const nwt={toc:[]};function ewt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}ewt.isMDXComponent=!0;const owt={toc:[]};function pwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},owt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}pwt.isMDXComponent=!0;const swt={toc:[]};function rwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},swt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}rwt.isMDXComponent=!0;const cwt={toc:[]};function awt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}awt.isMDXComponent=!0;const iwt={toc:[]};function lwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lwt.isMDXComponent=!0;const uwt={toc:[]};function mwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}mwt.isMDXComponent=!0;const dwt={toc:[]};function hwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}hwt.isMDXComponent=!0;const kwt={toc:[]};function ywt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ywt.isMDXComponent=!0;const fwt={toc:[]};function Mwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Mwt.isMDXComponent=!0;const wwt={toc:[]};function Dwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}Dwt.isMDXComponent=!0;const _wt={toc:[]};function Xwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_wt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the same the bounding box returned by ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,r.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Xwt.isMDXComponent=!0;const gwt={toc:[]};function xwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}xwt.isMDXComponent=!0;const Cwt={toc:[]};function Twt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Twt.isMDXComponent=!0;const vwt={toc:[]};function bwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}bwt.isMDXComponent=!0;const Lwt={toc:[]};function Zwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}Zwt.isMDXComponent=!0;const Nwt={toc:[]};function Awt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Awt.isMDXComponent=!0;const Rwt={toc:[]};function Ewt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}Ewt.isMDXComponent=!0;const Swt={toc:[]};function zwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Swt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}zwt.isMDXComponent=!0;const Iwt={toc:[]};function Wwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Iwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}Wwt.isMDXComponent=!0;const Pwt={toc:[]};function Gwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Gwt.isMDXComponent=!0;const Bwt={toc:[]};function Fwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Fwt.isMDXComponent=!0;const Uwt={toc:[]};function qwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}qwt.isMDXComponent=!0;const Vwt={toc:[]};function jwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}jwt.isMDXComponent=!0;const Owt={toc:[]};function Hwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Owt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default the ",(0,r.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Hwt.isMDXComponent=!0;const $wt={toc:[]};function Kwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$wt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Kwt.isMDXComponent=!0;const Ywt={toc:[]};function Jwt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ywt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Controls the sharpness of the corners. ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,r.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."))}Jwt.isMDXComponent=!0;const Qwt={toc:[]};function tDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qwt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}tDt.isMDXComponent=!0;const nDt={toc:[]};function eDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}eDt.isMDXComponent=!0;const oDt={toc:[]};function pDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}pDt.isMDXComponent=!0;const sDt={toc:[]};function rDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}rDt.isMDXComponent=!0;const cDt={toc:[]};function aDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}aDt.isMDXComponent=!0;const iDt={toc:[]};function lDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}lDt.isMDXComponent=!0;const uDt={toc:[]};function mDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}mDt.isMDXComponent=!0;const dDt={toc:[]};function hDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}hDt.isMDXComponent=!0;const kDt={toc:[]};function yDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}yDt.isMDXComponent=!0;const fDt={toc:[]};function MDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}MDt.isMDXComponent=!0;const wDt={toc:[]};function DDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,r.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}DDt.isMDXComponent=!0;const _Dt={toc:[]};function XDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_Dt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}XDt.isMDXComponent=!0;const gDt={toc:[]};function xDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Will set the corner drawing method to smooth corners."))}xDt.isMDXComponent=!0;const CDt={toc:[]};function TDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},CDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}TDt.isMDXComponent=!0;const vDt={toc:[]};function bDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}bDt.isMDXComponent=!0;const LDt={toc:[]};function ZDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},LDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}ZDt.isMDXComponent=!0;const NDt={toc:[]};function ADt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},NDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}ADt.isMDXComponent=!0;const RDt={toc:[]};function EDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},RDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}EDt.isMDXComponent=!0;const SDt={toc:[]};function zDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},SDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The state to apply to the node."))}zDt.isMDXComponent=!0;const IDt={toc:[]};function WDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},IDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}WDt.isMDXComponent=!0;const PDt={toc:[]};function GDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},PDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}GDt.isMDXComponent=!0;const BDt={toc:[]};function FDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},BDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}FDt.isMDXComponent=!0;const UDt={toc:[]};function qDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},UDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}qDt.isMDXComponent=!0;const VDt={toc:[]};function jDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},VDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}jDt.isMDXComponent=!0;const ODt={toc:[]};function HDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ODt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}HDt.isMDXComponent=!0;const $Dt={toc:[]};function KDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$Dt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}KDt.isMDXComponent=!0;const YDt={toc:[]};function JDt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},YDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}JDt.isMDXComponent=!0;const QDt={toc:[]};function t_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},QDt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the desired size of this node."))}t_t.isMDXComponent=!0;const n_t={toc:[]};function e_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},n_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}e_t.isMDXComponent=!0;const o_t={toc:[]};function p_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},o_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}p_t.isMDXComponent=!0;const s_t={toc:[]};function r_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},s_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}r_t.isMDXComponent=!0;const c_t={toc:[]};function a_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},c_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}a_t.isMDXComponent=!0;const i_t={toc:[]};function l_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},i_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}l_t.isMDXComponent=!0;const u_t={toc:[]};function m_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},u_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}m_t.isMDXComponent=!0;const d_t={toc:[]};function h_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},d_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}h_t.isMDXComponent=!0;const k_t={toc:[]};function y_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},k_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}y_t.isMDXComponent=!0;const f_t={toc:[]};function M_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},f_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}M_t.isMDXComponent=!0;const w_t={toc:[]};function D_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},w_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}D_t.isMDXComponent=!0;const __t={toc:[]};function X_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},__t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}X_t.isMDXComponent=!0;const g_t={toc:[]};function x_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},g_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}x_t.isMDXComponent=!0;const C_t={toc:[]};function T_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},C_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}T_t.isMDXComponent=!0;const v_t={toc:[]};function b_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},v_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}b_t.isMDXComponent=!0;const L_t={toc:[]};function Z_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},L_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return a snapshot of the node's current signal values."))}Z_t.isMDXComponent=!0;const N_t={toc:[]};function A_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},N_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}A_t.isMDXComponent=!0;const R_t={toc:[]};function E_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},R_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}E_t.isMDXComponent=!0;const S_t={toc:[]};function z_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},S_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}z_t.isMDXComponent=!0;const I_t={toc:[]};function W_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},I_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}W_t.isMDXComponent=!0;const P_t={toc:[]};function G_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},P_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}G_t.isMDXComponent=!0;const B_t={toc:[]};function F_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},B_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}F_t.isMDXComponent=!0;const U_t={toc:[]};function q_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},U_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}q_t.isMDXComponent=!0;const V_t={toc:[]};function j_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},V_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}j_t.isMDXComponent=!0;const O_t={toc:[]};function H_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},O_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}H_t.isMDXComponent=!0;const $_t={toc:[]};function K_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}K_t.isMDXComponent=!0;const Y_t={toc:[]};function J_t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Y_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}J_t.isMDXComponent=!0;const Q_t={toc:[]};function tXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Q_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}tXt.isMDXComponent=!0;const nXt={toc:[]};function eXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}eXt.isMDXComponent=!0;const oXt={toc:[]};function pXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}pXt.isMDXComponent=!0;const sXt={toc:[]};function rXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}rXt.isMDXComponent=!0;const cXt={toc:[]};function aXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}aXt.isMDXComponent=!0;const iXt={toc:[]};function lXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}lXt.isMDXComponent=!0;const uXt={toc:[]};function mXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}mXt.isMDXComponent=!0;const dXt={toc:[]};function hXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}hXt.isMDXComponent=!0;const kXt={toc:[]};function yXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node above the provided node in the parent's layout."))}yXt.isMDXComponent=!0;const fXt={toc:[]};function MXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}MXt.isMDXComponent=!0;const wXt={toc:[]};function DXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}DXt.isMDXComponent=!0;const _Xt={toc:[]};function XXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_Xt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}XXt.isMDXComponent=!0;const gXt={toc:[]};function xXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node below the provided node in the parent's layout."))}xXt.isMDXComponent=!0;const CXt={toc:[]};function TXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},CXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}TXt.isMDXComponent=!0;const vXt={toc:[]};function bXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}bXt.isMDXComponent=!0;const LXt={toc:[]};function ZXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},LXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}ZXt.isMDXComponent=!0;const NXt={toc:[]};function AXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},NXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}AXt.isMDXComponent=!0;const RXt={toc:[]};function EXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},RXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}EXt.isMDXComponent=!0;const SXt={toc:[]};function zXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},SXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}zXt.isMDXComponent=!0;const IXt={toc:[]};function WXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},IXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}WXt.isMDXComponent=!0;const PXt={toc:[]};function GXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},PXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the provided position relative to its siblings."))}GXt.isMDXComponent=!0;const BXt={toc:[]};function FXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},BXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index to move the node to."))}FXt.isMDXComponent=!0;const UXt={toc:[]};function qXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},UXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}qXt.isMDXComponent=!0;const VXt={toc:[]};function jXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},VXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}jXt.isMDXComponent=!0;const OXt={toc:[]};function HXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},OXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}HXt.isMDXComponent=!0;const $Xt={toc:[]};function KXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$Xt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}KXt.isMDXComponent=!0;const YXt={toc:[]};function JXt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},YXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}JXt.isMDXComponent=!0;const QXt={toc:[]};function tgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},QXt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}tgt.isMDXComponent=!0;const ngt={toc:[]};function egt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ngt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}egt.isMDXComponent=!0;const ogt={toc:[]};function pgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ogt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}pgt.isMDXComponent=!0;const sgt={toc:[]};function rgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sgt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}rgt.isMDXComponent=!0;const cgt={toc:[]};function agt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cgt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}agt.isMDXComponent=!0;const igt={toc:[]};function lgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},igt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}lgt.isMDXComponent=!0;const ugt={toc:[]};function mgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ugt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}mgt.isMDXComponent=!0;const dgt={toc:[]};function hgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dgt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}hgt.isMDXComponent=!0;const kgt={toc:[]};function ygt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kgt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}ygt.isMDXComponent=!0;const fgt={toc:[]};function Mgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fgt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Mgt.isMDXComponent=!0;const wgt={toc:[]};function Dgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wgt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}Dgt.isMDXComponent=!0;const _gt={toc:[]};function Xgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_gt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Xgt.isMDXComponent=!0;const ggt={toc:[]};function xgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ggt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}xgt.isMDXComponent=!0;const Cgt={toc:[]};function Tgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cgt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}Tgt.isMDXComponent=!0;const vgt={toc:[]};function bgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vgt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,r.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}bgt.isMDXComponent=!0;const Lgt={toc:[]};function Zgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lgt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Zgt.isMDXComponent=!0;const Ngt={toc:[]};function Agt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ngt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Restore the node to its last saved state."))}Agt.isMDXComponent=!0;const Rgt={toc:[]};function Egt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rgt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition"))}Egt.isMDXComponent=!0;const Sgt={toc:[]};function zgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sgt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The timing function to use for the transition"))}zgt.isMDXComponent=!0;const Igt={toc:[]};function Wgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Igt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,r.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Wgt.isMDXComponent=!0;const Pgt={toc:[]};function Ggt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pgt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Ggt.isMDXComponent=!0;const Bgt={toc:[]};function Fgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bgt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Fgt.isMDXComponent=!0;const Ugt={toc:[]};function qgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ugt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}qgt.isMDXComponent=!0;const Vgt={toc:[]};function jgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vgt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}jgt.isMDXComponent=!0;const Ogt={toc:[]};function Hgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ogt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Hgt.isMDXComponent=!0;const $gt={toc:[]};function Kgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$gt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}Kgt.isMDXComponent=!0;const Ygt={toc:[]};function Jgt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ygt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}Jgt.isMDXComponent=!0;const Qgt={toc:[]};function txt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qgt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}txt.isMDXComponent=!0;const nxt={toc:[]};function ext(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}ext.isMDXComponent=!0;const oxt={toc:[]};function pxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}pxt.isMDXComponent=!0;const sxt={toc:[]};function rxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the same the bounding box returned by ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,r.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}rxt.isMDXComponent=!0;const cxt={toc:[]};function axt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}axt.isMDXComponent=!0;const ixt={toc:[]};function lxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ixt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}lxt.isMDXComponent=!0;const uxt={toc:[]};function mxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}mxt.isMDXComponent=!0;const dxt={toc:[]};function hxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}hxt.isMDXComponent=!0;const kxt={toc:[]};function yxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}yxt.isMDXComponent=!0;const fxt={toc:[]};function Mxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}Mxt.isMDXComponent=!0;const wxt={toc:[]};function Dxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}Dxt.isMDXComponent=!0;const _xt={toc:[]};function Xxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_xt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}Xxt.isMDXComponent=!0;const gxt={toc:[]};function xxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}xxt.isMDXComponent=!0;const Cxt={toc:[]};function Txt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Txt.isMDXComponent=!0;const vxt={toc:[]};function bxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}bxt.isMDXComponent=!0;const Lxt={toc:[]};function Zxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}Zxt.isMDXComponent=!0;const Nxt={toc:[]};function Axt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default the ",(0,r.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Axt.isMDXComponent=!0;const Rxt={toc:[]};function Ext(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Ext.isMDXComponent=!0;const Sxt={toc:[]};function zxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Controls the sharpness of the corners. ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,r.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."))}zxt.isMDXComponent=!0;const Ixt={toc:[]};function Wxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ixt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Wxt.isMDXComponent=!0;const Pxt={toc:[]};function Gxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}Gxt.isMDXComponent=!0;const Bxt={toc:[]};function Fxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Fxt.isMDXComponent=!0;const Uxt={toc:[]};function qxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}qxt.isMDXComponent=!0;const Vxt={toc:[]};function jxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}jxt.isMDXComponent=!0;const Oxt={toc:[]};function Hxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Oxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Hxt.isMDXComponent=!0;const $xt={toc:[]};function Kxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$xt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Kxt.isMDXComponent=!0;const Yxt={toc:[]};function Jxt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Jxt.isMDXComponent=!0;const Qxt={toc:[]};function tCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qxt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}tCt.isMDXComponent=!0;const nCt={toc:[]};function eCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}eCt.isMDXComponent=!0;const oCt={toc:[]};function pCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,r.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}pCt.isMDXComponent=!0;const sCt={toc:[]};function rCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}rCt.isMDXComponent=!0;const cCt={toc:[]};function aCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Will set the corner drawing method to smooth corners."))}aCt.isMDXComponent=!0;const iCt={toc:[]};function lCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}lCt.isMDXComponent=!0;const uCt={toc:[]};function mCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}mCt.isMDXComponent=!0;const dCt={toc:[]};function hCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}hCt.isMDXComponent=!0;const kCt={toc:[]};function yCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}yCt.isMDXComponent=!0;const fCt={toc:[]};function MCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}MCt.isMDXComponent=!0;const wCt={toc:[]};function DCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The state to apply to the node."))}DCt.isMDXComponent=!0;const _Ct={toc:[]};function XCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_Ct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}XCt.isMDXComponent=!0;const gCt={toc:[]};function xCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}xCt.isMDXComponent=!0;const CCt={toc:[]};function TCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},CCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}TCt.isMDXComponent=!0;const vCt={toc:[]};function bCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}bCt.isMDXComponent=!0;const LCt={toc:[]};function ZCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},LCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}ZCt.isMDXComponent=!0;const NCt={toc:[]};function ACt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},NCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}ACt.isMDXComponent=!0;const RCt={toc:[]};function ECt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},RCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}ECt.isMDXComponent=!0;const SCt={toc:[]};function zCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},SCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}zCt.isMDXComponent=!0;const ICt={toc:[]};function WCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ICt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the desired size of this node."))}WCt.isMDXComponent=!0;const PCt={toc:[]};function GCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},PCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}GCt.isMDXComponent=!0;const BCt={toc:[]};function FCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},BCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}FCt.isMDXComponent=!0;const UCt={toc:[]};function qCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},UCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}qCt.isMDXComponent=!0;const VCt={toc:[]};function jCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},VCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}jCt.isMDXComponent=!0;const OCt={toc:[]};function HCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},OCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}HCt.isMDXComponent=!0;const $Ct={toc:[]};function KCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$Ct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}KCt.isMDXComponent=!0;const YCt={toc:[]};function JCt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},YCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}JCt.isMDXComponent=!0;const QCt={toc:[]};function tTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},QCt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}tTt.isMDXComponent=!0;const nTt={toc:[]};function eTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}eTt.isMDXComponent=!0;const oTt={toc:[]};function pTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}pTt.isMDXComponent=!0;const sTt={toc:[]};function rTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}rTt.isMDXComponent=!0;const cTt={toc:[]};function aTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned bounding box should be in local space."))}aTt.isMDXComponent=!0;const iTt={toc:[]};function lTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}lTt.isMDXComponent=!0;const uTt={toc:[]};function mTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}mTt.isMDXComponent=!0;const dTt={toc:[]};function hTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return a snapshot of the node's current signal values."))}hTt.isMDXComponent=!0;const kTt={toc:[]};function yTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}yTt.isMDXComponent=!0;const fTt={toc:[]};function MTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}MTt.isMDXComponent=!0;const wTt={toc:[]};function DTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}DTt.isMDXComponent=!0;const _Tt={toc:[]};function XTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_Tt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}XTt.isMDXComponent=!0;const gTt={toc:[]};function xTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}xTt.isMDXComponent=!0;const CTt={toc:[]};function TTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},CTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}TTt.isMDXComponent=!0;const vTt={toc:[]};function bTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}bTt.isMDXComponent=!0;const LTt={toc:[]};function ZTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},LTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}ZTt.isMDXComponent=!0;const NTt={toc:[]};function ATt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},NTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ATt.isMDXComponent=!0;const RTt={toc:[]};function ETt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},RTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}ETt.isMDXComponent=!0;const STt={toc:[]};function zTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},STt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}zTt.isMDXComponent=!0;const ITt={toc:[]};function WTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ITt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}WTt.isMDXComponent=!0;const PTt={toc:[]};function GTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},PTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}GTt.isMDXComponent=!0;const BTt={toc:[]};function FTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},BTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}FTt.isMDXComponent=!0;const UTt={toc:[]};function qTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},UTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}qTt.isMDXComponent=!0;const VTt={toc:[]};function jTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},VTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}jTt.isMDXComponent=!0;const OTt={toc:[]};function HTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},OTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}HTt.isMDXComponent=!0;const $Tt={toc:[]};function KTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$Tt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}KTt.isMDXComponent=!0;const YTt={toc:[]};function JTt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},YTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}JTt.isMDXComponent=!0;const QTt={toc:[]};function tvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},QTt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node above the provided node in the parent's layout."))}tvt.isMDXComponent=!0;const nvt={toc:[]};function evt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}evt.isMDXComponent=!0;const ovt={toc:[]};function pvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ovt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}pvt.isMDXComponent=!0;const svt={toc:[]};function rvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},svt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}rvt.isMDXComponent=!0;const cvt={toc:[]};function avt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node below the provided node in the parent's layout."))}avt.isMDXComponent=!0;const ivt={toc:[]};function lvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ivt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The sibling node below which to move."))}lvt.isMDXComponent=!0;const uvt={toc:[]};function mvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}mvt.isMDXComponent=!0;const dvt={toc:[]};function hvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}hvt.isMDXComponent=!0;const kvt={toc:[]};function yvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}yvt.isMDXComponent=!0;const fvt={toc:[]};function Mvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Mvt.isMDXComponent=!0;const wvt={toc:[]};function Dvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}Dvt.isMDXComponent=!0;const _vt={toc:[]};function Xvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_vt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Xvt.isMDXComponent=!0;const gvt={toc:[]};function xvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the provided position relative to its siblings."))}xvt.isMDXComponent=!0;const Cvt={toc:[]};function Tvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The index to move the node to."))}Tvt.isMDXComponent=!0;const vvt={toc:[]};function bvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}bvt.isMDXComponent=!0;const Lvt={toc:[]};function Zvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Zvt.isMDXComponent=!0;const Nvt={toc:[]};function Avt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Avt.isMDXComponent=!0;const Rvt={toc:[]};function Evt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}Evt.isMDXComponent=!0;const Svt={toc:[]};function zvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Svt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}zvt.isMDXComponent=!0;const Ivt={toc:[]};function Wvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ivt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}Wvt.isMDXComponent=!0;const Pvt={toc:[]};function Gvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Gvt.isMDXComponent=!0;const Bvt={toc:[]};function Fvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}Fvt.isMDXComponent=!0;const Uvt={toc:[]};function qvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Uvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}qvt.isMDXComponent=!0;const Vvt={toc:[]};function jvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}jvt.isMDXComponent=!0;const Ovt={toc:[]};function Hvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ovt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}Hvt.isMDXComponent=!0;const $vt={toc:[]};function Kvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$vt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}Kvt.isMDXComponent=!0;const Yvt={toc:[]};function Jvt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Yvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}Jvt.isMDXComponent=!0;const Qvt={toc:[]};function tbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qvt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}tbt.isMDXComponent=!0;const nbt={toc:[]};function ebt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}ebt.isMDXComponent=!0;const obt={toc:[]};function pbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},obt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}pbt.isMDXComponent=!0;const sbt={toc:[]};function rbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}rbt.isMDXComponent=!0;const cbt={toc:[]};function abt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}abt.isMDXComponent=!0;const ibt={toc:[]};function lbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ibt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}lbt.isMDXComponent=!0;const ubt={toc:[]};function mbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ubt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,r.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}mbt.isMDXComponent=!0;const dbt={toc:[]};function hbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}hbt.isMDXComponent=!0;const kbt={toc:[]};function ybt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Restore the node to its last saved state."))}ybt.isMDXComponent=!0;const fbt={toc:[]};function Mbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition"))}Mbt.isMDXComponent=!0;const wbt={toc:[]};function Dbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The timing function to use for the transition"))}Dbt.isMDXComponent=!0;const _bt={toc:[]};function Xbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_bt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used together with the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,r.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Xbt.isMDXComponent=!0;const gbt={toc:[]};function xbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}xbt.isMDXComponent=!0;const Cbt={toc:[]};function Tbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Cbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Tbt.isMDXComponent=!0;const vbt={toc:[]};function bbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}bbt.isMDXComponent=!0;const Lbt={toc:[]};function Zbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Lbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}Zbt.isMDXComponent=!0;const Nbt={toc:[]};function Abt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Nbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Abt.isMDXComponent=!0;const Rbt={toc:[]};function Ebt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Rbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}Ebt.isMDXComponent=!0;const Sbt={toc:[]};function zbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Sbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}zbt.isMDXComponent=!0;const Ibt={toc:[]};function Wbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ibt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Wbt.isMDXComponent=!0;const Pbt={toc:[]};function Gbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Pbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Gbt.isMDXComponent=!0;const Bbt={toc:[]};function Fbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Bbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}Fbt.isMDXComponent=!0;const Ubt={toc:[]};function qbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ubt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the same the bounding box returned by ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,r.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qbt.isMDXComponent=!0;const Vbt={toc:[]};function jbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Vbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}jbt.isMDXComponent=!0;const Obt={toc:[]};function Hbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Obt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Hbt.isMDXComponent=!0;const $bt={toc:[]};function Kbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$bt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Kbt.isMDXComponent=!0;const Ybt={toc:[]};function Jbt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Ybt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}Jbt.isMDXComponent=!0;const Qbt={toc:[]};function tLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},Qbt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}tLt.isMDXComponent=!0;const nLt={toc:[]};function eLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}eLt.isMDXComponent=!0;const oLt={toc:[]};function pLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}pLt.isMDXComponent=!0;const sLt={toc:[]};function rLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the path of this circle should be closed."))}rLt.isMDXComponent=!0;const cLt={toc:[]};function aLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This property can be used together with ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,r.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}aLt.isMDXComponent=!0;const iLt={toc:[]};function lLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The ending angle in degrees for the circle sector."))}lLt.isMDXComponent=!0;const uLt={toc:[]};function mLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This property can be used together with ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,r.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}mLt.isMDXComponent=!0;const dLt={toc:[]};function hLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The starting angle in degrees for the circle sector."))}hLt.isMDXComponent=!0;const kLt={toc:[]};function yLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Provide the color in one of the following formats:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"named color like ",(0,r.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,r.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,r.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,r.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,r.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}yLt.isMDXComponent=!0;const fLt={toc:[]};function MLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The color of the icon"))}MLt.isMDXComponent=!0;const wLt={toc:[]};function DLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default the ",(0,r.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}DLt.isMDXComponent=!0;const _Lt={toc:[]};function XLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_Lt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Controls the sharpness of the corners. ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,r.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."))}XLt.isMDXComponent=!0;const gLt={toc:[]};function xLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"You can find identifiers on ",(0,r.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}xLt.isMDXComponent=!0;const CLt={toc:[]};function TLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},CLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The identifier of the icon."))}TLt.isMDXComponent=!0;const vLt={toc:[]};function bLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,r.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}bLt.isMDXComponent=!0;const LLt={toc:[]};function ZLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},LLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Will set the corner drawing method to smooth corners."))}ZLt.isMDXComponent=!0;const NLt={toc:[]};function ALt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},NLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default the ",(0,r.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}ALt.isMDXComponent=!0;const RLt={toc:[]};function ELt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},RLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Controls the sharpness of the corners. ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,r.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."))}ELt.isMDXComponent=!0;const SLt={toc:[]};function zLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},SLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,r.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}zLt.isMDXComponent=!0;const ILt={toc:[]};function WLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ILt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Will set the corner drawing method to smooth corners."))}WLt.isMDXComponent=!0;const PLt={toc:[]};function GLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},PLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}GLt.isMDXComponent=!0;const BLt={toc:[]};function FLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},BLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}FLt.isMDXComponent=!0;const ULt={toc:[]};function qLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ULt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,r.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,r.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,r.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,r.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,r.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}qLt.isMDXComponent=!0;const VLt={toc:[]};function jLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},VLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}jLt.isMDXComponent=!0;const OLt={toc:[]};function HLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},OLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,r.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,r.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,r.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,r.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,r.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}HLt.isMDXComponent=!0;const $Lt={toc:[]};function KLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$Lt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}KLt.isMDXComponent=!0;const YLt={toc:[]};function JLt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},YLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default the ",(0,r.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}JLt.isMDXComponent=!0;const QLt={toc:[]};function tZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},QLt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Controls the sharpness of the corners. ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,r.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."))}tZt.isMDXComponent=!0;const nZt={toc:[]};function eZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,r.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}eZt.isMDXComponent=!0;const oZt={toc:[]};function pZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Will set the corner drawing method to smooth corners."))}pZt.isMDXComponent=!0;const sZt={toc:[]};function rZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"For example, a value of 6 creates a hexagon."))}rZt.isMDXComponent=!0;const cZt={toc:[]};function aZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Sets the number of sides of the polygon."))}aZt.isMDXComponent=!0;const iZt={toc:[]};function lZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default the ",(0,r.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}lZt.isMDXComponent=!0;const uZt={toc:[]};function mZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Controls the sharpness of the corners. ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,r.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."))}mZt.isMDXComponent=!0;const dZt={toc:[]};function hZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,r.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}hZt.isMDXComponent=!0;const kZt={toc:[]};function yZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Will set the corner drawing method to smooth corners."))}yZt.isMDXComponent=!0;const fZt={toc:[]};function MZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}MZt.isMDXComponent=!0;const wZt={toc:[]};function DZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}DZt.isMDXComponent=!0;const _Zt={toc:[]};function XZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_Zt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default the ",(0,r.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}XZt.isMDXComponent=!0;const gZt={toc:[]};function xZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Controls the sharpness of the corners. ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,r.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."))}xZt.isMDXComponent=!0;const CZt={toc:[]};function TZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},CZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,r.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}TZt.isMDXComponent=!0;const vZt={toc:[]};function bZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Will set the corner drawing method to smooth corners."))}bZt.isMDXComponent=!0;const LZt={toc:[]};function ZZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},LZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}ZZt.isMDXComponent=!0;const NZt={toc:[]};function AZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},NZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Evaluate the polynomial at the given t value."))}AZt.isMDXComponent=!0;const RZt={toc:[]};function EZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},RZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The t value at which to evaluate the curve."))}EZt.isMDXComponent=!0;const SZt={toc:[]};function zZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},SZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}zZt.isMDXComponent=!0;const IZt={toc:[]};function WZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},IZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The t value at which to evaluate the curve."))}WZt.isMDXComponent=!0;const PZt={toc:[]};function GZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},PZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,r.kt)("p",null,"Source code liberally taken from:\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}GZt.isMDXComponent=!0;const BZt={toc:[]};function FZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},BZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The constant coefficient"))}FZt.isMDXComponent=!0;const UZt={toc:[]};function qZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},UZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The constant coefficient"))}qZt.isMDXComponent=!0;const VZt={toc:[]};function jZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},VZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The linear coefficient"))}jZt.isMDXComponent=!0;const OZt={toc:[]};function HZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},OZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The constant coefficient"))}HZt.isMDXComponent=!0;const $Zt={toc:[]};function KZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$Zt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The linear coefficient"))}KZt.isMDXComponent=!0;const YZt={toc:[]};function JZt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},YZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The quadratic coefficient"))}JZt.isMDXComponent=!0;const QZt={toc:[]};function tNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},QZt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The constant coefficient"))}tNt.isMDXComponent=!0;const nNt={toc:[]};function eNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The linear coefficient"))}eNt.isMDXComponent=!0;const oNt={toc:[]};function pNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The quadratic coefficient"))}pNt.isMDXComponent=!0;const sNt={toc:[]};function rNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The cubic coefficient"))}rNt.isMDXComponent=!0;const cNt={toc:[]};function aNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The degree of the polynomial"))}aNt.isMDXComponent=!0;const iNt={toc:[]};function lNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return the nth derivative of the polynomial."))}lNt.isMDXComponent=!0;const uNt={toc:[]};function mNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The number of times to differentiate the polynomial."))}mNt.isMDXComponent=!0;const dNt={toc:[]};function hNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Evaluate the polynomial at the given value t."))}hNt.isMDXComponent=!0;const kNt={toc:[]};function yNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value to sample at"))}yNt.isMDXComponent=!0;const fNt={toc:[]};function MNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}MNt.isMDXComponent=!0;const wNt={toc:[]};function DNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value to sample at"))}DNt.isMDXComponent=!0;const _Nt={toc:[]};function XNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_Nt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The derivative of the polynomial to sample from"))}XNt.isMDXComponent=!0;const gNt={toc:[]};function xNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the local extrema of the polynomial."))}xNt.isMDXComponent=!0;const CNt={toc:[]};function TNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},CNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}TNt.isMDXComponent=!0;const vNt={toc:[]};function bNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return the output value range within the unit interval."))}bNt.isMDXComponent=!0;const LNt={toc:[]};function ZNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},LNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}ZNt.isMDXComponent=!0;const NNt={toc:[]};function ANt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},NNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}ANt.isMDXComponent=!0;const RNt={toc:[]};function ENt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},RNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}ENt.isMDXComponent=!0;const SNt={toc:[]};function zNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},SNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The point at which to split the polynomial."))}zNt.isMDXComponent=!0;const INt={toc:[]};function WNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},INt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Constructs a constant polynomial"))}WNt.isMDXComponent=!0;const PNt={toc:[]};function GNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},PNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The constant coefficient"))}GNt.isMDXComponent=!0;const BNt={toc:[]};function FNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},BNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Constructs a cubic polynomial"))}FNt.isMDXComponent=!0;const UNt={toc:[]};function qNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},UNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The constant coefficient"))}qNt.isMDXComponent=!0;const VNt={toc:[]};function jNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},VNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The linear coefficient"))}jNt.isMDXComponent=!0;const ONt={toc:[]};function HNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ONt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The quadratic coefficient"))}HNt.isMDXComponent=!0;const $Nt={toc:[]};function KNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$Nt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The cubic coefficient"))}KNt.isMDXComponent=!0;const YNt={toc:[]};function JNt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},YNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Constructs a linear polynomial"))}JNt.isMDXComponent=!0;const QNt={toc:[]};function tAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},QNt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The constant coefficient"))}tAt.isMDXComponent=!0;const nAt={toc:[]};function eAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The linear coefficient"))}eAt.isMDXComponent=!0;const oAt={toc:[]};function pAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Constructs a quadratic polynomial"))}pAt.isMDXComponent=!0;const sAt={toc:[]};function rAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The constant coefficient"))}rAt.isMDXComponent=!0;const cAt={toc:[]};function aAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The linear coefficient"))}aAt.isMDXComponent=!0;const iAt={toc:[]};function lAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The quadratic coefficient"))}lAt.isMDXComponent=!0;const uAt={toc:[]};function mAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}mAt.isMDXComponent=!0;const dAt={toc:[]};function hAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}hAt.isMDXComponent=!0;const kAt={toc:[]};function yAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Evaluate the polynomial at the given t value."))}yAt.isMDXComponent=!0;const fAt={toc:[]};function MAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The t value at which to evaluate the curve."))}MAt.isMDXComponent=!0;const wAt={toc:[]};function DAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}DAt.isMDXComponent=!0;const _At={toc:[]};function XAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_At,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The t value at which to evaluate the curve."))}XAt.isMDXComponent=!0;const gAt={toc:[]};function xAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}xAt.isMDXComponent=!0;const CAt={toc:[]};function TAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},CAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The knots defining the spline"))}TAt.isMDXComponent=!0;const vAt={toc:[]};function bAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the spline should be closed or not"))}bAt.isMDXComponent=!0;const LAt={toc:[]};function ZAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},LAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}ZAt.isMDXComponent=!0;const NAt={toc:[]};function AAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},NAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}AAt.isMDXComponent=!0;const RAt={toc:[]};function EAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},RAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Check if the signal is currently using its initial value."))}EAt.isMDXComponent=!0;const SAt={toc:[]};function zAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},SAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,r.kt)("p",null,"This method can be used to create copies of signals."))}zAt.isMDXComponent=!0;const IAt={toc:[]};function WAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},IAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}WAt.isMDXComponent=!0;const PAt={toc:[]};function GAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},PAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the raw value of this signal."))}GAt.isMDXComponent=!0;const BAt={toc:[]};function FAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},BAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}FAt.isMDXComponent=!0;const UAt={toc:[]};function qAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},UAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}qAt.isMDXComponent=!0;const VAt={toc:[]};function jAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},VAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}jAt.isMDXComponent=!0;const OAt={toc:[]};function HAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},OAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}HAt.isMDXComponent=!0;const $At={toc:[]};function KAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$At,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Compute the current value of the signal and immediately set it."))}KAt.isMDXComponent=!0;const YAt={toc:[]};function JAt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},YAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,r.kt)("p",null,"By default, any property is cloneable."),(0,r.kt)("p",null,"Must be specified before the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,r.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}JAt.isMDXComponent=!0;const QAt={toc:[]};function tRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},QAt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}tRt.isMDXComponent=!0;const nRt={toc:[]};function eRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a cloneable property decorator."))}eRt.isMDXComponent=!0;const oRt={toc:[]};function pRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the property should be cloneable."))}pRt.isMDXComponent=!0;const sRt={toc:[]};function rRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}rRt.isMDXComponent=!0;const cRt={toc:[]};function aRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}aRt.isMDXComponent=!0;const iRt={toc:[]};function lRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a compound property decorator."))}lRt.isMDXComponent=!0;const uRt={toc:[]};function mRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}mRt.isMDXComponent=!0;const dRt={toc:[]};function hRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,r.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,r.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}hRt.isMDXComponent=!0;const kRt={toc:[]};function yRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a computed method decorator."))}yRt.isMDXComponent=!0;const fRt={toc:[]};function MRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This decorator specifies the initial value of a property."),(0,r.kt)("p",null,"Must be specified before the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,r.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}MRt.isMDXComponent=!0;const wRt={toc:[]};function DRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}DRt.isMDXComponent=!0;const _Rt={toc:[]};function XRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_Rt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an initial signal value decorator."))}XRt.isMDXComponent=!0;const gRt={toc:[]};function xRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The initial value of the property."))}xRt.isMDXComponent=!0;const CRt={toc:[]};function TRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},CRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,r.kt)("p",null,"By default, any property is inspectable."),(0,r.kt)("p",null,"Must be specified before the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,r.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}TRt.isMDXComponent=!0;const vRt={toc:[]};function bRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}bRt.isMDXComponent=!0;const LRt={toc:[]};function ZRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},LRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an inspectable property decorator."))}ZRt.isMDXComponent=!0;const NRt={toc:[]};function ARt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},NRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the property should be inspectable."))}ARt.isMDXComponent=!0;const RRt={toc:[]};function ERt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},RRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,r.kt)("p",null,"Must be specified before the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,r.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}ERt.isMDXComponent=!0;const SRt={toc:[]};function zRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},SRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}zRt.isMDXComponent=!0;const IRt={toc:[]};function WRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},IRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a signal interpolation function decorator."))}WRt.isMDXComponent=!0;const PRt={toc:[]};function GRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},PRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The interpolation function for the property."))}GRt.isMDXComponent=!0;const BRt={toc:[]};function FRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},BRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,r.kt)("p",null,"If the wrapper class has a method called ",(0,r.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,r.kt)("p",null,"Must be specified before the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,r.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}FRt.isMDXComponent=!0;const URt={toc:[]};function qRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},URt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}qRt.isMDXComponent=!0;const VRt={toc:[]};function jRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},VRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a signal parser decorator."))}jRt.isMDXComponent=!0;const ORt={toc:[]};function HRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},ORt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The wrapper class for the property."))}HRt.isMDXComponent=!0;const $Rt={toc:[]};function KRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$Rt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This decorator turns the given property into a signal."),(0,r.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}KRt.isMDXComponent=!0;const YRt={toc:[]};function JRt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},YRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}JRt.isMDXComponent=!0;const QRt={toc:[]};function tEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},QRt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a signal decorator."))}tEt.isMDXComponent=!0;const nEt={toc:[]};function eEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,r.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,r.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,r.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,r.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,r.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,r.kt)("p",null,"Must be specified before the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,r.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}eEt.isMDXComponent=!0;const oEt={toc:[]};function pEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}pEt.isMDXComponent=!0;const sEt={toc:[]};function rEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a signal wrapper decorator."))}rEt.isMDXComponent=!0;const cEt={toc:[]};function aEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},cEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The wrapper class for the property."))}aEt.isMDXComponent=!0;const iEt={toc:[]};function lEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},iEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A unified abstraction for all CSS filters."))}lEt.isMDXComponent=!0;const uEt={toc:[]};function mEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},uEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the desired length is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}mEt.isMDXComponent=!0;const dEt={toc:[]};function hEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},dEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}hEt.isMDXComponent=!0;const kEt={toc:[]};function yEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},kEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value can be either:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'"))))}yEt.isMDXComponent=!0;const fEt={toc:[]};function MEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},fEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents a length used by most layout properties."))}MEt.isMDXComponent=!0;const wEt={toc:[]};function DEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},wEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,r.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}DEt.isMDXComponent=!0;const _Et={toc:[]};function XEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},_Et,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,r.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}XEt.isMDXComponent=!0;const gEt={toc:[]};function xEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},gEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value of the filter in pixels."))}xEt.isMDXComponent=!0;const CEt={toc:[]};function TEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},CEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,r.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}TEt.isMDXComponent=!0;const vEt={toc:[]};function bEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},vEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value of the filter."))}bEt.isMDXComponent=!0;const LEt={toc:[]};function ZEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},LEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,r.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}ZEt.isMDXComponent=!0;const NEt={toc:[]};function AEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},NEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value of the filter."))}AEt.isMDXComponent=!0;const REt={toc:[]};function EEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},REt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,r.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}EEt.isMDXComponent=!0;const SEt={toc:[]};function zEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},SEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value of the filter."))}zEt.isMDXComponent=!0;const IEt={toc:[]};function WEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},IEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,r.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}WEt.isMDXComponent=!0;const PEt={toc:[]};function GEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},PEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value of the filter in degrees."))}GEt.isMDXComponent=!0;const BEt={toc:[]};function FEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},BEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,r.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}FEt.isMDXComponent=!0;const UEt={toc:[]};function qEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},UEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value of the filter."))}qEt.isMDXComponent=!0;const VEt={toc:[]};function jEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},VEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,r.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}jEt.isMDXComponent=!0;const OEt={toc:[]};function HEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},OEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value of the filter."))}HEt.isMDXComponent=!0;const $Et={toc:[]};function KEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},$Et,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,r.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}KEt.isMDXComponent=!0;const YEt={toc:[]};function JEt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},YEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value of the filter."))}JEt.isMDXComponent=!0;const QEt={toc:[]};function tSt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},QEt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}tSt.isMDXComponent=!0;const nSt={toc:[]};function eSt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},nSt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Invoke the given callback in the context of this scene."))}eSt.isMDXComponent=!0;const oSt={toc:[]};function pSt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},oSt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The callback to invoke."))}pSt.isMDXComponent=!0;const sSt={toc:[]};function rSt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,s.Z)({},sSt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the view."),(0,r.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,r.kt)("p",null,"Can modify the state of the view."))}function cSt(t){let{id:n}=t;const e=o[n]??p.Fragment;return p.createElement(e,null)}rSt.isMDXComponent=!0},79322:(t,n,e)=>{e.d(n,{Z:()=>m});var o=e(2784),p=e(97219),s=e(28698);const r="toggle_S_IX",c="collapsed_wdUB",a="collapse_TjTN",i="inverse_g6vW",l="clearFix_HQ1T";var u=e(6277);function m(t){let{comment:n,full:e=!0}=t;const s=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@remarks"===n}))}),[n]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==n?void 0:n.summaryId}),o.createElement(p.Z,{id:null==s?void 0:s.contentId}),e&&o.createElement(d,{comment:n}))}function d(t){let{comment:n}=t;const[e,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return(null==n||null==(t=n.blockTags)?void 0:t.filter((t=>{let{tag:n}=t;return"@example"===n})))??[]}),[n]),h=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@defaultValue"===n}))}),[n]),k=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@deprecated"===n}))}),[n]),y=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@see"===n}))}),[n]);return o.createElement(o.Fragment,null,d.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(r,e&&c),onClick:t=>{t.preventDefault(),m(!e)},href:"#"},"Examples")),o.createElement(s.z,{lazy:!0,as:"div",collapsed:e},o.createElement("div",{className:a},d.map((t=>o.createElement(p.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,i)})),h&&o.createElement(o.Fragment,null,"Default Value:"," ",o.createElement("code",null,h.content.map((t=>t.text)).join(""))),k&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(p.Z,{id:k.contentId})),y&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(p.Z,{id:y.contentId})))}},62830:(t,n,e)=>{e.d(n,{Z:()=>Tt});var o=e(2784),p=e(37390),s=e(66835),r=e(80068),c=e(6277),a=e(68569);const i={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=e(7896);function u(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({width:n,height:e,"aria-hidden":"true",viewBox:"0 0 24 24"},p),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:n,highlight:e,onClick:p,link:l}=t;const m=(0,s.F)(),d=(0,r.s2)();return o.createElement("div",{className:(0,c.Z)(a.Z.codeBlockContent,i.codeBlock,e&&i.highlight,p&&i.pointer)},o.createElement("pre",{onClick:p,onKeyDown:t=>{"Enter"===t.key&&(null==p||p())},tabIndex:0,ref:m.codeBlockRef,className:(0,c.Z)(a.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:a.Z.codeBlockLines,style:d},n)),l&&o.createElement("div",{className:a.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=e(39318);function h(t){let{children:n}=t;return o.createElement(d.Z,{as:"div",className:(0,c.Z)(i.codeBlockContainer,"language-typescript")},n)}var k=e(89817);function y(t){let{children:n,type:e,to:p,id:s,tooltip:c}=t;const a=(0,r.Ld)(e);return p?o.createElement(k.Z,(0,l.Z)({id:s,to:p,"data-tooltip":c},a),n):o.createElement("span",(0,l.Z)({id:s},a),n)}let f,M;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(f||(f={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(M||(M={}));const w={[f.None]:i.none,[f.Angle]:i.angle,[f.Curly]:i.curly,[f.Square]:i.square,[f.Parentheses]:i.parentheses};function D(t){let{children:n,type:e,separator:p=M.Comma}=t;return o.createElement("span",{className:(0,c.Z)(i.list,w[e??f.None])},o.createElement("span",{className:(0,c.Z)(i.elements,p!==M.Comma&&i.left)},(Array.isArray(n)?n:[n]).flatMap(((t,n)=>o.createElement("span",{"data-separator":p,key:n,className:i.element},t)))))}var _=e(88617);function X(t){var n;let{type:e}=t;const p=(0,_.RU)(e.project),s=null==p?void 0:p[e.id],r=e.externalUrl??(0,_.Gr)(s);return o.createElement(o.Fragment,null,o.createElement(y,{to:r,type:r?"class-name":"constant",tooltip:!0},e.name),!(null==(n=e.typeArguments)||!n.length)&&o.createElement(D,{type:f.Angle},e.typeArguments.map(((t,n)=>o.createElement(P,{key:n,type:t})))))}function g(t){let{type:n}=t;return o.createElement(y,{type:"keyword"},n.name)}function x(t){let{type:n}=t;return n.elements?o.createElement(D,{type:f.Square},n.elements.map(((t,n)=>o.createElement(P,{key:n,type:t})))):o.createElement(o.Fragment,null,"[]")}function C(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(P,{type:n.elementType}),"[]")}function T(t){let{type:n}=t;return o.createElement(D,{type:f.Parentheses,separator:M.Pipe},n.types.map(((t,n)=>o.createElement(P,{key:n,type:t}))))}function v(t){let{type:n}=t;const[e,p]=(0,o.useMemo)((()=>{if(null===n.value)return["null","keyword"];switch(typeof n.value){case"object":return[(n.value.negative?"-":"")+n.value.value,"number"];case"boolean":return[n.value,"keyword"];case"number":return[n.value,"number"];case"string":return[`'${n.value}'`,"string"];default:return[n.value,"constant"]}}),[n.value]);return o.createElement(y,{type:p},e)}function b(t){let{type:n}=t;return n.asserts?o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"asserts "),o.createElement(y,null,n.name," ")):o.createElement(o.Fragment,null,o.createElement(y,null,n.name," "),o.createElement(y,{type:"keyword"},"is "),o.createElement(P,{type:n.targetType}))}function L(t){let{type:n}=t;const e=(0,_.in)();return o.createElement(K,{reflection:e(n.declaration)})}function Z(t){let{type:n}=t;return o.createElement(D,{type:f.Parentheses,separator:M.Ampersand},n.types.map(((t,n)=>o.createElement(P,{key:n,type:t}))))}function N(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"string"},"`",n.head),n.tail.map(((t,n)=>{let[e,p]=t;return o.createElement(o.Fragment,null,"${",o.createElement(P,{key:n,type:e}),"}",o.createElement(y,{type:"string"},p))})),o.createElement(y,{type:"string"},"`"))}function A(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"typeof "),o.createElement(P,{type:n.queryType}))}function R(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(P,{type:n.checkType}),o.createElement(y,{type:"keyword"}," extends "),o.createElement(P,{type:n.extendsType})," ? ",o.createElement(P,{type:n.trueType})," : ",o.createElement(P,{type:n.falseType}))}function E(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"infer "),o.createElement(y,{type:"constant"},n.name))}function S(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(P,{type:n.objectType}),"[",o.createElement(P,{type:n.indexType}),"]")}function z(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},n.operator," "),o.createElement(P,{type:n.target}))}function I(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(D,{type:f.Curly},o.createElement(o.Fragment,null,"[",o.createElement(y,{type:"class"},n.parameter),o.createElement(y,{type:"keyword"}," in "),o.createElement(P,{type:n.parameterType}),"]: ",o.createElement(P,{type:n.templateType}))))}function W(t){let{type:n}=t;return o.createElement(o.Fragment,null,n.name,": ",o.createElement(P,{type:n.element}))}function P(t){const n=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return z;case"conditional":return R;case"reflection":return L;case"query":return A;case"named-tuple-member":return W;case"union":return T;case"intrinsic":return g;case"literal":return v;case"reference":return X;case"predicate":return b;case"tuple":return x;case"array":return C;case"intersection":return Z;case"inferred":return E;case"mapped":return I;case"template-literal":return N;case"indexedAccess":return S}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(n,t)}function G(t){let{flags:n,explicitAccessModifier:e}=t;const p=[];return null!=n&&n.isAbstract&&p.push("abstract"),null!=n&&n.isStatic&&p.push("static"),null!=n&&n.isConst&&p.push("const"),null!=n&&n.isReadonly&&p.push("readonly"),null!=n&&n.isPrivate&&p.push("private"),null!=n&&n.isProtected&&p.push("protected"),(null==n||!n.isPublic)&&(!e||null!=n&&n.isProtected||null!=n&&n.isPrivate)||p.push("public"),o.createElement(o.Fragment,null,p.map((t=>o.createElement(y,{key:t,type:"keyword"},t," "))))}function B(t){let{reflection:n}=t;const e="__namedParameters"===n.name?"{...}":n.name;return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),n.flags.isRest&&"...",o.createElement(y,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"plain"},e),n.flags.isOptional&&"?",": ",n.type&&o.createElement(P,{type:n.type}),n.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(y,{type:"plain"},n.defaultValue)))}function F(t){let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),n.varianceModifier&&o.createElement(y,{type:"keyword"},n.varianceModifier," "),o.createElement(y,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"class-name"},n.name),n.type&&o.createElement(o.Fragment,null," extends ",o.createElement(P,{type:n.type})),n.default&&o.createElement(o.Fragment,null," = ",o.createElement(P,{type:n.default})))}function U(t){var n,e;let{reflection:s,flags:r}=t;const c=(0,_.in)(),a="__type"===s.name;return o.createElement(o.Fragment,null,o.createElement(G,{flags:r??s.flags,explicitAccessModifier:!a}),s.kind===p.W.GetSignature&&o.createElement(y,{type:"keyword"},"get "),s.kind===p.W.SetSignature&&o.createElement(y,{type:"keyword"},"set "),s.overwrites&&o.createElement(o.Fragment,null,o.createElement(y,{to:s.overwrites.externalUrl??(0,_.Gr)(c(s.overwrites.id)),type:"keyword"},"override")," "),s.kind===p.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(y,{to:"#",type:"keyword"},"new")," ",o.createElement(y,{type:"plain"},s.type.name)):a?"":o.createElement(y,{type:"function"},s.name),!(null==(n=s.typeParameter)||!n.length)&&o.createElement(D,{type:f.Angle},s.typeParameter.map((t=>o.createElement(F,{key:t.id,reflection:c(t)})))),null!=(e=s.parameters)&&e.length?o.createElement(D,{type:f.Parentheses},s.parameters.map((t=>o.createElement(B,{key:t,reflection:c(t)})))):"()",s.type&&o.createElement(o.Fragment,null,a?" => ":": ",o.createElement(P,{type:s.type})))}function q(t){let{reflection:n}=t;return o.createElement(B,{reflection:n})}const V={[p.W.Namespace]:"namespace",[p.W.Enum]:"enum",[p.W.Class]:"class",[p.W.Interface]:"interface"};function j(t){var n,e,p;let{reflection:s}=t;const r=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(G,{flags:s.flags}),o.createElement(y,{type:"keyword"},V[s.kind]," "),o.createElement(y,{type:"class-name"},s.name),!(null==(n=s.typeParameters)||!n.length)&&o.createElement(D,{type:f.Angle},s.typeParameters.map((t=>o.createElement(F,{key:t.id,reflection:r(t)}))))," ",!(null==(e=s.extendedTypes)||!e.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"extends "),o.createElement(D,null,s.extendedTypes.map(((t,n)=>o.createElement(P,{key:n,type:t}))))),!(null==(p=s.implementedTypes)||!p.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"implements "),o.createElement(D,null,s.implementedTypes.map(((t,n)=>o.createElement(P,{key:n,type:t}))))))}function O(t){let{reflection:n}=t;const e=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),o.createElement(y,{type:"keyword"},"type "),o.createElement(y,{type:"class-name"},n.name),n.typeParameters&&o.createElement(D,{type:f.Angle},n.typeParameters.map((t=>o.createElement(F,{key:t.id,reflection:e(t)}))))," = ",o.createElement(P,{type:n.type}))}function H(t){let{reflection:n}=t;const e=(0,_.in)();return n.signatures?o.createElement(U,{reflection:n.signatures[0]}):n.children?o.createElement(D,{type:f.Curly},n.children.map((t=>o.createElement(K,{key:t.id,reflection:e(t)})))):o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"unknown"))}function $(t){var n;let{reflection:e}=t;const p=(null==(n=e.signatures)?void 0:n[0])??e.getSignature??e.setSignature??e.indexSignature;return o.createElement(U,{reflection:p})}function K(t){let{reflection:n}=t;const e=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:case p.W.Module:case p.W.EnumMember:case p.W.Variable:case p.W.Function:break;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return j;case p.W.Constructor:return U;case p.W.Property:return q;case p.W.Method:return $;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:break;case p.W.TypeLiteral:return H;case p.W.TypeParameter:return F;case p.W.Accessor:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return O;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.id]);return o.createElement(e,{reflection:n})}function Y(t){let{children:n}=t;const e=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!e.current)return;const t=e.current.closest("pre");if(t.scrollWidth>t.clientWidth){const n=Array.from(e.current.querySelectorAll(`.${i.elements}`)).sort(((t,n)=>function(t,n){return t>n?1:t<n?-1:0}(n.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&n.length>0;)n.shift().classList.add(i.wrap)}})),o.createElement(o.Fragment,null,n&&o.createElement("span",{ref:e,className:(0,c.Z)(i.line,"token-line")},n),o.createElement("br",null))}var J=e(79322),Q=e(97219);function tt(t){let{parameters:n}=t;const e=(0,_.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(F,{reflection:t})),o.createElement(Q.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{parameters:n}=t;const e=(0,_.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(B,{reflection:t})),o.createElement(Q.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{signatures:n,flags:e,source:p}=t;const s=(0,_.in)(),r=(0,o.useMemo)((()=>n.map(s)),[n]),[c,a]=(0,o.useState)(r[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,r.map((t=>o.createElement(m,{link:null==p?void 0:p.url,key:t.id,highlight:n.length>1&&t.id===c.id,onClick:n.length>1?()=>a(t):void 0},o.createElement(Y,null,o.createElement(U,{reflection:t,flags:e})))))),o.createElement(J.Z,{comment:c.comment}),o.createElement(tt,{parameters:c.typeParameter}),o.createElement(nt,{parameters:c.parameters}))}var ot=e(57708);function pt(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0},p),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const st="header_nSmr",rt="filters_z1iC",ct="icon_ROIU";function at(){const t=(0,o.useRef)(null),[n,e]=(0,o.useState)(!1),[p,s]=(0,ot.mN)();return(0,o.useEffect)((()=>{const n=n=>{t.current&&!t.current.contains(n.target)&&e(!1)};return document.addEventListener("mousedown",n),document.addEventListener("touchstart",n),()=>{document.removeEventListener("mousedown",n),document.removeEventListener("touchstart",n)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,c.Z)("dropdown dropdown--right margin-bottom--md",n&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),e(!n)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),e(!n))}},"Filters",o.createElement(pt,{className:ct})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,c.Z)("dropdown__link",p.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:p.private,onChange:t=>{s({...p,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&e(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,c.Z)("dropdown__link",p.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:p.inherited,onChange:t=>{s({...p,inherited:t.target.checked})}}),"Inherited members")))))}function it(t){let{children:n,kind:e}=t;return e===p.W.Class||e===p.W.Interface?o.createElement("div",{className:(0,c.Z)("row",st)},o.createElement("div",{className:(0,c.Z)("col",rt)},o.createElement(at,null)),o.createElement("div",{className:"col"},n)):o.createElement(o.Fragment,null,n)}var lt=e(53181),ut=e(83851),mt=e(77336),dt=e(82009);function ht(t){let{group:n}=t;return"Constructors"===n.title&&0===n.external.length&&1===n.nested.length?o.createElement(Tt,{reflection:n.nested[0]}):o.createElement(o.Fragment,null,n.external.length>0&&o.createElement("ul",null,n.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t})))))),n.nested.length>0&&n.nested.map(((t,n)=>o.createElement(o.Fragment,{key:t.id},n>0&&o.createElement("hr",null),o.createElement(Tt,{reflection:t})))))}function kt(t){let{group:n,project:e}=t;const p=(0,lt.TH)(),s=(0,_.RU)(e),r=p.hash.split("-")[0].slice(1),[c]=(0,ot.mN)(),a=(0,o.useMemo)((()=>(n.categories??[n]).map((t=>function(t,n,e){const o=[],p=[],s=[];for(const r of t.children){const t=n[r];t&&(0,ot.It)(e,t)&&(s.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:s}}(t,s,c))).filter((t=>!!t))),[n,s,c]);return(0,o.useEffect)((()=>{if(1===a.length)return;const t=p.hash.split("-")[0].slice(1);for(const n of a)if(n.anchors.includes(t))return}),[p.hash,a]),0===a.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h2",id:n.title},n.title),a.length>1?o.createElement(mt.Z,{groupId:n.title},a.map((t=>o.createElement(dt.Z,{default:t.anchors.includes(r),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(ht,{group:t}))))):o.createElement(ht,{group:a[0]}))}function yt(t){var n,e,p,s,r;let{reflection:c}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(n=c.sources)||null==(e=n[0])?void 0:e.url},o.createElement(Y,null,o.createElement(K,{reflection:c})))),o.createElement(it,{kind:c.kind},o.createElement(J.Z,{comment:c.comment})),o.createElement(tt,{parameters:c.typeParameters}),(null==(p=c.implementedBy)?void 0:p.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,c.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),(null==(s=c.extendedBy)?void 0:s.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,c.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),c.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:c.signatures})),null==(r=c.groups)?void 0:r.map((t=>o.createElement(kt,{group:t,key:t.title,project:c.project}))))}function ft(t){var n;let{reflection:e,headless:p}=t;const s=[...e.signatures??[],e.setSignature,e.getSignature,e.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!p&&(e.hasOwnPage?o.createElement("h1",null,e.name):o.createElement(ut.Z,{as:"h3",id:e.anchor},o.createElement("code",null,e.name))),o.createElement(et,{signatures:s,flags:e.flags,source:null==(n=e.sources)?void 0:n[0]}),e.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:e.inheritedFrom}))),e.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(X,{type:e.overwrites}))))}function Mt(t){var n,e;let{reflection:p,headless:s}=t;return o.createElement(o.Fragment,null,!s&&(p.hasOwnPage?o.createElement("h1",null,p.name):o.createElement(ut.Z,{as:"h3",id:p.anchor},o.createElement("code",null,p.name))),o.createElement(h,null,o.createElement(m,{link:null==(n=p.sources)||null==(e=n[0])?void 0:e.url},o.createElement(Y,null,o.createElement(q,{reflection:p})))),o.createElement(J.Z,{comment:p.comment}),p.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:p.inheritedFrom}))))}function wt(t){var n,e,p;let{reflection:s}=t;const r=(0,_.RU)(s.project);return o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h3",id:s.anchor},o.createElement("code",null,s.name)),o.createElement(h,null,o.createElement(m,{link:null==(n=s.sources)||null==(e=n[0])?void 0:e.url},o.createElement(Y,null,o.createElement(K,{reflection:s})))),o.createElement(J.Z,{comment:s.comment}),o.createElement(tt,{parameters:s.typeParameters}),s.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:s.signatures})),null==(p=s.groups)?void 0:p.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>r[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Tt,{key:t.id,reflection:t})))))))}var Dt=e(78128);function _t(t){var n;let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(Dt.Z,{language:"ts"},"import ","{...}",' from "',e.importPath,'";'),o.createElement(it,{kind:e.kind},o.createElement(J.Z,{comment:e.comment})),null==(n=e.groups)?void 0:n.map((t=>o.createElement(kt,{group:t,key:t.title,project:e.project}))))}const Xt="cardContainer_ybwo",gt="cardTitle_Ehd1",xt="cardDescription_b6wr";function Ct(t){let{reflection:n}=t;const e=(0,_.RU)(n.project),p=n.groups[0].children.map((t=>e[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,c.Z)("row")},p.map((t=>{var n;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(k.Z,{href:t.href,className:(0,c.Z)("card padding--lg",Xt)},o.createElement("h2",{className:(0,c.Z)("text--truncate",gt)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,c.Z)("text--truncate",xt)},(null==(n=t.comment)?void 0:n.summaryText)??"\xa0")))}))))}function Tt(t){let{reflection:n,headless:e=!1}=t;const s=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:return Ct;case p.W.Module:return _t;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return yt;case p.W.Function:case p.W.Accessor:case p.W.Constructor:case p.W.Method:return ft;case p.W.Variable:case p.W.Property:case p.W.EnumMember:return Mt;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:case p.W.TypeLiteral:case p.W.TypeParameter:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return wt;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.kind]);return o.createElement(s,{reflection:n,headless:e})}},37390:(t,n,e)=>{let o;e.d(n,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},88617:(t,n,e)=>{e.d(n,{Gr:()=>i,RU:()=>r,gs:()=>s,in:()=>c,rG:()=>a});var o=e(2784);const p=o.createContext({lookup:{},urlLookup:{}});function s(t){let{children:n,lookup:e,urlLookup:s}=t;return o.createElement(p.Provider,{value:{lookup:e,urlLookup:s}},n)}function r(t){const{lookup:n}=(0,o.useContext)(p);return n[t]}function c(){const{lookup:t}=(0,o.useContext)(p);return n=>{if("number"==typeof(null==n?void 0:n.project))return t[n.project][n.id]}}function a(){const{urlLookup:t,lookup:n}=(0,o.useContext)(p);return e=>{var o;const p=t[e];return p?(null==(o=n[p.projectId])?void 0:o[p.id])??null:null}}function i(t){if(t)return t.href}},80068:(t,n,e)=>{e.d(n,{Ld:()=>c,Y0:()=>r,s2:()=>a});var o=e(2784),p=e(50822);const s=o.createContext(null);function r(t){let{children:n}=t;const e=(0,p.p)(),r=(0,o.useMemo)((()=>function(t,n){const{plain:e}=t,o=Object.create(null),p=t.styles.reduce(((t,e)=>{const{languages:o,style:p}=e;return o&&!o.includes(n)||e.types.forEach((n=>{t[n]={...t[n],...p}})),t}),o);return p.root=e,p.plain={...e,backgroundColor:null},p}(e,"typescript")),[e]);return o.createElement(s.Provider,{value:r},n)}function c(t){void 0===t&&(t="plain");const n=(0,o.useContext)(s);return{className:`token ${t}`,style:n[t]??n.plain}}function a(t){void 0===t&&(t="plain");const n=(0,o.useContext)(s);return n[t]??n.plain}},57708:(t,n,e)=>{e.d(n,{It:()=>m,Wy:()=>l,mN:()=>u});var o=e(2784),p=e(31263),s=e(89741);const r="api-filters",c=p.Z.canUseDOM?localStorage.getItem(r):null,a=c?JSON.parse(c):{inherited:!0,private:!1},i=o.createContext([a,()=>{}]);function l(t){let{children:n}=t;const[e,p]=(0,o.useState)(a),c=(0,s.Z)();return o.createElement(i.Provider,{value:[e,t=>{c&&localStorage.setItem(r,JSON.stringify(t)),p(t)}]},n)}function u(){return(0,o.useContext)(i)}function m(t,n){var e,o;const p=(null==(e=n.flags)?void 0:e.isPrivate)||(null==(o=n.flags)?void 0:o.isProtected);if(!t.private&&p)return!1;const s=!!n.inheritedFrom;return!(!t.inherited&&s)}},81004:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>c,metadata:()=>i,toc:()=>u});var o=e(7896),p=(e(2784),e(30876)),s=e(52665),r=e(42072);const c={sidebar_position:4,slug:"/positioning"},a="Positioning",i={unversionedId:"getting-started/positioning",id:"getting-started/positioning",title:"Positioning",description:"Motion Canvas uses a Cartesian coordinate system. Its origin is located in the",source:"@site/docs/getting-started/positioning.mdx",sourceDirName:"getting-started",slug:"/positioning",permalink:"/docs/positioning",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/getting-started/positioning.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",sidebarPosition:4,frontMatter:{sidebar_position:4,slug:"/positioning"},sidebar:"docs",previous:{title:"Scene hierarchy",permalink:"/docs/hierarchy"},next:{title:"Layouts",permalink:"/docs/layouts"}},l={},u=[{value:"Transform",id:"transform",level:2},{value:"<code>Node.position</code>",id:"nodeposition",level:3},{value:"<code>Node.scale</code>",id:"nodescale",level:3},{value:"<code>Node.rotation</code>",id:"noderotation",level:3},{value:"Absolute transform",id:"absolute-transform",level:2},{value:"<code>Node.absolutePosition</code>",id:"nodeabsoluteposition",level:3},{value:"<code>Node.absoluteScale</code>",id:"nodeabsolutescale",level:3},{value:"<code>Node.absoluteRotation</code>",id:"nodeabsoluterotation",level:3},{value:"Matrices",id:"matrices",level:2},{value:"<code>Node.localToWorld</code>",id:"nodelocaltoworld",level:3},{value:"<code>Node.worldToLocal</code>",id:"nodeworldtolocal",level:3},{value:"<code>Node.localToParent</code>",id:"nodelocaltoparent",level:3},{value:"<code>Node.worldToParent</code>",id:"nodeworldtoparent",level:3}],m={toc:u};function d(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},m,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"positioning"},"Positioning"),(0,p.kt)(s.Z,{name:"positioning",banner:!0,mdxType:"AnimationPlayer"}),(0,p.kt)("p",null,"Motion Canvas uses a Cartesian coordinate system. Its origin is located in the\ncenter of the scene, with the x-axis going to the right and the y-axis going\ndown."),(0,p.kt)("h2",{id:"transform"},"Transform"),(0,p.kt)("p",null,"All nodes are positioned relatively to their parents. This means that any\ntransformations applied to the parent are also applied to its children. The\ntransform of each node consists of the following properties:"),(0,p.kt)("h3",{id:"nodeposition"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.position")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#position",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"nodescale"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.scale")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#scale",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"noderotation"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.rotation")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#rotation",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"absolute-transform"},"Absolute transform"),(0,p.kt)("p",null,"Each of the basic transform properties has a dedicated helper method that\noperates in world space."),(0,p.kt)("p",null,"This can be helpful, for instance, when we need to match the transforms of two\nnodes located within different parents. Consider the following example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const circleA = createRef<Node>();\nconst circleB = createRef<Node>();\n\nview.add(\n  <>\n    <Node position={[200, 100]}>\n      <Circle\n        position={[0, 100]}\n        ref={circleA}\n        width={20}\n        height={20}\n        fill={'white'}\n      />\n    </Node>\n    <Circle ref={circleB} width={10} height={10} fill={'red'} />\n  </>,\n);\n\ncircleB().absolutePosition(circleA().absolutePosition());\n")),(0,p.kt)("p",null,"We access the absolute position (position in world space) of ",(0,p.kt)("inlineCode",{parentName:"p"},"circleA")," and\nassign it as the absolute position of ",(0,p.kt)("inlineCode",{parentName:"p"},"circleB"),". This will move the ",(0,p.kt)("inlineCode",{parentName:"p"},"circleB"),"\nright on top of ",(0,p.kt)("inlineCode",{parentName:"p"},"circleA"),"."),(0,p.kt)("admonition",{type:"info"},(0,p.kt)("p",{parentName:"admonition"},"Note that we still need to set the ",(0,p.kt)("inlineCode",{parentName:"p"},"absolutePosition")," of ",(0,p.kt)("inlineCode",{parentName:"p"},"circleB")," and not just\nthe ",(0,p.kt)("inlineCode",{parentName:"p"},"position"),". It may seem redundant since ",(0,p.kt)("inlineCode",{parentName:"p"},"circleB")," is a direct child of the\nscene view. But the local space of the scene view is ",(0,p.kt)("strong",{parentName:"p"},"not")," the same as the\nworld space.")),(0,p.kt)("p",null,"All available world-space properties are listed below:"),(0,p.kt)("h3",{id:"nodeabsoluteposition"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.absolutePosition")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#absolutePosition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"nodeabsolutescale"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.absoluteScale")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#absoluteScale",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"nodeabsoluterotation"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.absoluteRotation")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#absoluteRotation",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"matrices"},"Matrices"),(0,p.kt)("p",null,"For more advanced uses, nodes expose all the matrices necessary to map vectors\nfrom one space to another. For example, the helper properties described above\ncould be reimplemented using the ",(0,p.kt)("inlineCode",{parentName:"p"},"worldToParent")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"localToWorld")," matrices:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// getting the absolute position:\nnode.absolutePosition();\n// same as:\nVector2.zero.transformAsPoint(node.localToWorld());\n\n// setting the absolute position:\nnode.absolutePosition(vector);\n// same as:\nnode.position(vector.transformAsPoint(node.worldToParent()));\n")),(0,p.kt)("p",null,"The available matrices include:"),(0,p.kt)("h3",{id:"nodelocaltoworld"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.localToWorld")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#localToWorld",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"nodeworldtolocal"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.worldToLocal")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#worldToLocal",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"nodelocaltoparent"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.localToParent")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#localToParent",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"nodeworldtoparent"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.worldToParent")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#worldToParent",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null))}d.isMDXComponent=!0}}]);
(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[3239],{61532:t=>{function e(t){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}e.keys=()=>[],e.resolve=e,e.id=61532,t.exports=e},70989:(t,e,n)=>{"use strict";n.d(e,{A:()=>M});var o=n(93091),s=n(88104),r=n(15688);function p(t,e){return void 0===e&&(e=t=>t),(n,o)=>{n[`getDefault${(0,r.k)(o)}`]=function(){this.requestLayoutUpdate();const n=this.element.style[t];this.element.style[t]="";const o=e.call(this,this.styles.getPropertyValue(t));return this.element.style[t]=n,o}}}var i=n(46350),c=n(5788),a=n(29797),l=n(23357),u=n(98378),m=n(74534),d=n(67292),h=n(20092),f=n(11258),y=n(53693),k=n(68003),w=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class M extends h.N{get columnGap(){return this.gap.x}get rowGap(){return this.gap.y}getX(){return this.isLayoutRoot()?this.x.context.getter():this.computedPosition().x}setX(t){this.x.context.setter(t)}getY(){return this.isLayoutRoot()?this.y.context.getter():this.computedPosition().y}setY(t){this.y.context.setter(t)}get width(){return this.size.x}get height(){return this.size.y}getWidth(){return this.computedSize().width}setWidth(t){this.width.context.setter(t)}*tweenWidth(t,e,n,o){const s=this.desiredSize().x,r="number"!=typeof s||"number"!=typeof t;let p,i;p=r?this.size.x():s,r?(this.size.x(t),i=this.size.x()):i=t,this.size.x(p),r&&this.lockSize(),yield*(0,m.i)(e,(t=>this.size.x(o(p,i,n(t))))),this.size.x(t),r&&this.releaseSize()}getHeight(){return this.computedSize().height}setHeight(t){this.height.context.setter(t)}*tweenHeight(t,e,n,o){const s=this.desiredSize().y,r="number"!=typeof s||"number"!=typeof t;let p,i;p=r?this.size.y():s,r?(this.size.y(t),i=this.size.y()):i=t,this.size.y(p),r&&this.lockSize(),yield*(0,m.i)(e,(t=>this.size.y(o(p,i,n(t))))),this.size.y(t),r&&this.releaseSize()}desiredSize(){return{x:this.width.context.getter(),y:this.height.context.getter()}}*tweenSize(t,e,n,o){const s=this.desiredSize();let r,p;r="number"!=typeof s.x||"number"!=typeof s.y?this.size():new a.F(s),"object"==typeof t&&"number"==typeof t.x&&"number"==typeof t.y?p=new a.F(t):(this.size(t),p=this.size()),this.size(r),this.lockSize(),yield*(0,m.i)(e,(t=>this.size(o(r,p,n(t))))),this.releaseSize(),this.size(t)}constructor(t){super(t)}lockSize(){this.sizeLockCounter(this.sizeLockCounter()+1)}releaseSize(){this.sizeLockCounter(this.sizeLockCounter()-1)}parentTransform(){let t=this.parent();for(;t;){if(t instanceof M)return t;t=t.parent()}return null}anchorPosition(){const t=this.computedSize(),e=this.offset();return t.scale(.5).mul(e)}layoutEnabled(){var t;return this.layout()??(null==(t=this.parentTransform())?void 0:t.layoutEnabled())??!1}isLayoutRoot(){var t;return!this.layoutEnabled()||!(null!=(t=this.parentTransform())&&t.layoutEnabled())}localToParent(){const t=new DOMMatrix;t.translateSelf(this.x(),this.y()),t.rotateSelf(0,0,this.rotation()),t.scaleSelf(this.scale.x(),this.scale.y());const e=this.offset();if(!e.exactlyEquals(a.F.zero)){const n=this.size().mul(e).scale(-.5);t.translateSelf(n.x,n.y)}return t}scalingRotationMatrix(){const t=new DOMMatrix;t.rotateSelf(0,0,this.rotation()),t.scaleSelf(this.scale.x(),this.scale.y());const e=this.offset();if(!e.exactlyEquals(a.F.zero)){const n=this.size().mul(e).scale(-.5);t.translateSelf(n.x,n.y)}return t}getComputedLayout(){return new l.b(this.element.getBoundingClientRect())}computedPosition(){this.requestLayoutUpdate();const t=this.getComputedLayout(),e=new a.F(t.x+t.width/2*this.offset.x(),t.y+t.height/2*this.offset.y()),n=this.parentTransform();if(n){const o=n.getComputedLayout();e.x-=o.x+(o.width-t.width)/2,e.y-=o.y+(o.height-t.height)/2}return e}computedSize(){return this.requestLayoutUpdate(),this.getComputedLayout().size}requestLayoutUpdate(){const t=this.parentTransform();this.appendedToView()?(null==t||t.requestFontUpdate(),this.updateLayout()):t.requestLayoutUpdate()}appendedToView(){const t=this.isLayoutRoot();return t&&this.view().element.append(this.element),t}updateLayout(){if(this.applyFont(),this.applyFlex(),this.layoutEnabled()){const t=this.layoutChildren();for(const e of t)e.updateLayout()}}layoutChildren(){const t=[...this.children()],e=[],n=[];for(;t.length;){const o=t.shift();o instanceof M?(e.push(o),n.push(o.element)):o&&t.unshift(...o.children())}return this.element.replaceChildren(...n),e}requestFontUpdate(){var t;this.appendedToView(),null==(t=this.parentTransform())||t.requestFontUpdate(),this.applyFont()}getCacheBBox(){return l.b.fromSizeCentered(this.computedSize())}draw(t){if(this.clip()){const e=this.computedSize();if(0===e.width||0===e.height)return;t.beginPath(),t.rect(e.width/-2,e.height/-2,e.width,e.height),t.closePath(),t.clip()}this.drawChildren(t)}drawOverlay(t,e){const n=this.computedSize(),o=n.mul(this.offset()).scale(.5).transformAsPoint(e),s=l.b.fromSizeCentered(n),r=s.transformCorners(e),p=s.addSpacing(this.padding().scale(-1)).transformCorners(e),i=s.addSpacing(this.margin()).transformCorners(e);t.beginPath(),(0,f.pS)(t,i),(0,f.pS)(t,r),t.closePath(),t.fillStyle="rgba(255,193,125,0.6)",t.fill("evenodd"),t.beginPath(),(0,f.pS)(t,r),(0,f.pS)(t,p),t.closePath(),t.fillStyle="rgba(180,255,147,0.6)",t.fill("evenodd"),t.beginPath(),(0,f.pS)(t,r),t.closePath(),t.lineWidth=1,t.strokeStyle="white",t.stroke(),t.beginPath(),(0,f.wp)(t,o),t.stroke()}getOriginDelta(t){const e=this.computedSize().scale(.5),n=this.offset().mul(e);if(t===u.aP.Middle)return n.flipped;return(0,u.WS)(t).mul(e).sub(n)}moveOffset(t){const e=this.computedSize().scale(.5),n=this.offset().mul(e),o=t.mul(e);this.offset(t),this.position(this.position().add(o).sub(n))}parsePixels(t){return null===t?"":`${t}px`}parseLength(t){return null===t?"":"string"==typeof t?t:`${t}px`}applyFlex(){this.element.style.position=this.isLayoutRoot()?"absolute":"relative";const t=this.desiredSize();this.element.style.width=this.parseLength(t.x),this.element.style.height=this.parseLength(t.y),this.element.style.maxWidth=this.parseLength(this.maxWidth()),this.element.style.minWidth=this.parseLength(this.minWidth()),this.element.style.maxHeight=this.parseLength(this.maxHeight()),this.element.style.minHeight=this.parseLength(this.minHeight()),this.element.style.aspectRatio=null===this.ratio()?"":this.ratio().toString(),this.element.style.marginTop=this.parsePixels(this.margin.top()),this.element.style.marginBottom=this.parsePixels(this.margin.bottom()),this.element.style.marginLeft=this.parsePixels(this.margin.left()),this.element.style.marginRight=this.parsePixels(this.margin.right()),this.element.style.paddingTop=this.parsePixels(this.padding.top()),this.element.style.paddingBottom=this.parsePixels(this.padding.bottom()),this.element.style.paddingLeft=this.parsePixels(this.padding.left()),this.element.style.paddingRight=this.parsePixels(this.padding.right()),this.element.style.flexDirection=this.direction(),this.element.style.flexBasis=this.parseLength(this.basis()),this.element.style.flexWrap=this.wrap(),this.element.style.justifyContent=this.justifyContent(),this.element.style.alignContent=this.alignContent(),this.element.style.alignItems=this.alignItems(),this.element.style.alignSelf=this.alignSelf(),this.element.style.columnGap=this.parseLength(this.gap.x()),this.element.style.rowGap=this.parseLength(this.gap.y()),this.sizeLockCounter()>0?(this.element.style.flexGrow="0",this.element.style.flexShrink="0"):(this.element.style.flexGrow=this.grow().toString(),this.element.style.flexShrink=this.shrink().toString())}applyFont(){if(this.element.style.fontFamily=this.fontFamily.isInitial()?"":this.fontFamily(),this.element.style.fontSize=this.fontSize.isInitial()?"":`${this.fontSize()}px`,this.element.style.fontStyle=this.fontStyle.isInitial()?"":this.fontStyle(),this.lineHeight.isInitial())this.element.style.lineHeight="";else{const t=this.lineHeight();this.element.style.lineHeight="string"==typeof t?(parseFloat(t)/100).toString():`${t}px`}if(this.element.style.fontWeight=this.fontWeight.isInitial()?"":this.fontWeight().toString(),this.element.style.letterSpacing=this.letterSpacing.isInitial()?"":`${this.letterSpacing()}px`,this.element.style.textAlign=this.textAlign.isInitial()?"":this.textAlign(),this.textWrap.isInitial())this.element.style.whiteSpace="";else{const t=this.textWrap();this.element.style.whiteSpace="boolean"==typeof t?t?"normal":"nowrap":t}}dispose(){var t;super.dispose(),null==(t=this.sizeLockCounter)||t.context.dispose(),this.element&&(this.element.remove(),this.element.innerHTML=""),this.element=null,this.styles=null}hit(t){const e=t.transformAsPoint(this.localToParent().inverse());return this.cacheBBox().includes(e)?super.hit(t)??this:null}}function D(t){return(e,n)=>{(0,o.td)()(e,n),(0,o.r_)(!1)(e,n);const s=(0,o.uN)(e,n);s.getter=function(){return this.getOriginDelta(t).transformAsPoint(this.localToParent())},s.setter=function(e){return this.position((0,k.Pj)(e,(e=>this.getOriginDelta(t).transform(this.scalingRotationMatrix()).flipped.add(e)))),this}}}w([(0,o.nn)(null),(0,o.td)()],M.prototype,"layout",void 0),w([(0,o.nn)(null),(0,o.td)()],M.prototype,"maxWidth",void 0),w([(0,o.nn)(null),(0,o.td)()],M.prototype,"maxHeight",void 0),w([(0,o.nn)(null),(0,o.td)()],M.prototype,"minWidth",void 0),w([(0,o.nn)(null),(0,o.td)()],M.prototype,"minHeight",void 0),w([(0,o.nn)(null),(0,o.td)()],M.prototype,"ratio",void 0),w([(0,y.g)("margin")],M.prototype,"margin",void 0),w([(0,y.g)("padding")],M.prototype,"padding",void 0),w([(0,o.nn)("row"),(0,o.td)()],M.prototype,"direction",void 0),w([(0,o.nn)(null),(0,o.td)()],M.prototype,"basis",void 0),w([(0,o.nn)(0),(0,o.td)()],M.prototype,"grow",void 0),w([(0,o.nn)(1),(0,o.td)()],M.prototype,"shrink",void 0),w([(0,o.nn)("nowrap"),(0,o.td)()],M.prototype,"wrap",void 0),w([(0,o.nn)("start"),(0,o.td)()],M.prototype,"justifyContent",void 0),w([(0,o.nn)("normal"),(0,o.td)()],M.prototype,"alignContent",void 0),w([(0,o.nn)("stretch"),(0,o.td)()],M.prototype,"alignItems",void 0),w([(0,o.nn)("auto"),(0,o.td)()],M.prototype,"alignSelf",void 0),w([(0,o.nn)(0),(0,s.y)({x:"columnGap",y:"rowGap"})],M.prototype,"gap",void 0),w([p("font-family"),(0,o.td)()],M.prototype,"fontFamily",void 0),w([p("font-size",parseFloat),(0,o.td)()],M.prototype,"fontSize",void 0),w([p("font-style"),(0,o.td)()],M.prototype,"fontStyle",void 0),w([p("font-weight",parseInt),(0,o.td)()],M.prototype,"fontWeight",void 0),w([p("line-height",parseFloat),(0,o.td)()],M.prototype,"lineHeight",void 0),w([p("letter-spacing",(t=>"normal"===t?0:parseFloat(t))),(0,o.td)()],M.prototype,"letterSpacing",void 0),w([p("white-space",(t=>"pre"===t?"pre":"normal"===t)),(0,o.td)()],M.prototype,"textWrap",void 0),w([(0,o.nn)("inherit"),(0,o.td)()],M.prototype,"textDirection",void 0),w([p("text-align"),(0,o.td)()],M.prototype,"textAlign",void 0),w([(0,o.nn)({x:null,y:null}),(0,s.y)({x:"width",y:"height"})],M.prototype,"size",void 0),w([(0,d.C)()],M.prototype,"tweenWidth",null),w([(0,d.C)()],M.prototype,"tweenHeight",null),w([(0,i.F)()],M.prototype,"desiredSize",null),w([(0,d.C)()],M.prototype,"tweenSize",null),w([(0,s.y)("offset")],M.prototype,"offset",void 0),w([D(u.aP.Top)],M.prototype,"top",void 0),w([D(u.aP.Bottom)],M.prototype,"bottom",void 0),w([D(u.aP.Left)],M.prototype,"left",void 0),w([D(u.aP.Right)],M.prototype,"right",void 0),w([D(u.aP.TopLeft)],M.prototype,"topLeft",void 0),w([D(u.aP.TopRight)],M.prototype,"topRight",void 0),w([D(u.aP.BottomLeft)],M.prototype,"bottomLeft",void 0),w([D(u.aP.BottomRight)],M.prototype,"bottomRight",void 0),w([(0,o.nn)(!1),(0,o.td)()],M.prototype,"clip",void 0),w([(0,o.nn)(0),(0,o.td)()],M.prototype,"sizeLockCounter",void 0),w([(0,i.F)()],M.prototype,"parentTransform",null),w([(0,i.F)()],M.prototype,"anchorPosition",null),w([(0,i.F)()],M.prototype,"layoutEnabled",null),w([(0,i.F)()],M.prototype,"isLayoutRoot",null),w([(0,i.F)()],M.prototype,"scalingRotationMatrix",null),w([(0,i.F)()],M.prototype,"computedPosition",null),w([(0,i.F)()],M.prototype,"computedSize",null),w([(0,i.F)()],M.prototype,"requestLayoutUpdate",null),w([(0,i.F)()],M.prototype,"appendedToView",null),w([(0,i.F)()],M.prototype,"updateLayout",null),w([(0,i.F)()],M.prototype,"layoutChildren",null),w([(0,i.F)()],M.prototype,"requestFontUpdate",null),w([(0,i.F)()],M.prototype,"applyFlex",null),w([(0,i.F)()],M.prototype,"applyFont",null),(0,c.f)(M.prototype,(t=>{t.element=document.createElement("div"),t.element.style.display="flex",t.element.style.boxSizing="border-box",t.styles=getComputedStyle(t.element)}))},20092:(t,e,n)=>{"use strict";n.d(e,{N:()=>v});var o=n(93091),s=n(88104),r=n(46350),p=n(43595),i=n(29797),c=n(74741),a=n(23357),l=n(49111),u=n(3163);var m=n(97074),d=n(74534),h=n(13170),f=n(67292),y=n(11258),k=n(97140);const w={invert:{name:"invert"},sepia:{name:"sepia"},grayscale:{name:"grayscale"},brightness:{name:"brightness",default:1},contrast:{name:"contrast",default:1},saturate:{name:"saturate",default:1},hue:{name:"hue-rotate",unit:"deg",scale:1},blur:{name:"blur",transform:!0,unit:"px",scale:1}};class M{get name(){return this.props.name}get default(){return this.props.default}constructor(t){this.props={name:"invert",default:0,unit:"%",scale:100,transform:!1,...t,value:t.value??t.default??0},this.value=(0,k.g)(this.props.value,h.UI,this)}isActive(){return this.value()!==this.props.default}serialize(t){let e=this.value();return this.props.transform&&(e=(0,c.X)(e,t)),`${this.props.name}(${e*this.props.scale}${this.props.unit})`}}var D=n(5376),_=n(5788),X=n(16249),g=n(68003);class x extends X.V{constructor(t,e){var n;super(t,h.o0,e),n=this;for(const o in w){const t=w[o];Object.defineProperty(this.invokable,o,{value:function(e,o,s){var r,p,i;if(void 0===s&&(s=m.qb),void 0===e)return(null==(p=n.get())||null==(i=p.find((e=>e.name===t.name)))?void 0:i.value())??t.default??0;let c=null==(r=n.get())?void 0:r.find((e=>e.name===t.name));return c||(c=new M(t),n.set([...n.get(),c])),void 0===o?(c.value(e),n.owner):c.value(e,o,s)}})}}*tweener(t,e,n){const o=this.get(),s=(0,g.Wg)(t);if(function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n].name!==e[n].name)return!1;return!0}(o,s))return yield*(0,D.$)(...o.map(((t,o)=>t.value(s[o].value(),e,n)))),void this.set(s);for(const i of s)i.value(i.default);const r=s.map((t=>t.value.context.raw())),p=o.length>0&&s.length>0?e/2:e;o.length>0&&(yield*(0,D.$)(...o.map((t=>t.value(t.default,p,n))))),this.set(s),s.length>0&&(yield*(0,D.$)(...s.map(((t,e)=>t.value(r[e],p,n)))))}}var C=n(76062),T=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class v{get x(){return this.position.x}get y(){return this.position.y}getAbsolutePosition(){const t=this.localToWorld();return new i.F(t.m41,t.m42)}setAbsolutePosition(t){this.position((0,g.Pj)(t,(t=>new i.F(t).transformAsPoint(this.worldToParent()))))}getAbsoluteRotation(){const t=this.localToWorld();return i.F.degrees(t.m11,t.m12)}setAbsoluteRotation(t){this.rotation((0,g.Pj)(t,(t=>(0,c.$)(t,this.worldToParent()))))}getAbsoluteScale(){const t=this.localToWorld();return new i.F(i.F.magnitude(t.m11,t.m12),i.F.magnitude(t.m21,t.m22))}setAbsoluteScale(t){this.scale((0,g.Pj)(t,(t=>this.getRelativeScale(new i.F(t)))))}getRelativeScale(t){var e;const n=(null==(e=this.parent())?void 0:e.absoluteScale())??i.F.one;return t.div(n)}*tweenCompositeOperation(t,e,n){const o=(0,g.Wg)(t);"source-over"===o?(yield*this.compositeOverride(1,e,n),this.compositeOverride(0),this.compositeOperation(o)):(this.compositeOperation(o),this.compositeOverride(1),yield*this.compositeOverride(0,e,n))}absoluteOpacity(){var t;return((null==(t=this.parent())?void 0:t.absoluteOpacity())??1)*this.opacity()}hasFilters(){return!!this.filters().find((t=>t.isActive()))}hasShadow(){return!!this.shadowColor()&&(this.shadowBlur()>0||0!==this.shadowOffset.x()||0!==this.shadowOffset.y())}filterString(){let t="";const e=this.compositeToWorld();for(const n of this.filters())n.isActive()&&(t+=" "+n.serialize(e));return t}setChildren(t){this.spawner(t)}getChildren(){return this.spawnChildren(),this.realChildren}spawnChildren(){const t=this.spawner();if((0,g.PG)(this.spawner.context.raw())){const e=new Set;for(const n of t){const t=n.parent.context.raw();if(t&&t!==this)throw new l.t("The spawner returned a node that already has a parent","A spawner should either create entirely new nodes or reuse nodes from a pool.");n.parent(this),e.add(n.key)}for(const t of this.realChildren)e.has(t.key)||t.parent(null);this.realChildren=t}else this.realChildren=t}sortedChildren(){return[...this.children()].sort(((t,e)=>Math.sign(t.zIndex()-e.zIndex())))}constructor(t){let{children:e,spawner:n,key:s,...r}=t;this.compositeOverride=(0,k.g)(0),this.stateStack=[],this.realChildren=[],this.parent=(0,k.g)(null),this.properties=(0,o.RG)(this);const p=(0,u.$r)();this.key=p.registerNode(this,s),this.view2D=p.getView(),this.creationStack=(new Error).stack,(0,o.Xd)(this,r),this.add(e),n&&this.children(n)}localToWorld(){const t=this.parent();return t?t.localToWorld().multiply(this.localToParent()):this.localToParent()}worldToLocal(){return this.localToWorld().inverse()}worldToParent(){var t;return(null==(t=this.parent())?void 0:t.worldToLocal())??new DOMMatrix}localToParent(){const t=new DOMMatrix;return t.translateSelf(this.position.x(),this.position.y()),t.rotateSelf(0,0,this.rotation()),t.scaleSelf(this.scale.x(),this.scale.y()),t}compositeToWorld(){var t;return(null==(t=this.compositeRoot())?void 0:t.localToWorld())??new DOMMatrix}compositeRoot(){var t;return this.composite()?this:(null==(t=this.parent())?void 0:t.compositeRoot())??null}compositeToLocal(){const t=this.compositeRoot();if(t){const e=this.worldToLocal();return e.m44=1,t.localToWorld().multiply(e)}return new DOMMatrix}view(){return this.view2D}add(t){return this.insert(t,1/0)}insert(t,e){void 0===e&&(e=0);const n=Array.isArray(t)?t:[t];if(0===n.length)return this;const o=this.children(),s=o.slice(0,e);for(const r of n)r instanceof v&&(s.push(r),r.remove(),r.parent(this));return s.push(...o.slice(e)),this.children(s),this}remove(){const t=this.parent();return null===t||(t.children(t.children().filter((t=>t!==this))),this.parent(null)),this}move(t){void 0===t&&(t=1);const e=this.parent();if(0===t||!e)return this;const n=e.children(),o=[];if(t>0)for(let s=0;s<n.length;s++){const e=n[s];if(e===this){const e=s+t;for(;s<e&&s+1<n.length;s++)o[s]=n[s+1]}o[s]=e}else for(let s=n.length-1;s>=0;s--){const e=n[s];if(e===this){const e=s+t;for(;s>e&&s>0;s--)o[s]=n[s-1]}o[s]=e}return e.children(o),this}moveUp(){return this.move(1)}moveDown(){return this.move(-1)}moveToTop(){return this.move(1/0)}moveToBottom(){return this.move(-1/0)}moveTo(t){const e=this.parent();if(!e)return this;const n=t-e.children().indexOf(this);return this.move(n)}moveBelow(t,e){void 0===e&&(e=!1);const n=this.parent();if(!n)return this;if(t.parent()!==n)return(0,u.wL)().error("Cannot position nodes relative to each other if they don't belong to the same parent."),this;const o=n.children(),s=o.indexOf(this),r=o.indexOf(t);if(!e&&s<r)return this;const p=r-s-1;return this.move(p)}moveAbove(t,e){void 0===e&&(e=!1);const n=this.parent();if(!n)return this;if(t.parent()!==n)return(0,u.wL)().error("Cannot position nodes relative to each other if they don't belong to the same parent."),this;const o=n.children(),s=o.indexOf(this),r=o.indexOf(t);if(!e&&s>r)return this;const p=r-s+1;return this.move(p)}reparent(t){const e=this.absolutePosition(),n=this.absoluteRotation(),o=this.absoluteScale();t.add(this),this.absolutePosition(e),this.absoluteRotation(n),this.absoluteScale(o)}removeChildren(){for(const t of this.children())t.remove()}dispose(){this.stateStack=[];for(const{signal:t}of this)null==t||t.context.dispose()}clone(t){void 0===t&&(t={});const e={...t};(0,g.PG)(this.spawner.context.raw())?e.spawner=this.spawner.context.raw():this.children().length>0&&(e.children??(e.children=this.children().map((t=>t.clone()))));for(const{key:n,meta:o,signal:s}of this)if(o.cloneable&&!(n in e))if(o.compound)for(const[t,r]of o.compoundEntries)r in e||(e[r]=s[t].context.raw());else e[n]=s.context.raw();return this.instantiate(e)}snapshotClone(t){void 0===t&&(t={});const e={...this.getState(),...t};return this.children().length>0&&(e.children??(e.children=this.children().map((t=>t.snapshotClone())))),this.instantiate(e)}reactiveClone(t){void 0===t&&(t={});const e={...t};this.children().length>0&&(e.children??(e.children=this.children().map((t=>t.reactiveClone()))));for(const{key:n,meta:o,signal:s}of this)o.cloneable&&!(n in e)&&(e[n]=()=>s());return this.instantiate(e)}instantiate(t){return void 0===t&&(t={}),new this.constructor(t)}requiresCache(){return this.cache()||this.opacity()<1||"source-over"!==this.compositeOperation()||this.hasFilters()||this.hasShadow()}cacheCanvas(){const t=document.createElement("canvas").getContext("2d");if(!t)throw new Error("Could not create a cache canvas");return t}cachedCanvas(){const t=this.cacheCanvas(),e=this.worldSpaceCacheBBox(),n=this.localToWorld();return t.canvas.width=e.width,t.canvas.height=e.height,t.setTransform(n.a,n.b,n.c,n.d,n.e-e.x,n.f-e.y),this.draw(t),t}getCacheBBox(){return new a.b}cacheBBox(){const t=this.getCacheBBox(),e=this.children();if(0===e.length)return t;const n=t.corners;for(const o of e){const t=o.fullCacheBBox(),e=o.localToParent();n.push(...t.corners.map((t=>t.transformAsPoint(e))))}return a.b.fromPoints(...n)}fullCacheBBox(){const t=this.compositeToLocal(),e=this.shadowOffset().transform(t),n=(0,c.X)(this.shadowBlur(),t),o=this.cacheBBox().expand(2*this.filters.blur()+n);return e.x<0?(o.x+=e.x,o.width-=e.x):o.width+=e.x,e.y<0?(o.y+=e.y,o.height-=e.y):o.height+=e.y,o}worldSpaceCacheBBox(){const t=a.b.fromSizeCentered(this.view().size()),e=a.b.fromPoints(...t.transformCorners(this.view().localToWorld())),n=a.b.fromPoints(...this.cacheBBox().transformCorners(this.localToWorld()));return e.intersection(n).pixelPerfect}setupDrawFromCache(t){if(t.globalCompositeOperation=this.compositeOperation(),t.globalAlpha*=this.opacity(),this.hasFilters()&&(t.filter=this.filterString()),this.hasShadow()){const e=this.compositeToWorld(),n=this.shadowOffset().transform(e),o=(0,c.X)(this.shadowBlur(),e);t.shadowColor=this.shadowColor().serialize(),t.shadowBlur=o,t.shadowOffsetX=n.x,t.shadowOffsetY=n.y}}render(t){if(!(this.absoluteOpacity()<=0)){if(t.save(),this.transformContext(t),this.requiresCache()){const e=this.worldSpaceCacheBBox();if(0!==e.width&&0!==e.height){this.setupDrawFromCache(t);const n=this.cachedCanvas(),o=this.compositeOverride(),s=this.worldToLocal();t.transform(s.a,s.b,s.c,s.d,s.e,s.f),t.drawImage(n.canvas,e.position.x,e.position.y),o>0&&(t.save(),t.globalAlpha*=o,t.globalCompositeOperation="source-over",t.drawImage(n.canvas,e.position.x,e.position.y),t.restore())}}else this.draw(t);t.restore()}}draw(t){this.drawChildren(t)}drawChildren(t){for(const e of this.sortedChildren())e.render(t)}drawOverlay(t,e){const n=this.cacheBBox().transformCorners(e),o=this.getCacheBBox().transformCorners(e);t.strokeStyle="white",t.lineWidth=1,t.beginPath(),(0,y.pS)(t,n),t.closePath(),t.stroke(),t.strokeStyle="blue",t.beginPath(),(0,y.pS)(t,o),t.closePath(),t.stroke()}transformContext(t){const e=this.localToParent();t.transform(e.a,e.b,e.c,e.d,e.e,e.f)}hit(t){let e=null;const n=t.transformAsPoint(this.localToParent().inverse());for(const o of this.children().reverse())if(e=o.hit(n),e)break;return e}collectAsyncResources(){for(const t of this.children())t.collectAsyncResources()}async toPromise(){do{await C.k.consumePromises(),this.collectAsyncResources()}while(C.k.hasPromises());return this}getState(){const t={};for(const{key:e,meta:n,signal:o}of this)n.cloneable&&!(e in t)&&(t[e]=o());return t}applyState(t){for(const e in t){const n=this.signalByKey(e);n&&n(t[e])}}save(){this.stateStack.push(this.getState())}restore(t,e){void 0===e&&(e=m.qb);const n=this.stateStack.pop();if(void 0===n)return;const o=this.getState();for(const s in n)o[s]===n[s]&&delete n[s];return(0,d.i)(t,(t=>{const s=e(t),r=Object.keys(n).reduce(((t,e)=>(t[e]=(0,h.o0)(o[e],n[e],s),t)),{});this.applyState(r)}))}*[Symbol.iterator](){for(const t in this.properties){const e=this.properties[t],n=this.signalByKey(t);yield{meta:e,signal:n,key:t}}}signalByKey(t){return this[t]}}T([(0,s.y)()],v.prototype,"position",void 0),T([(0,o.YS)(i.F),(0,o.r_)(!1),(0,o.td)()],v.prototype,"absolutePosition",void 0),T([(0,o.nn)(0),(0,o.td)()],v.prototype,"rotation",void 0),T([(0,o.r_)(!1),(0,o.td)()],v.prototype,"absoluteRotation",void 0),T([(0,o.nn)(i.F.one),(0,s.y)("scale")],v.prototype,"scale",void 0),T([(0,o.YS)(i.F),(0,o.r_)(!1),(0,o.td)()],v.prototype,"absoluteScale",void 0),T([(0,o.nn)(0),(0,o.td)()],v.prototype,"zIndex",void 0),T([(0,o.nn)(!1),(0,o.td)()],v.prototype,"cache",void 0),T([(0,o.nn)(!1),(0,o.td)()],v.prototype,"composite",void 0),T([(0,o.nn)("source-over"),(0,o.td)()],v.prototype,"compositeOperation",void 0),T([(0,f.C)()],v.prototype,"tweenCompositeOperation",null),T([(0,o.nn)(1),(0,o.td)()],v.prototype,"opacity",void 0),T([(0,r.F)()],v.prototype,"absoluteOpacity",null),T([(t,e)=>{const n=(0,o.J)(t,e);(0,_.f)(t,(t=>{t[e]=new x(n.default??[],t).toSignal()}))}],v.prototype,"filters",void 0),T([(0,o.nn)("#0000"),(0,p.j)()],v.prototype,"shadowColor",void 0),T([(0,o.nn)(0),(0,o.td)()],v.prototype,"shadowBlur",void 0),T([(0,s.y)("shadowOffset")],v.prototype,"shadowOffset",void 0),T([(0,r.F)()],v.prototype,"hasFilters",null),T([(0,r.F)()],v.prototype,"hasShadow",null),T([(0,r.F)()],v.prototype,"filterString",null),T([(0,o.Oq)(!1),(0,o.r_)(!1),(0,o.nn)([]),(0,o.td)()],v.prototype,"spawner",void 0),T([(0,o.Oq)(!1),(0,o.r_)(!1),(0,o.td)()],v.prototype,"children",void 0),T([(0,r.F)()],v.prototype,"spawnChildren",null),T([(0,r.F)()],v.prototype,"sortedChildren",null),T([(0,r.F)()],v.prototype,"localToWorld",null),T([(0,r.F)()],v.prototype,"worldToLocal",null),T([(0,r.F)()],v.prototype,"worldToParent",null),T([(0,r.F)()],v.prototype,"localToParent",null),T([(0,r.F)()],v.prototype,"compositeToWorld",null),T([(0,r.F)()],v.prototype,"compositeRoot",null),T([(0,r.F)()],v.prototype,"compositeToLocal",null),T([(0,r.F)()],v.prototype,"cacheCanvas",null),T([(0,r.F)()],v.prototype,"cachedCanvas",null),T([(0,r.F)()],v.prototype,"cacheBBox",null),T([(0,r.F)()],v.prototype,"fullCacheBBox",null),T([(0,r.F)()],v.prototype,"worldSpaceCacheBBox",null),v.prototype.isClass=!0},15498:(t,e,n)=>{"use strict";n.d(e,{U:()=>a});var o=n(23357),s=n(13730),r=n(11258),p=n(93091),i=n(53693),c=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class a extends s.b{constructor(t){super(t)}getPath(){const t=new Path2D,e=this.radius(),n=this.smoothCorners(),s=this.cornerSharpness(),p=o.b.fromSizeCentered(this.size());return(0,r.Zy)(t,p,e,n,s),t}getCacheBBox(){return super.getCacheBBox().expand(this.rippleSize())}getRipplePath(){const t=new Path2D,e=this.rippleSize(),n=this.radius().addScalar(e),s=this.smoothCorners(),p=this.cornerSharpness(),i=o.b.fromSizeCentered(this.size()).expand(e);return(0,r.Zy)(t,i,n,s,p),t}}c([(0,i.g)("radius")],a.prototype,"radius",void 0),c([(0,p.nn)(!1),(0,p.td)()],a.prototype,"smoothCorners",void 0),c([(0,p.nn)(.6),(0,p.td)()],a.prototype,"cornerSharpness",void 0)},13730:(t,e,n)=>{"use strict";n.d(e,{b:()=>h});var o=n(93091),s=n(46350),r=n(70989),p=n(67292),i=n(97074),c=n(13170),a=n(11258),l=n(30204);function u(){return(t,e)=>{(0,o.td)()(t,e),(0,o.E2)(a.av)(t,e),(0,o.JI)(l.I.lerp)(t,e),(0,o.nn)(null)(t,e)}}var m=n(97140),d=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class h extends r.A{rippleSize(){return(0,i.ad)(this.rippleStrength(),0,50)}constructor(t){super(t),this.rippleStrength=(0,m.g)(0)}applyText(t){t.direction=this.textDirection(),this.element.dir=this.textDirection()}applyStyle(t){t.fillStyle=(0,a.ho)(this.fill(),t),t.strokeStyle=(0,a.ho)(this.stroke(),t),t.lineWidth=this.lineWidth(),t.lineJoin=this.lineJoin(),t.lineCap=this.lineCap(),t.setLineDash(this.lineDash()),t.lineDashOffset=this.lineDashOffset(),this.antialiased()||(t.filter="url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxmaWx0ZXIgaWQ9ImZpbHRlciIgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj48ZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVGdW5jUiB0eXBlPSJpZGVudGl0eSIvPjxmZUZ1bmNHIHR5cGU9ImlkZW50aXR5Ii8+PGZlRnVuY0IgdHlwZT0iaWRlbnRpdHkiLz48ZmVGdW5jQSB0eXBlPSJkaXNjcmV0ZSIgdGFibGVWYWx1ZXM9IjAgMSIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj48L2ZpbHRlcj48L3N2Zz4=#filter)")}draw(t){this.drawShape(t),this.clip()&&t.clip(this.getPath()),this.drawChildren(t)}drawShape(t){const e=this.getPath(),n=this.lineWidth()>0&&null!==this.stroke(),o=null!==this.fill();t.save(),this.applyStyle(t),this.drawRipple(t),this.strokeFirst()?(n&&t.stroke(e),o&&t.fill(e)):(o&&t.fill(e),n&&t.stroke(e)),t.restore()}getCacheBBox(){return super.getCacheBBox().expand(this.lineWidth()/2)}getPath(){return new Path2D}getRipplePath(){return new Path2D}drawRipple(t){const e=this.rippleStrength();if(e>0){const n=this.getRipplePath();t.save(),t.globalAlpha*=(0,c.UI)(.54,0,e),t.fill(n),t.restore()}}*ripple(t){void 0===t&&(t=1),this.rippleStrength(0),yield*this.rippleStrength(1,t,i.GE),this.rippleStrength(0)}}d([u()],h.prototype,"fill",void 0),d([u()],h.prototype,"stroke",void 0),d([(0,o.nn)(!1),(0,o.td)()],h.prototype,"strokeFirst",void 0),d([(0,o.nn)(0),(0,o.td)()],h.prototype,"lineWidth",void 0),d([(0,o.nn)("miter"),(0,o.td)()],h.prototype,"lineJoin",void 0),d([(0,o.nn)("butt"),(0,o.td)()],h.prototype,"lineCap",void 0),d([(0,o.nn)([]),(0,o.td)()],h.prototype,"lineDash",void 0),d([(0,o.nn)(0),(0,o.td)()],h.prototype,"lineDashOffset",void 0),d([(0,o.nn)(!0),(0,o.td)()],h.prototype,"antialiased",void 0),d([(0,s.F)()],h.prototype,"rippleSize",null),d([(0,s.F)()],h.prototype,"getPath",null),d([(0,p.C)()],h.prototype,"ripple",null)},70419:(t,e,n)=>{"use strict";n.d(e,{h:()=>c});var o=n(15498),s=n(93091),r=n(88733),p=n(79116),i=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class c extends o.U{constructor(t){super({composite:!0,fontFamily:"Roboto",fontSize:48,lineHeight:"120%",textWrap:!1,fontStyle:"normal",...t}),this.view2D=this,c.shadowRoot.append(this.element),this.applyFlex()}transformContext(){}dispose(){this.removeChildren(),super.dispose()}render(t){this.computedSize(),this.computedPosition(),super.render(t)}requestLayoutUpdate(){this.updateLayout()}requestFontUpdate(){this.applyFont()}view(){return this}}i([(0,s.nn)(r.q.Paused),(0,s.td)()],c.prototype,"playbackState",void 0),i([(0,s.td)()],c.prototype,"assetHash",void 0),i([(0,p.V)((()=>{const t="motion-canvas-2d-frame";let e=document.querySelector(`#${t}`);return e||(e=document.createElement("div"),e.id=t,e.style.position="absolute",e.style.pointerEvents="none",e.style.top="0",e.style.left="0",e.style.opacity="0",e.style.overflow="hidden",document.body.prepend(e)),e.shadowRoot??e.attachShadow({mode:"open"})}))],c,"shadowRoot",void 0)},43595:(t,e,n)=>{"use strict";n.d(e,{j:()=>r});var o=n(30204),s=n(93091);function r(){return(t,e)=>{(0,s.td)()(t,e),(0,s.YS)(o.I)(t,e)}}},37060:(t,e,n)=>{"use strict";n.d(e,{I:()=>u});var o=n(3163),s=n(93091),r=n(5788),p=n(13170),i=n(46096),c=n(16249),a=n(834),l=n(68003);function u(t){return(e,n)=>{const u=(0,s.J)(e,n);u.compound=!0,u.compoundEntries=Object.entries(t),(0,r.f)(e,(t=>{if(!u.parser)return void(0,o.wL)().error(`Missing parser decorator for "${n.toString()}"`);const e=u.default,s=u.parser.bind(t),r=new i.N(u.compoundEntries.map((n=>{let[o,r]=n;const i=new c.V((0,l.Pj)(e,(t=>s(t)[o])),p.UI,t,void 0,(0,a.f)(void 0,t,r)).toSignal();return[o,i]})),s,e,u.interpolationFunction??p.o0,t,(0,a.f)(u,t,n));t[n]=r.toSignal()}))}}},46350:(t,e,n)=>{"use strict";n.d(e,{F:()=>r});var o=n(5788),s=n(73662);function r(){return(t,e)=>{(0,o.f)(t,(t=>{const n=Object.getPrototypeOf(t)[e];t[e]=(0,s.D)(n.bind(t),t)}))}}},5788:(t,e,n)=>{"use strict";n.d(e,{f:()=>s,j:()=>r});const o=Symbol.for("@motion-canvas/2d/decorators/initializers");function s(t,e){if(t[o]){if(t[o]&&!Object.prototype.hasOwnProperty.call(t,o)){const e=Object.getPrototypeOf(t);t[o]=[...e[o]]}}else t[o]=[];t[o].push(e)}function r(t,e){if(t[o])try{t[o].forEach((n=>n(t,e)))}catch(n){throw n.inspect??(n.inspect=t.key),n}}},93091:(t,e,n)=>{"use strict";n.d(e,{E2:()=>k,J:()=>u,JI:()=>y,Oq:()=>D,RG:()=>m,Xd:()=>d,YS:()=>w,nn:()=>f,r_:()=>M,td:()=>h,uN:()=>l});var o=n(13170),s=n(5788),r=n(15688),p=n(3163),i=n(834),c=n(16249);const a=Symbol.for("@motion-canvas/2d/decorators/properties");function l(t,e){var n;return(null==(n=t[a])?void 0:n[e])??null}function u(t,e){let n;return t[a]?t[a]&&!Object.prototype.hasOwnProperty.call(t,a)?t[a]=n=Object.fromEntries(Object.entries(t[a]).map((t=>{let[e,n]=t;return[e,{...n}]}))):n=t[a]:t[a]=n={},n[e]??(n[e]={cloneable:!0,inspectable:!0,compoundEntries:[]}),n[e]}function m(t){return t&&"object"==typeof t?t[a]??{}:{}}function d(t,e){(0,s.j)(t);for(const[n,o]of Object.entries(m(t))){const s=t[n];if(s.reset(),void 0!==e[n]&&s(e[n]),void 0!==o.compoundEntries)for(const[t,n]of o.compoundEntries)n in e&&s[t](e[n])}}function h(){return(t,e)=>{const n=u(t,e);(0,s.f)(t,(t=>{var s,p;const a=null==(s=t[`getDefault${(0,r.k)(e)}`])?void 0:s.bind(t),l=new c.V(a??n.default,n.interpolationFunction??o.o0,t,null==(p=n.parser)?void 0:p.bind(t),(0,i.f)(n,t,e));t[e]=l.toSignal()}))}}function f(t){return(e,n)=>{const o=l(e,n);o?o.default=t:(0,p.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function y(t){return(e,n)=>{const o=l(e,n);o?o.interpolationFunction=t:(0,p.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function k(t){return(e,n)=>{const o=l(e,n);o?o.parser=t:(0,p.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function w(t){return(e,n)=>{const o=l(e,n);o?(o.parser=e=>new t(e),"lerp"in t&&(o.interpolationFunction??(o.interpolationFunction=t.lerp))):(0,p.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function M(t){return void 0===t&&(t=!0),(e,n)=>{const o=l(e,n);o?o.cloneable=t:(0,p.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function D(t){return void 0===t&&(t=!0),(e,n)=>{const o=l(e,n);o?o.inspectable=t:(0,p.wL)().error(`Missing property decorator for "${n.toString()}"`)}}},53693:(t,e,n)=>{"use strict";n.d(e,{g:()=>p});var o=n(43188),s=n(37060),r=n(93091);function p(t){return(e,n)=>{(0,s.I)({top:t?`${t}Top`:"top",right:t?`${t}Right`:"right",bottom:t?`${t}Bottom`:"bottom",left:t?`${t}Left`:"left"})(e,n),(0,r.YS)(o.K)(e,n)}}},88104:(t,e,n)=>{"use strict";n.d(e,{y:()=>p});var o=n(29797),s=n(37060),r=n(93091);function p(t){return(e,n)=>{(0,s.I)("object"==typeof t?t:{x:t?`${t}X`:"x",y:t?`${t}Y`:"y"})(e,n),(0,r.YS)(o.F)(e,n)}}},15914:(t,e,n)=>{"use strict";n.d(e,{r:()=>v});var o=n(92673),s=n(82344),r=n(11726);var p=n(80638),i=n(5881),c=n(97140);class a{constructor(t){this.scene=t,this.signals={},this.variables={},this.handleReset=()=>{this.signals={}},t.onReset.subscribe(this.handleReset)}get(t,e){var n;return(n=this.signals)[t]??(n[t]=(0,c.g)(this.variables[t]??e)),()=>this.signals[t]()}updateSignals(t){this.variables=t,Object.keys(t).map((e=>{e in this.signals&&this.signals[e](t[e])}))}}var l,u=n(1323),m=n(96881),d=n(42075),h=n(67292),f=n(3163),y=n(97715);!function(t){t[t.BeforeRender=0]="BeforeRender",t[t.BeginRender=1]="BeginRender",t[t.FinishRender=2]="FinishRender",t[t.AfterRender=3]="AfterRender"}(l||(l={}));class k{get onBeforeRender(){return this.beforeRender.subscribable}get onBeginRender(){return this.beginRender.subscribable}get onFinishRender(){return this.finishRender.subscribable}get onAfterRender(){return this.afterRender.subscribable}constructor(t){this.scene=t,this.beforeRender=new m.p,this.beginRender=new m.p,this.finishRender=new m.p,this.afterRender=new m.p,this.scene.onRenderLifecycle.subscribe((t=>{let[e,n]=t;switch(e){case l.BeforeRender:return this.beforeRender.dispatch(n);case l.BeginRender:return this.beginRender.dispatch(n);case l.FinishRender:return this.finishRender.dispatch(n);case l.AfterRender:return this.afterRender.dispatch(n)}})),this.scene.onReset.subscribe((()=>{this.beforeRender.clear(),this.beginRender.clear(),this.finishRender.clear(),this.afterRender.clear()}))}}var w,M=n(23357);!function(t){t[t.Initial=0]="Initial",t[t.AfterTransitionIn=1]="AfterTransitionIn",t[t.CanTransitionOut=2]="CanTransitionOut",t[t.Finished=3]="Finished"}(w||(w={}));var D=n(76062),_=n(88733);class X{get onChanged(){return this.slides.subscribable}constructor(t){this.scene=t,this.slides=new u.G([]),this.lookup=new Map,this.collisionLookup=new Set,this.current=null,this.canResume=!1,this.waitsForId=null,this.targetId=null,this.handleReload=()=>{this.lookup.clear(),this.collisionLookup.clear(),this.current=null,this.waitsForId=null,this.targetId=null},this.handleReset=()=>{this.collisionLookup.clear(),this.current=null,this.waitsForId=null},this.handleRecalculated=()=>{this.slides.current=[...this.lookup.values()]},this.scene.onReloaded.subscribe(this.handleReload),this.scene.onReset.subscribe(this.handleReset),this.scene.onRecalculated.subscribe(this.handleRecalculated)}setTarget(t){this.targetId=t}resume(){this.canResume=!0}isWaitingFor(t){return this.waitsForId===t}isWaiting(){return null!==this.waitsForId}didHappen(t){if(null===this.current)return!1;for(const n of this.lookup.keys()){var e;if(n===t)return!0;if(n===(null==(e=this.current)?void 0:e.id))return!1}return!1}getCurrent(){return this.current}register(t,e){if(null!==this.waitsForId)throw new Error(`The animation already waits for a slide: ${this.waitsForId}.`);const n=this.toId(t);this.scene.playback.state!==_.q.Presenting&&(this.lookup.has(n)||this.lookup.set(n,{id:n,name:t,time:e,scene:this.scene,stack:(new Error).stack}),this.collisionLookup.has(t)?this.scene.logger.warn({message:`A slide named "${t}" already exists.`,stack:(new Error).stack}):this.collisionLookup.add(t)),this.waitsForId=n,this.current=this.lookup.get(n)??null,this.canResume=!1}shouldWait(t){const e=this.toId(t);if(this.waitsForId!==e)throw new Error(`The animation waits for a different slide: ${this.waitsForId}.`);if(!this.lookup.get(e))throw new Error(`Could not find the "${t}" slide.`);let n=this.canResume;return this.scene.playback.state!==_.q.Presenting&&(n=e!==this.targetId),n&&(this.waitsForId=null),!n}toId(t){return`${this.scene.name}:${t}`}}class g{get firstFrame(){return this.cache.current.firstFrame}get lastFrame(){return this.firstFrame+this.cache.current.duration}get onCacheChanged(){return this.cache.subscribable}get onReloaded(){return this.reloaded.subscribable}get onRecalculated(){return this.recalculated.subscribable}get onThreadChanged(){return this.thread.subscribable}get onRenderLifecycle(){return this.renderLifecycle.subscribable}get onReset(){return this.afterReset.subscribable}get LifecycleEvents(){return this.logger.warn("LifecycleEvents is deprecated. Use lifecycleEvents instead."),this.lifecycleEvents}get previous(){return this.previousScene}constructor(t){this.cache=new u.G({firstFrame:0,transitionDuration:0,duration:0,lastFrame:0}),this.reloaded=new m.p,this.recalculated=new m.p,this.thread=new u.G(null),this.renderLifecycle=new m.p,this.afterReset=new m.p,this.lifecycleEvents=new k(this),this.previousScene=null,this.runner=null,this.state=w.Initial,this.cached=!1,this.counters={},this.name=t.name,this.size=t.size,this.resolutionScale=t.resolutionScale,this.logger=t.logger,this.playback=t.playback,this.meta=t.meta,this.runnerFactory=t.config,this.creationStack=t.stack,(0,d.G)(this.runnerFactory,(0,h.C)(this.name)),this.timeEvents=new t.timeEventsClass(this),this.variables=new a(this),this.slides=new X(this),this.random=new r.k(this.meta.seed.get())}update(){}async render(t){let e=0;do{e++,await D.k.consumePromises(),t.save();const n=M.b.fromSizeCentered(this.getSize());t.clearRect(n.x,n.y,n.width,n.height),this.execute((()=>this.draw(t))),t.restore()}while(D.k.hasPromises()&&e<10);e>1&&this.logger.debug(`render iterations: ${e}`)}reload(t){let{config:e,size:n,stack:o,resolutionScale:s}=void 0===t?{}:t;e&&(this.runnerFactory=e),n&&(this.size=n),s&&(this.resolutionScale=s),o&&(this.creationStack=o),this.cached=!1,this.reloaded.dispatch()}async recalculate(t){const e=this.cache.current;if(e.firstFrame=this.playback.frame,e.lastFrame=e.firstFrame+e.duration,this.isCached())return t(e.lastFrame),void(this.cache.current={...e});for(e.transitionDuration=-1,await this.reset();!this.canTransitionOut();)e.transitionDuration<0&&this.state===w.AfterTransitionIn&&(e.transitionDuration=this.playback.frame-e.firstFrame),t(this.playback.frame+1),await this.next();-1===e.transitionDuration&&(e.transitionDuration=0),e.lastFrame=this.playback.frame,e.duration=e.lastFrame-e.firstFrame,await new Promise((t=>setTimeout(t,0))),this.cached=!0,this.cache.current={...e},this.recalculated.dispatch()}async next(){if(!this.runner)return;let t=this.execute((()=>this.runner.next()));for(this.update();t.value;){if((0,p.x)(t.value)){const e=await t.value.toPromise();t=this.execute((()=>this.runner.next(e)))}else if((0,i.t)(t.value)){const e=await t.value;t=this.execute((()=>this.runner.next(e)))}else this.logger.warn({message:"Invalid value yielded by the scene.",object:t.value}),t=this.execute((()=>this.runner.next(t.value)));this.update()}if(D.k.hasPromises()){var e;const t=await D.k.consumePromises();this.logger.error({message:"Tried to access an asynchronous property before the node was ready. Make sure to yield the node before accessing the property.",stack:t[0].stack,inspect:(null==(e=t[0].owner)?void 0:e.key)??void 0})}t.done&&(this.state=w.Finished)}async reset(t){void 0===t&&(t=null),this.counters={},this.previousScene=t,this.random=new r.k(this.meta.seed.get()),this.runner=(0,i.C)((()=>this.runnerFactory(this.getView())),(t=>{this.thread.current=t})),this.state=w.AfterTransitionIn,this.afterReset.dispatch(),await this.next()}getSize(){return this.size}isAfterTransitionIn(){return this.state===w.AfterTransitionIn}canTransitionOut(){return this.state===w.CanTransitionOut||this.state===w.Finished}isFinished(){return this.state===w.Finished}enterInitial(){this.state===w.AfterTransitionIn?this.state=w.Initial:this.logger.warn(`Scene ${this.name} entered initial in an unexpected state: ${this.state}`)}enterAfterTransitionIn(){this.state===w.Initial?this.state=w.AfterTransitionIn:this.logger.warn(`Scene ${this.name} transitioned in an unexpected state: ${this.state}`)}enterCanTransitionOut(){this.state===w.AfterTransitionIn||this.state===w.Initial?this.state=w.CanTransitionOut:this.logger.warn(`Scene ${this.name} was marked as finished in an unexpected state: ${this.state}`)}isCached(){return this.cached}execute(t){let e;(0,f.DO)(this),(0,y.wA)(this.playback);try{e=t()}finally{(0,y.Mh)(this.playback),(0,f.ug)(this)}return e}}var x=n(29797),C=n(70419);class T extends g{constructor(t){super(t),this.view=null,this.registeredNodes={},this.nodeCounters={},this.assetHash=Date.now().toString(),this.recreateView()}getView(){return this.view}next(){var t;return null==(t=this.getView())||t.playbackState(this.playback.state),super.next()}draw(t){t.save(),this.renderLifecycle.dispatch([l.BeforeRender,t]),t.save(),this.renderLifecycle.dispatch([l.BeginRender,t]),this.getView().playbackState(this.playback.state),this.getView().render(t),this.renderLifecycle.dispatch([l.FinishRender,t]),t.restore(),this.renderLifecycle.dispatch([l.AfterRender,t]),t.restore()}reset(t){for(const n in this.registeredNodes)try{this.registeredNodes[n].dispose()}catch(e){this.logger.error(e)}return this.registeredNodes={},this.nodeCounters={},this.recreateView(),super.reset(t)}inspectPosition(t,e){return this.execute((()=>{var n;return(null==(n=this.getView().hit(new x.F(t,e).scale(this.resolutionScale)))?void 0:n.key)??null}))}validateInspection(t){var e;return(null==(e=this.getNode(t))?void 0:e.key)??null}inspectAttributes(t){const e=this.getNode(t);if(!e)return null;const n={stack:e.creationStack,key:e.key};for(const{key:o,meta:s,signal:r}of e)s.inspectable&&(n[o]=r());return n}drawOverlay(t,e,n){const o=this.getNode(t);o&&this.execute((()=>{o.drawOverlay(n,e.scale(1/this.resolutionScale,1/this.resolutionScale).multiplySelf(o.localToWorld()))}))}registerNode(t,e){var n,o;const s=(null==(n=t.constructor)?void 0:n.name)??"unknown";(o=this.nodeCounters)[s]??(o[s]=0);const r=this.nodeCounters[s]++;return e??(e=`${this.name}/${s}[${r}]`),this.registeredNodes[e]=t,e}getNode(t){return"string"!=typeof t?null:this.registeredNodes[t]??null}recreateView(){this.execute((()=>{const t=this.getSize();this.view=new C.h({position:t.scale(this.resolutionScale/2),scale:this.resolutionScale,assetHash:this.assetHash,size:t})}))}}function v(t){return{klass:T,config:t,stack:(new Error).stack,meta:new o.v("scene",{version:new s.C("version",1),timeEvents:new s.C("time events",[]),seed:new s.C("seed",r.k.createSeed())})}}},11258:(t,e,n)=>{"use strict";n.d(e,{Nb:()=>g,JQ:()=>x,av:()=>d,AE:()=>w,pS:()=>_,wp:()=>X,is:()=>k,Zy:()=>f,kZ:()=>D,Ao:()=>M,pt:()=>C,ho:()=>h});var o=n(93091),s=n(88104),r=n(46350),p=n(30204),i=n(68003),c=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class a{constructor(t){(0,o.Xd)(this,t)}canvasGradient(t){let e;switch(this.type()){case"linear":e=t.createLinearGradient(this.from.x(),this.from.y(),this.to.x(),this.to.y());break;case"conic":e=t.createConicGradient(this.angle(),this.from.x(),this.from.y());break;case"radial":e=t.createRadialGradient(this.from.x(),this.from.y(),this.fromRadius(),this.to.x(),this.to.y(),this.toRadius())}for(const{offset:n,color:o}of this.stops())e.addColorStop((0,i.Wg)(n),new p.I((0,i.Wg)(o)).serialize());return e}}c([(0,o.nn)("linear"),(0,o.td)()],a.prototype,"type",void 0),c([(0,s.y)("from")],a.prototype,"from",void 0),c([(0,s.y)("to")],a.prototype,"to",void 0),c([(0,o.nn)(0),(0,o.td)()],a.prototype,"angle",void 0),c([(0,o.nn)(0),(0,o.td)()],a.prototype,"fromRadius",void 0),c([(0,o.nn)(0),(0,o.td)()],a.prototype,"toRadius",void 0),c([(0,o.nn)([]),(0,o.td)()],a.prototype,"stops",void 0),c([(0,r.F)()],a.prototype,"canvasGradient",null);var l=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class u{constructor(t){(0,o.Xd)(this,t)}canvasPattern(t){return t.createPattern(this.image(),this.repetition())}}l([(0,o.td)()],u.prototype,"image",void 0),l([(0,o.nn)(null),(0,o.td)()],u.prototype,"repetition",void 0),l([(0,r.F)()],u.prototype,"canvasPattern",null);var m=n(29797);function d(t){return null===t?null:t instanceof a||t instanceof u?t:new p.I(t)}function h(t,e){return null===t?"":t instanceof p.I?t.serialize():t instanceof a?t.canvasGradient(e):t instanceof u?t.canvasPattern(e)??"":""}function f(t,e,n,o,s){if(0===n.top&&0===n.right&&0===n.bottom&&0===n.left)return void function(t,e){t.rect(e.x,e.y,e.width,e.height)}(t,e);const r=y(n.top,n.right,n.left,e),p=y(n.right,n.top,n.bottom,e),i=y(n.bottom,n.left,n.right,e),c=y(n.left,n.bottom,n.top,e);if(o){const n=t=>t-t*s;return t.moveTo(e.left+r,e.top),t.lineTo(e.right-p,e.top),t.bezierCurveTo(e.right-n(p),e.top,e.right,e.top+n(p),e.right,e.top+p),t.lineTo(e.right,e.bottom-i),t.bezierCurveTo(e.right,e.bottom-n(i),e.right-n(i),e.bottom,e.right-i,e.bottom),t.lineTo(e.left+c,e.bottom),t.bezierCurveTo(e.left+n(c),e.bottom,e.left,e.bottom-n(c),e.left,e.bottom-c),t.lineTo(e.left,e.top+r),void t.bezierCurveTo(e.left,e.top+n(r),e.left+n(r),e.top,e.left+r,e.top)}t.moveTo(e.left+r,e.top),t.arcTo(e.right,e.top,e.right,e.bottom,p),t.arcTo(e.right,e.bottom,e.left,e.bottom,i),t.arcTo(e.left,e.bottom,e.left,e.top,c),t.arcTo(e.left,e.top,e.right,e.top,r)}function y(t,e,n,o){const s=t+e>o.width?o.width*(t/(t+e)):t,r=t+n>o.height?o.height*(t/(t+n)):t;return Math.min(s,r)}function k(t,e,n){const o=e.size.scale(.5);for(let s=0;s<=n;s++){const e=2*s*Math.PI/n,r=m.F.fromRadians(e).perpendicular.mul(o);0==s?M(t,r):D(t,r)}t.closePath()}function w(t,e,n,o){o?t.drawImage(e,n.x,n.y,n.width,n.height,o.x,o.y,o.width,o.height):t.drawImage(e,n.x,n.y,n.width,n.height)}function M(t,e){t.moveTo(e.x,e.y)}function D(t,e){t.lineTo(e.x,e.y)}function _(t,e){if(!(e.length<2)){M(t,e[0]);for(const n of e.slice(1))D(t,n)}}function X(t,e,n){void 0===n&&(n=8),D(t,e.addY(-n)),D(t,e.addY(n)),D(t,e),D(t,e.addX(-n)),g(t,e,n)}function g(t,e,n,o,s,r){void 0===o&&(o=0),void 0===s&&(s=2*Math.PI),void 0===r&&(r=!1),t.arc(e.x,e.y,n,o,s,r)}function x(t,e,n,o){t.bezierCurveTo(e.x,e.y,n.x,n.y,o.x,o.y)}function C(t,e,n){t.quadraticCurveTo(e.x,e.y,n.x,n.y)}},834:(t,e,n)=>{"use strict";n.d(e,{f:()=>s});var o=n(15688);function s(t,e,n){void 0===t&&(t={});const s={};if(n&&e){const r=t.setter??(null==e?void 0:e[`set${(0,o.k)(n)}`]);r&&(s.setter=r.bind(e));const p=t.getter??(null==e?void 0:e[`get${(0,o.k)(n)}`]);p&&(s.getter=p.bind(e));const i=t.tweener??(null==e?void 0:e[`tween${(0,o.k)(n)}`]);i&&(s.tweener=i.bind(e))}return s}},88733:(t,e,n)=>{"use strict";n.d(e,{q:()=>o,r:()=>r});var o,s=n(1323);!function(t){t[t.Playing=0]="Playing",t[t.Rendering=1]="Rendering",t[t.Paused=2]="Paused",t[t.Presenting=3]="Presenting"}(o||(o={}));class r{constructor(){this.frame=0,this.speed=1,this.fps=30,this.duration=0,this.finished=!1,this.slides=[],this.previousScene=null,this.state=o.Paused,this.currentSceneReference=null,this.scenes=new s.G([])}get onSceneChanged(){if(null===this.currentSceneReference)throw new Error("PlaybackManager has not been properly initialized");return this.currentSceneReference.subscribable}get onScenesRecalculated(){return this.scenes.subscribable}get currentScene(){if(null===this.currentSceneReference)throw new Error("PlaybackManager has not been properly initialized");return this.currentSceneReference.current}set currentScene(t){if(!t)throw new Error("Invalid scene.");this.currentSceneReference??(this.currentSceneReference=new s.G(t)),this.currentSceneReference.current=t}setup(t){this.scenes.current=t,this.currentScene=t[0]}async progress(){return this.finished=await this.next(),this.finished}async seek(t){if(t<=this.frame||this.currentScene.isCached()&&this.currentScene.lastFrame<t){const e=this.findBestScene(t);e!==this.currentScene?(this.previousScene=null,this.currentScene=e,this.frame=this.currentScene.firstFrame,await this.currentScene.reset()):this.frame>=t&&(this.previousScene=null,this.frame=this.currentScene.firstFrame,await this.currentScene.reset())}for(this.finished=!1;this.frame<t&&!this.finished;)this.finished=await this.next();return this.finished}async goBack(){let t=this.currentScene.slides.getCurrent();if(t&&this.currentScene.slides.isWaiting()){const e=this.slides.indexOf(t);t=this.slides[e-1]}await this.seekSlide(t)}async goForward(){const t=this.currentScene.slides.getCurrent(),e=this.slides.indexOf(t);await this.seekSlide(this.slides[e+1])}async goTo(t){await this.seekSlide(this.slides.find((e=>e.id===t)))}async seekSlide(t){if(void 0===t&&(t=null),!t)return;const{id:e,scene:n}=t;for((this.currentScene!==n||this.currentScene.slides.didHappen(e))&&(this.previousScene=null,this.currentScene=n,this.frame=this.currentScene.firstFrame,this.currentScene.slides.setTarget(e),await this.currentScene.reset()),this.finished=!1,this.currentScene.slides.setTarget(e);!this.currentScene.slides.isWaitingFor(e)&&!this.finished;)this.finished=await this.next();return this.currentScene.slides.setTarget(null),this.finished}async reset(){this.previousScene=null,this.currentScene=this.scenes.current[0],this.frame=0,await this.currentScene.reset()}reload(t){this.scenes.current.forEach((e=>e.reload(t)))}async recalculate(){this.previousScene=null,this.slides=[];const t=this.speed;this.frame=0,this.speed=1;const e=[];try{for(const t of this.scenes.current)await t.recalculate((t=>{this.frame=t})),this.slides.push(...t.slides.onChanged.current),e.push(t)}finally{this.speed=t}this.scenes.current=e,this.duration=this.frame}async next(){if(this.previousScene&&(await this.previousScene.next(),this.currentScene.isFinished()&&(this.previousScene=null)),this.frame+=this.speed,this.currentScene.isFinished())return!0;if(await this.currentScene.next(),this.previousScene&&this.currentScene.isAfterTransitionIn()&&(this.previousScene=null),this.currentScene.canTransitionOut()){this.previousScene=this.currentScene;const t=this.getNextScene(this.previousScene);t&&(this.currentScene=t,await this.currentScene.reset(this.previousScene)),t&&!this.currentScene.isAfterTransitionIn()||(this.previousScene=null)}return this.currentScene.isFinished()}findBestScene(t){let e=this.scenes.current[0];for(const n of this.scenes.current){if(!n.isCached()||n.lastFrame>t)return n;e=n}return e}getNextScene(t){const e=this.scenes.current;if(!t)return e[0];const n=e.findIndex((e=>e===t));return n<0?null:e[n+1]??null}}},2672:(t,e,n)=>{"use strict";n.d(e,{J:()=>f});var o=n(88733),s=n(1323),r=n(3163);class p{get onDataChanged(){return this.data.subscribable}constructor(t){this.logger=t,this.data=new s.G(null),this.context=new AudioContext,this.audioElement=new Audio,this.source=null,this.error=!1,this.abortController=null,this.offset=0}getTime(){return this.toAbsoluteTime(this.audioElement.currentTime)}setTime(t){this.audioElement.currentTime=this.toRelativeTime(t)}setOffset(t){this.offset=t}setMuted(t){this.audioElement.muted=t}setSource(t){var e;this.source=t,this.audioElement.src=t,null==(e=this.abortController)||e.abort(),this.abortController=new AbortController,this.loadData(this.abortController.signal).catch((t=>{"AbortError"!==t.name&&this.logger.error(t)}))}isInRange(t){return t>=this.offset&&t<this.audioElement.duration}toRelativeTime(t){return Math.max(0,t-this.offset)}toAbsoluteTime(t){return t+this.offset}isReady(){return this.source&&!this.error}async setPaused(t){if(this.source&&this.audioElement.paused!==t)if(t)this.audioElement.pause();else try{return await this.audioElement.play(),this.error=!1,!0}catch(e){this.error||(0,r.wL)().error(e),this.error=!0}return!1}async loadData(t){if(this.data.current=null,!this.source)return;const e=await fetch(this.source,{signal:t}),n=await e.arrayBuffer();if(t.aborted)return;const o=await this.decodeAudioData(n);if(t.aborted)return;const s=256,r=~~(o.length/s),p=[];let i=0;for(let c=0;c<o.numberOfChannels;c++){const t=o.getChannelData(c);for(let e=0;e<r;e++){const n=~~(e*s),o=~~(n+s);let r=t[n],a=r;for(let e=n;e<o;e++){const n=t[e];n>a&&(a=n),n<r&&(r=n)}(0===c||a>p[2*e])&&(p[2*e]=a),(0===c||r<p[2*e+1])&&(p[2*e+1]=r),a>i&&(i=a),Math.abs(r)>i&&(i=Math.abs(r))}}this.data.current={peaks:p,absoluteMax:i,length:r,sampleRate:o.sampleRate/s*2}}decodeAudioData(t){return new Promise(((e,n)=>this.context.decodeAudioData(t,e,n)))}}var i=n(13170),c=n(11395);class a extends c.p{async dispatch(t){await Promise.all(this.notifySubscribers(t))}}var l=n(96881),u=n(29797);class m{constructor(t){this.playback=t}secondsToFrames(t){return Math.ceil(t*this.playback.fps)}framesToSeconds(t){return t/this.playback.fps}get time(){return this.framesToSeconds(this.playback.frame)}get frame(){return this.playback.frame}get speed(){return this.playback.speed}get fps(){return this.playback.fps}get state(){return this.playback.state}}var d=n(15649);class h{get onChanged(){return this.events.subscribable}constructor(t){this.scene=t,this.events=new s.G([]),this.registeredEvents={},this.lookup={},this.collisionLookup=new Set,this.previousReference=[],this.didEventsChange=!1,this.preserveTiming=!0,this.handleReload=()=>{this.registeredEvents={},this.collisionLookup.clear()},this.handleRecalculated=()=>{var t;this.preserveTiming=!0,this.events.current=Object.values(this.registeredEvents),(this.didEventsChange||((null==(t=this.previousReference)?void 0:t.length)??0)!==this.events.current.length)&&(this.didEventsChange=!1,this.previousReference=Object.values(this.registeredEvents).map((t=>({name:t.name,targetTime:t.targetTime}))),this.scene.meta.timeEvents.set(this.previousReference))},this.handleReset=()=>{this.collisionLookup.clear()},this.handleMetaChanged=t=>{t!==this.previousReference&&(this.previousReference=t,this.load(t),this.scene.reload())},this.previousReference=t.meta.timeEvents.get(),this.load(this.previousReference),t.onReloaded.subscribe(this.handleReload),t.onRecalculated.subscribe(this.handleRecalculated),t.onReset.subscribe(this.handleReset),t.meta.timeEvents.onChanged.subscribe(this.handleMetaChanged,!1)}set(t,e,n){void 0===n&&(n=!0),this.lookup[t]&&this.lookup[t].offset!==e&&(this.preserveTiming=n,this.lookup[t]={...this.lookup[t],targetTime:this.lookup[t].initialTime+e,offset:e},this.registeredEvents[t]=this.lookup[t],this.events.current=Object.values(this.registeredEvents),this.didEventsChange=!0,this.scene.reload())}register(t,e){if(this.collisionLookup.has(t))return this.scene.logger.error({message:`name "${t}" has already been used for another event name.`,stack:(new Error).stack}),0;if(this.collisionLookup.add(t),this.lookup[t]){let n=!1;const o={...this.lookup[t]},s=(new Error).stack;o.stack!==s&&(o.stack=s,n=!0),o.initialTime!==e&&(o.initialTime=e,n=!0);const r=Math.max(0,o.targetTime-o.initialTime);this.preserveTiming&&o.offset!==r&&(o.offset=r,n=!0);const p=o.initialTime+o.offset;this.preserveTiming||o.targetTime===p||(this.didEventsChange=!0,o.targetTime=p,n=!0),n&&(this.lookup[t]=o)}else this.didEventsChange=!0,this.lookup[t]={name:t,initialTime:e,targetTime:e,offset:0,stack:(new Error).stack};return this.registeredEvents[t]=this.lookup[t],this.lookup[t].offset}load(t){for(const e of t){const t=this.lookup[e.name]??{name:e.name,initialTime:0,offset:0};this.lookup[e.name]={...t,targetTime:e.targetTime}}}}class f{get onRender(){return this.render.subscribable}get onStateChanged(){return this.playerState.subscribable}get onFrameChanged(){return this.frame.subscribable}get onDurationChanged(){return this.duration.subscribable}get onRecalculated(){return this.recalculated.subscribable}get startFrame(){return Math.min(this.playback.duration,this.status.secondsToFrames(this.startTime))}get endFrame(){return Math.min(this.playback.duration,this.status.secondsToFrames(this.endTime))}get finished(){return this.playback.finished||this.playback.frame>=this.endFrame}constructor(t,e,n,r){var i,c;void 0===e&&(e={}),void 0===n&&(n={}),void 0===r&&(r=-1),this.project=t,this.settings=e,this.initialState=n,this.initialFrame=r,this.render=new a,this.frame=new s.G(0),this.duration=new s.G(0),this.recalculated=new l.p,this.lock=new d.L,this.startTime=0,this.endTime=1/0,this.requestId=null,this.renderTime=0,this.requestedSeek=-1,this.requestedRecalculation=!0,this.active=!1,this.playerState=new s.G({loop:!0,muted:!0,speed:1,...n,paused:!0}),this.requestedSeek=r,this.logger=this.project.logger,this.playback=new o.r,this.status=new m(this.playback),this.audio=new p(this.logger),this.size=e.size??new u.F(1920,1080),this.resolutionScale=e.resolutionScale??1,this.startTime=(null==(i=e.range)?void 0:i[0])??0,this.endTime=(null==(c=e.range)?void 0:c[1])??1/0,this.playback.fps=e.fps??60,this.audio.setOffset(e.audioOffset??0),t.audio&&this.audio.setSource(t.audio);const f=[];for(const o of t.scenes){var y;const e=new o.klass({...o,playback:this.status,logger:this.project.logger,size:this.size,resolutionScale:this.resolutionScale,timeEventsClass:h});null==(y=o.onReplaced)||y.subscribe((t=>{e.reload(t)}),!1),e.onReloaded.subscribe((()=>this.requestRecalculation())),e.variables.updateSignals(t.variables??{}),f.push(e)}this.playback.setup(f),this.activate()}async configure(t){await this.lock.acquire();let e=this.playback.frame,n=!1;if(this.startTime=t.range[0],this.endTime=t.range[1],this.playback.fps!==t.fps){const o=t.fps/this.playback.fps;this.playback.fps=t.fps,e=Math.floor(e*o),n=!0}t.size.exactlyEquals(this.size)&&t.resolutionScale===this.resolutionScale||(this.size=t.size,this.resolutionScale=t.resolutionScale,this.playback.reload({size:this.size,resolutionScale:this.resolutionScale})),void 0!==t.audioOffset&&this.audio.setOffset(t.audioOffset),this.lock.release(),n&&(this.playback.reload(),this.frame.current=e,this.requestRecalculation(),this.requestedSeek=e)}requestSeek(t){this.requestedSeek=this.clampRange(t)}requestPreviousFrame(){this.requestedSeek=this.frame.current-this.playback.speed}requestNextFrame(){this.requestedSeek=this.frame.current+this.playback.speed}requestReset(){this.requestedSeek=0}toggleLoop(t){void 0===t&&(t=!this.playerState.current.loop),t!==this.playerState.current.loop&&(this.playerState.current={...this.playerState.current,loop:t})}togglePlayback(t){void 0===t&&(t=this.playerState.current.paused),t===this.playerState.current.paused&&(this.playerState.current={...this.playerState.current,paused:!t},t&&!this.playerState.current.loop&&this.playback.frame===this.playback.duration&&this.requestReset())}toggleAudio(t){void 0===t&&(t=this.playerState.current.muted),t===this.playerState.current.muted&&(this.playerState.current={...this.playerState.current,muted:!t})}setSpeed(t){t!==this.playerState.current.speed&&(this.playback.speed=t,this.playback.reload(),this.playerState.current={...this.playerState.current,speed:t},this.requestRecalculation())}setVariables(t){for(const e of this.playback.onScenesRecalculated.current)e.variables.updateSignals(t)}activate(){this.active=!0,this.request()}deactivate(){this.active=!1,null!==this.requestId&&(cancelAnimationFrame(this.requestId),this.requestId=null)}requestRecalculation(){this.requestedRecalculation=!0,this.request()}async prepare(){const t={...this.playerState.current,seek:this.requestedSeek};if(this.requestedSeek=-1,this.requestedRecalculation){t.seek<0&&(t.seek=this.playback.frame);try{await this.playback.recalculate(),this.duration.current=this.playback.frame,this.recalculated.dispatch()}catch(n){throw this.requestSeek(t.seek),n}finally{this.requestedRecalculation=!1}}(!t.loop&&this.finished&&!t.paused&&t.seek<0||this.endFrame===this.startFrame)&&(this.togglePlayback(!1),t.paused=!0),t.loop&&(t.seek>this.endFrame||this.finished&&!t.paused)&&this.startFrame!==this.endTime&&(t.seek=this.startFrame);const e=t.paused||this.finished||!this.audio.isInRange(this.status.time);return await this.audio.setPaused(e)&&this.syncAudio(-3),this.audio.setMuted(t.muted),t}async run(){const t=await this.prepare(),e=this.playback.state;if(this.playback.state=t.paused?o.q.Paused:o.q.Playing,t.seek>=0||!this.isInRange(this.status.frame)){const e=t.seek<0?this.status.frame:t.seek,n=this.clampRange(e);this.logger.profile("seek time"),await this.playback.seek(n),this.logger.profile("seek time"),this.syncAudio(-3)}else{if(t.paused||1===t.speed&&this.audio.isReady()&&this.audio.isInRange(this.status.time)&&this.audio.getTime()<this.status.time)return t.paused&&e!==o.q.Paused&&await this.render.dispatch(),!t.paused&&this.status.time>this.audio.getTime()+.02&&this.syncAudio(),void this.request();if(this.audio.isReady()&&1===t.speed&&this.audio.isInRange(this.status.time)&&this.status.framesToSeconds(this.playback.frame+1)<this.audio.getTime()-.02){const t=this.status.secondsToFrames(this.audio.getTime());await this.playback.seek(t)}else this.status.frame<this.endFrame&&(await this.playback.progress(),1!==t.speed&&this.syncAudio())}!t.paused&&this.playback.currentScene.slides.isWaiting()&&(this.togglePlayback(!1),t.paused=!0),await this.render.dispatch(),this.frame.current=this.playback.frame,this.request()}request(){this.active&&(this.requestId??(this.requestId=requestAnimationFrame((async t=>{if(this.requestId=null,t-this.renderTime>=1e3/(this.status.fps+5)){this.renderTime=t,await this.lock.acquire();try{await this.run()}catch(e){this.logger.error(e)}this.lock.release()}else this.request()}))))}clampRange(t){return(0,i.uZ)(this.startFrame,this.endFrame,t)}isInRange(t){return t>=this.startFrame&&t<=this.endFrame}syncAudio(t){void 0===t&&(t=0),this.audio.setTime(this.status.framesToSeconds(this.playback.frame+t))}}},9989:(t,e,n)=>{"use strict";n.d(e,{H:()=>r});var o=n(1119),s=n(29797);class r{get canvasSize(){return this.size.scale(this.resolutionScale)}constructor(){this.background=null,this.resolutionScale=1,this.colorSpace="srgb",this.size=s.F.zero,this.finalBuffer=document.createElement("canvas"),this.currentBuffer=document.createElement("canvas"),this.previousBuffer=document.createElement("canvas");const t=this.colorSpace;this.context=(0,o.f)({colorSpace:t},this.finalBuffer),this.currentContext=(0,o.f)({colorSpace:t},this.currentBuffer),this.previousContext=(0,o.f)({colorSpace:t},this.previousBuffer)}configure(t){let{colorSpace:e=this.colorSpace,size:n=this.size,resolutionScale:s=this.resolutionScale,background:r=this.background}=t;e!==this.colorSpace&&(this.colorSpace=e,this.context=(0,o.f)({colorSpace:e},this.finalBuffer),this.currentContext=(0,o.f)({colorSpace:e},this.currentBuffer),this.previousContext=(0,o.f)({colorSpace:e},this.previousBuffer)),n.exactlyEquals(this.size)&&s===this.resolutionScale||(this.resolutionScale=s,this.size=n,this.resizeCanvas(this.context),this.resizeCanvas(this.currentContext),this.resizeCanvas(this.previousContext)),this.background="string"==typeof r?r:(null==r?void 0:r.serialize())??null}async render(t,e){e&&(this.transformCanvas(this.previousContext),await e.render(this.previousContext)),this.transformCanvas(this.currentContext),await t.render(this.currentContext);const n=this.canvasSize;this.context.clearRect(0,0,n.width,n.height),this.background&&(this.context.save(),this.context.fillStyle=this.background,this.context.fillRect(0,0,n.width,n.height),this.context.restore()),e&&this.context.drawImage(this.previousBuffer,0,0),this.context.drawImage(this.currentBuffer,0,0)}transformCanvas(t){const e=this.canvasSize.scale(.5);t.setTransform(this.resolutionScale,0,0,this.resolutionScale,e.x,e.y)}resizeCanvas(t){const e=this.canvasSize;t.canvas.width=e.width,t.canvas.height=e.height}}},42075:(t,e,n)=>{"use strict";function o(t){const e={[t.name]:t},n=Object.getOwnPropertyDescriptor(e,t.name);if(n){for(var o=arguments.length,s=new Array(o>1?o-1:0),r=1;r<o;r++)s[r-1]=arguments[r];for(let o=s.length-1;o>=0;o--)s[o](e,t.name,n)}}n.d(e,{G:()=>o})},79116:(t,e,n)=>{"use strict";n.d(e,{V:()=>s});const o=Symbol.for("@motion-canvas/core/decorators/UNINITIALIZED");function s(t){return(e,n)=>{let s=o;Object.defineProperty(e,n,{get(){return s===o&&(s=t.call(this)),s}})}}},67292:(t,e,n)=>{"use strict";function o(t){return function(e,n,o){o.value.prototype.name=t??n,o.value.prototype.threadable=!0}}n.d(e,{C:()=>o})},96881:(t,e,n)=>{"use strict";n.d(e,{p:()=>s});var o=n(11395);class s extends o.p{dispatch(t){this.notifySubscribers(t)}}},11395:(t,e,n)=>{"use strict";n.d(e,{l:()=>s,p:()=>o});class o{constructor(){this.subscribable=new s(this),this.subscribers=new Set}subscribe(t){return this.subscribers.add(t),()=>this.unsubscribe(t)}unsubscribe(t){this.subscribers.delete(t)}clear(){this.subscribers.clear()}notifySubscribers(t){return[...this.subscribers].map((e=>e(t)))}}class s{constructor(t){this.dispatcher=t}subscribe(t){return this.dispatcher.subscribe(t)}unsubscribe(t){this.dispatcher.unsubscribe(t)}}},1323:(t,e,n)=>{"use strict";n.d(e,{G:()=>s});var o=n(11395);class s extends o.p{set current(t){this.value=t,this.notifySubscribers(t)}get current(){return this.value}constructor(t){super(),this.value=t,this.subscribable=new r(this)}subscribe(t,e){void 0===e&&(e=!0);const n=super.subscribe(t);return e&&t(this.value),n}}class r extends o.l{get current(){return this.dispatcher.current}subscribe(t,e){return void 0===e&&(e=!0),this.dispatcher.subscribe(t,e)}}},5376:(t,e,n)=>{"use strict";n.d(e,{$:()=>p});var o=n(51284),s=n(42075),r=n(67292);function*p(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];for(const o of e)yield o;yield*(0,o.v)(...e)}(0,s.G)(p,(0,r.C)())},77396:(t,e,n)=>{"use strict";n.d(e,{K:()=>s});var o=n(75168);function s(t,e){let n;return"string"==typeof t?(n=e(),(0,o.i)(n,t)):(n=t(),(0,o.i)(n,n)),n}},84266:(t,e,n)=>{"use strict";n.d(e,{A:()=>c,X:()=>a});var o=n(42075),s=n(67292),r=n(30092),p=n(56632),i=n(97715);function*c(t,e){yield*a((0,r.Y)(t)),e&&(yield*e)}function*a(t,e){void 0===t&&(t=0);const n=(0,p.nn)(),o=(0,i.te)().framesToSeconds(1),s=n.time()+t;for(;s-o>n.fixed;)yield;n.time(s),e&&(yield*e)}(0,o.G)(c,(0,s.C)()),(0,o.G)(a,(0,s.C)())},82344:(t,e,n)=>{"use strict";n.d(e,{C:()=>s});var o=n(1323);class s{get onChanged(){return this.value.subscribable}get onDisabled(){return this.disabled.subscribable}constructor(t,e){this.name=t,this.type=void 0,this.spacing=!1,this.description="",this.disabled=new o.G(!1),this.value=new o.G(e)}get(){return this.value.current}set(t){this.value.current=this.parse(t)}parse(t){return t}serialize(){return this.value.current}clone(){return new this.constructor(this.name,this.get())}disable(t){return void 0===t&&(t=!0),this.disabled.current=t,this}space(t){return void 0===t&&(t=!0),this.spacing=t,this}describe(t){return this.description=t,this}}},92673:(t,e,n)=>{"use strict";n.d(e,{v:()=>p});var o=n(82344),s=n(1323);class r extends o.C{get onFieldsChanged(){return this.event.subscribable}constructor(t,e){const n=new Map(Object.entries(e));super(t,Object.fromEntries(Array.from(n,(t=>{let[e,n]=t;return[e,n.get()]})))),this.type=Object,this.ignoreChange=!1,this.customFields={},this.handleChange=()=>{this.ignoreChange||(this.value.current=this.transform("get"))},this.event=new s.G([...n.values()]),this.fields=n;for(const[o,s]of this.fields)Object.defineProperty(this,o,{value:s}),s.onChanged.subscribe(this.handleChange)}set(t){this.ignoreChange=!0;for(const[e,n]of Object.entries(t)){const t=this.fields.get(e);t?t.set(n):this.customFields[e]=n}this.ignoreChange=!1,this.handleChange()}serialize(){return this.transform("serialize")}clone(){return new this.constructor(this.name,this.transform("clone"))}transform(t){return{...Object.fromEntries(Array.from(this.fields,(e=>{let[n,o]=e;return[n,o[t]()]}))),...this.customFields}}}const p=r},11726:(t,e,n)=>{"use strict";n.d(e,{k:()=>r});var o=n(13170),s=n(37762);class r{constructor(t){this.state=t}static createSeed(){return Math.floor(4294967296*Math.random())}nextFloat(t,e){return void 0===t&&(t=0),void 0===e&&(e=1),(0,o.UI)(t,e,this.next())}nextInt(t,e){void 0===t&&(t=0),void 0===e&&(e=4294967296);let n=Math.floor((0,o.UI)(t,e,this.next()));return n===e&&(n=t),n}floatArray(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,s.w)(t).map((()=>this.nextFloat(e,n)))}intArray(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=4294967296),(0,s.w)(t).map((()=>this.nextInt(e,n)))}spawn(){return new r(this.nextInt())}next(){this.state|=0,this.state=this.state+1831565813|0;let t=Math.imul(this.state^this.state>>>15,1|this.state);return t=t+Math.imul(t^t>>>7,61|t)^t,((t^t>>>14)>>>0)/4294967296}}},46096:(t,e,n)=>{"use strict";n.d(e,{N:()=>p});var o=n(13170),s=n(16249),r=n(68003);class p extends s.V{constructor(t,e,n,p,i,c){var a;void 0===i&&(i=void 0),void 0===c&&(c={}),super(void 0,p,i,e,c),this.entries=t,this.signals=[],this.parser=e;for(const l of t){let t,p;Array.isArray(l)?([t,p]=l,(a=p.context).owner??(a.owner=this)):(t=l,p=new s.V((0,r.Pj)(n,(t=>e(t)[l])),o.UI,i??this.invokable).toSignal()),this.signals.push([t,p]),Object.defineProperty(this.invokable,t,{value:p})}}toSignal(){return this.invokable}parse(t){return this.parser(t)}getter(){return this.parse(Object.fromEntries(this.signals.map((t=>{let[e,n]=t;return[e,n()]}))))}setter(t){if((0,r.PG)(t))for(const[e,n]of this.signals)n((()=>this.parser(t())[e]));else{const e=this.parse(t);for(const[t,n]of this.signals)n(e[t])}return this.owner}reset(){for(const[,t]of this.signals)t.reset();return this.owner}save(){for(const[,t]of this.signals)t.save();return this.owner}}},81865:(t,e,n)=>{"use strict";n.d(e,{h:()=>p});var o=n(3163),s=n(90031),r=n(76062);class p extends r.k{constructor(t,e){super(e),this.factory=t,this.markDirty()}toSignal(){return this.invokable}dispose(){super.dispose(),this.last=void 0}invoke(){if(this.event.isRaised()){this.clearDependencies(),this.startCollecting();try{this.last=this.factory(...arguments)}catch(e){var t;(0,o.wL)().error({...(0,s.d)(e),inspect:null==(t=this.owner)?void 0:t.key})}this.finishCollecting()}return this.event.reset(),this.collect(),this.last}}},76062:(t,e,n)=>{"use strict";n.d(e,{k:()=>p});var o=n(11395);class s extends o.p{constructor(){super(...arguments),this.value=!1}raise(){this.value||(this.value=!0,this.notifySubscribers())}reset(){this.value=!1}isRaised(){return this.value}subscribe(t){const e=super.subscribe(t);return this.value&&t(),e}}var r=n(49111);class p{static collectPromise(t,e){void 0===e&&(e=null);const n={promise:t,value:e,stack:(new Error).stack},o=this.collectionStack.at(-1);return o&&(n.owner=o.owner),t.then((t=>{n.value=t,null==o||o.markDirty()})),this.promises.push(n),n}static hasPromises(){return this.promises.length>0}static async consumePromises(){const t=[...this.promises];return await Promise.all(t.map((t=>t.promise))),this.promises=this.promises.filter((e=>!t.includes(e))),t}constructor(t){this.owner=t,this.dependencies=new Set,this.event=new s,this.markDirty=()=>this.event.raise(),this.invokable=this.invoke.bind(this),Object.defineProperty(this.invokable,"context",{value:this}),Object.defineProperty(this.invokable,"toPromise",{value:this.toPromise.bind(this)})}invoke(){}startCollecting(){if(p.collectionSet.has(this))throw new r.t("A circular dependency occurred between signals.","This can happen when signals reference each other in a loop.\n        Try using the attached stack trace to locate said loop.");p.collectionSet.add(this),p.collectionStack.push(this)}finishCollecting(){if(p.collectionSet.delete(this),p.collectionStack.pop()!==this)throw new Error("collectStart/collectEnd was called out of order.")}clearDependencies(){this.dependencies.forEach((t=>t.unsubscribe(this.markDirty))),this.dependencies.clear()}collect(){const t=p.collectionStack.at(-1);t&&(t.dependencies.add(this.event.subscribable),this.event.subscribe(t.markDirty))}dispose(){this.clearDependencies(),this.event.clear(),this.owner=null}async toPromise(){do{await p.consumePromises(),this.invokable()}while(p.hasPromises());return this.invokable}}p.collectionSet=new Set,p.collectionStack=[],p.promises=[]},16249:(t,e,n)=>{"use strict";n.d(e,{V:()=>m});var o=n(97074),s=n(74534),r=n(3163),p=n(90031),i=n(77396),c=n(84266),a=n(76062),l=n(68003),u=n(60771);class m extends a.k{constructor(t,e,n,o,s){void 0===n&&(n=void 0),void 0===o&&(o=t=>t),void 0===s&&(s={}),super(n),this.initial=t,this.interpolation=e,this.parser=o,Object.defineProperty(this.invokable,"reset",{value:this.reset.bind(this)}),Object.defineProperty(this.invokable,"save",{value:this.save.bind(this)}),Object.defineProperty(this.invokable,"isInitial",{value:this.isInitial.bind(this)}),void 0!==this.initial&&(this.current=this.initial,this.markDirty(),(0,l.PG)(this.initial)||(this.last=this.parse(this.initial))),this.extensions={getter:this.getter.bind(this),setter:this.setter.bind(this),tweener:this.tweener.bind(this),...s}}toSignal(){return this.invokable}parse(t){return this.parser(t)}set(t){return this.extensions.setter(t),this.owner}setter(t){return t===u.T&&(t=this.initial),this.current===t||(this.current=t,this.markDirty(),this.clearDependencies(),(0,l.PG)(t)||(this.last=this.parse(t))),this.owner}get(){return this.extensions.getter()}getter(){if(this.event.isRaised()&&(0,l.PG)(this.current)){this.clearDependencies(),this.startCollecting();try{this.last=this.parse(this.current())}catch(e){var t;(0,r.wL)().error({...(0,p.d)(e),inspect:null==(t=this.owner)?void 0:t.key})}this.finishCollecting()}return this.event.reset(),this.collect(),this.last}invoke(t,e,n,s){if(void 0===n&&(n=o.qb),void 0===s&&(s=this.interpolation),void 0===t)return this.get();if(void 0===e)return this.set(t);return this.createQueue(n,s).to(t,e)}createQueue(t,e){var n=this;const o=this.get(),s=[],r=(0,i.K)((function*(){for(;s.length>0;)yield*s.shift()}));return r.to=function(o,p,i,c){return void 0===i&&(i=t),void 0===c&&(c=e),t=i,e=c,s.push(n.tween(o,p,i,c)),r},r.back=function(p,i,c){return void 0===i&&(i=t),void 0===c&&(c=e),t=i,e=c,s.push(n.tween(o,p,t,e)),r},r.wait=t=>(s.push((0,c.X)(t)),r),r.run=t=>(s.push(t),r),r.do=t=>(s.push((0,i.K)((function*(){t()}))),r),r}*tween(t,e,n,o){t===u.T&&(t=this.initial),yield*this.extensions.tweener(t,e,n,o),this.set(t)}*tweener(t,e,n,o){const r=this.get();yield*(0,s.i)(e,(e=>{this.set(o(r,this.parse((0,l.Wg)(t)),n(e)))}))}dispose(){super.dispose(),this.initial=void 0,this.current=void 0,this.last=void 0}reset(){return void 0!==this.initial&&this.set(this.initial),this.owner}save(){return this.set(this.get())}isInitial(){return this.collect(),this.current===this.initial}raw(){return this.current}}},73662:(t,e,n)=>{"use strict";n.d(e,{D:()=>s});var o=n(81865);function s(t,e){return new o.h(t,e).toSignal()}},97140:(t,e,n)=>{"use strict";n.d(e,{g:()=>r});var o=n(13170),s=n(16249);function r(t,e,n){return void 0===e&&(e=o.o0),new s.V(t,e,n).toSignal()}},60771:(t,e,n)=>{"use strict";n.d(e,{T:()=>o});const o=Symbol.for("@motion-canvas/core/signals/default")},68003:(t,e,n)=>{"use strict";function o(t){return"function"==typeof t}function s(t,e){return o(t)?()=>e(t()):e(t)}function r(t){return o(t)?t():t}n.d(e,{PG:()=>o,Pj:()=>s,Wg:()=>r})},50580:(t,e,n)=>{"use strict";n.d(e,{j:()=>p});var o=n(56632),s=n(97140),r=n(75168);class p{get fixed(){return this.fixedTime}get canceled(){var t;return this.isCanceled||((null==(t=this.parent)?void 0:t.canceled)??!1)}get paused(){var t;return this.isPaused||((null==(t=this.parent)?void 0:t.paused)??!1)}constructor(t){this.runner=t,this.children=[],this.time=(0,s.g)(0),this.parent=null,this.isCanceled=!1,this.isPaused=!1,this.fixedTime=0}next(){if(this.paused)return{value:null,done:!1};(0,o.h$)(this);const t=this.runner.next(this.value);return(0,o.kw)(this),this.value=null,t}update(t){this.paused||(this.time(this.time()+t),this.fixedTime+=t),this.children=this.children.filter((t=>!t.canceled))}add(t){t.cancel(),t.parent=this,t.isCanceled=!1,t.time(this.time()),t.fixedTime=this.fixedTime,this.children.push(t),(0,r.i)(t.runner,`unknown ${this.children.length}`)}cancel(){this.isCanceled=!0,this.parent=null}pause(t){this.isPaused=t}}},80638:(t,e,n)=>{"use strict";function o(t){return t&&("object"==typeof t||"function"==typeof t)&&"toPromise"in t}function s(t){return null!==t&&"object"==typeof t&&Symbol.iterator in t&&"next"in t}n.d(e,{R:()=>s,x:()=>o})},51284:(t,e,n)=>{"use strict";n.d(e,{v:()=>p});var o=n(42075),s=n(67292),r=n(56632);function*p(t){let e=!0;for(var n=arguments.length,o=new Array(n>1?n-1:0),s=1;s<n;s++)o[s-1]=arguments[s];"boolean"==typeof t?e=t:o.push(t);const p=(0,r.nn)(),i=o.map((t=>p.children.find((e=>e.runner===t)))).filter((t=>t)),c=p.time();let a;if(e){for(;i.find((t=>!t.canceled));)yield;a=Math.max(...i.map((t=>t.time())))}else{for(;!i.find((t=>t.canceled));)yield;const t=i.filter((t=>t.canceled));a=Math.min(...t.map((t=>t.time())))}p.time(Math.max(c,a))}(0,o.G)(p,(0,s.C)())},75168:(t,e,n)=>{"use strict";function o(t,e){const n=Object.getPrototypeOf(t);n.threadable||(n.threadable=!0,n.name="string"==typeof e?e:s(e))}function s(t){return Object.getPrototypeOf(t).name??null}n.d(e,{i:()=>o,z:()=>s})},5881:(t,e,n)=>{"use strict";n.d(e,{C:()=>l,t:()=>a});var o=n(42075),s=n(67292),r=n(50580),p=n(80638),i=n(75168),c=n(97715);function a(t){return"function"==typeof(null==t?void 0:t.then)}function*l(t,e){const n=(0,c.te)(),o=t();(0,i.i)(o,"root");const s=new r.j(o);null==e||e(s);let a=[s];for(;a.length>0;){const t=[],e=[...a],o=n.framesToSeconds(1)*n.speed;for(;e.length>0;){const n=e.pop();if(!n||n.canceled)continue;const s=n.next();if(s.done)n.cancel();else if((0,p.R)(s.value)){const t=new r.j(s.value);n.value=s.value,n.add(t),e.push(n),e.push(t)}else s.value?(n.value=yield s.value,e.push(n)):(n.update(o),t.unshift(n))}a=t.filter((t=>!t.canceled)),a.length>0&&(yield)}}(0,o.G)(l,(0,s.C)())},13170:(t,e,n)=>{"use strict";n.d(e,{JC:()=>r,UI:()=>i,Vz:()=>u,a2:()=>c,o0:()=>p,uZ:()=>a,vl:()=>l});var o=n(3163),s=n(29797);function r(t,e,n){if(e.length>=t.length){const o=Math.floor(e.length*n),s=Math.floor(i(t.length-1,e.length,n));let r="";for(let n=0;n<e.length;n++)n<o?r+=e[n]:(t[n]||n<=s)&&(r+=t[n]??e[n]);return r}{const o=Math.round(t.length*(1-n)),s=Math.floor(i(t.length+1,e.length,n)),r=[];for(let n=t.length-1;n>=0;n--)n<o?r.unshift(t[n]):(e[n]||n<s)&&r.unshift(e[n]??t[n]);return r.join("")}}function p(t,e,n,s){if(void 0===s&&(s=!1),0===n)return t;if(1===n)return e;if(null!=t&&null!=e){if("number"==typeof t&&"number"==typeof e)return i(t,e,n);if("string"==typeof t&&"string"==typeof e)return r(t,e,n);if("boolean"==typeof t&&"boolean"==typeof e)return n<.5?t:e;if("lerp"in t)return t.lerp(e,n);if(t&&e&&"object"==typeof t&&"object"==typeof e)if(Array.isArray(t)&&Array.isArray(e)){if(t.length===e.length)return t.map(((t,o)=>p(t,e[o],n)))}else{let o=!1;if(t instanceof Map||e instanceof Map||(o=!0,t=new Map(Object.entries(t)),e=new Map(Object.entries(e))),t instanceof Map&&e instanceof Map){const s=new Map;for(const o of new Set([...t.keys(),...e.keys()])){const r=p(t.get(o),e.get(o),n,!0);void 0!==r&&s.set(o,r)}return o?Object.fromEntries(s):s}}return e}s||(0,o.wL)().warn(`Attempting to lerp ${t} -> ${e} may result in unexpected behavior.`)}function i(t,e,n){return t+(e-t)*n}function c(t,e,n,o,s){return n+(s-t)*(o-n)/(e-t)}function a(t,e,n){return n<t?t:n>e?e:n}function l(t,e,n,o,s){const r=c(t,e,n,o,s);return n>o&&([n,o]=[o,n]),a(n,o,r)}function u(t,e,n){let o=e;n>1?n=1/n:o=!o;const r=i(o?Math.acos(a(-1,1,1-t)):Math.asin(t),i(0,Math.PI/2,t),n);let p=Math.sin(r),c=1-Math.cos(r);return e&&([p,c]=[c,p]),new s.F(p,c)}},97074:(t,e,n)=>{"use strict";n.d(e,{BH:()=>E,Bl:()=>b,C6:()=>B,FG:()=>c,Fs:()=>i,GE:()=>P,Ge:()=>C,Ij:()=>R,J7:()=>y,Kx:()=>Z,Mg:()=>g,N1:()=>r,O$:()=>s,Q9:()=>u,SJ:()=>F,UE:()=>W,Y3:()=>f,Yw:()=>I,ad:()=>_,cv:()=>U,du:()=>N,eE:()=>G,e_:()=>D,ei:()=>x,en:()=>O,g4:()=>h,hN:()=>X,hl:()=>a,j$:()=>T,jv:()=>S,lj:()=>v,mC:()=>A,n5:()=>k,pl:()=>w,qS:()=>L,qb:()=>d,rz:()=>M,sK:()=>j,to:()=>l,vh:()=>p,w2:()=>m,zk:()=>z});var o=n(13170);function s(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,o.a2)(-1,1,e,n,Math.sin(t))}function r(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.cos(t*Math.PI/2),(0,o.UI)(e,n,t)}function p(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=Math.sin(t*Math.PI/2),(0,o.UI)(e,n,t)}function i(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=-(Math.cos(Math.PI*t)-1)/2,(0,o.UI)(e,n,t)}function c(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t,(0,o.UI)(e,n,t)}function a(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,2),(0,o.UI)(e,n,t)}function l(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2,(0,o.UI)(e,n,t)}function u(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t*t,(0,o.UI)(e,n,t)}function m(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,3),(0,o.UI)(e,n,t)}function d(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,(0,o.UI)(e,n,t)}function h(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t*t*t,(0,o.UI)(e,n,t)}function f(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,4),(0,o.UI)(e,n,t)}function y(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?8*t*t*t*t:1-Math.pow(-2*t+2,4)/2,(0,o.UI)(e,n,t)}function k(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t*t*t*t,(0,o.UI)(e,n,t)}function w(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,5),(0,o.UI)(e,n,t)}function M(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?16*t*t*t*t*t:1-Math.pow(-2*t+2,5)/2,(0,o.UI)(e,n,t)}function D(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=0===t?0:Math.pow(2,10*t-10),(0,o.UI)(e,n,t)}function _(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1===t?1:1-Math.pow(2,-10*t),(0,o.UI)(e,n,t)}function X(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=0===t?0:1===t?1:t<.5?Math.pow(2,20*t-10)/2:(2-Math.pow(2,-20*t+10))/2,(0,o.UI)(e,n,t)}function g(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.sqrt(1-Math.pow(t,2)),(0,o.UI)(e,n,t)}function x(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=Math.sqrt(1-Math.pow(t-1,2)),(0,o.UI)(e,n,t)}function C(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?(1-Math.sqrt(1-Math.pow(2*t,2)))/2:(Math.sqrt(1-Math.pow(-2*t+2,2))+1)/2,(0,o.UI)(e,n,t)}function T(t){return void 0===t&&(t=1.70158),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=(t+1)*e*e*e-t*e*e,(0,o.UI)(n,s,e)}}function v(t){return void 0===t&&(t=1.70158),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=1+(t+1)*Math.pow(e-1,3)+t*Math.pow(e-1,2),(0,o.UI)(n,s,e)}}function b(t,e){return void 0===t&&(t=1.70158),void 0===e&&(e=1.525),function(n,s,r){return void 0===s&&(s=0),void 0===r&&(r=1),n=n<.5?Math.pow(2*n,2)*(2*(t*e+1)*n-t*e)/2:(Math.pow(2*n-2,2)*((t*e+1)*(2*n-2)+t*e)+2)/2,(0,o.UI)(s,r,n)}}function L(t){return void 0===t&&(t=2.094395),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=0===e?0:1===e?1:-Math.pow(2,10*e-10)*Math.sin((10*e-10.75)*t),(0,o.UI)(n,s,e)}}function Z(t){return void 0===t&&(t=2.094395),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=0===e?0:1===e?1:Math.pow(2,-10*e)*Math.sin((10*e-.75)*t)+1,(0,o.UI)(n,s,e)}}function N(t){return void 0===t&&(t=1.39626),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=0===e?0:1===e?1:e<.5?-Math.pow(2,20*e-10)*Math.sin((20*e-11.125)*t)/2:Math.pow(2,-20*e+10)*Math.sin((20*e-11.125)*t)/2+1,(0,o.UI)(n,s,e)}}function S(t,e){void 0===t&&(t=7.5625),void 0===e&&(e=2.75);const n=z(t,e);return function(t,e,o){return void 0===e&&(e=0),void 0===o&&(o=1),1-n(1-t,e,o)}}function z(t,e){return void 0===t&&(t=7.5625),void 0===e&&(e=2.75),function(n,s,r){return void 0===s&&(s=0),void 0===r&&(r=1),n<1/e?n*=t*n:n=n<2/e?t*(n-=1.505/e)*n+.75:n<2.5/e?t*(n-=2.25/e)*n+.9375:t*(n-=2.625/e)*n+.984375,(0,o.UI)(s,r,n)}}function R(t,e){void 0===t&&(t=7.5625),void 0===e&&(e=2.75);const n=z(t,e);return function(t,e,o){return void 0===e&&(e=0),void 0===o&&(o=1),t<.5?(1-n(1-2*t,e,o))/2:(1+n(2*t-1,e,o))/2}}function P(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,o.UI)(e,n,t)}function A(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,o.a2)(-1,1,e,n,Math.cos(t))}const I=T(),W=v(),E=b(),F=S(),B=z(),O=R(),G=L(),j=Z(),U=N()},74534:(t,e,n)=>{"use strict";n.d(e,{i:()=>p});var o=n(42075),s=n(67292),r=n(56632);function*p(t,e,n){const o=(0,r.nn)(),s=o.time(),p=o.time()+t;for(e(0,0);p>o.fixed;){const n=o.fixed-s;n>0&&e(n/t,n),yield}o.time(p),e(1,t),null==n||n(1,t)}(0,o.G)(p,(0,s.C)())},23357:(t,e,n)=>{"use strict";n.d(e,{b:()=>p});var o=n(29797),s=n(13170),r=n(46096);class p{static createSignal(t,e){return void 0===e&&(e=p.lerp),new r.N(["x","y","width","height"],(t=>new p(t)),t,e).toSignal()}static lerp(t,e,n){let r,i,c,a;return"number"==typeof n?r=i=c=a=n:n instanceof o.F?(r=c=n.x,i=a=n.y):(r=n.x,i=n.y,c=n.width,a=n.height),new p((0,s.UI)(t.x,e.x,r),(0,s.UI)(t.y,e.y,i),(0,s.UI)(t.width,e.width,c),(0,s.UI)(t.height,e.height,a))}static arcLerp(t,e,n,o,r){return void 0===o&&(o=!1),r??(r=(t.position.sub(e.position).ctg+t.size.sub(e.size).ctg)/2),p.lerp(t,e,(0,s.Vz)(n,o,r))}static fromSizeCentered(t){return new p(-t.width/2,-t.height/2,t.width,t.height)}static fromPoints(){let t=1/0,e=1/0,n=-1/0,o=-1/0;for(var s=arguments.length,r=new Array(s),i=0;i<s;i++)r[i]=arguments[i];for(const p of r)p.x>n&&(n=p.x),p.x<t&&(t=p.x),p.y>o&&(o=p.y),p.y<e&&(e=p.y);return new p(t,e,n-t,o-e)}static fromBBoxes(){let t=1/0,e=1/0,n=-1/0,o=-1/0;for(var s=arguments.length,r=new Array(s),i=0;i<s;i++)r[i]=arguments[i];for(const p of r){const s=p.x+p.width;s>n&&(n=s),p.x<t&&(t=p.x);const r=p.y+p.height;r>o&&(o=r),p.y<e&&(e=p.y)}return new p(t,e,n-t,o-e)}lerp(t,e){return p.lerp(this,t,e)}get position(){return new o.F(this.x,this.y)}set position(t){this.x=t.x,this.y=t.y}get size(){return new o.F(this.width,this.height)}get center(){return new o.F(this.x+this.width/2,this.y+this.height/2)}get left(){return this.x}set left(t){this.width+=this.x-t,this.x=t}get right(){return this.x+this.width}set right(t){this.width=t-this.x}get top(){return this.y}set top(t){this.height+=this.y-t,this.y=t}get bottom(){return this.y+this.height}set bottom(t){this.height=t-this.y}get topLeft(){return this.position}get topRight(){return new o.F(this.x+this.width,this.y)}get bottomLeft(){return new o.F(this.x,this.y+this.height)}get bottomRight(){return new o.F(this.x+this.width,this.y+this.height)}get corners(){return[this.topLeft,this.topRight,this.bottomRight,this.bottomLeft]}get pixelPerfect(){return new p(Math.floor(this.x),Math.floor(this.y),Math.ceil(this.width+1),Math.ceil(this.height+1))}constructor(t,e,n,s){if(void 0===e&&(e=0),void 0===n&&(n=0),void 0===s&&(s=0),this.x=0,this.y=0,this.width=0,this.height=0,null!=t){if("number"==typeof t)return this.x=t,this.y=e,this.width=n,void(this.height=s);if(t instanceof o.F)return this.x=t.x,this.y=t.y,void(e instanceof o.F&&(this.width=e.x,this.height=e.y));if(Array.isArray(t))return this.x=t[0],this.y=t[1],this.width=t[2],void(this.height=t[3]);this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height}}transform(t){return new p(this.position.transformAsPoint(t),this.size.transform(t))}transformCorners(t){return this.corners.map((e=>e.transformAsPoint(t)))}expand(t){return new p(this.x-t,this.y-t,this.width+2*t,this.height+2*t)}addSpacing(t){const e=new p(this);return e.left-=t.left,e.top-=t.top,e.right+=t.right,e.bottom+=t.bottom,e}includes(t){return t.x>=this.x&&t.x<=this.x+this.width&&t.y>=this.y&&t.y<=this.y+this.height}intersects(t){return this.left<t.right&&this.right>t.left&&this.top<t.bottom&&this.bottom>t.top}intersection(t){const e=new p;return this.intersects(t)&&(e.left=Math.max(this.left,t.left),e.top=Math.max(this.top,t.top),e.right=Math.min(this.right,t.right),e.bottom=Math.min(this.bottom,t.bottom)),e}toSymbol(){return p.symbol}serialize(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}p.symbol=Symbol.for("@motion-canvas/core/types/Rect")},30204:(t,e,n)=>{"use strict";n.d(e,{I:()=>r});var o=n(5392),s=n(16249);const r=(o.Color.symbol=o.Color.prototype.symbol=Symbol.for("@motion-canvas/core/types/Color"),o.Color.lerp=o.Color.prototype.lerp=function(t,e,n,s){void 0===s&&(s="lch"),"string"==typeof t&&(t=new o.Color(t)),"string"==typeof e&&(e=new o.Color(e));const r=t instanceof o.Color,p=e instanceof o.Color;return r||(t=p?e.alpha(0):new o.Color("rgba(0, 0, 0, 0)")),p||(e=r?t.alpha(0):new o.Color("rgba(0, 0, 0, 0)")),(0,o.mix)(t,e,n,s)},o.Color.createLerp=o.Color.prototype.createLerp=t=>(e,n,s)=>o.Color.lerp(e,n,s,t),o.Color.createSignal=function(t,e){return void 0===e&&(e=o.Color.lerp),new s.V(t,e,void 0,(t=>new o.Color(t))).toSignal()},o.Color.prototype.toSymbol=()=>o.Color.symbol,o.Color.prototype.serialize=function(){return this.css()},o.Color.prototype.lerp=function(t,e,n){return o.Color.lerp(this,t,e,n)},o.Color)},74741:(t,e,n)=>{"use strict";n.d(e,{$:()=>s,X:()=>r});var o=n(29797);function s(t,e){return o.F.fromDegrees(t).transform(e).degrees}function r(t,e){return o.F.magnitude(e.m11,e.m12)*t}},98378:(t,e,n)=>{"use strict";n.d(e,{M5:()=>o,Nm:()=>s,WS:()=>c,aP:()=>r,lk:()=>i});var o,s,r,p=n(29797);function i(t,e){return void 0===e&&(e=o.Horizontal|o.Vertical),e&o.Vertical&&(t&s.Top?t=t&~s.Top|s.Bottom:t&s.Bottom&&(t=t&~s.Bottom|s.Top)),e&o.Horizontal&&(t&s.Left?t=t&~s.Left|s.Right:t&s.Right&&(t=t&~s.Right|s.Left)),t}function c(t){if(t===r.Middle)return p.F.zero;let e=0;t&s.Left?e=-1:t&s.Right&&(e=1);let n=0;return t&s.Top?n=-1:t&s.Bottom&&(n=1),new p.F(e,n)}!function(t){t[t.Vertical=1]="Vertical",t[t.Horizontal=2]="Horizontal"}(o||(o={})),function(t){t[t.Top=4]="Top",t[t.Bottom=8]="Bottom",t[t.Left=16]="Left",t[t.Right=32]="Right"}(s||(s={})),function(t){t[t.Middle=3]="Middle",t[t.Top=5]="Top",t[t.Bottom=9]="Bottom",t[t.Left=18]="Left",t[t.Right=34]="Right",t[t.TopLeft=20]="TopLeft",t[t.TopRight=36]="TopRight",t[t.BottomLeft=24]="BottomLeft",t[t.BottomRight=40]="BottomRight"}(r||(r={}))},43188:(t,e,n)=>{"use strict";n.d(e,{K:()=>r});var o=n(13170),s=n(46096);class r{static createSignal(t,e){return void 0===e&&(e=r.lerp),new s.N(["top","right","bottom","left"],(t=>new r(t)),t,e).toSignal()}static lerp(t,e,n){return new r((0,o.UI)(t.top,e.top,n),(0,o.UI)(t.right,e.right,n),(0,o.UI)(t.bottom,e.bottom,n),(0,o.UI)(t.left,e.left,n))}get x(){return this.left+this.right}get y(){return this.top+this.bottom}constructor(t,e,n,o){if(void 0===t&&(t=0),this.top=0,this.right=0,this.bottom=0,this.left=0,null!=t){if(Array.isArray(t)&&(o=t[3],n=t[2],e=t[1],t=t[0]),"number"==typeof t)return this.top=t,this.right=void 0!==e?e:t,this.bottom=void 0!==n?n:t,void(this.left=void 0!==o?o:void 0!==e?e:t);this.top=t.top,this.right=t.right,this.bottom=t.bottom,this.left=t.left}}lerp(t,e){return r.lerp(this,t,e)}scale(t){return new r(this.top*t,this.right*t,this.bottom*t,this.left*t)}addScalar(t){return new r(this.top+t,this.right+t,this.bottom+t,this.left+t)}toSymbol(){return r.symbol}serialize(){return{top:this.top,right:this.right,bottom:this.bottom,left:this.left}}}r.symbol=Symbol.for("@motion-canvas/core/types/Spacing")},57292:(t,e,n)=>{"use strict";n.d(e,{I:()=>o,P:()=>s});const o=1e-6;function s(t){return t&&"object"==typeof t&&"toSymbol"in t}},29797:(t,e,n)=>{"use strict";n.d(e,{F:()=>c});var o=n(13170),s=n(98378),r=n(57292),p=n(46096),i=n(48733);class c{static createSignal(t,e,n){return void 0===e&&(e=c.lerp),new p.N(["x","y"],(t=>new c(t)),t,e,n).toSignal()}static lerp(t,e,n){let s,r;return"number"==typeof n?s=r=n:(s=n.x,r=n.y),new c((0,o.UI)(t.x,e.x,s),(0,o.UI)(t.y,e.y,r))}static arcLerp(t,e,n,s,r){return void 0===s&&(s=!1),r??(r=t.sub(e).ctg),c.lerp(t,e,(0,o.Vz)(n,s,r))}static createArcLerp(t,e){return(n,o,s)=>c.arcLerp(n,o,s,t,e)}static fromOrigin(t){const e=new c;return t===s.aP.Middle||(t&s.Nm.Left?e.x=-1:t&s.Nm.Right&&(e.x=1),t&s.Nm.Top?e.y=-1:t&s.Nm.Bottom&&(e.y=1)),e}static fromScalar(t){return new c(t,t)}static fromRadians(t){return new c(Math.cos(t),Math.sin(t))}static fromDegrees(t){return c.fromRadians(t*i.q)}static radians(t,e){return Math.atan2(e,t)}static degrees(t,e){return c.radians(t,e)*i.I}static magnitude(t,e){return Math.sqrt(t*t+e*e)}static squaredMagnitude(t,e){return t*t+e*e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}get magnitude(){return c.magnitude(this.x,this.y)}get squaredMagnitude(){return c.squaredMagnitude(this.x,this.y)}get normalized(){return this.scale(1/c.magnitude(this.x,this.y))}get safe(){return new c(isNaN(this.x)?0:this.x,isNaN(this.y)?0:this.y)}get flipped(){return new c(-this.x,-this.y)}get floored(){return new c(Math.floor(this.x),Math.floor(this.y))}get perpendicular(){return new c(this.y,-this.x)}get radians(){return c.radians(this.x,this.y)}get degrees(){return c.degrees(this.x,this.y)}get ctg(){return this.x/this.y}constructor(t,e){if(this.x=0,this.y=0,null!=t){if("object"!=typeof t)return this.x=t,void(this.y=e??t);if(Array.isArray(t))return this.x=t[0],void(this.y=t[1]);if("width"in t)return this.x=t.width,void(this.y=t.height);this.x=t.x,this.y=t.y}}lerp(t,e){return c.lerp(this,t,e)}getOriginOffset(t){const e=c.fromOrigin(t);return e.x*=this.x/2,e.y*=this.y/2,e}scale(t){return new c(this.x*t,this.y*t)}transformAsPoint(t){return new c(this.x*t.m11+this.y*t.m21+t.m41,this.x*t.m12+this.y*t.m22+t.m42)}transform(t){return new c(this.x*t.m11+this.y*t.m21,this.x*t.m12+this.y*t.m22)}mul(t){const e=new c(t);return new c(this.x*e.x,this.y*e.y)}div(t){const e=new c(t);return new c(this.x/e.x,this.y/e.y)}add(t){const e=new c(t);return new c(this.x+e.x,this.y+e.y)}sub(t){const e=new c(t);return new c(this.x-e.x,this.y-e.y)}dot(t){const e=new c(t);return this.x*e.x+this.y*e.y}mod(t){const e=new c(t);return new c(this.x%e.x,this.y%e.y)}addX(t){return new c(this.x+t,this.y)}addY(t){return new c(this.x,this.y+t)}toSymbol(){return c.symbol}serialize(){return{x:this.x,y:this.y}}exactlyEquals(t){return this.x===t.x&&this.y===t.y}equals(t,e){return void 0===e&&(e=r.I),Math.abs(this.x-t.x)<=e+Number.EPSILON&&Math.abs(this.y-t.y)<=e+Number.EPSILON}}c.symbol=Symbol.for("@motion-canvas/core/types/Vector2"),c.zero=new c,c.one=new c(1,1),c.right=new c(1,0),c.left=new c(-1,0),c.up=new c(0,1),c.down=new c(0,-1)},49111:(t,e,n)=>{"use strict";n.d(e,{t:()=>o});class o extends Error{constructor(t,e){super(t),this.remarks=e}}},15649:(t,e,n)=>{"use strict";n.d(e,{L:()=>o});class o{constructor(){this.resolveCurrent=null,this.current=null}async acquire(){for(;this.current;)await this.current;this.current=new Promise((t=>{this.resolveCurrent=t}))}release(){var t;this.current=null,null==(t=this.resolveCurrent)||t.call(this),this.resolveCurrent=null}}},15688:(t,e,n)=>{"use strict";function o(t){return t[0].toUpperCase()+t.slice(1)}n.d(e,{k:()=>o})},90031:(t,e,n)=>{"use strict";function o(t){return{message:t.message,stack:t.stack,remarks:t.remarks}}n.d(e,{d:()=>o})},1119:(t,e,n)=>{"use strict";function o(t,e){void 0===e&&(e=document.createElement("canvas"));const n=e.getContext("2d",t);if(!n)throw new Error("Could not create a 2D context.");return n}n.d(e,{f:()=>o})},48733:(t,e,n)=>{"use strict";n.d(e,{I:()=>o,q:()=>s});const o=180/Math.PI,s=Math.PI/180},37762:(t,e,n)=>{"use strict";function o(t,e,n){let o=0,s=t;void 0!==e&&(o=t,s=e),n=void 0===n?o<s?1:-1:n;const r=[];let p=Math.max(Math.ceil((s-o)/n),0),i=0;for(;p--;)r[i++]=o,o+=n;return r}n.d(e,{w:()=>o})},30092:(t,e,n)=>{"use strict";n.d(e,{Y:()=>r});var o=n(3163),s=n(56632);function r(t){const e=(0,o.$r)(),n=(0,s.nn)();return e.timeEvents.register(t,n.time())}},97715:(t,e,n)=>{"use strict";n.d(e,{Mh:()=>p,te:()=>s,wA:()=>r});const o=[];function s(){const t=o.at(-1);if(!t)throw new Error("The playback is not available in the current context.");return t}function r(t){o.push(t)}function p(t){if(o.pop()!==t)throw new Error("startPlayback/endPlayback were called out of order.")}},3163:(t,e,n)=>{"use strict";n.d(e,{$r:()=>s,DO:()=>r,ug:()=>p,vl:()=>c,wL:()=>i});const o=[];function s(){const t=o.at(-1);if(!t)throw new Error("The scene is not available in the current context.");return t}function r(t){o.push(t)}function p(t){if(o.pop()!==t)throw new Error("startScene/endScene were called out of order.")}function i(){var t;return(null==(t=o.at(-1))?void 0:t.logger)??console}function c(){s().enterCanTransitionOut()}},56632:(t,e,n)=>{"use strict";n.d(e,{h$:()=>p,kw:()=>i,nn:()=>r});var o=n(49111);const s=[];function r(){const t=s.at(-1);if(!t)throw new o.t("The thread is not available in the current context.","<p><code>useThread()</code> can only be called from within generator functions.\n      It&#39;s not available during rendering.</p>\n");return t}function p(t){s.push(t)}function i(t){if(s.pop()!==t)throw new Error("startThread/endThread was called out of order.")}},69573:(t,e,n)=>{"use strict";n.d(e,{Z:()=>s});var o=n(2784);function s(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"}))}},10700:(t,e,n)=>{"use strict";n.d(e,{Z:()=>s});var o=n(2784);function s(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M3 15h8v-2H3v2zm0 4h8v-2H3v2zm0-8h8V9H3v2zm0-6v2h8V5H3zm10 0h8v14h-8V5z"}))}},48015:(t,e,n)=>{"use strict";n.d(e,{Z:()=>s});var o=n(2784);function s(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z"}))}},64415:(t,e,n)=>{"use strict";n.r(e),n.d(e,{default:()=>h});var o=n(2784),s=n(42104),r=n(49072),p=n(76183),i=n(31930),c=n(88617),a=n(80068),l=n(57708),u=n(70532),m=n(37390),d=n(89741);function h(t){var e,n,h;let{route:f}=t;const y=(0,c.RU)(f.projectId),k=y[f.reflectionId],[w]=(0,l.mN)(),M=(0,d.Z)(),D=(0,o.useMemo)((()=>{const t=[];if(!k.groups||k.kind===m.W.Project)return t;for(const e of k.groups)if(t.push({value:e.title,id:e.title,level:2}),e.children)for(const n of e.children){const e=y[n];!e||e.hasOwnPage||M&&!(0,l.It)(w,e)||t.push({value:`<code>${e.name}</code>`,id:e.anchor,level:3})}return t}),[w,k,M]);return o.createElement(p.b,{content:{frontMatter:{},metadata:{id:k.docId,unversionedId:k.docId,version:"current",title:k.name,description:null==(e=k.comment)?void 0:e.summaryText,slug:k.url,permalink:k.url,editUrl:(null==(n=k.sources)||null==(h=n[0])?void 0:h.url)??void 0,draft:!1,tags:[],frontMatter:{},next:k.next,previous:k.previous},toc:D,assets:{}}},o.createElement(a.Y0,null,o.createElement(s.Z,null),o.createElement(u.Z,null,o.createElement(r.Z,null,o.createElement(i.Z,{reflection:k})))))}},99703:(t,e,n)=>{"use strict";n.d(e,{Z:()=>$_e});var o={};n.r(o),n.d(o,{content_0_0:()=>c,content_0_10:()=>w,content_0_100:()=>te,content_0_1000:()=>Ek,content_0_1002:()=>Bk,content_0_1004:()=>Gk,content_0_1006:()=>Uk,content_0_1008:()=>Vk,content_0_1010:()=>$k,content_0_1012:()=>Jk,content_0_1014:()=>Kk,content_0_1016:()=>ew,content_0_1018:()=>ow,content_0_102:()=>ne,content_0_1020:()=>rw,content_0_1022:()=>iw,content_0_1024:()=>aw,content_0_1026:()=>uw,content_0_1028:()=>dw,content_0_1030:()=>fw,content_0_1032:()=>kw,content_0_104:()=>se,content_0_106:()=>pe,content_0_108:()=>ce,content_0_110:()=>le,content_0_112:()=>me,content_0_114:()=>he,content_0_116:()=>ye,content_0_118:()=>we,content_0_12:()=>D,content_0_120:()=>De,content_0_122:()=>Xe,content_0_124:()=>xe,content_0_126:()=>Te,content_0_128:()=>be,content_0_130:()=>Ze,content_0_132:()=>Se,content_0_134:()=>Re,content_0_136:()=>Ae,content_0_138:()=>We,content_0_14:()=>X,content_0_140:()=>Fe,content_0_142:()=>Oe,content_0_144:()=>je,content_0_146:()=>qe,content_0_148:()=>He,content_0_150:()=>Qe,content_0_152:()=>Ye,content_0_154:()=>tn,content_0_156:()=>nn,content_0_158:()=>sn,content_0_16:()=>x,content_0_160:()=>pn,content_0_162:()=>an,content_0_164:()=>un,content_0_166:()=>dn,content_0_168:()=>fn,content_0_170:()=>kn,content_0_172:()=>Mn,content_0_174:()=>_n,content_0_176:()=>gn,content_0_178:()=>Cn,content_0_18:()=>T,content_0_180:()=>vn,content_0_182:()=>Ln,content_0_184:()=>Nn,content_0_186:()=>zn,content_0_188:()=>Pn,content_0_190:()=>In,content_0_192:()=>En,content_0_194:()=>Bn,content_0_196:()=>Gn,content_0_198:()=>Un,content_0_2:()=>l,content_0_20:()=>b,content_0_200:()=>Vn,content_0_202:()=>$n,content_0_204:()=>Jn,content_0_206:()=>Kn,content_0_208:()=>eo,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>io,content_0_216:()=>ao,content_0_218:()=>uo,content_0_22:()=>Z,content_0_220:()=>ho,content_0_222:()=>yo,content_0_224:()=>wo,content_0_226:()=>Do,content_0_228:()=>Xo,content_0_230:()=>xo,content_0_232:()=>To,content_0_234:()=>bo,content_0_236:()=>Zo,content_0_238:()=>So,content_0_24:()=>S,content_0_240:()=>Ro,content_0_242:()=>Ao,content_0_244:()=>Wo,content_0_246:()=>Fo,content_0_248:()=>Oo,content_0_250:()=>jo,content_0_252:()=>qo,content_0_254:()=>Ho,content_0_256:()=>Qo,content_0_258:()=>Yo,content_0_26:()=>R,content_0_260:()=>ts,content_0_262:()=>ns,content_0_264:()=>ss,content_0_266:()=>ps,content_0_268:()=>cs,content_0_270:()=>ls,content_0_272:()=>ms,content_0_274:()=>hs,content_0_276:()=>ys,content_0_278:()=>ws,content_0_28:()=>A,content_0_280:()=>Ds,content_0_282:()=>Xs,content_0_284:()=>xs,content_0_286:()=>Ts,content_0_288:()=>bs,content_0_290:()=>Zs,content_0_292:()=>Ss,content_0_294:()=>Rs,content_0_296:()=>As,content_0_298:()=>Ws,content_0_30:()=>W,content_0_300:()=>Fs,content_0_302:()=>Os,content_0_304:()=>js,content_0_306:()=>qs,content_0_308:()=>Hs,content_0_310:()=>Qs,content_0_312:()=>Ys,content_0_314:()=>tr,content_0_316:()=>nr,content_0_318:()=>sr,content_0_32:()=>F,content_0_320:()=>pr,content_0_322:()=>cr,content_0_324:()=>lr,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>yr,content_0_332:()=>wr,content_0_334:()=>Dr,content_0_336:()=>Xr,content_0_338:()=>xr,content_0_34:()=>O,content_0_340:()=>Tr,content_0_342:()=>br,content_0_344:()=>Zr,content_0_346:()=>Sr,content_0_348:()=>Rr,content_0_350:()=>Ar,content_0_352:()=>Wr,content_0_354:()=>Fr,content_0_356:()=>Or,content_0_358:()=>jr,content_0_36:()=>j,content_0_360:()=>qr,content_0_362:()=>Hr,content_0_364:()=>Qr,content_0_366:()=>Yr,content_0_368:()=>tp,content_0_370:()=>np,content_0_372:()=>sp,content_0_374:()=>pp,content_0_376:()=>cp,content_0_378:()=>lp,content_0_38:()=>q,content_0_380:()=>mp,content_0_382:()=>hp,content_0_384:()=>yp,content_0_386:()=>wp,content_0_388:()=>Dp,content_0_390:()=>Xp,content_0_392:()=>xp,content_0_394:()=>Tp,content_0_396:()=>bp,content_0_398:()=>Zp,content_0_4:()=>m,content_0_40:()=>H,content_0_400:()=>Sp,content_0_402:()=>Rp,content_0_404:()=>Ap,content_0_406:()=>Wp,content_0_408:()=>Fp,content_0_410:()=>Op,content_0_412:()=>jp,content_0_414:()=>qp,content_0_416:()=>Hp,content_0_418:()=>Qp,content_0_42:()=>Q,content_0_420:()=>Yp,content_0_422:()=>ti,content_0_424:()=>ni,content_0_426:()=>si,content_0_428:()=>pi,content_0_430:()=>ci,content_0_432:()=>li,content_0_434:()=>mi,content_0_436:()=>hi,content_0_438:()=>yi,content_0_44:()=>Y,content_0_440:()=>wi,content_0_442:()=>Di,content_0_444:()=>Xi,content_0_446:()=>xi,content_0_448:()=>Ti,content_0_450:()=>bi,content_0_452:()=>Zi,content_0_454:()=>Si,content_0_456:()=>Ri,content_0_458:()=>Ai,content_0_46:()=>tt,content_0_460:()=>Wi,content_0_462:()=>Fi,content_0_464:()=>Oi,content_0_466:()=>ji,content_0_468:()=>qi,content_0_470:()=>Hi,content_0_472:()=>Qi,content_0_474:()=>Yi,content_0_476:()=>tc,content_0_478:()=>nc,content_0_48:()=>nt,content_0_480:()=>sc,content_0_482:()=>pc,content_0_484:()=>cc,content_0_486:()=>lc,content_0_488:()=>mc,content_0_490:()=>hc,content_0_492:()=>yc,content_0_494:()=>wc,content_0_496:()=>Dc,content_0_498:()=>Xc,content_0_50:()=>st,content_0_500:()=>xc,content_0_502:()=>Tc,content_0_504:()=>bc,content_0_506:()=>Zc,content_0_508:()=>Sc,content_0_510:()=>Rc,content_0_512:()=>Ac,content_0_514:()=>Wc,content_0_516:()=>Fc,content_0_518:()=>Oc,content_0_52:()=>pt,content_0_520:()=>jc,content_0_522:()=>qc,content_0_524:()=>Hc,content_0_526:()=>Qc,content_0_528:()=>Yc,content_0_530:()=>ta,content_0_532:()=>na,content_0_534:()=>sa,content_0_536:()=>pa,content_0_538:()=>ca,content_0_54:()=>ct,content_0_540:()=>la,content_0_542:()=>ma,content_0_544:()=>ha,content_0_546:()=>ya,content_0_548:()=>wa,content_0_550:()=>Da,content_0_552:()=>Xa,content_0_554:()=>xa,content_0_556:()=>Ta,content_0_558:()=>ba,content_0_56:()=>lt,content_0_560:()=>Za,content_0_562:()=>Sa,content_0_564:()=>Ra,content_0_566:()=>Aa,content_0_568:()=>Wa,content_0_570:()=>Fa,content_0_572:()=>Oa,content_0_574:()=>ja,content_0_576:()=>qa,content_0_578:()=>Ha,content_0_58:()=>mt,content_0_580:()=>Qa,content_0_582:()=>Ya,content_0_584:()=>tl,content_0_586:()=>nl,content_0_588:()=>sl,content_0_590:()=>pl,content_0_592:()=>cl,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>yl,content_0_602:()=>wl,content_0_604:()=>Dl,content_0_606:()=>Xl,content_0_608:()=>xl,content_0_610:()=>Tl,content_0_612:()=>bl,content_0_614:()=>Zl,content_0_616:()=>Sl,content_0_618:()=>Rl,content_0_62:()=>yt,content_0_620:()=>Al,content_0_622:()=>Wl,content_0_624:()=>Fl,content_0_626:()=>Ol,content_0_628:()=>jl,content_0_630:()=>ql,content_0_632:()=>Hl,content_0_634:()=>Ql,content_0_636:()=>Yl,content_0_638:()=>tu,content_0_64:()=>wt,content_0_640:()=>nu,content_0_642:()=>su,content_0_644:()=>pu,content_0_646:()=>cu,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>yu,content_0_656:()=>wu,content_0_658:()=>Du,content_0_66:()=>Dt,content_0_660:()=>Xu,content_0_662:()=>xu,content_0_664:()=>Tu,content_0_666:()=>bu,content_0_668:()=>Zu,content_0_670:()=>Su,content_0_672:()=>Ru,content_0_674:()=>Au,content_0_676:()=>Wu,content_0_678:()=>Fu,content_0_68:()=>Xt,content_0_680:()=>Ou,content_0_682:()=>ju,content_0_684:()=>qu,content_0_686:()=>Hu,content_0_688:()=>Qu,content_0_690:()=>Yu,content_0_692:()=>tm,content_0_694:()=>nm,content_0_696:()=>sm,content_0_698:()=>pm,content_0_70:()=>xt,content_0_700:()=>cm,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>ym,content_0_710:()=>wm,content_0_712:()=>Dm,content_0_714:()=>Xm,content_0_716:()=>xm,content_0_718:()=>Tm,content_0_72:()=>Tt,content_0_720:()=>bm,content_0_722:()=>Zm,content_0_724:()=>Sm,content_0_726:()=>Rm,content_0_728:()=>Am,content_0_730:()=>Wm,content_0_732:()=>Fm,content_0_734:()=>Om,content_0_736:()=>jm,content_0_738:()=>qm,content_0_74:()=>bt,content_0_740:()=>Hm,content_0_742:()=>Qm,content_0_744:()=>Ym,content_0_746:()=>td,content_0_748:()=>nd,content_0_750:()=>sd,content_0_752:()=>pd,content_0_754:()=>cd,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>Zt,content_0_760:()=>hd,content_0_762:()=>yd,content_0_764:()=>wd,content_0_766:()=>Dd,content_0_768:()=>Xd,content_0_770:()=>xd,content_0_772:()=>Td,content_0_774:()=>bd,content_0_776:()=>Zd,content_0_778:()=>Sd,content_0_78:()=>St,content_0_780:()=>Rd,content_0_782:()=>Ad,content_0_784:()=>Wd,content_0_786:()=>Fd,content_0_788:()=>Od,content_0_790:()=>jd,content_0_792:()=>qd,content_0_794:()=>Hd,content_0_796:()=>Qd,content_0_798:()=>Yd,content_0_8:()=>y,content_0_80:()=>Rt,content_0_800:()=>th,content_0_802:()=>nh,content_0_804:()=>sh,content_0_806:()=>ph,content_0_808:()=>ch,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>yh,content_0_818:()=>wh,content_0_82:()=>At,content_0_820:()=>Dh,content_0_822:()=>Xh,content_0_824:()=>xh,content_0_826:()=>Th,content_0_828:()=>bh,content_0_830:()=>Zh,content_0_832:()=>Sh,content_0_834:()=>Rh,content_0_836:()=>Ah,content_0_838:()=>Wh,content_0_84:()=>Wt,content_0_840:()=>Fh,content_0_842:()=>Oh,content_0_844:()=>jh,content_0_846:()=>qh,content_0_848:()=>Hh,content_0_850:()=>Qh,content_0_852:()=>Yh,content_0_854:()=>tf,content_0_856:()=>nf,content_0_858:()=>sf,content_0_86:()=>Ft,content_0_860:()=>pf,content_0_862:()=>af,content_0_864:()=>uf,content_0_866:()=>df,content_0_868:()=>ff,content_0_870:()=>kf,content_0_872:()=>Mf,content_0_874:()=>_f,content_0_876:()=>gf,content_0_878:()=>Cf,content_0_88:()=>Ot,content_0_880:()=>vf,content_0_882:()=>Lf,content_0_884:()=>Nf,content_0_886:()=>zf,content_0_888:()=>Pf,content_0_890:()=>If,content_0_892:()=>Ef,content_0_894:()=>Bf,content_0_896:()=>Gf,content_0_898:()=>Uf,content_0_90:()=>jt,content_0_900:()=>Vf,content_0_902:()=>$f,content_0_904:()=>Jf,content_0_906:()=>Kf,content_0_908:()=>ey,content_0_910:()=>oy,content_0_912:()=>ry,content_0_914:()=>iy,content_0_916:()=>ay,content_0_918:()=>uy,content_0_92:()=>qt,content_0_920:()=>dy,content_0_922:()=>fy,content_0_924:()=>ky,content_0_926:()=>My,content_0_928:()=>_y,content_0_930:()=>gy,content_0_932:()=>Cy,content_0_934:()=>vy,content_0_936:()=>Ly,content_0_938:()=>Ny,content_0_94:()=>Ht,content_0_940:()=>zy,content_0_942:()=>Py,content_0_944:()=>Iy,content_0_946:()=>Ey,content_0_948:()=>By,content_0_950:()=>Gy,content_0_952:()=>Uy,content_0_954:()=>Vy,content_0_956:()=>$y,content_0_958:()=>Jy,content_0_96:()=>Qt,content_0_960:()=>Ky,content_0_962:()=>ek,content_0_964:()=>ok,content_0_966:()=>rk,content_0_968:()=>ik,content_0_970:()=>ak,content_0_972:()=>uk,content_0_974:()=>dk,content_0_976:()=>fk,content_0_978:()=>kk,content_0_98:()=>Yt,content_0_980:()=>Mk,content_0_982:()=>_k,content_0_984:()=>gk,content_0_986:()=>Ck,content_0_988:()=>vk,content_0_990:()=>Lk,content_0_992:()=>Nk,content_0_994:()=>zk,content_0_996:()=>Pk,content_0_998:()=>Ik,content_2241_0:()=>Mw,content_2241_10:()=>Lw,content_2241_100:()=>uD,content_2241_1000:()=>VA,content_2241_1002:()=>$A,content_2241_1004:()=>JA,content_2241_1006:()=>KA,content_2241_1008:()=>eI,content_2241_1010:()=>oI,content_2241_1012:()=>rI,content_2241_1014:()=>iI,content_2241_1016:()=>aI,content_2241_1018:()=>uI,content_2241_102:()=>dD,content_2241_1020:()=>dI,content_2241_1022:()=>fI,content_2241_1024:()=>kI,content_2241_1026:()=>MI,content_2241_1028:()=>_I,content_2241_1030:()=>gI,content_2241_1032:()=>CI,content_2241_1034:()=>vI,content_2241_1036:()=>LI,content_2241_1038:()=>NI,content_2241_104:()=>fD,content_2241_1040:()=>zI,content_2241_1042:()=>PI,content_2241_1044:()=>II,content_2241_1046:()=>EI,content_2241_1048:()=>BI,content_2241_1050:()=>GI,content_2241_1052:()=>UI,content_2241_1054:()=>VI,content_2241_1056:()=>$I,content_2241_1058:()=>JI,content_2241_106:()=>kD,content_2241_1060:()=>KI,content_2241_1062:()=>eW,content_2241_1064:()=>oW,content_2241_1066:()=>rW,content_2241_1068:()=>iW,content_2241_1070:()=>aW,content_2241_1072:()=>uW,content_2241_1074:()=>dW,content_2241_1076:()=>fW,content_2241_1078:()=>kW,content_2241_108:()=>MD,content_2241_1080:()=>MW,content_2241_1082:()=>_W,content_2241_1084:()=>gW,content_2241_1086:()=>CW,content_2241_1088:()=>vW,content_2241_1090:()=>LW,content_2241_1092:()=>NW,content_2241_1094:()=>zW,content_2241_1096:()=>PW,content_2241_1098:()=>IW,content_2241_110:()=>_D,content_2241_1100:()=>EW,content_2241_1102:()=>BW,content_2241_1104:()=>GW,content_2241_1106:()=>UW,content_2241_1108:()=>VW,content_2241_1110:()=>$W,content_2241_1112:()=>JW,content_2241_1114:()=>KW,content_2241_1116:()=>eE,content_2241_1118:()=>oE,content_2241_112:()=>gD,content_2241_1120:()=>rE,content_2241_1122:()=>iE,content_2241_1124:()=>aE,content_2241_1126:()=>uE,content_2241_1128:()=>dE,content_2241_1130:()=>fE,content_2241_1132:()=>kE,content_2241_1134:()=>ME,content_2241_1136:()=>_E,content_2241_1138:()=>gE,content_2241_114:()=>CD,content_2241_1140:()=>CE,content_2241_1142:()=>vE,content_2241_1144:()=>LE,content_2241_1146:()=>NE,content_2241_1148:()=>zE,content_2241_1150:()=>PE,content_2241_1152:()=>IE,content_2241_1154:()=>EE,content_2241_1156:()=>BE,content_2241_1158:()=>GE,content_2241_116:()=>vD,content_2241_1160:()=>UE,content_2241_1162:()=>VE,content_2241_1164:()=>$E,content_2241_1166:()=>JE,content_2241_1168:()=>KE,content_2241_1170:()=>eF,content_2241_1172:()=>oF,content_2241_1174:()=>rF,content_2241_1176:()=>iF,content_2241_1178:()=>aF,content_2241_118:()=>LD,content_2241_1180:()=>uF,content_2241_1182:()=>dF,content_2241_1184:()=>fF,content_2241_1186:()=>kF,content_2241_1188:()=>MF,content_2241_1190:()=>_F,content_2241_1192:()=>gF,content_2241_1194:()=>CF,content_2241_1196:()=>vF,content_2241_1198:()=>LF,content_2241_12:()=>Nw,content_2241_120:()=>ND,content_2241_1200:()=>NF,content_2241_1202:()=>zF,content_2241_1204:()=>PF,content_2241_1206:()=>IF,content_2241_1208:()=>EF,content_2241_1210:()=>BF,content_2241_1212:()=>GF,content_2241_1214:()=>UF,content_2241_1216:()=>VF,content_2241_1218:()=>$F,content_2241_122:()=>zD,content_2241_1220:()=>JF,content_2241_1222:()=>KF,content_2241_1224:()=>eB,content_2241_1226:()=>oB,content_2241_1228:()=>rB,content_2241_1230:()=>iB,content_2241_1232:()=>aB,content_2241_1234:()=>uB,content_2241_1236:()=>dB,content_2241_1238:()=>fB,content_2241_124:()=>PD,content_2241_1240:()=>kB,content_2241_1242:()=>MB,content_2241_1244:()=>_B,content_2241_1246:()=>gB,content_2241_1248:()=>CB,content_2241_1250:()=>vB,content_2241_1252:()=>LB,content_2241_1254:()=>NB,content_2241_1256:()=>zB,content_2241_1258:()=>PB,content_2241_126:()=>ID,content_2241_1260:()=>IB,content_2241_1262:()=>EB,content_2241_1264:()=>BB,content_2241_1266:()=>GB,content_2241_1268:()=>UB,content_2241_1270:()=>VB,content_2241_1272:()=>$B,content_2241_1274:()=>JB,content_2241_1276:()=>KB,content_2241_1278:()=>eO,content_2241_128:()=>ED,content_2241_1280:()=>oO,content_2241_1282:()=>rO,content_2241_1284:()=>iO,content_2241_1286:()=>aO,content_2241_1288:()=>uO,content_2241_1290:()=>dO,content_2241_1292:()=>fO,content_2241_1294:()=>kO,content_2241_1296:()=>MO,content_2241_1298:()=>_O,content_2241_130:()=>BD,content_2241_1300:()=>gO,content_2241_1302:()=>CO,content_2241_1304:()=>vO,content_2241_1306:()=>LO,content_2241_1308:()=>NO,content_2241_1310:()=>zO,content_2241_1312:()=>PO,content_2241_1314:()=>IO,content_2241_1316:()=>EO,content_2241_1318:()=>BO,content_2241_132:()=>GD,content_2241_1320:()=>GO,content_2241_1322:()=>UO,content_2241_1324:()=>VO,content_2241_1326:()=>$O,content_2241_1328:()=>JO,content_2241_1330:()=>KO,content_2241_1332:()=>eG,content_2241_1334:()=>oG,content_2241_1336:()=>rG,content_2241_1338:()=>iG,content_2241_134:()=>UD,content_2241_1340:()=>aG,content_2241_1342:()=>uG,content_2241_1344:()=>dG,content_2241_1346:()=>fG,content_2241_1348:()=>kG,content_2241_1350:()=>MG,content_2241_1352:()=>_G,content_2241_1354:()=>gG,content_2241_1356:()=>CG,content_2241_1358:()=>vG,content_2241_136:()=>VD,content_2241_1360:()=>LG,content_2241_1362:()=>NG,content_2241_1364:()=>zG,content_2241_1366:()=>PG,content_2241_1368:()=>IG,content_2241_1370:()=>EG,content_2241_1372:()=>BG,content_2241_1374:()=>GG,content_2241_1376:()=>UG,content_2241_1378:()=>VG,content_2241_138:()=>$D,content_2241_1380:()=>$G,content_2241_1382:()=>JG,content_2241_1384:()=>KG,content_2241_1386:()=>ej,content_2241_1388:()=>oj,content_2241_1390:()=>rj,content_2241_1392:()=>ij,content_2241_1394:()=>aj,content_2241_1396:()=>uj,content_2241_1398:()=>dj,content_2241_14:()=>zw,content_2241_140:()=>JD,content_2241_1400:()=>fj,content_2241_1402:()=>kj,content_2241_1404:()=>Mj,content_2241_1406:()=>_j,content_2241_1408:()=>gj,content_2241_1410:()=>Cj,content_2241_1412:()=>vj,content_2241_1414:()=>Lj,content_2241_1416:()=>Nj,content_2241_1418:()=>zj,content_2241_142:()=>KD,content_2241_1420:()=>Pj,content_2241_1422:()=>Ij,content_2241_1424:()=>Ej,content_2241_1426:()=>Bj,content_2241_1428:()=>Gj,content_2241_1430:()=>Uj,content_2241_1432:()=>Vj,content_2241_1434:()=>$j,content_2241_1436:()=>Jj,content_2241_1438:()=>Kj,content_2241_144:()=>e_,content_2241_1440:()=>eU,content_2241_1442:()=>oU,content_2241_1444:()=>rU,content_2241_1446:()=>iU,content_2241_1448:()=>aU,content_2241_1450:()=>uU,content_2241_1452:()=>dU,content_2241_1454:()=>fU,content_2241_1456:()=>kU,content_2241_1458:()=>MU,content_2241_146:()=>o_,content_2241_1460:()=>_U,content_2241_1462:()=>gU,content_2241_1464:()=>CU,content_2241_1466:()=>vU,content_2241_1468:()=>LU,content_2241_1470:()=>NU,content_2241_1472:()=>zU,content_2241_1474:()=>PU,content_2241_1476:()=>IU,content_2241_1478:()=>EU,content_2241_148:()=>r_,content_2241_1480:()=>BU,content_2241_1482:()=>GU,content_2241_1484:()=>UU,content_2241_1486:()=>VU,content_2241_1488:()=>$U,content_2241_1490:()=>JU,content_2241_1492:()=>KU,content_2241_1494:()=>eq,content_2241_1496:()=>oq,content_2241_1498:()=>rq,content_2241_150:()=>i_,content_2241_1500:()=>iq,content_2241_1502:()=>aq,content_2241_1504:()=>uq,content_2241_1506:()=>dq,content_2241_1508:()=>fq,content_2241_1510:()=>kq,content_2241_1512:()=>Mq,content_2241_1514:()=>_q,content_2241_1516:()=>gq,content_2241_1518:()=>Cq,content_2241_152:()=>a_,content_2241_1520:()=>vq,content_2241_1522:()=>Lq,content_2241_1524:()=>Nq,content_2241_1526:()=>zq,content_2241_1528:()=>Pq,content_2241_1530:()=>Iq,content_2241_1532:()=>Eq,content_2241_1534:()=>Bq,content_2241_1536:()=>Gq,content_2241_1538:()=>Uq,content_2241_154:()=>u_,content_2241_1540:()=>Vq,content_2241_1542:()=>$q,content_2241_1544:()=>Jq,content_2241_1546:()=>Kq,content_2241_1548:()=>eV,content_2241_1550:()=>oV,content_2241_1552:()=>rV,content_2241_1554:()=>iV,content_2241_1556:()=>aV,content_2241_1558:()=>uV,content_2241_156:()=>d_,content_2241_1560:()=>dV,content_2241_1562:()=>fV,content_2241_1564:()=>kV,content_2241_1566:()=>MV,content_2241_1568:()=>_V,content_2241_1570:()=>gV,content_2241_1572:()=>CV,content_2241_1574:()=>vV,content_2241_1576:()=>LV,content_2241_1578:()=>NV,content_2241_158:()=>f_,content_2241_1580:()=>zV,content_2241_1582:()=>PV,content_2241_1584:()=>IV,content_2241_1586:()=>EV,content_2241_1588:()=>BV,content_2241_1590:()=>GV,content_2241_1592:()=>UV,content_2241_1594:()=>VV,content_2241_1596:()=>$V,content_2241_1598:()=>JV,content_2241_16:()=>Pw,content_2241_160:()=>k_,content_2241_1600:()=>KV,content_2241_1602:()=>eH,content_2241_1604:()=>oH,content_2241_1606:()=>rH,content_2241_1608:()=>iH,content_2241_1610:()=>aH,content_2241_1612:()=>uH,content_2241_1614:()=>dH,content_2241_1616:()=>fH,content_2241_1618:()=>kH,content_2241_162:()=>M_,content_2241_1620:()=>MH,content_2241_1622:()=>_H,content_2241_1624:()=>gH,content_2241_1626:()=>CH,content_2241_1628:()=>vH,content_2241_1630:()=>LH,content_2241_1632:()=>NH,content_2241_1634:()=>zH,content_2241_1636:()=>PH,content_2241_1638:()=>IH,content_2241_164:()=>__,content_2241_1640:()=>EH,content_2241_1642:()=>BH,content_2241_1644:()=>GH,content_2241_1646:()=>UH,content_2241_1648:()=>VH,content_2241_1650:()=>$H,content_2241_1652:()=>JH,content_2241_1654:()=>KH,content_2241_1656:()=>e$,content_2241_1658:()=>o$,content_2241_166:()=>g_,content_2241_1660:()=>r$,content_2241_1662:()=>i$,content_2241_1664:()=>a$,content_2241_1666:()=>u$,content_2241_1668:()=>d$,content_2241_1670:()=>f$,content_2241_1672:()=>k$,content_2241_1674:()=>M$,content_2241_1676:()=>_$,content_2241_1678:()=>g$,content_2241_168:()=>C_,content_2241_1680:()=>C$,content_2241_1682:()=>v$,content_2241_1684:()=>L$,content_2241_1686:()=>N$,content_2241_1688:()=>z$,content_2241_1690:()=>P$,content_2241_1692:()=>I$,content_2241_1694:()=>E$,content_2241_1696:()=>B$,content_2241_1698:()=>G$,content_2241_170:()=>v_,content_2241_1700:()=>U$,content_2241_1702:()=>V$,content_2241_1704:()=>$$,content_2241_1706:()=>J$,content_2241_1708:()=>K$,content_2241_1710:()=>eQ,content_2241_1712:()=>oQ,content_2241_1714:()=>rQ,content_2241_1716:()=>iQ,content_2241_1718:()=>aQ,content_2241_172:()=>L_,content_2241_1720:()=>uQ,content_2241_1722:()=>dQ,content_2241_1724:()=>fQ,content_2241_1726:()=>kQ,content_2241_1728:()=>MQ,content_2241_1730:()=>_Q,content_2241_1732:()=>gQ,content_2241_1734:()=>CQ,content_2241_1736:()=>vQ,content_2241_1738:()=>LQ,content_2241_174:()=>N_,content_2241_1740:()=>NQ,content_2241_1742:()=>zQ,content_2241_1744:()=>PQ,content_2241_1746:()=>IQ,content_2241_1748:()=>EQ,content_2241_1750:()=>BQ,content_2241_1752:()=>GQ,content_2241_1754:()=>UQ,content_2241_1756:()=>VQ,content_2241_1758:()=>$Q,content_2241_176:()=>z_,content_2241_1760:()=>JQ,content_2241_1762:()=>KQ,content_2241_1764:()=>eJ,content_2241_1766:()=>oJ,content_2241_1768:()=>rJ,content_2241_1770:()=>iJ,content_2241_1772:()=>aJ,content_2241_1774:()=>uJ,content_2241_1776:()=>dJ,content_2241_1778:()=>fJ,content_2241_178:()=>P_,content_2241_1780:()=>kJ,content_2241_1782:()=>MJ,content_2241_1784:()=>_J,content_2241_1786:()=>gJ,content_2241_1788:()=>CJ,content_2241_1790:()=>vJ,content_2241_1792:()=>LJ,content_2241_1794:()=>NJ,content_2241_1796:()=>zJ,content_2241_1798:()=>PJ,content_2241_18:()=>Iw,content_2241_180:()=>I_,content_2241_1800:()=>IJ,content_2241_1802:()=>EJ,content_2241_1804:()=>BJ,content_2241_1806:()=>GJ,content_2241_1808:()=>UJ,content_2241_1810:()=>VJ,content_2241_1812:()=>$J,content_2241_1814:()=>JJ,content_2241_1816:()=>KJ,content_2241_1818:()=>eY,content_2241_182:()=>E_,content_2241_1820:()=>oY,content_2241_1822:()=>rY,content_2241_1824:()=>iY,content_2241_1826:()=>aY,content_2241_1828:()=>uY,content_2241_1830:()=>dY,content_2241_1832:()=>fY,content_2241_1834:()=>kY,content_2241_1836:()=>MY,content_2241_1838:()=>_Y,content_2241_184:()=>B_,content_2241_1840:()=>gY,content_2241_1842:()=>CY,content_2241_1844:()=>vY,content_2241_1846:()=>LY,content_2241_1848:()=>NY,content_2241_1850:()=>zY,content_2241_1852:()=>PY,content_2241_1854:()=>IY,content_2241_1856:()=>EY,content_2241_1858:()=>BY,content_2241_186:()=>G_,content_2241_1860:()=>GY,content_2241_1862:()=>UY,content_2241_1864:()=>VY,content_2241_1866:()=>$Y,content_2241_1868:()=>JY,content_2241_1870:()=>KY,content_2241_1872:()=>eK,content_2241_1874:()=>oK,content_2241_1876:()=>rK,content_2241_1878:()=>iK,content_2241_188:()=>U_,content_2241_1880:()=>aK,content_2241_1882:()=>uK,content_2241_1884:()=>dK,content_2241_1886:()=>fK,content_2241_1888:()=>kK,content_2241_1890:()=>MK,content_2241_1892:()=>_K,content_2241_1894:()=>gK,content_2241_1896:()=>CK,content_2241_1898:()=>vK,content_2241_190:()=>V_,content_2241_1900:()=>LK,content_2241_1902:()=>NK,content_2241_1904:()=>zK,content_2241_1906:()=>PK,content_2241_1908:()=>IK,content_2241_1910:()=>EK,content_2241_1912:()=>BK,content_2241_1914:()=>GK,content_2241_1916:()=>UK,content_2241_1918:()=>VK,content_2241_192:()=>$_,content_2241_1920:()=>$K,content_2241_1922:()=>JK,content_2241_1924:()=>KK,content_2241_1926:()=>e0,content_2241_1928:()=>o0,content_2241_1930:()=>r0,content_2241_1932:()=>i0,content_2241_1934:()=>a0,content_2241_1936:()=>u0,content_2241_1938:()=>d0,content_2241_194:()=>J_,content_2241_1940:()=>f0,content_2241_1942:()=>k0,content_2241_1944:()=>M0,content_2241_1946:()=>_0,content_2241_1948:()=>g0,content_2241_1950:()=>C0,content_2241_1952:()=>v0,content_2241_1954:()=>L0,content_2241_1956:()=>N0,content_2241_1958:()=>z0,content_2241_196:()=>K_,content_2241_1960:()=>P0,content_2241_1962:()=>I0,content_2241_1964:()=>E0,content_2241_1966:()=>B0,content_2241_1968:()=>G0,content_2241_1970:()=>U0,content_2241_1972:()=>V0,content_2241_1974:()=>$0,content_2241_1976:()=>J0,content_2241_1978:()=>K0,content_2241_198:()=>eX,content_2241_1980:()=>e2,content_2241_1982:()=>o2,content_2241_1984:()=>r2,content_2241_1986:()=>i2,content_2241_1988:()=>a2,content_2241_1990:()=>u2,content_2241_1992:()=>d2,content_2241_1994:()=>f2,content_2241_1996:()=>k2,content_2241_1998:()=>M2,content_2241_2:()=>_w,content_2241_20:()=>Ew,content_2241_200:()=>oX,content_2241_2000:()=>_2,content_2241_2002:()=>g2,content_2241_2004:()=>C2,content_2241_2006:()=>v2,content_2241_2008:()=>L2,content_2241_2010:()=>N2,content_2241_2012:()=>z2,content_2241_2014:()=>P2,content_2241_2016:()=>I2,content_2241_2018:()=>E2,content_2241_202:()=>rX,content_2241_2020:()=>B2,content_2241_2022:()=>G2,content_2241_2024:()=>U2,content_2241_2026:()=>V2,content_2241_2028:()=>$2,content_2241_2030:()=>J2,content_2241_2032:()=>K2,content_2241_2034:()=>e1,content_2241_2036:()=>o1,content_2241_2038:()=>r1,content_2241_204:()=>iX,content_2241_2040:()=>i1,content_2241_2042:()=>a1,content_2241_2044:()=>u1,content_2241_2046:()=>d1,content_2241_2048:()=>f1,content_2241_2050:()=>k1,content_2241_2052:()=>M1,content_2241_2054:()=>_1,content_2241_2056:()=>g1,content_2241_2058:()=>C1,content_2241_206:()=>aX,content_2241_2060:()=>v1,content_2241_2062:()=>L1,content_2241_2064:()=>N1,content_2241_2066:()=>z1,content_2241_2068:()=>P1,content_2241_2070:()=>I1,content_2241_2072:()=>E1,content_2241_2074:()=>B1,content_2241_2076:()=>G1,content_2241_2078:()=>U1,content_2241_208:()=>uX,content_2241_2080:()=>V1,content_2241_2082:()=>$1,content_2241_2084:()=>J1,content_2241_2086:()=>K1,content_2241_2088:()=>e4,content_2241_2090:()=>o4,content_2241_2092:()=>r4,content_2241_2094:()=>i4,content_2241_2096:()=>a4,content_2241_2098:()=>u4,content_2241_210:()=>dX,content_2241_2100:()=>d4,content_2241_2102:()=>f4,content_2241_2104:()=>k4,content_2241_2106:()=>M4,content_2241_2108:()=>_4,content_2241_2110:()=>g4,content_2241_2112:()=>C4,content_2241_2114:()=>v4,content_2241_2116:()=>L4,content_2241_2118:()=>N4,content_2241_212:()=>fX,content_2241_2120:()=>z4,content_2241_2122:()=>P4,content_2241_2124:()=>I4,content_2241_2126:()=>E4,content_2241_2128:()=>B4,content_2241_2130:()=>G4,content_2241_2132:()=>U4,content_2241_2134:()=>V4,content_2241_2136:()=>$4,content_2241_2138:()=>J4,content_2241_214:()=>kX,content_2241_2140:()=>K4,content_2241_2142:()=>e6,content_2241_2144:()=>o6,content_2241_2146:()=>r6,content_2241_2148:()=>i6,content_2241_2150:()=>a6,content_2241_2152:()=>u6,content_2241_2154:()=>d6,content_2241_2156:()=>f6,content_2241_2158:()=>k6,content_2241_216:()=>MX,content_2241_2160:()=>M6,content_2241_2162:()=>_6,content_2241_2164:()=>g6,content_2241_2166:()=>C6,content_2241_2168:()=>v6,content_2241_2170:()=>L6,content_2241_2172:()=>N6,content_2241_2174:()=>z6,content_2241_2176:()=>P6,content_2241_2178:()=>I6,content_2241_218:()=>_X,content_2241_2180:()=>E6,content_2241_2182:()=>B6,content_2241_2184:()=>G6,content_2241_2186:()=>U6,content_2241_2188:()=>V6,content_2241_2190:()=>$6,content_2241_2192:()=>J6,content_2241_2194:()=>K6,content_2241_2196:()=>e3,content_2241_2198:()=>o3,content_2241_22:()=>Bw,content_2241_220:()=>gX,content_2241_2200:()=>r3,content_2241_2202:()=>i3,content_2241_2204:()=>a3,content_2241_2206:()=>u3,content_2241_2208:()=>d3,content_2241_2210:()=>f3,content_2241_2212:()=>k3,content_2241_2214:()=>M3,content_2241_2216:()=>_3,content_2241_2218:()=>g3,content_2241_222:()=>CX,content_2241_2220:()=>C3,content_2241_2222:()=>v3,content_2241_2224:()=>L3,content_2241_2226:()=>N3,content_2241_2228:()=>z3,content_2241_2230:()=>P3,content_2241_2232:()=>I3,content_2241_2234:()=>E3,content_2241_2236:()=>B3,content_2241_2238:()=>G3,content_2241_224:()=>vX,content_2241_2240:()=>U3,content_2241_2242:()=>V3,content_2241_2244:()=>$3,content_2241_2246:()=>J3,content_2241_2248:()=>K3,content_2241_2250:()=>e8,content_2241_2252:()=>o8,content_2241_2254:()=>r8,content_2241_2256:()=>i8,content_2241_2258:()=>a8,content_2241_226:()=>LX,content_2241_2260:()=>u8,content_2241_2262:()=>d8,content_2241_2264:()=>f8,content_2241_2266:()=>k8,content_2241_2268:()=>M8,content_2241_2270:()=>_8,content_2241_2272:()=>g8,content_2241_2274:()=>C8,content_2241_2276:()=>v8,content_2241_2278:()=>L8,content_2241_228:()=>NX,content_2241_2280:()=>N8,content_2241_2282:()=>z8,content_2241_2284:()=>P8,content_2241_2286:()=>I8,content_2241_2288:()=>E8,content_2241_2290:()=>B8,content_2241_2292:()=>G8,content_2241_2294:()=>U8,content_2241_2296:()=>V8,content_2241_2298:()=>$8,content_2241_230:()=>zX,content_2241_2300:()=>J8,content_2241_2302:()=>K8,content_2241_2304:()=>e5,content_2241_2306:()=>o5,content_2241_2308:()=>r5,content_2241_2310:()=>i5,content_2241_2312:()=>a5,content_2241_2314:()=>u5,content_2241_2316:()=>d5,content_2241_2318:()=>f5,content_2241_232:()=>PX,content_2241_2320:()=>k5,content_2241_2322:()=>M5,content_2241_2324:()=>_5,content_2241_2326:()=>g5,content_2241_2328:()=>C5,content_2241_2330:()=>v5,content_2241_2332:()=>L5,content_2241_2334:()=>N5,content_2241_2336:()=>z5,content_2241_2338:()=>P5,content_2241_234:()=>IX,content_2241_2340:()=>I5,content_2241_2342:()=>E5,content_2241_2344:()=>B5,content_2241_2346:()=>G5,content_2241_2348:()=>U5,content_2241_2350:()=>V5,content_2241_2352:()=>$5,content_2241_2354:()=>J5,content_2241_2356:()=>K5,content_2241_2358:()=>e7,content_2241_236:()=>EX,content_2241_2360:()=>o7,content_2241_2362:()=>r7,content_2241_2364:()=>i7,content_2241_2366:()=>a7,content_2241_2368:()=>u7,content_2241_2370:()=>d7,content_2241_2372:()=>f7,content_2241_2374:()=>k7,content_2241_2376:()=>M7,content_2241_2378:()=>_7,content_2241_238:()=>BX,content_2241_2380:()=>g7,content_2241_2382:()=>C7,content_2241_2384:()=>v7,content_2241_2386:()=>L7,content_2241_2388:()=>N7,content_2241_2390:()=>z7,content_2241_2392:()=>P7,content_2241_2394:()=>I7,content_2241_2396:()=>E7,content_2241_2398:()=>B7,content_2241_24:()=>Gw,content_2241_240:()=>GX,content_2241_2400:()=>G7,content_2241_2402:()=>U7,content_2241_2404:()=>V7,content_2241_2406:()=>$7,content_2241_2408:()=>J7,content_2241_2410:()=>K7,content_2241_2412:()=>e9,content_2241_2414:()=>o9,content_2241_2416:()=>r9,content_2241_2418:()=>i9,content_2241_242:()=>UX,content_2241_2420:()=>a9,content_2241_2422:()=>u9,content_2241_2424:()=>d9,content_2241_2426:()=>f9,content_2241_2428:()=>k9,content_2241_2430:()=>M9,content_2241_2432:()=>_9,content_2241_2434:()=>g9,content_2241_2436:()=>C9,content_2241_2438:()=>v9,content_2241_244:()=>VX,content_2241_2440:()=>L9,content_2241_2442:()=>N9,content_2241_2444:()=>z9,content_2241_2446:()=>P9,content_2241_2448:()=>I9,content_2241_2450:()=>E9,content_2241_2452:()=>B9,content_2241_2454:()=>G9,content_2241_2456:()=>U9,content_2241_2458:()=>V9,content_2241_246:()=>$X,content_2241_2460:()=>$9,content_2241_2462:()=>J9,content_2241_2464:()=>K9,content_2241_2466:()=>ett,content_2241_2468:()=>ott,content_2241_2470:()=>rtt,content_2241_2472:()=>itt,content_2241_2474:()=>att,content_2241_2476:()=>utt,content_2241_2478:()=>dtt,content_2241_248:()=>JX,content_2241_2480:()=>ftt,content_2241_2482:()=>ktt,content_2241_2484:()=>Mtt,content_2241_2486:()=>_tt,content_2241_2488:()=>gtt,content_2241_2490:()=>Ctt,content_2241_2492:()=>vtt,content_2241_2494:()=>Ltt,content_2241_2496:()=>Ntt,content_2241_2498:()=>ztt,content_2241_250:()=>KX,content_2241_2500:()=>Ptt,content_2241_2502:()=>Itt,content_2241_2504:()=>Ett,content_2241_2506:()=>Btt,content_2241_2508:()=>Gtt,content_2241_2510:()=>Utt,content_2241_2512:()=>Vtt,content_2241_2514:()=>$tt,content_2241_2516:()=>Jtt,content_2241_2518:()=>Ktt,content_2241_252:()=>eg,content_2241_2520:()=>eet,content_2241_2522:()=>oet,content_2241_2524:()=>ret,content_2241_2526:()=>iet,content_2241_2528:()=>aet,content_2241_2530:()=>met,content_2241_2532:()=>het,content_2241_2534:()=>yet,content_2241_2536:()=>wet,content_2241_2538:()=>Det,content_2241_254:()=>og,content_2241_2540:()=>Xet,content_2241_2542:()=>xet,content_2241_2544:()=>Tet,content_2241_2546:()=>bet,content_2241_2548:()=>Zet,content_2241_2550:()=>Set,content_2241_2552:()=>Ret,content_2241_2554:()=>Aet,content_2241_2556:()=>Wet,content_2241_2558:()=>Fet,content_2241_256:()=>rg,content_2241_2560:()=>Oet,content_2241_2562:()=>jet,content_2241_2564:()=>qet,content_2241_2566:()=>Het,content_2241_2568:()=>Qet,content_2241_2570:()=>Yet,content_2241_2572:()=>tnt,content_2241_2574:()=>nnt,content_2241_2576:()=>snt,content_2241_2578:()=>pnt,content_2241_258:()=>ig,content_2241_2580:()=>cnt,content_2241_2582:()=>lnt,content_2241_2584:()=>mnt,content_2241_2586:()=>hnt,content_2241_2588:()=>ynt,content_2241_2590:()=>wnt,content_2241_2592:()=>Dnt,content_2241_2594:()=>Xnt,content_2241_2596:()=>xnt,content_2241_2598:()=>Tnt,content_2241_26:()=>Uw,content_2241_260:()=>ag,content_2241_2600:()=>bnt,content_2241_2602:()=>Znt,content_2241_2604:()=>Snt,content_2241_2606:()=>Rnt,content_2241_2608:()=>Ant,content_2241_2610:()=>Wnt,content_2241_2612:()=>Fnt,content_2241_2614:()=>Ont,content_2241_2616:()=>jnt,content_2241_2618:()=>qnt,content_2241_262:()=>ug,content_2241_2620:()=>Hnt,content_2241_2622:()=>Qnt,content_2241_2624:()=>Ynt,content_2241_2626:()=>tot,content_2241_2628:()=>not,content_2241_2630:()=>sot,content_2241_2632:()=>pot,content_2241_2634:()=>cot,content_2241_2636:()=>lot,content_2241_2638:()=>mot,content_2241_264:()=>dg,content_2241_2640:()=>hot,content_2241_2642:()=>yot,content_2241_2644:()=>wot,content_2241_2646:()=>Dot,content_2241_2648:()=>Xot,content_2241_2650:()=>xot,content_2241_2652:()=>Tot,content_2241_2654:()=>bot,content_2241_2656:()=>Zot,content_2241_2658:()=>Sot,content_2241_266:()=>fg,content_2241_2660:()=>Rot,content_2241_2662:()=>Aot,content_2241_2664:()=>Wot,content_2241_2666:()=>Fot,content_2241_2668:()=>Oot,content_2241_2670:()=>jot,content_2241_2672:()=>qot,content_2241_2674:()=>Hot,content_2241_2676:()=>Qot,content_2241_2678:()=>Yot,content_2241_268:()=>kg,content_2241_2680:()=>tst,content_2241_2682:()=>nst,content_2241_2684:()=>sst,content_2241_2686:()=>pst,content_2241_2688:()=>cst,content_2241_2690:()=>lst,content_2241_2692:()=>mst,content_2241_2694:()=>hst,content_2241_2696:()=>yst,content_2241_2698:()=>wst,content_2241_270:()=>Mg,content_2241_2700:()=>Dst,content_2241_2702:()=>Xst,content_2241_2704:()=>xst,content_2241_2706:()=>Tst,content_2241_2708:()=>bst,content_2241_2710:()=>Zst,content_2241_2712:()=>Sst,content_2241_2714:()=>Rst,content_2241_2716:()=>Ast,content_2241_2718:()=>Wst,content_2241_272:()=>_g,content_2241_2720:()=>Fst,content_2241_2722:()=>Ost,content_2241_2724:()=>jst,content_2241_2726:()=>qst,content_2241_2728:()=>Hst,content_2241_2730:()=>Qst,content_2241_2732:()=>Yst,content_2241_2734:()=>trt,content_2241_2736:()=>nrt,content_2241_2738:()=>srt,content_2241_274:()=>gg,content_2241_2740:()=>prt,content_2241_2742:()=>crt,content_2241_2744:()=>lrt,content_2241_2746:()=>mrt,content_2241_2748:()=>hrt,content_2241_2750:()=>yrt,content_2241_2752:()=>wrt,content_2241_2754:()=>Drt,content_2241_2756:()=>Xrt,content_2241_2758:()=>xrt,content_2241_276:()=>Cg,content_2241_2760:()=>Trt,content_2241_2762:()=>brt,content_2241_2764:()=>Zrt,content_2241_2766:()=>Srt,content_2241_2768:()=>Rrt,content_2241_2770:()=>Art,content_2241_2772:()=>Wrt,content_2241_2774:()=>Frt,content_2241_2776:()=>Ort,content_2241_2778:()=>jrt,content_2241_278:()=>vg,content_2241_2780:()=>qrt,content_2241_2782:()=>Hrt,content_2241_2784:()=>Qrt,content_2241_2786:()=>Yrt,content_2241_2788:()=>tpt,content_2241_2790:()=>npt,content_2241_2792:()=>spt,content_2241_2794:()=>ppt,content_2241_2796:()=>cpt,content_2241_2798:()=>lpt,content_2241_28:()=>Vw,content_2241_280:()=>Lg,content_2241_2800:()=>mpt,content_2241_2802:()=>hpt,content_2241_2804:()=>ypt,content_2241_2806:()=>wpt,content_2241_2808:()=>Dpt,content_2241_2810:()=>Xpt,content_2241_2812:()=>xpt,content_2241_2814:()=>Tpt,content_2241_2816:()=>bpt,content_2241_2818:()=>Zpt,content_2241_282:()=>Ng,content_2241_2820:()=>Spt,content_2241_2822:()=>Rpt,content_2241_2824:()=>Apt,content_2241_2826:()=>Wpt,content_2241_2828:()=>Fpt,content_2241_2830:()=>Opt,content_2241_2832:()=>jpt,content_2241_2834:()=>qpt,content_2241_2836:()=>Hpt,content_2241_2838:()=>Qpt,content_2241_284:()=>zg,content_2241_2840:()=>Ypt,content_2241_2842:()=>tit,content_2241_2844:()=>nit,content_2241_2846:()=>sit,content_2241_2848:()=>pit,content_2241_2850:()=>cit,content_2241_2852:()=>lit,content_2241_2854:()=>mit,content_2241_2856:()=>hit,content_2241_2858:()=>yit,content_2241_286:()=>Pg,content_2241_2860:()=>wit,content_2241_2862:()=>Dit,content_2241_2864:()=>Xit,content_2241_2866:()=>xit,content_2241_2868:()=>Tit,content_2241_2870:()=>bit,content_2241_2872:()=>Zit,content_2241_2874:()=>Sit,content_2241_2876:()=>Rit,content_2241_2878:()=>Ait,content_2241_288:()=>Ig,content_2241_2880:()=>Wit,content_2241_2882:()=>Fit,content_2241_2884:()=>Oit,content_2241_2886:()=>jit,content_2241_2888:()=>qit,content_2241_2890:()=>Hit,content_2241_2892:()=>Qit,content_2241_2894:()=>Yit,content_2241_2896:()=>tct,content_2241_2898:()=>nct,content_2241_290:()=>Eg,content_2241_2900:()=>sct,content_2241_2902:()=>pct,content_2241_2904:()=>cct,content_2241_2906:()=>lct,content_2241_2908:()=>mct,content_2241_2910:()=>hct,content_2241_2912:()=>yct,content_2241_2914:()=>wct,content_2241_2916:()=>Dct,content_2241_2918:()=>Xct,content_2241_292:()=>Bg,content_2241_2920:()=>xct,content_2241_2922:()=>Tct,content_2241_2924:()=>bct,content_2241_2926:()=>Zct,content_2241_2928:()=>Sct,content_2241_2930:()=>Rct,content_2241_2932:()=>Act,content_2241_2934:()=>Wct,content_2241_2936:()=>Fct,content_2241_2938:()=>Oct,content_2241_294:()=>Gg,content_2241_2940:()=>jct,content_2241_2942:()=>qct,content_2241_2944:()=>Hct,content_2241_2946:()=>Qct,content_2241_2948:()=>Yct,content_2241_2950:()=>tat,content_2241_2952:()=>nat,content_2241_2954:()=>sat,content_2241_2956:()=>pat,content_2241_2958:()=>cat,content_2241_296:()=>Ug,content_2241_2960:()=>lat,content_2241_2962:()=>mat,content_2241_2964:()=>hat,content_2241_2966:()=>yat,content_2241_2968:()=>wat,content_2241_2970:()=>Dat,content_2241_2972:()=>Xat,content_2241_2974:()=>xat,content_2241_2976:()=>Tat,content_2241_2978:()=>bat,content_2241_298:()=>Vg,content_2241_2980:()=>Zat,content_2241_2982:()=>Sat,content_2241_2984:()=>Rat,content_2241_2986:()=>Aat,content_2241_2988:()=>Wat,content_2241_2990:()=>Fat,content_2241_2992:()=>Oat,content_2241_2994:()=>jat,content_2241_2996:()=>qat,content_2241_2998:()=>Hat,content_2241_30:()=>$w,content_2241_300:()=>$g,content_2241_3000:()=>Qat,content_2241_3002:()=>Yat,content_2241_3004:()=>tlt,content_2241_3006:()=>nlt,content_2241_3008:()=>slt,content_2241_3010:()=>plt,content_2241_3012:()=>clt,content_2241_3014:()=>llt,content_2241_3016:()=>mlt,content_2241_3018:()=>hlt,content_2241_302:()=>Jg,content_2241_3020:()=>ylt,content_2241_3022:()=>wlt,content_2241_3024:()=>Dlt,content_2241_3026:()=>Xlt,content_2241_3028:()=>xlt,content_2241_3030:()=>Tlt,content_2241_3032:()=>blt,content_2241_3034:()=>Zlt,content_2241_3036:()=>Slt,content_2241_3038:()=>Rlt,content_2241_304:()=>Kg,content_2241_3040:()=>Alt,content_2241_3042:()=>Wlt,content_2241_3044:()=>Flt,content_2241_3046:()=>Olt,content_2241_3048:()=>jlt,content_2241_3050:()=>qlt,content_2241_3052:()=>Hlt,content_2241_3054:()=>Qlt,content_2241_3056:()=>Ylt,content_2241_3058:()=>tut,content_2241_306:()=>ex,content_2241_3060:()=>nut,content_2241_3062:()=>sut,content_2241_3064:()=>put,content_2241_3066:()=>cut,content_2241_3068:()=>lut,content_2241_3070:()=>mut,content_2241_3072:()=>hut,content_2241_3074:()=>yut,content_2241_3076:()=>wut,content_2241_3078:()=>Dut,content_2241_308:()=>ox,content_2241_3080:()=>Xut,content_2241_3082:()=>xut,content_2241_3084:()=>Tut,content_2241_3086:()=>but,content_2241_3088:()=>Zut,content_2241_3090:()=>Sut,content_2241_3092:()=>Rut,content_2241_3094:()=>Aut,content_2241_3096:()=>Wut,content_2241_3098:()=>Fut,content_2241_310:()=>rx,content_2241_3100:()=>Out,content_2241_3102:()=>jut,content_2241_3104:()=>qut,content_2241_3106:()=>Hut,content_2241_3108:()=>Qut,content_2241_3110:()=>Yut,content_2241_3112:()=>tmt,content_2241_3114:()=>nmt,content_2241_3116:()=>smt,content_2241_3118:()=>pmt,content_2241_312:()=>ix,content_2241_3120:()=>cmt,content_2241_3122:()=>lmt,content_2241_3124:()=>mmt,content_2241_3126:()=>hmt,content_2241_3128:()=>ymt,content_2241_3130:()=>wmt,content_2241_3132:()=>Dmt,content_2241_3134:()=>Xmt,content_2241_3136:()=>xmt,content_2241_3138:()=>Tmt,content_2241_314:()=>ax,content_2241_3140:()=>bmt,content_2241_3142:()=>Zmt,content_2241_3144:()=>Smt,content_2241_3146:()=>Rmt,content_2241_3148:()=>Amt,content_2241_3150:()=>Wmt,content_2241_3152:()=>Fmt,content_2241_3154:()=>Omt,content_2241_3156:()=>jmt,content_2241_3158:()=>qmt,content_2241_316:()=>ux,content_2241_3160:()=>Hmt,content_2241_3162:()=>Qmt,content_2241_3164:()=>Ymt,content_2241_3166:()=>tdt,content_2241_3168:()=>ndt,content_2241_3170:()=>sdt,content_2241_3172:()=>pdt,content_2241_3174:()=>cdt,content_2241_3176:()=>ldt,content_2241_3178:()=>mdt,content_2241_318:()=>dx,content_2241_3180:()=>hdt,content_2241_3182:()=>ydt,content_2241_3184:()=>wdt,content_2241_3186:()=>Ddt,content_2241_3188:()=>Xdt,content_2241_3190:()=>xdt,content_2241_3192:()=>Tdt,content_2241_3194:()=>bdt,content_2241_3196:()=>Zdt,content_2241_3198:()=>Sdt,content_2241_32:()=>Jw,content_2241_320:()=>fx,content_2241_3200:()=>Rdt,content_2241_3202:()=>Adt,content_2241_3204:()=>Wdt,content_2241_3206:()=>Fdt,content_2241_3208:()=>Odt,content_2241_3210:()=>jdt,content_2241_3212:()=>qdt,content_2241_3214:()=>Hdt,content_2241_3216:()=>Qdt,content_2241_3218:()=>Ydt,content_2241_322:()=>kx,content_2241_3220:()=>tht,content_2241_3222:()=>nht,content_2241_3224:()=>sht,content_2241_3226:()=>pht,content_2241_3228:()=>cht,content_2241_3230:()=>lht,content_2241_3232:()=>mht,content_2241_3234:()=>hht,content_2241_3236:()=>yht,content_2241_3238:()=>wht,content_2241_324:()=>Mx,content_2241_3240:()=>Dht,content_2241_3242:()=>Xht,content_2241_3244:()=>xht,content_2241_3246:()=>Tht,content_2241_3248:()=>bht,content_2241_3250:()=>Zht,content_2241_3252:()=>Sht,content_2241_3254:()=>Rht,content_2241_3256:()=>Aht,content_2241_3258:()=>Wht,content_2241_326:()=>_x,content_2241_3260:()=>Fht,content_2241_3262:()=>Oht,content_2241_3264:()=>jht,content_2241_3266:()=>qht,content_2241_3268:()=>Hht,content_2241_3270:()=>Qht,content_2241_3272:()=>Yht,content_2241_3274:()=>tft,content_2241_3276:()=>nft,content_2241_3278:()=>sft,content_2241_328:()=>gx,content_2241_3280:()=>pft,content_2241_3282:()=>cft,content_2241_3284:()=>lft,content_2241_3286:()=>mft,content_2241_3288:()=>hft,content_2241_3290:()=>yft,content_2241_3292:()=>wft,content_2241_3294:()=>Dft,content_2241_3296:()=>Xft,content_2241_3298:()=>xft,content_2241_330:()=>Cx,content_2241_3300:()=>Tft,content_2241_3302:()=>bft,content_2241_3304:()=>Zft,content_2241_3306:()=>Sft,content_2241_3308:()=>Rft,content_2241_3310:()=>Aft,content_2241_3312:()=>Wft,content_2241_3314:()=>Fft,content_2241_3316:()=>Oft,content_2241_3318:()=>jft,content_2241_332:()=>vx,content_2241_3320:()=>qft,content_2241_3322:()=>Hft,content_2241_3324:()=>Qft,content_2241_3326:()=>Yft,content_2241_3328:()=>tyt,content_2241_3330:()=>nyt,content_2241_3332:()=>syt,content_2241_3334:()=>pyt,content_2241_3336:()=>cyt,content_2241_3338:()=>lyt,content_2241_334:()=>Lx,content_2241_3340:()=>myt,content_2241_3342:()=>hyt,content_2241_3344:()=>yyt,content_2241_3346:()=>wyt,content_2241_3348:()=>Dyt,content_2241_3350:()=>Xyt,content_2241_3352:()=>xyt,content_2241_3354:()=>Tyt,content_2241_3356:()=>byt,content_2241_3358:()=>Zyt,content_2241_336:()=>Nx,content_2241_3360:()=>Syt,content_2241_3362:()=>Ryt,content_2241_3364:()=>Ayt,content_2241_3366:()=>Wyt,content_2241_3368:()=>Fyt,content_2241_3370:()=>Oyt,content_2241_3372:()=>jyt,content_2241_3374:()=>qyt,content_2241_3376:()=>Hyt,content_2241_3378:()=>Qyt,content_2241_338:()=>zx,content_2241_3380:()=>Yyt,content_2241_3382:()=>tkt,content_2241_3384:()=>nkt,content_2241_3386:()=>skt,content_2241_3388:()=>pkt,content_2241_3390:()=>ckt,content_2241_3392:()=>lkt,content_2241_3394:()=>mkt,content_2241_3396:()=>hkt,content_2241_3398:()=>ykt,content_2241_34:()=>Kw,content_2241_340:()=>Px,content_2241_3400:()=>wkt,content_2241_3402:()=>Dkt,content_2241_3404:()=>Xkt,content_2241_3406:()=>xkt,content_2241_3408:()=>Tkt,content_2241_3410:()=>bkt,content_2241_3412:()=>Zkt,content_2241_3414:()=>Skt,content_2241_3416:()=>Rkt,content_2241_3418:()=>Akt,content_2241_342:()=>Ix,content_2241_3420:()=>Wkt,content_2241_3422:()=>Fkt,content_2241_3424:()=>Okt,content_2241_3426:()=>jkt,content_2241_3428:()=>qkt,content_2241_3430:()=>Hkt,content_2241_3432:()=>Qkt,content_2241_3434:()=>Ykt,content_2241_3436:()=>twt,content_2241_3438:()=>nwt,content_2241_344:()=>Ex,content_2241_3440:()=>swt,content_2241_3442:()=>pwt,content_2241_3444:()=>cwt,content_2241_3446:()=>lwt,content_2241_3448:()=>mwt,content_2241_3450:()=>hwt,content_2241_3452:()=>ywt,content_2241_3454:()=>wwt,content_2241_3456:()=>Dwt,content_2241_3458:()=>Xwt,content_2241_346:()=>Bx,content_2241_3460:()=>xwt,content_2241_3462:()=>Twt,content_2241_3464:()=>bwt,content_2241_3466:()=>Zwt,content_2241_3468:()=>Swt,content_2241_3470:()=>Rwt,content_2241_3472:()=>Awt,content_2241_3474:()=>Wwt,content_2241_3476:()=>Fwt,content_2241_3478:()=>Owt,content_2241_348:()=>Gx,content_2241_3480:()=>jwt,content_2241_3482:()=>qwt,content_2241_3484:()=>Hwt,content_2241_3486:()=>Qwt,content_2241_3488:()=>Ywt,content_2241_3490:()=>tMt,content_2241_3492:()=>nMt,content_2241_3494:()=>sMt,content_2241_3496:()=>pMt,content_2241_3498:()=>cMt,content_2241_350:()=>Ux,content_2241_3500:()=>lMt,content_2241_3502:()=>mMt,content_2241_3504:()=>hMt,content_2241_3506:()=>yMt,content_2241_3508:()=>wMt,content_2241_3510:()=>DMt,content_2241_3512:()=>XMt,content_2241_3514:()=>xMt,content_2241_3516:()=>TMt,content_2241_3518:()=>bMt,content_2241_352:()=>Vx,content_2241_3520:()=>ZMt,content_2241_3522:()=>SMt,content_2241_3524:()=>RMt,content_2241_3526:()=>AMt,content_2241_3528:()=>WMt,content_2241_3530:()=>FMt,content_2241_3532:()=>OMt,content_2241_3534:()=>jMt,content_2241_3536:()=>qMt,content_2241_3538:()=>HMt,content_2241_354:()=>$x,content_2241_3540:()=>QMt,content_2241_3542:()=>YMt,content_2241_3544:()=>tDt,content_2241_3546:()=>nDt,content_2241_3548:()=>sDt,content_2241_3550:()=>pDt,content_2241_3552:()=>cDt,content_2241_3554:()=>lDt,content_2241_3556:()=>mDt,content_2241_3558:()=>hDt,content_2241_356:()=>Jx,content_2241_3560:()=>yDt,content_2241_3562:()=>wDt,content_2241_3564:()=>DDt,content_2241_3566:()=>XDt,content_2241_3568:()=>xDt,content_2241_3570:()=>TDt,content_2241_3572:()=>bDt,content_2241_3574:()=>ZDt,content_2241_3576:()=>SDt,content_2241_3578:()=>RDt,content_2241_358:()=>Kx,content_2241_3580:()=>ADt,content_2241_3582:()=>WDt,content_2241_3584:()=>FDt,content_2241_3586:()=>ODt,content_2241_3588:()=>jDt,content_2241_3590:()=>qDt,content_2241_3592:()=>HDt,content_2241_3594:()=>QDt,content_2241_3596:()=>YDt,content_2241_3598:()=>t_t,content_2241_36:()=>eM,content_2241_360:()=>eC,content_2241_3600:()=>n_t,content_2241_3602:()=>s_t,content_2241_3604:()=>p_t,content_2241_3606:()=>c_t,content_2241_3608:()=>l_t,content_2241_3610:()=>m_t,content_2241_3612:()=>h_t,content_2241_3614:()=>y_t,content_2241_3616:()=>w_t,content_2241_3618:()=>D_t,content_2241_362:()=>oC,content_2241_3620:()=>X_t,content_2241_3622:()=>x_t,content_2241_3624:()=>T_t,content_2241_3626:()=>b_t,content_2241_3628:()=>Z_t,content_2241_3630:()=>S_t,content_2241_3632:()=>R_t,content_2241_3634:()=>A_t,content_2241_3636:()=>W_t,content_2241_3638:()=>F_t,content_2241_364:()=>rC,content_2241_3640:()=>O_t,content_2241_3642:()=>j_t,content_2241_3644:()=>q_t,content_2241_3646:()=>H_t,content_2241_3648:()=>Q_t,content_2241_3650:()=>Y_t,content_2241_3652:()=>tXt,content_2241_3654:()=>nXt,content_2241_3656:()=>sXt,content_2241_3658:()=>pXt,content_2241_366:()=>iC,content_2241_3660:()=>cXt,content_2241_3662:()=>lXt,content_2241_3664:()=>mXt,content_2241_3666:()=>hXt,content_2241_3668:()=>yXt,content_2241_3670:()=>wXt,content_2241_3672:()=>DXt,content_2241_3674:()=>XXt,content_2241_3676:()=>xXt,content_2241_3678:()=>TXt,content_2241_368:()=>aC,content_2241_3680:()=>bXt,content_2241_3682:()=>ZXt,content_2241_3684:()=>SXt,content_2241_3686:()=>RXt,content_2241_3688:()=>AXt,content_2241_3690:()=>WXt,content_2241_3692:()=>FXt,content_2241_3694:()=>OXt,content_2241_3696:()=>jXt,content_2241_3698:()=>qXt,content_2241_370:()=>uC,content_2241_3700:()=>HXt,content_2241_3702:()=>QXt,content_2241_3704:()=>YXt,content_2241_3706:()=>tgt,content_2241_3708:()=>ngt,content_2241_3710:()=>sgt,content_2241_3712:()=>pgt,content_2241_3714:()=>cgt,content_2241_3716:()=>lgt,content_2241_3718:()=>mgt,content_2241_372:()=>dC,content_2241_3720:()=>hgt,content_2241_3722:()=>ygt,content_2241_3724:()=>wgt,content_2241_3726:()=>Dgt,content_2241_3728:()=>Xgt,content_2241_3730:()=>xgt,content_2241_3732:()=>Tgt,content_2241_3734:()=>bgt,content_2241_3736:()=>Zgt,content_2241_3738:()=>Sgt,content_2241_374:()=>fC,content_2241_3740:()=>Rgt,content_2241_3742:()=>Agt,content_2241_3744:()=>Wgt,content_2241_3746:()=>Fgt,content_2241_3748:()=>Ogt,content_2241_3750:()=>jgt,content_2241_3752:()=>qgt,content_2241_3754:()=>Hgt,content_2241_3756:()=>Qgt,content_2241_3758:()=>Ygt,content_2241_376:()=>kC,content_2241_3760:()=>txt,content_2241_3762:()=>nxt,content_2241_3764:()=>sxt,content_2241_3766:()=>pxt,content_2241_3768:()=>cxt,content_2241_3770:()=>lxt,content_2241_3772:()=>mxt,content_2241_3774:()=>hxt,content_2241_3776:()=>yxt,content_2241_3778:()=>wxt,content_2241_378:()=>MC,content_2241_3780:()=>Dxt,content_2241_3782:()=>Xxt,content_2241_3784:()=>xxt,content_2241_3786:()=>Txt,content_2241_3788:()=>bxt,content_2241_3790:()=>Zxt,content_2241_3792:()=>Sxt,content_2241_3794:()=>Rxt,content_2241_3796:()=>Axt,content_2241_3798:()=>Wxt,content_2241_38:()=>oM,content_2241_380:()=>_C,content_2241_3800:()=>Fxt,content_2241_3802:()=>Oxt,content_2241_3804:()=>jxt,content_2241_3806:()=>qxt,content_2241_3808:()=>Hxt,content_2241_3810:()=>Qxt,content_2241_3812:()=>Yxt,content_2241_3814:()=>tCt,content_2241_3816:()=>nCt,content_2241_3818:()=>sCt,content_2241_382:()=>gC,content_2241_3820:()=>pCt,content_2241_3822:()=>cCt,content_2241_3824:()=>lCt,content_2241_3826:()=>mCt,content_2241_3828:()=>hCt,content_2241_3830:()=>yCt,content_2241_3832:()=>wCt,content_2241_3834:()=>DCt,content_2241_3836:()=>XCt,content_2241_3838:()=>xCt,content_2241_384:()=>CC,content_2241_3840:()=>TCt,content_2241_3842:()=>bCt,content_2241_3844:()=>ZCt,content_2241_3846:()=>SCt,content_2241_3848:()=>RCt,content_2241_3850:()=>ACt,content_2241_3852:()=>WCt,content_2241_3854:()=>FCt,content_2241_3856:()=>OCt,content_2241_3858:()=>jCt,content_2241_386:()=>vC,content_2241_3860:()=>qCt,content_2241_3862:()=>HCt,content_2241_3864:()=>QCt,content_2241_3866:()=>YCt,content_2241_3868:()=>tTt,content_2241_3870:()=>nTt,content_2241_3872:()=>sTt,content_2241_3874:()=>pTt,content_2241_3876:()=>cTt,content_2241_3878:()=>lTt,content_2241_388:()=>LC,content_2241_3880:()=>mTt,content_2241_3882:()=>hTt,content_2241_3884:()=>yTt,content_2241_3886:()=>wTt,content_2241_3888:()=>DTt,content_2241_3890:()=>XTt,content_2241_3892:()=>xTt,content_2241_3894:()=>TTt,content_2241_3896:()=>bTt,content_2241_3898:()=>ZTt,content_2241_390:()=>NC,content_2241_3900:()=>STt,content_2241_3902:()=>RTt,content_2241_3904:()=>ATt,content_2241_3906:()=>WTt,content_2241_3908:()=>FTt,content_2241_3910:()=>OTt,content_2241_3912:()=>jTt,content_2241_3914:()=>qTt,content_2241_3916:()=>HTt,content_2241_3918:()=>QTt,content_2241_392:()=>zC,content_2241_3920:()=>YTt,content_2241_3922:()=>tvt,content_2241_3924:()=>nvt,content_2241_3926:()=>svt,content_2241_3928:()=>pvt,content_2241_3930:()=>cvt,content_2241_3932:()=>lvt,content_2241_3934:()=>mvt,content_2241_3936:()=>hvt,content_2241_3938:()=>yvt,content_2241_394:()=>PC,content_2241_3940:()=>wvt,content_2241_3942:()=>Dvt,content_2241_3944:()=>Xvt,content_2241_3946:()=>xvt,content_2241_3948:()=>Tvt,content_2241_3950:()=>bvt,content_2241_3952:()=>Zvt,content_2241_3954:()=>Svt,content_2241_3956:()=>Rvt,content_2241_3958:()=>Avt,content_2241_396:()=>IC,content_2241_3960:()=>Wvt,content_2241_3962:()=>Fvt,content_2241_3964:()=>Ovt,content_2241_3966:()=>jvt,content_2241_3968:()=>qvt,content_2241_3970:()=>Hvt,content_2241_3972:()=>Qvt,content_2241_3974:()=>Yvt,content_2241_3976:()=>tbt,content_2241_3978:()=>nbt,content_2241_398:()=>EC,content_2241_3980:()=>sbt,content_2241_3982:()=>pbt,content_2241_3984:()=>cbt,content_2241_3986:()=>lbt,content_2241_3988:()=>mbt,content_2241_3990:()=>hbt,content_2241_3992:()=>ybt,content_2241_3994:()=>wbt,content_2241_3996:()=>Dbt,content_2241_3998:()=>Xbt,content_2241_4:()=>gw,content_2241_40:()=>rM,content_2241_400:()=>BC,content_2241_4000:()=>xbt,content_2241_4002:()=>Tbt,content_2241_4004:()=>bbt,content_2241_4006:()=>Zbt,content_2241_4008:()=>Sbt,content_2241_4010:()=>Rbt,content_2241_4012:()=>Abt,content_2241_4014:()=>Wbt,content_2241_4016:()=>Fbt,content_2241_4018:()=>Obt,content_2241_402:()=>GC,content_2241_4020:()=>jbt,content_2241_4022:()=>qbt,content_2241_4024:()=>Hbt,content_2241_4026:()=>Qbt,content_2241_4028:()=>Ybt,content_2241_4030:()=>tLt,content_2241_4032:()=>nLt,content_2241_4034:()=>sLt,content_2241_4036:()=>pLt,content_2241_4038:()=>cLt,content_2241_404:()=>UC,content_2241_4040:()=>lLt,content_2241_4042:()=>mLt,content_2241_4044:()=>hLt,content_2241_4046:()=>yLt,content_2241_4048:()=>wLt,content_2241_4050:()=>DLt,content_2241_4052:()=>XLt,content_2241_4054:()=>xLt,content_2241_4056:()=>TLt,content_2241_4058:()=>bLt,content_2241_406:()=>VC,content_2241_4060:()=>ZLt,content_2241_4062:()=>SLt,content_2241_4064:()=>RLt,content_2241_4066:()=>ALt,content_2241_4068:()=>WLt,content_2241_4070:()=>FLt,content_2241_4072:()=>OLt,content_2241_4074:()=>jLt,content_2241_4076:()=>qLt,content_2241_4078:()=>HLt,content_2241_408:()=>$C,content_2241_4080:()=>QLt,content_2241_4082:()=>YLt,content_2241_4084:()=>tZt,content_2241_4086:()=>nZt,content_2241_4088:()=>sZt,content_2241_4090:()=>pZt,content_2241_4092:()=>cZt,content_2241_4094:()=>lZt,content_2241_4096:()=>mZt,content_2241_4098:()=>hZt,content_2241_410:()=>JC,content_2241_4100:()=>yZt,content_2241_4102:()=>wZt,content_2241_4104:()=>DZt,content_2241_4106:()=>XZt,content_2241_4108:()=>xZt,content_2241_4110:()=>TZt,content_2241_4112:()=>bZt,content_2241_4114:()=>ZZt,content_2241_4116:()=>SZt,content_2241_4118:()=>RZt,content_2241_412:()=>KC,content_2241_4120:()=>AZt,content_2241_4122:()=>WZt,content_2241_4124:()=>FZt,content_2241_4126:()=>OZt,content_2241_4128:()=>jZt,content_2241_4130:()=>qZt,content_2241_4132:()=>HZt,content_2241_4134:()=>QZt,content_2241_4136:()=>YZt,content_2241_4138:()=>tNt,content_2241_414:()=>eT,content_2241_4140:()=>nNt,content_2241_4142:()=>sNt,content_2241_4144:()=>pNt,content_2241_4146:()=>cNt,content_2241_4148:()=>lNt,content_2241_4150:()=>mNt,content_2241_4152:()=>hNt,content_2241_4154:()=>yNt,content_2241_4156:()=>wNt,content_2241_4158:()=>DNt,content_2241_416:()=>oT,content_2241_4160:()=>XNt,content_2241_4162:()=>xNt,content_2241_4164:()=>TNt,content_2241_4166:()=>bNt,content_2241_4168:()=>ZNt,content_2241_4170:()=>SNt,content_2241_4172:()=>RNt,content_2241_4174:()=>ANt,content_2241_4176:()=>WNt,content_2241_4178:()=>FNt,content_2241_418:()=>rT,content_2241_4180:()=>ONt,content_2241_4182:()=>jNt,content_2241_4184:()=>qNt,content_2241_4186:()=>HNt,content_2241_4188:()=>QNt,content_2241_4190:()=>YNt,content_2241_4192:()=>tSt,content_2241_4194:()=>nSt,content_2241_4196:()=>sSt,content_2241_4198:()=>pSt,content_2241_42:()=>iM,content_2241_420:()=>iT,content_2241_4200:()=>cSt,content_2241_4202:()=>lSt,content_2241_4204:()=>mSt,content_2241_4206:()=>hSt,content_2241_4208:()=>ySt,content_2241_4210:()=>wSt,content_2241_4212:()=>DSt,content_2241_4214:()=>XSt,content_2241_4216:()=>xSt,content_2241_4218:()=>TSt,content_2241_422:()=>aT,content_2241_4220:()=>bSt,content_2241_4222:()=>ZSt,content_2241_4224:()=>SSt,content_2241_4226:()=>RSt,content_2241_4228:()=>ASt,content_2241_4230:()=>WSt,content_2241_4232:()=>FSt,content_2241_4234:()=>OSt,content_2241_4236:()=>jSt,content_2241_4238:()=>qSt,content_2241_424:()=>uT,content_2241_4240:()=>HSt,content_2241_4242:()=>QSt,content_2241_4244:()=>YSt,content_2241_4246:()=>tzt,content_2241_4248:()=>nzt,content_2241_4250:()=>szt,content_2241_4252:()=>pzt,content_2241_4254:()=>czt,content_2241_4256:()=>lzt,content_2241_4258:()=>mzt,content_2241_426:()=>dT,content_2241_4260:()=>hzt,content_2241_4262:()=>yzt,content_2241_4264:()=>wzt,content_2241_4266:()=>Dzt,content_2241_4268:()=>Xzt,content_2241_4270:()=>xzt,content_2241_4272:()=>Tzt,content_2241_4274:()=>bzt,content_2241_4276:()=>Zzt,content_2241_4278:()=>Szt,content_2241_428:()=>fT,content_2241_4280:()=>Rzt,content_2241_4282:()=>Azt,content_2241_4284:()=>Wzt,content_2241_4286:()=>Fzt,content_2241_4288:()=>Ozt,content_2241_4290:()=>jzt,content_2241_4292:()=>qzt,content_2241_4294:()=>Hzt,content_2241_4296:()=>Qzt,content_2241_4298:()=>Yzt,content_2241_430:()=>kT,content_2241_4300:()=>tRt,content_2241_4302:()=>nRt,content_2241_4304:()=>sRt,content_2241_4306:()=>pRt,content_2241_4308:()=>cRt,content_2241_4310:()=>lRt,content_2241_4312:()=>mRt,content_2241_4314:()=>hRt,content_2241_4316:()=>yRt,content_2241_4318:()=>wRt,content_2241_432:()=>MT,content_2241_4320:()=>DRt,content_2241_4322:()=>XRt,content_2241_4324:()=>xRt,content_2241_4326:()=>TRt,content_2241_4328:()=>bRt,content_2241_4330:()=>ZRt,content_2241_4332:()=>SRt,content_2241_4334:()=>RRt,content_2241_4336:()=>ARt,content_2241_4338:()=>WRt,content_2241_434:()=>_T,content_2241_4340:()=>FRt,content_2241_4342:()=>ORt,content_2241_4344:()=>jRt,content_2241_4346:()=>qRt,content_2241_4348:()=>HRt,content_2241_4350:()=>QRt,content_2241_4352:()=>YRt,content_2241_4354:()=>tPt,content_2241_4356:()=>nPt,content_2241_4358:()=>sPt,content_2241_436:()=>gT,content_2241_4360:()=>pPt,content_2241_4362:()=>cPt,content_2241_4364:()=>lPt,content_2241_4366:()=>mPt,content_2241_4368:()=>hPt,content_2241_4370:()=>yPt,content_2241_4372:()=>wPt,content_2241_4374:()=>DPt,content_2241_4376:()=>XPt,content_2241_4378:()=>xPt,content_2241_438:()=>CT,content_2241_4380:()=>TPt,content_2241_4382:()=>bPt,content_2241_4384:()=>ZPt,content_2241_4386:()=>SPt,content_2241_4388:()=>RPt,content_2241_4390:()=>APt,content_2241_4392:()=>WPt,content_2241_4394:()=>FPt,content_2241_4396:()=>OPt,content_2241_4398:()=>jPt,content_2241_44:()=>aM,content_2241_440:()=>vT,content_2241_4400:()=>qPt,content_2241_4402:()=>HPt,content_2241_4404:()=>QPt,content_2241_4406:()=>YPt,content_2241_4408:()=>tAt,content_2241_4410:()=>nAt,content_2241_4412:()=>sAt,content_2241_4414:()=>pAt,content_2241_4416:()=>cAt,content_2241_4418:()=>lAt,content_2241_442:()=>LT,content_2241_4420:()=>mAt,content_2241_4422:()=>hAt,content_2241_4424:()=>yAt,content_2241_4426:()=>wAt,content_2241_4428:()=>DAt,content_2241_4430:()=>XAt,content_2241_4432:()=>xAt,content_2241_4434:()=>TAt,content_2241_4436:()=>bAt,content_2241_4438:()=>ZAt,content_2241_444:()=>NT,content_2241_4440:()=>SAt,content_2241_4442:()=>RAt,content_2241_4444:()=>AAt,content_2241_4446:()=>WAt,content_2241_4448:()=>FAt,content_2241_4450:()=>OAt,content_2241_4452:()=>jAt,content_2241_4454:()=>qAt,content_2241_4456:()=>HAt,content_2241_4458:()=>QAt,content_2241_446:()=>zT,content_2241_4460:()=>YAt,content_2241_4462:()=>tIt,content_2241_4464:()=>nIt,content_2241_4466:()=>sIt,content_2241_4468:()=>pIt,content_2241_4470:()=>cIt,content_2241_4472:()=>lIt,content_2241_4474:()=>mIt,content_2241_4476:()=>hIt,content_2241_4478:()=>yIt,content_2241_448:()=>PT,content_2241_4480:()=>wIt,content_2241_4482:()=>DIt,content_2241_4484:()=>XIt,content_2241_4486:()=>xIt,content_2241_4488:()=>TIt,content_2241_4490:()=>bIt,content_2241_4492:()=>ZIt,content_2241_4494:()=>SIt,content_2241_4496:()=>RIt,content_2241_4498:()=>AIt,content_2241_450:()=>IT,content_2241_4500:()=>WIt,content_2241_4502:()=>FIt,content_2241_4504:()=>OIt,content_2241_4506:()=>jIt,content_2241_4508:()=>qIt,content_2241_4510:()=>HIt,content_2241_4512:()=>QIt,content_2241_4514:()=>YIt,content_2241_4516:()=>tWt,content_2241_4518:()=>nWt,content_2241_452:()=>ET,content_2241_4520:()=>sWt,content_2241_4522:()=>pWt,content_2241_4524:()=>cWt,content_2241_4526:()=>lWt,content_2241_4528:()=>mWt,content_2241_4530:()=>hWt,content_2241_4532:()=>yWt,content_2241_4534:()=>wWt,content_2241_4536:()=>DWt,content_2241_4538:()=>XWt,content_2241_454:()=>BT,content_2241_4540:()=>xWt,content_2241_4542:()=>TWt,content_2241_4544:()=>bWt,content_2241_4546:()=>ZWt,content_2241_4548:()=>SWt,content_2241_4550:()=>RWt,content_2241_4552:()=>AWt,content_2241_4554:()=>WWt,content_2241_4556:()=>FWt,content_2241_4558:()=>OWt,content_2241_456:()=>GT,content_2241_4560:()=>jWt,content_2241_4562:()=>qWt,content_2241_4564:()=>HWt,content_2241_4566:()=>QWt,content_2241_4568:()=>YWt,content_2241_4570:()=>tEt,content_2241_4572:()=>nEt,content_2241_4574:()=>sEt,content_2241_4576:()=>pEt,content_2241_4578:()=>cEt,content_2241_458:()=>UT,content_2241_4580:()=>lEt,content_2241_4582:()=>mEt,content_2241_4584:()=>hEt,content_2241_4586:()=>yEt,content_2241_4588:()=>wEt,content_2241_4590:()=>DEt,content_2241_4592:()=>XEt,content_2241_4594:()=>xEt,content_2241_4596:()=>TEt,content_2241_4598:()=>bEt,content_2241_46:()=>uM,content_2241_460:()=>VT,content_2241_4600:()=>ZEt,content_2241_4602:()=>SEt,content_2241_4604:()=>REt,content_2241_4606:()=>AEt,content_2241_4608:()=>WEt,content_2241_4610:()=>FEt,content_2241_4612:()=>OEt,content_2241_4614:()=>jEt,content_2241_4616:()=>qEt,content_2241_4618:()=>HEt,content_2241_462:()=>$T,content_2241_4620:()=>QEt,content_2241_4622:()=>YEt,content_2241_4624:()=>tFt,content_2241_4626:()=>nFt,content_2241_4628:()=>sFt,content_2241_4630:()=>pFt,content_2241_4632:()=>cFt,content_2241_4634:()=>lFt,content_2241_4636:()=>mFt,content_2241_4638:()=>hFt,content_2241_464:()=>JT,content_2241_4640:()=>yFt,content_2241_4642:()=>wFt,content_2241_4644:()=>DFt,content_2241_4646:()=>XFt,content_2241_4648:()=>xFt,content_2241_4650:()=>TFt,content_2241_4652:()=>bFt,content_2241_4654:()=>ZFt,content_2241_4656:()=>SFt,content_2241_4658:()=>RFt,content_2241_466:()=>KT,content_2241_4660:()=>AFt,content_2241_4662:()=>WFt,content_2241_4664:()=>FFt,content_2241_4666:()=>OFt,content_2241_4668:()=>jFt,content_2241_4670:()=>qFt,content_2241_4672:()=>HFt,content_2241_4674:()=>QFt,content_2241_4676:()=>YFt,content_2241_4678:()=>tBt,content_2241_468:()=>ev,content_2241_4680:()=>nBt,content_2241_4682:()=>sBt,content_2241_4684:()=>pBt,content_2241_4686:()=>cBt,content_2241_4688:()=>lBt,content_2241_4690:()=>mBt,content_2241_4692:()=>hBt,content_2241_4694:()=>yBt,content_2241_4696:()=>wBt,content_2241_4698:()=>DBt,content_2241_470:()=>ov,content_2241_4700:()=>XBt,content_2241_4702:()=>xBt,content_2241_4704:()=>TBt,content_2241_4706:()=>bBt,content_2241_4708:()=>ZBt,content_2241_4710:()=>SBt,content_2241_4712:()=>RBt,content_2241_4714:()=>ABt,content_2241_4716:()=>WBt,content_2241_4718:()=>FBt,content_2241_472:()=>rv,content_2241_4720:()=>OBt,content_2241_4722:()=>jBt,content_2241_4724:()=>qBt,content_2241_4726:()=>HBt,content_2241_4728:()=>QBt,content_2241_4730:()=>YBt,content_2241_4732:()=>tOt,content_2241_4734:()=>nOt,content_2241_4736:()=>sOt,content_2241_4738:()=>pOt,content_2241_474:()=>iv,content_2241_4740:()=>cOt,content_2241_4742:()=>lOt,content_2241_4744:()=>mOt,content_2241_4746:()=>hOt,content_2241_4748:()=>yOt,content_2241_4750:()=>wOt,content_2241_4752:()=>DOt,content_2241_4754:()=>XOt,content_2241_4756:()=>xOt,content_2241_4758:()=>TOt,content_2241_476:()=>av,content_2241_4760:()=>bOt,content_2241_4762:()=>ZOt,content_2241_4764:()=>SOt,content_2241_4766:()=>ROt,content_2241_4768:()=>AOt,content_2241_4770:()=>WOt,content_2241_4772:()=>FOt,content_2241_4774:()=>OOt,content_2241_4776:()=>jOt,content_2241_4778:()=>qOt,content_2241_478:()=>uv,content_2241_4780:()=>HOt,content_2241_4782:()=>QOt,content_2241_4784:()=>YOt,content_2241_4786:()=>tGt,content_2241_4788:()=>nGt,content_2241_4790:()=>sGt,content_2241_4792:()=>pGt,content_2241_4794:()=>cGt,content_2241_4796:()=>lGt,content_2241_4798:()=>mGt,content_2241_48:()=>dM,content_2241_480:()=>dv,content_2241_4800:()=>hGt,content_2241_4802:()=>yGt,content_2241_4804:()=>wGt,content_2241_4806:()=>DGt,content_2241_4808:()=>XGt,content_2241_4810:()=>xGt,content_2241_4812:()=>TGt,content_2241_4814:()=>bGt,content_2241_4816:()=>ZGt,content_2241_4818:()=>SGt,content_2241_482:()=>fv,content_2241_4820:()=>RGt,content_2241_4822:()=>AGt,content_2241_4824:()=>WGt,content_2241_4826:()=>FGt,content_2241_4828:()=>OGt,content_2241_4830:()=>jGt,content_2241_4832:()=>qGt,content_2241_4834:()=>HGt,content_2241_4836:()=>QGt,content_2241_4838:()=>YGt,content_2241_484:()=>kv,content_2241_4840:()=>tjt,content_2241_4842:()=>njt,content_2241_4844:()=>sjt,content_2241_4846:()=>pjt,content_2241_4848:()=>cjt,content_2241_4850:()=>ljt,content_2241_4852:()=>mjt,content_2241_4854:()=>hjt,content_2241_4856:()=>yjt,content_2241_4858:()=>wjt,content_2241_486:()=>Mv,content_2241_4860:()=>Djt,content_2241_4862:()=>Xjt,content_2241_4864:()=>xjt,content_2241_4866:()=>Tjt,content_2241_4868:()=>bjt,content_2241_4870:()=>Zjt,content_2241_4872:()=>Sjt,content_2241_4874:()=>Rjt,content_2241_4876:()=>Ajt,content_2241_4878:()=>Wjt,content_2241_488:()=>_v,content_2241_4880:()=>Fjt,content_2241_4882:()=>Ojt,content_2241_4884:()=>jjt,content_2241_4886:()=>qjt,content_2241_4888:()=>Hjt,content_2241_4890:()=>Qjt,content_2241_4892:()=>Yjt,content_2241_4894:()=>tUt,content_2241_4896:()=>nUt,content_2241_4898:()=>sUt,content_2241_490:()=>gv,content_2241_4900:()=>pUt,content_2241_4902:()=>cUt,content_2241_4904:()=>lUt,content_2241_4906:()=>mUt,content_2241_4908:()=>hUt,content_2241_4910:()=>yUt,content_2241_4912:()=>wUt,content_2241_4914:()=>DUt,content_2241_4916:()=>XUt,content_2241_4918:()=>xUt,content_2241_492:()=>Cv,content_2241_4920:()=>TUt,content_2241_4922:()=>bUt,content_2241_4924:()=>ZUt,content_2241_4926:()=>SUt,content_2241_4928:()=>RUt,content_2241_4930:()=>AUt,content_2241_4932:()=>WUt,content_2241_4934:()=>FUt,content_2241_4936:()=>OUt,content_2241_4938:()=>jUt,content_2241_494:()=>vv,content_2241_4940:()=>qUt,content_2241_4942:()=>HUt,content_2241_4944:()=>QUt,content_2241_4946:()=>YUt,content_2241_4948:()=>tqt,content_2241_4950:()=>nqt,content_2241_4952:()=>sqt,content_2241_4954:()=>pqt,content_2241_4956:()=>cqt,content_2241_4958:()=>lqt,content_2241_496:()=>Lv,content_2241_4960:()=>mqt,content_2241_4962:()=>hqt,content_2241_4964:()=>yqt,content_2241_4966:()=>wqt,content_2241_4968:()=>Dqt,content_2241_4970:()=>Xqt,content_2241_4972:()=>xqt,content_2241_4974:()=>Tqt,content_2241_4976:()=>bqt,content_2241_4978:()=>Zqt,content_2241_498:()=>Nv,content_2241_4980:()=>Sqt,content_2241_4982:()=>Rqt,content_2241_4984:()=>Aqt,content_2241_4986:()=>Wqt,content_2241_4988:()=>Fqt,content_2241_4990:()=>Oqt,content_2241_4992:()=>jqt,content_2241_4994:()=>qqt,content_2241_4996:()=>Hqt,content_2241_4998:()=>Qqt,content_2241_50:()=>fM,content_2241_500:()=>zv,content_2241_5000:()=>Yqt,content_2241_5002:()=>tVt,content_2241_5004:()=>nVt,content_2241_5006:()=>sVt,content_2241_5008:()=>pVt,content_2241_5010:()=>cVt,content_2241_5012:()=>lVt,content_2241_5014:()=>mVt,content_2241_5016:()=>hVt,content_2241_5018:()=>yVt,content_2241_502:()=>Pv,content_2241_5020:()=>wVt,content_2241_5022:()=>DVt,content_2241_5024:()=>XVt,content_2241_5026:()=>xVt,content_2241_5028:()=>TVt,content_2241_5030:()=>bVt,content_2241_5032:()=>ZVt,content_2241_5034:()=>SVt,content_2241_5036:()=>RVt,content_2241_5038:()=>AVt,content_2241_504:()=>Iv,content_2241_5040:()=>WVt,content_2241_5042:()=>FVt,content_2241_5044:()=>OVt,content_2241_5046:()=>jVt,content_2241_5048:()=>qVt,content_2241_5050:()=>HVt,content_2241_5052:()=>QVt,content_2241_5054:()=>YVt,content_2241_5056:()=>tHt,content_2241_5058:()=>nHt,content_2241_506:()=>Ev,content_2241_5060:()=>sHt,content_2241_5062:()=>pHt,content_2241_5064:()=>cHt,content_2241_5066:()=>lHt,content_2241_5068:()=>mHt,content_2241_5070:()=>hHt,content_2241_5072:()=>yHt,content_2241_5074:()=>wHt,content_2241_5076:()=>DHt,content_2241_5078:()=>XHt,content_2241_508:()=>Bv,content_2241_5080:()=>xHt,content_2241_5082:()=>THt,content_2241_5084:()=>bHt,content_2241_5086:()=>ZHt,content_2241_5088:()=>SHt,content_2241_5090:()=>RHt,content_2241_5092:()=>AHt,content_2241_5094:()=>WHt,content_2241_5096:()=>FHt,content_2241_5098:()=>OHt,content_2241_510:()=>Gv,content_2241_5100:()=>jHt,content_2241_5102:()=>qHt,content_2241_5104:()=>HHt,content_2241_5106:()=>QHt,content_2241_5108:()=>YHt,content_2241_5110:()=>t$t,content_2241_5112:()=>n$t,content_2241_5114:()=>s$t,content_2241_5116:()=>p$t,content_2241_5118:()=>c$t,content_2241_512:()=>Uv,content_2241_5120:()=>l$t,content_2241_5122:()=>m$t,content_2241_5124:()=>h$t,content_2241_5126:()=>y$t,content_2241_5128:()=>w$t,content_2241_5130:()=>D$t,content_2241_5132:()=>X$t,content_2241_5134:()=>x$t,content_2241_5136:()=>T$t,content_2241_5138:()=>b$t,content_2241_514:()=>Vv,content_2241_5140:()=>Z$t,content_2241_5142:()=>S$t,content_2241_5144:()=>R$t,content_2241_5146:()=>A$t,content_2241_5148:()=>W$t,content_2241_5150:()=>F$t,content_2241_5152:()=>O$t,content_2241_5154:()=>j$t,content_2241_5156:()=>q$t,content_2241_5158:()=>H$t,content_2241_516:()=>$v,content_2241_5160:()=>Q$t,content_2241_5162:()=>Y$t,content_2241_5164:()=>tQt,content_2241_5166:()=>nQt,content_2241_5168:()=>sQt,content_2241_5170:()=>pQt,content_2241_5172:()=>cQt,content_2241_5174:()=>lQt,content_2241_5176:()=>mQt,content_2241_5178:()=>hQt,content_2241_518:()=>Jv,content_2241_5180:()=>yQt,content_2241_5182:()=>wQt,content_2241_5184:()=>DQt,content_2241_5186:()=>XQt,content_2241_5188:()=>xQt,content_2241_5190:()=>TQt,content_2241_5192:()=>bQt,content_2241_5194:()=>ZQt,content_2241_5196:()=>SQt,content_2241_5198:()=>RQt,content_2241_52:()=>kM,content_2241_520:()=>Kv,content_2241_5200:()=>AQt,content_2241_5202:()=>WQt,content_2241_5204:()=>FQt,content_2241_5206:()=>OQt,content_2241_5208:()=>jQt,content_2241_5210:()=>qQt,content_2241_5212:()=>HQt,content_2241_5214:()=>QQt,content_2241_5216:()=>YQt,content_2241_5218:()=>tJt,content_2241_522:()=>eb,content_2241_5220:()=>nJt,content_2241_5222:()=>sJt,content_2241_5224:()=>pJt,content_2241_5226:()=>cJt,content_2241_5228:()=>lJt,content_2241_5230:()=>mJt,content_2241_5232:()=>hJt,content_2241_5234:()=>yJt,content_2241_5236:()=>wJt,content_2241_5238:()=>DJt,content_2241_524:()=>ob,content_2241_5240:()=>XJt,content_2241_5242:()=>xJt,content_2241_5244:()=>TJt,content_2241_5246:()=>bJt,content_2241_5248:()=>ZJt,content_2241_5250:()=>SJt,content_2241_5252:()=>RJt,content_2241_5254:()=>AJt,content_2241_5256:()=>WJt,content_2241_5258:()=>FJt,content_2241_526:()=>rb,content_2241_5260:()=>OJt,content_2241_5262:()=>jJt,content_2241_5264:()=>qJt,content_2241_5266:()=>HJt,content_2241_5268:()=>QJt,content_2241_5270:()=>YJt,content_2241_5272:()=>tYt,content_2241_5274:()=>nYt,content_2241_5276:()=>sYt,content_2241_5278:()=>pYt,content_2241_528:()=>ib,content_2241_5280:()=>cYt,content_2241_5282:()=>lYt,content_2241_5284:()=>mYt,content_2241_5286:()=>hYt,content_2241_5288:()=>yYt,content_2241_5290:()=>wYt,content_2241_5292:()=>DYt,content_2241_5294:()=>XYt,content_2241_5296:()=>xYt,content_2241_5298:()=>TYt,content_2241_530:()=>ab,content_2241_5300:()=>bYt,content_2241_5302:()=>ZYt,content_2241_5304:()=>SYt,content_2241_5306:()=>RYt,content_2241_5308:()=>AYt,content_2241_5310:()=>WYt,content_2241_5312:()=>FYt,content_2241_5314:()=>OYt,content_2241_5316:()=>jYt,content_2241_5318:()=>qYt,content_2241_532:()=>ub,content_2241_5320:()=>HYt,content_2241_5322:()=>QYt,content_2241_5324:()=>YYt,content_2241_5326:()=>tKt,content_2241_5328:()=>nKt,content_2241_5330:()=>sKt,content_2241_5332:()=>pKt,content_2241_5334:()=>cKt,content_2241_5336:()=>lKt,content_2241_5338:()=>mKt,content_2241_534:()=>db,content_2241_5340:()=>hKt,content_2241_5342:()=>yKt,content_2241_5344:()=>wKt,content_2241_5346:()=>DKt,content_2241_5348:()=>XKt,content_2241_5350:()=>xKt,content_2241_5352:()=>TKt,content_2241_5354:()=>bKt,content_2241_5356:()=>ZKt,content_2241_5358:()=>SKt,content_2241_536:()=>fb,content_2241_5360:()=>RKt,content_2241_5362:()=>AKt,content_2241_5364:()=>WKt,content_2241_5366:()=>FKt,content_2241_5368:()=>OKt,content_2241_5370:()=>jKt,content_2241_5372:()=>qKt,content_2241_5374:()=>HKt,content_2241_5376:()=>QKt,content_2241_5378:()=>YKt,content_2241_538:()=>kb,content_2241_5380:()=>t0t,content_2241_5382:()=>n0t,content_2241_5384:()=>s0t,content_2241_5386:()=>p0t,content_2241_5388:()=>c0t,content_2241_5390:()=>l0t,content_2241_5392:()=>m0t,content_2241_5394:()=>h0t,content_2241_5396:()=>y0t,content_2241_5398:()=>w0t,content_2241_54:()=>MM,content_2241_540:()=>Mb,content_2241_5400:()=>D0t,content_2241_5402:()=>X0t,content_2241_5404:()=>x0t,content_2241_5406:()=>T0t,content_2241_5408:()=>b0t,content_2241_5410:()=>Z0t,content_2241_5412:()=>S0t,content_2241_5414:()=>R0t,content_2241_5416:()=>A0t,content_2241_5418:()=>W0t,content_2241_542:()=>_b,content_2241_5420:()=>F0t,content_2241_5422:()=>O0t,content_2241_5424:()=>j0t,content_2241_5426:()=>q0t,content_2241_5428:()=>H0t,content_2241_5430:()=>Q0t,content_2241_5432:()=>Y0t,content_2241_5434:()=>t2t,content_2241_5436:()=>n2t,content_2241_5438:()=>s2t,content_2241_544:()=>gb,content_2241_5440:()=>p2t,content_2241_5442:()=>c2t,content_2241_5444:()=>l2t,content_2241_5446:()=>m2t,content_2241_5448:()=>h2t,content_2241_5450:()=>y2t,content_2241_5452:()=>w2t,content_2241_5454:()=>D2t,content_2241_5456:()=>X2t,content_2241_5458:()=>x2t,content_2241_546:()=>Cb,content_2241_5460:()=>T2t,content_2241_5462:()=>b2t,content_2241_5464:()=>Z2t,content_2241_5466:()=>S2t,content_2241_5468:()=>R2t,content_2241_5470:()=>A2t,content_2241_5472:()=>W2t,content_2241_5474:()=>F2t,content_2241_5476:()=>O2t,content_2241_5478:()=>j2t,content_2241_548:()=>vb,content_2241_5480:()=>q2t,content_2241_5482:()=>H2t,content_2241_5484:()=>Q2t,content_2241_5486:()=>Y2t,content_2241_5488:()=>t1t,content_2241_5490:()=>n1t,content_2241_5492:()=>s1t,content_2241_5494:()=>p1t,content_2241_5496:()=>c1t,content_2241_5498:()=>l1t,content_2241_550:()=>Lb,content_2241_5500:()=>m1t,content_2241_5502:()=>h1t,content_2241_5504:()=>y1t,content_2241_5506:()=>w1t,content_2241_5508:()=>D1t,content_2241_5510:()=>X1t,content_2241_5512:()=>x1t,content_2241_5514:()=>T1t,content_2241_5516:()=>b1t,content_2241_5518:()=>Z1t,content_2241_552:()=>Nb,content_2241_5520:()=>S1t,content_2241_5522:()=>R1t,content_2241_5524:()=>A1t,content_2241_5526:()=>W1t,content_2241_5528:()=>F1t,content_2241_5530:()=>O1t,content_2241_5532:()=>j1t,content_2241_5534:()=>q1t,content_2241_5536:()=>H1t,content_2241_5538:()=>Q1t,content_2241_554:()=>zb,content_2241_5540:()=>Y1t,content_2241_5542:()=>t4t,content_2241_5544:()=>n4t,content_2241_5546:()=>s4t,content_2241_5548:()=>p4t,content_2241_5550:()=>c4t,content_2241_5552:()=>l4t,content_2241_5554:()=>m4t,content_2241_5556:()=>h4t,content_2241_5558:()=>y4t,content_2241_556:()=>Pb,content_2241_5560:()=>w4t,content_2241_5562:()=>D4t,content_2241_5564:()=>X4t,content_2241_5566:()=>x4t,content_2241_5568:()=>T4t,content_2241_5570:()=>b4t,content_2241_5572:()=>Z4t,content_2241_5574:()=>S4t,content_2241_5576:()=>R4t,content_2241_5578:()=>A4t,content_2241_558:()=>Ib,content_2241_5580:()=>W4t,content_2241_5582:()=>F4t,content_2241_5584:()=>O4t,content_2241_5586:()=>j4t,content_2241_5588:()=>q4t,content_2241_5590:()=>H4t,content_2241_5592:()=>Q4t,content_2241_5594:()=>Y4t,content_2241_5596:()=>t6t,content_2241_5598:()=>n6t,content_2241_56:()=>_M,content_2241_560:()=>Eb,content_2241_5600:()=>s6t,content_2241_5602:()=>p6t,content_2241_5604:()=>c6t,content_2241_5606:()=>l6t,content_2241_5608:()=>m6t,content_2241_5610:()=>h6t,content_2241_5612:()=>y6t,content_2241_5614:()=>w6t,content_2241_5616:()=>D6t,content_2241_5618:()=>X6t,content_2241_562:()=>Bb,content_2241_5620:()=>x6t,content_2241_5622:()=>T6t,content_2241_5624:()=>b6t,content_2241_5626:()=>Z6t,content_2241_5628:()=>S6t,content_2241_5630:()=>R6t,content_2241_5632:()=>A6t,content_2241_5634:()=>W6t,content_2241_5636:()=>F6t,content_2241_5638:()=>O6t,content_2241_564:()=>Gb,content_2241_5640:()=>j6t,content_2241_5642:()=>q6t,content_2241_5644:()=>H6t,content_2241_5646:()=>Q6t,content_2241_5648:()=>Y6t,content_2241_5650:()=>t3t,content_2241_5652:()=>n3t,content_2241_5654:()=>s3t,content_2241_5656:()=>p3t,content_2241_5658:()=>c3t,content_2241_566:()=>Ub,content_2241_5660:()=>l3t,content_2241_5662:()=>m3t,content_2241_5664:()=>h3t,content_2241_5666:()=>y3t,content_2241_5668:()=>w3t,content_2241_5670:()=>D3t,content_2241_5672:()=>X3t,content_2241_5674:()=>x3t,content_2241_5676:()=>T3t,content_2241_5678:()=>b3t,content_2241_568:()=>Vb,content_2241_5680:()=>Z3t,content_2241_5682:()=>S3t,content_2241_5684:()=>R3t,content_2241_5686:()=>A3t,content_2241_5688:()=>W3t,content_2241_5690:()=>F3t,content_2241_5692:()=>O3t,content_2241_5694:()=>j3t,content_2241_5696:()=>q3t,content_2241_5698:()=>H3t,content_2241_570:()=>$b,content_2241_5700:()=>Q3t,content_2241_5702:()=>Y3t,content_2241_5704:()=>t8t,content_2241_5706:()=>n8t,content_2241_5708:()=>s8t,content_2241_5710:()=>p8t,content_2241_5712:()=>c8t,content_2241_5714:()=>l8t,content_2241_5716:()=>m8t,content_2241_5718:()=>h8t,content_2241_572:()=>Jb,content_2241_5720:()=>y8t,content_2241_5722:()=>w8t,content_2241_5724:()=>D8t,content_2241_5726:()=>X8t,content_2241_5728:()=>x8t,content_2241_5730:()=>T8t,content_2241_5732:()=>b8t,content_2241_5734:()=>Z8t,content_2241_5736:()=>S8t,content_2241_5738:()=>R8t,content_2241_574:()=>Kb,content_2241_5740:()=>A8t,content_2241_5742:()=>W8t,content_2241_5744:()=>F8t,content_2241_5746:()=>O8t,content_2241_5748:()=>j8t,content_2241_5750:()=>q8t,content_2241_5752:()=>H8t,content_2241_5754:()=>Q8t,content_2241_5756:()=>Y8t,content_2241_5758:()=>t5t,content_2241_576:()=>eL,content_2241_5760:()=>n5t,content_2241_5762:()=>s5t,content_2241_5764:()=>p5t,content_2241_5766:()=>c5t,content_2241_5768:()=>l5t,content_2241_5770:()=>m5t,content_2241_5772:()=>h5t,content_2241_5774:()=>y5t,content_2241_5776:()=>w5t,content_2241_5778:()=>D5t,content_2241_578:()=>oL,content_2241_5780:()=>X5t,content_2241_5782:()=>x5t,content_2241_5784:()=>T5t,content_2241_5786:()=>b5t,content_2241_5788:()=>Z5t,content_2241_5790:()=>S5t,content_2241_5792:()=>R5t,content_2241_5794:()=>A5t,content_2241_5796:()=>W5t,content_2241_5798:()=>F5t,content_2241_58:()=>gM,content_2241_580:()=>rL,content_2241_5800:()=>O5t,content_2241_5802:()=>j5t,content_2241_5804:()=>q5t,content_2241_5806:()=>H5t,content_2241_5808:()=>Q5t,content_2241_5810:()=>Y5t,content_2241_5812:()=>t7t,content_2241_5814:()=>n7t,content_2241_5816:()=>s7t,content_2241_5818:()=>p7t,content_2241_582:()=>iL,content_2241_5820:()=>c7t,content_2241_5822:()=>l7t,content_2241_5824:()=>m7t,content_2241_5826:()=>h7t,content_2241_5828:()=>y7t,content_2241_5830:()=>w7t,content_2241_5832:()=>D7t,content_2241_5834:()=>X7t,content_2241_5836:()=>x7t,content_2241_5838:()=>T7t,content_2241_584:()=>aL,content_2241_5840:()=>b7t,content_2241_5842:()=>Z7t,content_2241_5844:()=>S7t,content_2241_5846:()=>R7t,content_2241_5848:()=>A7t,content_2241_5850:()=>W7t,content_2241_5852:()=>F7t,content_2241_5854:()=>O7t,content_2241_5856:()=>j7t,content_2241_5858:()=>q7t,content_2241_586:()=>uL,content_2241_5860:()=>H7t,content_2241_5862:()=>Q7t,content_2241_5864:()=>Y7t,content_2241_5866:()=>t9t,content_2241_5868:()=>n9t,content_2241_5870:()=>s9t,content_2241_5872:()=>p9t,content_2241_5874:()=>c9t,content_2241_5876:()=>l9t,content_2241_5878:()=>m9t,content_2241_588:()=>dL,content_2241_5880:()=>h9t,content_2241_5882:()=>y9t,content_2241_5884:()=>w9t,content_2241_5886:()=>D9t,content_2241_5888:()=>X9t,content_2241_5890:()=>x9t,content_2241_5892:()=>T9t,content_2241_5894:()=>b9t,content_2241_5896:()=>Z9t,content_2241_5898:()=>S9t,content_2241_590:()=>fL,content_2241_5900:()=>R9t,content_2241_5902:()=>A9t,content_2241_5904:()=>W9t,content_2241_5906:()=>F9t,content_2241_5908:()=>O9t,content_2241_5910:()=>j9t,content_2241_5912:()=>q9t,content_2241_5914:()=>H9t,content_2241_5916:()=>Q9t,content_2241_5918:()=>Y9t,content_2241_592:()=>kL,content_2241_5920:()=>tte,content_2241_5922:()=>nte,content_2241_5924:()=>ste,content_2241_5926:()=>pte,content_2241_5928:()=>cte,content_2241_5930:()=>lte,content_2241_5932:()=>mte,content_2241_5934:()=>hte,content_2241_5936:()=>yte,content_2241_5938:()=>wte,content_2241_594:()=>ML,content_2241_5940:()=>Dte,content_2241_5942:()=>Xte,content_2241_5944:()=>xte,content_2241_5946:()=>Tte,content_2241_5948:()=>bte,content_2241_5950:()=>Zte,content_2241_5952:()=>Ste,content_2241_5954:()=>Rte,content_2241_5956:()=>Ate,content_2241_5958:()=>Wte,content_2241_596:()=>_L,content_2241_5960:()=>Fte,content_2241_5962:()=>Ote,content_2241_5964:()=>jte,content_2241_5966:()=>qte,content_2241_5968:()=>Hte,content_2241_5970:()=>Qte,content_2241_5972:()=>Yte,content_2241_5974:()=>tee,content_2241_5976:()=>nee,content_2241_5978:()=>see,content_2241_598:()=>gL,content_2241_5980:()=>pee,content_2241_5982:()=>cee,content_2241_5984:()=>lee,content_2241_5986:()=>mee,content_2241_5988:()=>hee,content_2241_5990:()=>yee,content_2241_5992:()=>wee,content_2241_5994:()=>Dee,content_2241_5996:()=>Xee,content_2241_5998:()=>xee,content_2241_6:()=>Cw,content_2241_60:()=>CM,content_2241_600:()=>CL,content_2241_6000:()=>Tee,content_2241_6002:()=>bee,content_2241_6004:()=>Zee,content_2241_6006:()=>See,content_2241_6008:()=>Ree,content_2241_6010:()=>Aee,content_2241_6012:()=>Wee,content_2241_6014:()=>Fee,content_2241_6016:()=>Oee,content_2241_6018:()=>jee,content_2241_602:()=>vL,content_2241_6020:()=>qee,content_2241_6022:()=>Hee,content_2241_6024:()=>Qee,content_2241_6026:()=>Yee,content_2241_6028:()=>tne,content_2241_6030:()=>nne,content_2241_6032:()=>sne,content_2241_6034:()=>pne,content_2241_6036:()=>cne,content_2241_6038:()=>lne,content_2241_604:()=>LL,content_2241_6040:()=>mne,content_2241_6042:()=>hne,content_2241_6044:()=>yne,content_2241_6046:()=>wne,content_2241_6048:()=>Dne,content_2241_6050:()=>Xne,content_2241_6052:()=>xne,content_2241_6054:()=>Tne,content_2241_6056:()=>bne,content_2241_6058:()=>Zne,content_2241_606:()=>NL,content_2241_6060:()=>Sne,content_2241_6062:()=>Rne,content_2241_6064:()=>Ane,content_2241_6066:()=>Wne,content_2241_6068:()=>Fne,content_2241_6070:()=>One,content_2241_6072:()=>jne,content_2241_6074:()=>qne,content_2241_6076:()=>Hne,content_2241_6078:()=>Qne,content_2241_608:()=>zL,content_2241_6080:()=>Yne,content_2241_6082:()=>toe,content_2241_6084:()=>noe,content_2241_6086:()=>soe,content_2241_6088:()=>poe,content_2241_6090:()=>coe,content_2241_6092:()=>loe,content_2241_6094:()=>moe,content_2241_6096:()=>hoe,content_2241_6098:()=>yoe,content_2241_610:()=>PL,content_2241_6100:()=>woe,content_2241_6102:()=>Doe,content_2241_6104:()=>Xoe,content_2241_6106:()=>xoe,content_2241_6108:()=>Toe,content_2241_6110:()=>boe,content_2241_6112:()=>Zoe,content_2241_6114:()=>Soe,content_2241_6116:()=>Roe,content_2241_6118:()=>Aoe,content_2241_612:()=>IL,content_2241_6120:()=>Woe,content_2241_6122:()=>Foe,content_2241_6124:()=>Ooe,content_2241_6126:()=>joe,content_2241_6128:()=>qoe,content_2241_6130:()=>Hoe,content_2241_6132:()=>Qoe,content_2241_6134:()=>Yoe,content_2241_6136:()=>tse,content_2241_6138:()=>nse,content_2241_614:()=>EL,content_2241_6140:()=>sse,content_2241_6142:()=>pse,content_2241_6144:()=>cse,content_2241_6146:()=>lse,content_2241_6148:()=>mse,content_2241_6150:()=>hse,content_2241_6152:()=>yse,content_2241_6154:()=>wse,content_2241_6156:()=>Dse,content_2241_6158:()=>Xse,content_2241_616:()=>BL,content_2241_6160:()=>xse,content_2241_6162:()=>Tse,content_2241_6164:()=>bse,content_2241_6166:()=>Zse,content_2241_6168:()=>Sse,content_2241_6170:()=>Rse,content_2241_6172:()=>Ase,content_2241_6174:()=>Wse,content_2241_6176:()=>Fse,content_2241_6178:()=>Ose,content_2241_618:()=>GL,content_2241_6180:()=>jse,content_2241_6182:()=>qse,content_2241_6184:()=>Hse,content_2241_6186:()=>Qse,content_2241_6188:()=>Yse,content_2241_6190:()=>tre,content_2241_6192:()=>nre,content_2241_6194:()=>sre,content_2241_6196:()=>pre,content_2241_6198:()=>cre,content_2241_62:()=>vM,content_2241_620:()=>UL,content_2241_6200:()=>lre,content_2241_6202:()=>mre,content_2241_6204:()=>hre,content_2241_6206:()=>yre,content_2241_6208:()=>wre,content_2241_6210:()=>Dre,content_2241_6212:()=>Xre,content_2241_6214:()=>xre,content_2241_6216:()=>Tre,content_2241_6218:()=>bre,content_2241_622:()=>VL,content_2241_6220:()=>Zre,content_2241_6222:()=>Sre,content_2241_6224:()=>Rre,content_2241_6226:()=>Are,content_2241_6228:()=>Wre,content_2241_6230:()=>Fre,content_2241_6232:()=>Ore,content_2241_6234:()=>jre,content_2241_6236:()=>qre,content_2241_6238:()=>Hre,content_2241_624:()=>$L,content_2241_6240:()=>Qre,content_2241_6242:()=>Yre,content_2241_6244:()=>tpe,content_2241_6246:()=>npe,content_2241_6248:()=>spe,content_2241_6250:()=>ppe,content_2241_6252:()=>cpe,content_2241_6254:()=>lpe,content_2241_6256:()=>mpe,content_2241_6258:()=>hpe,content_2241_626:()=>JL,content_2241_6260:()=>ype,content_2241_6262:()=>wpe,content_2241_6264:()=>Dpe,content_2241_6266:()=>Xpe,content_2241_6268:()=>xpe,content_2241_6270:()=>Tpe,content_2241_6272:()=>bpe,content_2241_6274:()=>Zpe,content_2241_6276:()=>Spe,content_2241_6278:()=>Rpe,content_2241_628:()=>KL,content_2241_6280:()=>Ape,content_2241_6282:()=>Wpe,content_2241_6284:()=>Fpe,content_2241_6286:()=>Ope,content_2241_6288:()=>jpe,content_2241_6290:()=>qpe,content_2241_6292:()=>Hpe,content_2241_6294:()=>Qpe,content_2241_6296:()=>Ype,content_2241_6298:()=>tie,content_2241_630:()=>eZ,content_2241_6300:()=>nie,content_2241_6302:()=>sie,content_2241_6304:()=>pie,content_2241_6306:()=>cie,content_2241_6308:()=>lie,content_2241_6310:()=>mie,content_2241_6312:()=>hie,content_2241_6314:()=>yie,content_2241_6316:()=>wie,content_2241_6318:()=>Die,content_2241_632:()=>oZ,content_2241_6320:()=>Xie,content_2241_6322:()=>xie,content_2241_6324:()=>Tie,content_2241_6326:()=>bie,content_2241_6328:()=>Zie,content_2241_6330:()=>Sie,content_2241_6332:()=>Rie,content_2241_6334:()=>Aie,content_2241_6336:()=>Wie,content_2241_6338:()=>Fie,content_2241_634:()=>rZ,content_2241_6340:()=>Oie,content_2241_6342:()=>jie,content_2241_6344:()=>qie,content_2241_6346:()=>Hie,content_2241_6348:()=>Qie,content_2241_6350:()=>Yie,content_2241_6352:()=>tce,content_2241_6354:()=>nce,content_2241_6356:()=>sce,content_2241_6358:()=>pce,content_2241_636:()=>iZ,content_2241_6360:()=>cce,content_2241_6362:()=>lce,content_2241_6364:()=>mce,content_2241_6366:()=>hce,content_2241_6368:()=>yce,content_2241_6370:()=>wce,content_2241_6372:()=>Dce,content_2241_6374:()=>Xce,content_2241_6376:()=>xce,content_2241_6378:()=>Tce,content_2241_638:()=>aZ,content_2241_6380:()=>bce,content_2241_6382:()=>Zce,content_2241_6384:()=>Sce,content_2241_6386:()=>Rce,content_2241_6388:()=>Ace,content_2241_6390:()=>Wce,content_2241_6392:()=>Fce,content_2241_6394:()=>Oce,content_2241_6396:()=>jce,content_2241_6398:()=>qce,content_2241_64:()=>LM,content_2241_640:()=>uZ,content_2241_6400:()=>Hce,content_2241_6402:()=>Qce,content_2241_6404:()=>Yce,content_2241_6406:()=>tae,content_2241_6408:()=>nae,content_2241_6410:()=>sae,content_2241_6412:()=>pae,content_2241_6414:()=>cae,content_2241_6416:()=>lae,content_2241_6418:()=>mae,content_2241_642:()=>dZ,content_2241_6420:()=>hae,content_2241_6422:()=>yae,content_2241_6424:()=>wae,content_2241_6426:()=>Dae,content_2241_6428:()=>Xae,content_2241_6430:()=>xae,content_2241_6432:()=>Tae,content_2241_6434:()=>bae,content_2241_6436:()=>Zae,content_2241_6438:()=>Sae,content_2241_644:()=>fZ,content_2241_6440:()=>Rae,content_2241_6442:()=>Aae,content_2241_6444:()=>Wae,content_2241_6446:()=>Fae,content_2241_6448:()=>Oae,content_2241_6450:()=>jae,content_2241_6452:()=>qae,content_2241_6454:()=>Hae,content_2241_6456:()=>Qae,content_2241_6458:()=>Yae,content_2241_646:()=>kZ,content_2241_6460:()=>tle,content_2241_6462:()=>nle,content_2241_6464:()=>sle,content_2241_6466:()=>ple,content_2241_6468:()=>cle,content_2241_6470:()=>lle,content_2241_6472:()=>mle,content_2241_6474:()=>hle,content_2241_6476:()=>yle,content_2241_6478:()=>wle,content_2241_648:()=>MZ,content_2241_6480:()=>Dle,content_2241_6482:()=>Xle,content_2241_6484:()=>xle,content_2241_6486:()=>Tle,content_2241_6488:()=>ble,content_2241_6490:()=>Zle,content_2241_6492:()=>Sle,content_2241_6494:()=>Rle,content_2241_6496:()=>Ale,content_2241_6498:()=>Wle,content_2241_650:()=>_Z,content_2241_6500:()=>Fle,content_2241_6502:()=>Ole,content_2241_6504:()=>jle,content_2241_6506:()=>qle,content_2241_6508:()=>Hle,content_2241_6510:()=>Qle,content_2241_6512:()=>Yle,content_2241_6514:()=>tue,content_2241_6516:()=>nue,content_2241_6518:()=>sue,content_2241_652:()=>gZ,content_2241_6520:()=>pue,content_2241_6522:()=>cue,content_2241_6524:()=>lue,content_2241_6526:()=>mue,content_2241_6528:()=>hue,content_2241_6530:()=>yue,content_2241_6532:()=>wue,content_2241_6534:()=>Due,content_2241_6536:()=>Xue,content_2241_6538:()=>xue,content_2241_654:()=>CZ,content_2241_6540:()=>Tue,content_2241_6542:()=>bue,content_2241_6544:()=>Zue,content_2241_6546:()=>Sue,content_2241_6548:()=>Rue,content_2241_6550:()=>Aue,content_2241_6552:()=>Wue,content_2241_6554:()=>Fue,content_2241_6556:()=>Oue,content_2241_6558:()=>jue,content_2241_656:()=>vZ,content_2241_6560:()=>que,content_2241_6562:()=>Hue,content_2241_6564:()=>Que,content_2241_6566:()=>Yue,content_2241_6568:()=>tme,content_2241_6570:()=>nme,content_2241_6572:()=>sme,content_2241_6574:()=>pme,content_2241_6576:()=>cme,content_2241_6578:()=>lme,content_2241_658:()=>LZ,content_2241_6580:()=>mme,content_2241_6582:()=>hme,content_2241_6584:()=>yme,content_2241_6586:()=>wme,content_2241_6588:()=>Dme,content_2241_6590:()=>Xme,content_2241_6592:()=>xme,content_2241_6594:()=>Tme,content_2241_6596:()=>bme,content_2241_6598:()=>Zme,content_2241_66:()=>NM,content_2241_660:()=>NZ,content_2241_6600:()=>Sme,content_2241_6602:()=>Rme,content_2241_6604:()=>Ame,content_2241_6606:()=>Wme,content_2241_6608:()=>Fme,content_2241_6610:()=>Ome,content_2241_6612:()=>jme,content_2241_6614:()=>qme,content_2241_6616:()=>Hme,content_2241_6618:()=>Qme,content_2241_662:()=>zZ,content_2241_6620:()=>Yme,content_2241_6622:()=>tde,content_2241_6624:()=>nde,content_2241_6626:()=>sde,content_2241_6628:()=>pde,content_2241_6630:()=>cde,content_2241_6632:()=>lde,content_2241_6634:()=>mde,content_2241_6636:()=>hde,content_2241_6638:()=>yde,content_2241_664:()=>PZ,content_2241_6640:()=>wde,content_2241_6642:()=>Dde,content_2241_6644:()=>Xde,content_2241_6646:()=>xde,content_2241_6648:()=>Tde,content_2241_6650:()=>bde,content_2241_6652:()=>Zde,content_2241_6654:()=>Sde,content_2241_6656:()=>Rde,content_2241_6658:()=>Ade,content_2241_666:()=>IZ,content_2241_6660:()=>Wde,content_2241_6662:()=>Fde,content_2241_6664:()=>Ode,content_2241_6666:()=>jde,content_2241_6668:()=>qde,content_2241_6670:()=>Hde,content_2241_6672:()=>Qde,content_2241_6674:()=>Yde,content_2241_6676:()=>the,content_2241_6678:()=>nhe,content_2241_668:()=>EZ,content_2241_6680:()=>she,content_2241_6682:()=>phe,content_2241_6684:()=>che,content_2241_6686:()=>lhe,content_2241_6688:()=>mhe,content_2241_6690:()=>hhe,content_2241_6692:()=>yhe,content_2241_6694:()=>whe,content_2241_6696:()=>Dhe,content_2241_6698:()=>Xhe,content_2241_670:()=>BZ,content_2241_6700:()=>xhe,content_2241_6702:()=>The,content_2241_6704:()=>bhe,content_2241_6706:()=>Zhe,content_2241_6708:()=>She,content_2241_6710:()=>Rhe,content_2241_6712:()=>Ahe,content_2241_6714:()=>Whe,content_2241_6716:()=>Fhe,content_2241_6718:()=>Ohe,content_2241_672:()=>GZ,content_2241_6720:()=>jhe,content_2241_6722:()=>qhe,content_2241_6724:()=>Hhe,content_2241_6726:()=>Qhe,content_2241_6728:()=>Yhe,content_2241_6730:()=>tfe,content_2241_6732:()=>nfe,content_2241_6734:()=>sfe,content_2241_6736:()=>pfe,content_2241_6738:()=>cfe,content_2241_674:()=>UZ,content_2241_6740:()=>lfe,content_2241_6742:()=>mfe,content_2241_6744:()=>hfe,content_2241_6746:()=>yfe,content_2241_6748:()=>wfe,content_2241_6750:()=>Dfe,content_2241_6752:()=>Xfe,content_2241_6754:()=>xfe,content_2241_6756:()=>Tfe,content_2241_6758:()=>bfe,content_2241_676:()=>VZ,content_2241_6760:()=>Zfe,content_2241_6762:()=>Sfe,content_2241_6764:()=>Rfe,content_2241_6766:()=>Afe,content_2241_6768:()=>Wfe,content_2241_6770:()=>Ffe,content_2241_6772:()=>Ofe,content_2241_6774:()=>jfe,content_2241_6776:()=>qfe,content_2241_6778:()=>Hfe,content_2241_678:()=>$Z,content_2241_6780:()=>Qfe,content_2241_6782:()=>Yfe,content_2241_6784:()=>tye,content_2241_6786:()=>nye,content_2241_6788:()=>sye,content_2241_6790:()=>pye,content_2241_6792:()=>cye,content_2241_6794:()=>lye,content_2241_6796:()=>mye,content_2241_6798:()=>hye,content_2241_68:()=>zM,content_2241_680:()=>JZ,content_2241_6800:()=>yye,content_2241_6802:()=>wye,content_2241_6804:()=>Dye,content_2241_6806:()=>Xye,content_2241_6808:()=>xye,content_2241_6810:()=>Tye,content_2241_6812:()=>bye,content_2241_6814:()=>Zye,content_2241_6816:()=>Sye,content_2241_6818:()=>Rye,content_2241_682:()=>KZ,content_2241_6820:()=>Aye,content_2241_6822:()=>Wye,content_2241_6824:()=>Fye,content_2241_6826:()=>Oye,content_2241_6828:()=>jye,content_2241_6830:()=>qye,content_2241_6832:()=>Hye,content_2241_6834:()=>Qye,content_2241_6836:()=>Yye,content_2241_6838:()=>tke,content_2241_684:()=>eN,content_2241_6840:()=>nke,content_2241_6842:()=>ske,content_2241_6844:()=>pke,content_2241_6846:()=>cke,content_2241_6848:()=>lke,content_2241_6850:()=>mke,content_2241_6852:()=>hke,content_2241_6854:()=>yke,content_2241_6856:()=>wke,content_2241_6858:()=>Dke,content_2241_686:()=>oN,content_2241_6860:()=>Xke,content_2241_6862:()=>xke,content_2241_6864:()=>Tke,content_2241_6866:()=>bke,content_2241_6868:()=>Zke,content_2241_6870:()=>Ske,content_2241_6872:()=>Rke,content_2241_6874:()=>Ake,content_2241_6876:()=>Wke,content_2241_6878:()=>Fke,content_2241_688:()=>rN,content_2241_6880:()=>Oke,content_2241_6882:()=>jke,content_2241_6884:()=>qke,content_2241_6886:()=>Hke,content_2241_6888:()=>Qke,content_2241_6890:()=>Yke,content_2241_6892:()=>twe,content_2241_6894:()=>nwe,content_2241_6896:()=>swe,content_2241_6898:()=>pwe,content_2241_690:()=>iN,content_2241_6900:()=>cwe,content_2241_6902:()=>lwe,content_2241_6904:()=>mwe,content_2241_6906:()=>hwe,content_2241_6908:()=>ywe,content_2241_6910:()=>wwe,content_2241_6912:()=>Dwe,content_2241_6914:()=>Xwe,content_2241_6916:()=>xwe,content_2241_6918:()=>Twe,content_2241_692:()=>aN,content_2241_6920:()=>bwe,content_2241_6922:()=>Zwe,content_2241_6924:()=>Swe,content_2241_6926:()=>Rwe,content_2241_6928:()=>Awe,content_2241_6930:()=>Wwe,content_2241_6932:()=>Fwe,content_2241_6934:()=>Owe,content_2241_6936:()=>jwe,content_2241_6938:()=>qwe,content_2241_694:()=>uN,content_2241_6940:()=>Hwe,content_2241_6942:()=>Qwe,content_2241_6944:()=>Ywe,content_2241_6946:()=>tMe,content_2241_6948:()=>nMe,content_2241_6950:()=>sMe,content_2241_6952:()=>pMe,content_2241_6954:()=>cMe,content_2241_6956:()=>lMe,content_2241_6958:()=>mMe,content_2241_696:()=>dN,content_2241_6960:()=>hMe,content_2241_6962:()=>yMe,content_2241_6964:()=>wMe,content_2241_6966:()=>DMe,content_2241_6968:()=>XMe,content_2241_6970:()=>xMe,content_2241_6972:()=>TMe,content_2241_6974:()=>bMe,content_2241_6976:()=>ZMe,content_2241_6978:()=>SMe,content_2241_698:()=>fN,content_2241_6980:()=>RMe,content_2241_6982:()=>AMe,content_2241_6984:()=>WMe,content_2241_6986:()=>FMe,content_2241_6988:()=>OMe,content_2241_6990:()=>jMe,content_2241_6992:()=>qMe,content_2241_6994:()=>HMe,content_2241_6996:()=>QMe,content_2241_6998:()=>YMe,content_2241_70:()=>PM,content_2241_700:()=>kN,content_2241_7000:()=>tDe,content_2241_7002:()=>nDe,content_2241_7004:()=>sDe,content_2241_7006:()=>pDe,content_2241_7008:()=>cDe,content_2241_7010:()=>lDe,content_2241_7012:()=>mDe,content_2241_7014:()=>hDe,content_2241_7016:()=>yDe,content_2241_7018:()=>wDe,content_2241_702:()=>MN,content_2241_7020:()=>DDe,content_2241_7022:()=>XDe,content_2241_7024:()=>xDe,content_2241_7026:()=>TDe,content_2241_7028:()=>bDe,content_2241_7030:()=>ZDe,content_2241_7032:()=>SDe,content_2241_7034:()=>RDe,content_2241_7036:()=>ADe,content_2241_7038:()=>WDe,content_2241_704:()=>_N,content_2241_7040:()=>FDe,content_2241_7042:()=>ODe,content_2241_7044:()=>jDe,content_2241_7046:()=>qDe,content_2241_7048:()=>HDe,content_2241_7050:()=>QDe,content_2241_7052:()=>YDe,content_2241_7054:()=>t_e,content_2241_7056:()=>n_e,content_2241_7058:()=>s_e,content_2241_706:()=>gN,content_2241_7060:()=>p_e,content_2241_7062:()=>c_e,content_2241_7064:()=>l_e,content_2241_7066:()=>m_e,content_2241_7068:()=>h_e,content_2241_7070:()=>y_e,content_2241_7072:()=>w_e,content_2241_7074:()=>D_e,content_2241_7076:()=>X_e,content_2241_7078:()=>x_e,content_2241_708:()=>CN,content_2241_7080:()=>T_e,content_2241_7082:()=>b_e,content_2241_7084:()=>Z_e,content_2241_7086:()=>S_e,content_2241_7088:()=>R_e,content_2241_7090:()=>A_e,content_2241_7092:()=>W_e,content_2241_7094:()=>F_e,content_2241_7096:()=>O_e,content_2241_7098:()=>j_e,content_2241_710:()=>vN,content_2241_7100:()=>q_e,content_2241_7102:()=>H_e,content_2241_712:()=>LN,content_2241_714:()=>NN,content_2241_716:()=>zN,content_2241_718:()=>PN,content_2241_72:()=>IM,content_2241_720:()=>IN,content_2241_722:()=>EN,content_2241_724:()=>BN,content_2241_726:()=>GN,content_2241_728:()=>UN,content_2241_730:()=>VN,content_2241_732:()=>$N,content_2241_734:()=>JN,content_2241_736:()=>KN,content_2241_738:()=>eS,content_2241_74:()=>EM,content_2241_740:()=>oS,content_2241_742:()=>rS,content_2241_744:()=>iS,content_2241_746:()=>aS,content_2241_748:()=>uS,content_2241_750:()=>dS,content_2241_752:()=>fS,content_2241_754:()=>kS,content_2241_756:()=>MS,content_2241_758:()=>_S,content_2241_76:()=>BM,content_2241_760:()=>gS,content_2241_762:()=>CS,content_2241_764:()=>vS,content_2241_766:()=>LS,content_2241_768:()=>NS,content_2241_770:()=>zS,content_2241_772:()=>PS,content_2241_774:()=>IS,content_2241_776:()=>ES,content_2241_778:()=>BS,content_2241_78:()=>GM,content_2241_780:()=>GS,content_2241_782:()=>US,content_2241_784:()=>VS,content_2241_786:()=>$S,content_2241_788:()=>JS,content_2241_790:()=>KS,content_2241_792:()=>ez,content_2241_794:()=>oz,content_2241_796:()=>rz,content_2241_798:()=>iz,content_2241_8:()=>vw,content_2241_80:()=>UM,content_2241_800:()=>az,content_2241_802:()=>uz,content_2241_804:()=>dz,content_2241_806:()=>fz,content_2241_808:()=>kz,content_2241_810:()=>Mz,content_2241_812:()=>_z,content_2241_814:()=>gz,content_2241_816:()=>Cz,content_2241_818:()=>vz,content_2241_82:()=>VM,content_2241_820:()=>Lz,content_2241_822:()=>Nz,content_2241_824:()=>zz,content_2241_826:()=>Pz,content_2241_828:()=>Iz,content_2241_830:()=>Ez,content_2241_832:()=>Bz,content_2241_834:()=>Gz,content_2241_836:()=>Uz,content_2241_838:()=>Vz,content_2241_84:()=>$M,content_2241_840:()=>$z,content_2241_842:()=>Jz,content_2241_844:()=>Kz,content_2241_846:()=>eR,content_2241_848:()=>oR,content_2241_850:()=>rR,content_2241_852:()=>iR,content_2241_854:()=>aR,content_2241_856:()=>uR,content_2241_858:()=>dR,content_2241_86:()=>JM,content_2241_860:()=>fR,content_2241_862:()=>kR,content_2241_864:()=>MR,content_2241_866:()=>_R,content_2241_868:()=>gR,content_2241_870:()=>CR,content_2241_872:()=>vR,content_2241_874:()=>LR,content_2241_876:()=>NR,content_2241_878:()=>zR,content_2241_88:()=>KM,content_2241_880:()=>PR,content_2241_882:()=>IR,content_2241_884:()=>ER,content_2241_886:()=>BR,content_2241_888:()=>GR,content_2241_890:()=>UR,content_2241_892:()=>VR,content_2241_894:()=>$R,content_2241_896:()=>JR,content_2241_898:()=>KR,content_2241_90:()=>eD,content_2241_900:()=>eP,content_2241_902:()=>oP,content_2241_904:()=>rP,content_2241_906:()=>iP,content_2241_908:()=>aP,content_2241_910:()=>uP,content_2241_912:()=>dP,content_2241_914:()=>fP,content_2241_916:()=>kP,content_2241_918:()=>MP,content_2241_92:()=>oD,content_2241_920:()=>_P,content_2241_922:()=>gP,content_2241_924:()=>CP,content_2241_926:()=>vP,content_2241_928:()=>LP,content_2241_930:()=>NP,content_2241_932:()=>zP,content_2241_934:()=>PP,content_2241_936:()=>IP,content_2241_938:()=>EP,content_2241_94:()=>rD,content_2241_940:()=>BP,content_2241_942:()=>GP,content_2241_944:()=>UP,content_2241_946:()=>VP,content_2241_948:()=>$P,content_2241_950:()=>JP,content_2241_952:()=>KP,content_2241_954:()=>eA,content_2241_956:()=>oA,content_2241_958:()=>rA,content_2241_96:()=>iD,content_2241_960:()=>iA,content_2241_962:()=>aA,content_2241_964:()=>uA,content_2241_966:()=>dA,content_2241_968:()=>fA,content_2241_970:()=>kA,content_2241_972:()=>MA,content_2241_974:()=>_A,content_2241_976:()=>gA,content_2241_978:()=>CA,content_2241_98:()=>aD,content_2241_980:()=>vA,content_2241_982:()=>LA,content_2241_984:()=>NA,content_2241_986:()=>zA,content_2241_988:()=>PA,content_2241_990:()=>IA,content_2241_992:()=>EA,content_2241_994:()=>BA,content_2241_996:()=>GA,content_2241_998:()=>UA});var s=n(2784),r=n(7896),p=n(30876);const i={toc:[]};function c(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},i,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Property decorators."))}c.isMDXComponent=!0;const a={toc:[]};function l(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},a,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,p.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a lazy decorator."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function that returns the value of this property."))}h.isMDXComponent=!0;const f={toc:[]};function y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},f,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscriptions and triggering of events."))}y.isMDXComponent=!0;const k={toc:[]};function w(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},k,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,p.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}w.isMDXComponent=!0;const M={toc:[]};function D(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},M,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}D.isMDXComponent=!0;const _={toc:[]};function X(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches an asynchronous ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}X.isMDXComponent=!0;const g={toc:[]};function x(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}x.isMDXComponent=!0;const C={toc:[]};function T(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},C,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}T.isMDXComponent=!0;const v={toc:[]};function b(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},v,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}b.isMDXComponent=!0;const L={toc:[]};function Z(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},L,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Z.isMDXComponent=!0;const N={toc:[]};function S(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},N,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}S.isMDXComponent=!0;const z={toc:[]};function R(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},z,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}R.isMDXComponent=!0;const P={toc:[]};function A(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},P,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}A.isMDXComponent=!0;const I={toc:[]};function W(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},I,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}W.isMDXComponent=!0;const E={toc:[]};function F(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},E,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}F.isMDXComponent=!0;const B={toc:[]};function O(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},B,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}O.isMDXComponent=!0;const G={toc:[]};function j(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},G,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}j.isMDXComponent=!0;const U={toc:[]};function q(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},U,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}q.isMDXComponent=!0;const V={toc:[]};function H(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},V,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}H.isMDXComponent=!0;const $={toc:[]};function Q(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Q.isMDXComponent=!0;const J={toc:[]};function Y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},J,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Y.isMDXComponent=!0;const K={toc:[]};function tt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},K,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value argument to subscribers."))}tt.isMDXComponent=!0;const et={toc:[]};function nt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},et,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A base for dispatching ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,p.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}nt.isMDXComponent=!0;const ot={toc:[]};function st(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}st.isMDXComponent=!0;const rt={toc:[]};function pt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}pt.isMDXComponent=!0;const it={toc:[]};function ct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},it,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}ct.isMDXComponent=!0;const at={toc:[]};function lt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},at,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}ht.isMDXComponent=!0;const ft={toc:[]};function yt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}yt.isMDXComponent=!0;const kt={toc:[]};function wt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}wt.isMDXComponent=!0;const Mt={toc:[]};function Dt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,p.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,p.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}Dt.isMDXComponent=!0;const _t={toc:[]};function Xt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}Xt.isMDXComponent=!0;const gt={toc:[]};function xt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}xt.isMDXComponent=!0;const Ct={toc:[]};function Tt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}Tt.isMDXComponent=!0;const vt={toc:[]};function bt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Are subscribers being notified?"))}bt.isMDXComponent=!0;const Lt={toc:[]};function Zt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Notify all current and future subscribers."))}Zt.isMDXComponent=!0;const Nt={toc:[]};function St(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Stop notifying future subscribers."))}St.isMDXComponent=!0;const zt={toc:[]};function Rt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}Rt.isMDXComponent=!0;const Pt={toc:[]};function At(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}At.isMDXComponent=!0;const It={toc:[]};function Wt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},It,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Wt.isMDXComponent=!0;const Et={toc:[]};function Ft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Et,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Ft.isMDXComponent=!0;const Bt={toc:[]};function Ot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Ot.isMDXComponent=!0;const Gt={toc:[]};function jt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}jt.isMDXComponent=!0;const Ut={toc:[]};function qt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}qt.isMDXComponent=!0;const Vt={toc:[]};function Ht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}Ht.isMDXComponent=!0;const $t={toc:[]};function Qt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}Qt.isMDXComponent=!0;const Jt={toc:[]};function Yt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Yt.isMDXComponent=!0;const Kt={toc:[]};function te(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}te.isMDXComponent=!0;const ee={toc:[]};function ne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}ne.isMDXComponent=!0;const oe={toc:[]};function se(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}se.isMDXComponent=!0;const re={toc:[]};function pe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},re,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}pe.isMDXComponent=!0;const ie={toc:[]};function ce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ce.isMDXComponent=!0;const ae={toc:[]};function le(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}le.isMDXComponent=!0;const ue={toc:[]};function me(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}me.isMDXComponent=!0;const de={toc:[]};function he(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},de,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}he.isMDXComponent=!0;const fe={toc:[]};function ye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}ye.isMDXComponent=!0;const ke={toc:[]};function we(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}we.isMDXComponent=!0;const Me={toc:[]};function De(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Me,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}De.isMDXComponent=!0;const _e={toc:[]};function Xe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}Xe.isMDXComponent=!0;const ge={toc:[]};function xe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}xe.isMDXComponent=!0;const Ce={toc:[]};function Te(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Te.isMDXComponent=!0;const ve={toc:[]};function be(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ve,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}be.isMDXComponent=!0;const Le={toc:[]};function Ze(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Le,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}Ze.isMDXComponent=!0;const Ne={toc:[]};function Se(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}Se.isMDXComponent=!0;const ze={toc:[]};function Re(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ze,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Re.isMDXComponent=!0;const Pe={toc:[]};function Ae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Ae.isMDXComponent=!0;const Ie={toc:[]};function We(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value."))}We.isMDXComponent=!0;const Ee={toc:[]};function Fe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}Fe.isMDXComponent=!0;const Be={toc:[]};function Oe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Be,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Setting the value will immediately notify all subscribers."))}Oe.isMDXComponent=!0;const Ge={toc:[]};function je(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set the current value of this dispatcher."))}je.isMDXComponent=!0;const Ue={toc:[]};function qe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new value."))}qe.isMDXComponent=!0;const Ve={toc:[]};function He(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ve,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}He.isMDXComponent=!0;const $e={toc:[]};function Qe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}Qe.isMDXComponent=!0;const Je={toc:[]};function Ye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Je,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ye.isMDXComponent=!0;const Ke={toc:[]};function tn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}tn.isMDXComponent=!0;const en={toc:[]};function nn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},en,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}nn.isMDXComponent=!0;const on={toc:[]};function sn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},on,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}sn.isMDXComponent=!0;const rn={toc:[]};function pn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}pn.isMDXComponent=!0;const cn={toc:[]};function an(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ln,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}dn.isMDXComponent=!0;const hn={toc:[]};function fn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}fn.isMDXComponent=!0;const yn={toc:[]};function kn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}kn.isMDXComponent=!0;const wn={toc:[]};function Mn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}Mn.isMDXComponent=!0;const Dn={toc:[]};function _n(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}_n.isMDXComponent=!0;const Xn={toc:[]};function gn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}gn.isMDXComponent=!0;const xn={toc:[]};function Cn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}Cn.isMDXComponent=!0;const Tn={toc:[]};function vn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}vn.isMDXComponent=!0;const bn={toc:[]};function Ln(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of times the timer has ticked."))}Ln.isMDXComponent=!0;const Zn={toc:[]};function Nn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator responsible for running this timer."))}Nn.isMDXComponent=!0;const Sn={toc:[]};function zn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the timer ticks."))}zn.isMDXComponent=!0;const Rn={toc:[]};function Pn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current iteration index."))}Pn.isMDXComponent=!0;const An={toc:[]};function In(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},An,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}In.isMDXComponent=!0;const Wn={toc:[]};function En(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}En.isMDXComponent=!0;const Fn={toc:[]};function Bn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Bn.isMDXComponent=!0;const On={toc:[]};function Gn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},On,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Gn.isMDXComponent=!0;const jn={toc:[]};function Un(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Un.isMDXComponent=!0;const qn={toc:[]};function Vn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Vn.isMDXComponent=!0;const Hn={toc:[]};function $n(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}$n.isMDXComponent=!0;const Qn={toc:[]};function Jn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run tasks one after another."))}Jn.isMDXComponent=!0;const Yn={toc:[]};function Kn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Kn.isMDXComponent=!0;const to={toc:[]};function eo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},to,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}eo.isMDXComponent=!0;const no={toc:[]};function oo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},no,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}oo.isMDXComponent=!0;const so={toc:[]};function ro(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},so,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay in seconds"))}ro.isMDXComponent=!0;const po={toc:[]};function io(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},po,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task or callback to run after the delay."))}io.isMDXComponent=!0;const co={toc:[]};function ao(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},co,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}ao.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Call the given callback every N seconds."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interval between subsequent calls."))}ho.isMDXComponent=!0;const fo={toc:[]};function yo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to be called."))}yo.isMDXComponent=!0;const ko={toc:[]};function wo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ko,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each iteration waits until the previous one is completed."))}wo.isMDXComponent=!0;const Mo={toc:[]};function Do(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}Do.isMDXComponent=!0;const _o={toc:[]};function Xo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_o,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator N times."))}Xo.isMDXComponent=!0;const go={toc:[]};function xo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},go,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The number of iterations."))}xo.isMDXComponent=!0;const Co={toc:[]};function To(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Co,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}To.isMDXComponent=!0;const vo={toc:[]};function bo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}bo.isMDXComponent=!0;const Lo={toc:[]};function Zo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Zo.isMDXComponent=!0;const No={toc:[]};function So(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},No,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run a generator in a loop for the given amount of time."))}So.isMDXComponent=!0;const zo={toc:[]};function Ro(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration in seconds."))}Ro.isMDXComponent=!0;const Po={toc:[]};function Ao(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Po,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Ao.isMDXComponent=!0;const Io={toc:[]};function Wo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Io,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Wo.isMDXComponent=!0;const Eo={toc:[]};function Fo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Fo.isMDXComponent=!0;const Bo={toc:[]};function Oo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run a generator in a loop until the given time event."))}Oo.isMDXComponent=!0;const Go={toc:[]};function jo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Go,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The event."))}jo.isMDXComponent=!0;const Uo={toc:[]};function qo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}qo.isMDXComponent=!0;const Vo={toc:[]};function Ho(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Do nothing."))}Ho.isMDXComponent=!0;const $o={toc:[]};function Qo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$o,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Qo.isMDXComponent=!0;const Jo={toc:[]};function Yo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}Yo.isMDXComponent=!0;const Ko={toc:[]};function ts(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ko,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}ts.isMDXComponent=!0;const es={toc:[]};function ns(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},es,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}ns.isMDXComponent=!0;const os={toc:[]};function ss(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},os,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}ss.isMDXComponent=!0;const rs={toc:[]};function ps(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional name used when displaying this generator in the UI."))}ps.isMDXComponent=!0;const is={toc:[]};function cs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},is,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}cs.isMDXComponent=!0;const as={toc:[]};function ls(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},as,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},us,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ds,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Start all tasks one after another with a constant delay between."))}hs.isMDXComponent=!0;const fs={toc:[]};function ys(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay between each of the tasks."))}ys.isMDXComponent=!0;const ks={toc:[]};function ws(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ks,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to be run in a sequence."))}ws.isMDXComponent=!0;const Ms={toc:[]};function Ds(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ms,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}Ds.isMDXComponent=!0;const _s={toc:[]};function Xs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_s,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for the given amount of time."))}Xs.isMDXComponent=!0;const gs={toc:[]};function xs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The relative time in seconds."))}xs.isMDXComponent=!0;const Cs={toc:[]};function Ts(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}Ts.isMDXComponent=!0;const vs={toc:[]};function bs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}bs.isMDXComponent=!0;const Ls={toc:[]};function Zs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ls,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}Zs.isMDXComponent=!0;const Ns={toc:[]};function Ss(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ns,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the given time event."))}Ss.isMDXComponent=!0;const zs={toc:[]};function Rs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the time event."))}Rs.isMDXComponent=!0;const Ps={toc:[]};function As(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ps,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}As.isMDXComponent=!0;const Is={toc:[]};function Ws(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Is,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Multi-media management."))}Ws.isMDXComponent=!0;const Es={toc:[]};function Fs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Es,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Fs.isMDXComponent=!0;const Bs={toc:[]};function Os(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause/resume the audio."))}Os.isMDXComponent=!0;const Gs={toc:[]};function js(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the audio should be paused or resumed."))}js.isMDXComponent=!0;const Us={toc:[]};function qs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Us,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The absolute biggest value from the peaks array."))}qs.isMDXComponent=!0;const Vs={toc:[]};function Hs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of samples taken."))}Hs.isMDXComponent=!0;const $s={toc:[]};function Qs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$s,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Qs.isMDXComponent=!0;const Js={toc:[]};function Ys(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Js,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Samples per seconds."))}Ys.isMDXComponent=!0;const Ks={toc:[]};function tr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ks,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Abstract scene representations and related utilities."))}tr.isMDXComponent=!0;const er={toc:[]};function nr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},er,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Signifies the various stages of a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}nr.isMDXComponent=!0;const or={toc:[]};function sr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},or,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs after a render ends."))}sr.isMDXComponent=!0;const rr={toc:[]};function pr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}pr.isMDXComponent=!0;const ir={toc:[]};function cr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ir,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,p.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}cr.isMDXComponent=!0;const ar={toc:[]};function lr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ar,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,p.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ur,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes the state of a scene."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}hr.isMDXComponent=!0;const fr={toc:[]};function yr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished transitioning in."))}yr.isMDXComponent=!0;const kr={toc:[]};function wr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}wr.isMDXComponent=!0;const Mr={toc:[]};function Dr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene is ready to transition out."))}Dr.isMDXComponent=!0;const _r={toc:[]};function Xr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_r,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoking ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}Xr.isMDXComponent=!0;const gr={toc:[]};function xr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished."))}xr.isMDXComponent=!0;const Cr={toc:[]};function Tr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has just been created/reset."))}Tr.isMDXComponent=!0;const vr={toc:[]};function br(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The default implementation of the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,p.kt)("p",null,"Uses generators to control the animation."))}br.isMDXComponent=!0;const Lr={toc:[]};function Zr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}Zr.isMDXComponent=!0;const Nr={toc:[]};function Sr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}Sr.isMDXComponent=!0;const zr={toc:[]};function Rr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}Rr.isMDXComponent=!0;const Pr={toc:[]};function Ar(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,p.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Ar.isMDXComponent=!0;const Ir={toc:[]};function Wr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ir,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,p.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Wr.isMDXComponent=!0;const Er={toc:[]};function Fr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Er,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}Fr.isMDXComponent=!0;const Br={toc:[]};function Or(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Br,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}Or.isMDXComponent=!0;const Gr={toc:[]};function jr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}jr.isMDXComponent=!0;const Ur={toc:[]};function qr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ur,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}qr.isMDXComponent=!0;const Vr={toc:[]};function Hr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}Hr.isMDXComponent=!0;const $r={toc:[]};function Qr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$r,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Qr.isMDXComponent=!0;const Jr={toc:[]};function Yr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}Yr.isMDXComponent=!0;const Kr={toc:[]};function tp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}tp.isMDXComponent=!0;const ep={toc:[]};function np(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ep,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}np.isMDXComponent=!0;const op={toc:[]};function sp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},op,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}sp.isMDXComponent=!0;const rp={toc:[]};function pp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}pp.isMDXComponent=!0;const ip={toc:[]};function cp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ip,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}cp.isMDXComponent=!0;const ap={toc:[]};function lp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ap,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,p.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},up,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoke the given callback in the context of this scene."))}hp.isMDXComponent=!0;const fp={toc:[]};function yp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to invoke."))}yp.isMDXComponent=!0;const kp={toc:[]};function wp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}wp.isMDXComponent=!0;const Mp={toc:[]};function Dp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}Dp.isMDXComponent=!0;const _p={toc:[]};function Xp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_p,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}Xp.isMDXComponent=!0;const gp={toc:[]};function xp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}xp.isMDXComponent=!0;const Cp={toc:[]};function Tp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}Tp.isMDXComponent=!0;const vp={toc:[]};function bp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}bp.isMDXComponent=!0;const Lp={toc:[]};function Zp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}Zp.isMDXComponent=!0;const Np={toc:[]};function Sp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Np,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}Sp.isMDXComponent=!0;const zp={toc:[]};function Rp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}Rp.isMDXComponent=!0;const Pp={toc:[]};function Ap(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, an updated version of the description."))}Ap.isMDXComponent=!0;const Ip={toc:[]};function Wp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ip,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}Wp.isMDXComponent=!0;const Ep={toc:[]};function Fp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ep,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}Fp.isMDXComponent=!0;const Bp={toc:[]};function Op(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}Op.isMDXComponent=!0;const Gp={toc:[]};function jp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}jp.isMDXComponent=!0;const Up={toc:[]};function qp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Up,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}qp.isMDXComponent=!0;const Vp={toc:[]};function Hp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Lifecycle events for ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Hp.isMDXComponent=!0;const $p={toc:[]};function Qp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$p,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A random number generator based on\n",(0,p.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,p.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Qp.isMDXComponent=!0;const Jp={toc:[]};function Yp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get an array filled with random floats in the given range."))}Yp.isMDXComponent=!0;const Kp={toc:[]};function ti(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The size of the array."))}ti.isMDXComponent=!0;const ei={toc:[]};function ni(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ei,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}ni.isMDXComponent=!0;const oi={toc:[]};function si(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range."))}si.isMDXComponent=!0;const ri={toc:[]};function pi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ri,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get an array filled with random integers in the given range."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"}),(0,p.kt)("li",{parentName:"ul"})))}pi.isMDXComponent=!0;const ii={toc:[]};function ci(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ii,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The size of the array."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}ci.isMDXComponent=!0;const ai={toc:[]};function li(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ai,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ui,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. Exclusive."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},di,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the next random float in the given range."))}hi.isMDXComponent=!0;const fi={toc:[]};function yi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}yi.isMDXComponent=!0;const ki={toc:[]};function wi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ki,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range."))}wi.isMDXComponent=!0;const Mi={toc:[]};function Di(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the next random integer in the given range."))}Di.isMDXComponent=!0;const _i={toc:[]};function Xi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_i,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}Xi.isMDXComponent=!0;const gi={toc:[]};function xi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. Exclusive."))}xi.isMDXComponent=!0;const Ci={toc:[]};function Ti(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ci,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a new independent generator."))}Ti.isMDXComponent=!0;const vi={toc:[]};function bi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get variable signal if exists or create signal if not"))}bi.isMDXComponent=!0;const Li={toc:[]};function Zi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Li,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the variable."))}Zi.isMDXComponent=!0;const Ni={toc:[]};function Si(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ni,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}Si.isMDXComponent=!0;const zi={toc:[]};function Ri(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get variable signal if exists or create signal if not"))}Ri.isMDXComponent=!0;const Pi={toc:[]};function Ai(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset all stored signals."))}Ai.isMDXComponent=!0;const Ii={toc:[]};function Wi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ii,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update all signals with new project variable values."))}Wi.isMDXComponent=!0;const Ei={toc:[]};function Fi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ei,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes cached information about the timing of a scene."))}Fi.isMDXComponent=!0;const Bi={toc:[]};function Oi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes a complete scene together with the meta file."))}Oi.isMDXComponent=!0;const Gi={toc:[]};function ji(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Configuration object."))}ji.isMDXComponent=!0;const Ui={toc:[]};function qi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ui,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The class used to instantiate the scene."))}qi.isMDXComponent=!0;const Vi={toc:[]};function Hi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The stack trace at the moment of creation."))}Hi.isMDXComponent=!0;const $i={toc:[]};function Qi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$i,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Qi.isMDXComponent=!0;const Ji={toc:[]};function Yi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ji,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Yi.isMDXComponent=!0;const Ki={toc:[]};function tc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ki,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}tc.isMDXComponent=!0;const ec={toc:[]};function nc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ec,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for the inspected element."))}nc.isMDXComponent=!0;const oc={toc:[]};function sc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element for which to draw an overlay."))}sc.isMDXComponent=!0;const rc={toc:[]};function pc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}pc.isMDXComponent=!0;const ic={toc:[]};function cc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ic,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}cc.isMDXComponent=!0;const ac={toc:[]};function lc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ac,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the attributes of the inspected element."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to inspect."))}hc.isMDXComponent=!0;const fc={toc:[]};function yc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a possible element to inspect at a given position."))}yc.isMDXComponent=!0;const kc={toc:[]};function wc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The x coordinate."))}wc.isMDXComponent=!0;const Mc={toc:[]};function Dc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The y coordinate."))}Dc.isMDXComponent=!0;const _c={toc:[]};function Xc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_c,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}Xc.isMDXComponent=!0;const gc={toc:[]};function xc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the inspected element is still valid."))}xc.isMDXComponent=!0;const Cc={toc:[]};function Tc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to validate."))}Tc.isMDXComponent=!0;const vc={toc:[]};function bc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,p.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}bc.isMDXComponent=!0;const Lc={toc:[]};function Zc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main interface for scenes."))}Zc.isMDXComponent=!0;const Nc={toc:[]};function Sc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}Sc.isMDXComponent=!0;const zc={toc:[]};function Rc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}Rc.isMDXComponent=!0;const Pc={toc:[]};function Ac(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}Ac.isMDXComponent=!0;const Ic={toc:[]};function Wc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ic,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,p.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Wc.isMDXComponent=!0;const Ec={toc:[]};function Fc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ec,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,p.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Fc.isMDXComponent=!0;const Bc={toc:[]};function Oc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}Oc.isMDXComponent=!0;const Gc={toc:[]};function jc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}jc.isMDXComponent=!0;const Uc={toc:[]};function qc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,p.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}qc.isMDXComponent=!0;const Vc={toc:[]};function Hc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}Hc.isMDXComponent=!0;const $c={toc:[]};function Qc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$c,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}Qc.isMDXComponent=!0;const Jc={toc:[]};function Yc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}Yc.isMDXComponent=!0;const Kc={toc:[]};function ta(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}ta.isMDXComponent=!0;const ea={toc:[]};function na(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ea,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}na.isMDXComponent=!0;const oa={toc:[]};function sa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}sa.isMDXComponent=!0;const ra={toc:[]};function pa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ra,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}pa.isMDXComponent=!0;const ia={toc:[]};function ca(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ia,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}ca.isMDXComponent=!0;const aa={toc:[]};function la(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ua,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,p.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},da,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}ha.isMDXComponent=!0;const fa={toc:[]};function ya(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}ya.isMDXComponent=!0;const ka={toc:[]};function wa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ka,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}wa.isMDXComponent=!0;const Ma={toc:[]};function Da(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ma,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}Da.isMDXComponent=!0;const _a={toc:[]};function Xa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_a,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}Xa.isMDXComponent=!0;const ga={toc:[]};function xa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ga,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}xa.isMDXComponent=!0;const Ca={toc:[]};function Ta(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ca,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}Ta.isMDXComponent=!0;const va={toc:[]};function ba(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},va,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}ba.isMDXComponent=!0;const La={toc:[]};function Za(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},La,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}Za.isMDXComponent=!0;const Na={toc:[]};function Sa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Na,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, an updated version of the description."))}Sa.isMDXComponent=!0;const za={toc:[]};function Ra(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},za,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}Ra.isMDXComponent=!0;const Pa={toc:[]};function Aa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}Aa.isMDXComponent=!0;const Ia={toc:[]};function Wa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ia,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}Wa.isMDXComponent=!0;const Ea={toc:[]};function Fa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ea,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}Fa.isMDXComponent=!0;const Ba={toc:[]};function Oa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ba,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Oa.isMDXComponent=!0;const Ga={toc:[]};function ja(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ga,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each class implementing the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}ja.isMDXComponent=!0;const Ua={toc:[]};function qa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ua,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constructor used when creating new scenes."))}qa.isMDXComponent=!0;const Va={toc:[]};function Ha(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Va,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,p.kt)("inlineCode",{parentName:"a"},"config")),"."))}Ha.isMDXComponent=!0;const $a={toc:[]};function Qa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$a,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes a scene exposed by scene files."))}Qa.isMDXComponent=!0;const Ja={toc:[]};function Ya(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ja,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Configuration object."))}Ya.isMDXComponent=!0;const Ka={toc:[]};function tl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ka,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The class used to instantiate the scene."))}tl.isMDXComponent=!0;const el={toc:[]};function nl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},el,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The stack trace at the moment of creation."))}nl.isMDXComponent=!0;const ol={toc:[]};function sl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ol,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}sl.isMDXComponent=!0;const rl={toc:[]};function pl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A part of the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,p.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}pl.isMDXComponent=!0;const il={toc:[]};function cl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},il,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}cl.isMDXComponent=!0;const al={toc:[]};function ll(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},al,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ul,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}hl.isMDXComponent=!0;const fl={toc:[]};function yl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents attributes of an inspected element."))}yl.isMDXComponent=!0;const kl={toc:[]};function wl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}wl.isMDXComponent=!0;const Ml={toc:[]};function Dl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ml,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents an element to inspect."))}Dl.isMDXComponent=!0;const _l={toc:[]};function Xl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_l,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A runtime representation of the scene metadata."))}Xl.isMDXComponent=!0;const gl={toc:[]};function xl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a runtime representation of the scene metadata."))}xl.isMDXComponent=!0;const Cl={toc:[]};function Tl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}Tl.isMDXComponent=!0;const vl={toc:[]};function bl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}bl.isMDXComponent=!0;const Ll={toc:[]};function Zl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ll,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the signal is currently using its initial value."))}Zl.isMDXComponent=!0;const Nl={toc:[]};function Sl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}Sl.isMDXComponent=!0;const zl={toc:[]};function Rl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Rl.isMDXComponent=!0;const Pl={toc:[]};function Al(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}Al.isMDXComponent=!0;const Il={toc:[]};function Wl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Il,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Wl.isMDXComponent=!0;const El={toc:[]};function Fl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},El,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Fl.isMDXComponent=!0;const Bl={toc:[]};function Ol(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Ol.isMDXComponent=!0;const Gl={toc:[]};function jl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}jl.isMDXComponent=!0;const Ul={toc:[]};function ql(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ul,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}ql.isMDXComponent=!0;const Vl={toc:[]};function Hl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}Hl.isMDXComponent=!0;const $l={toc:[]};function Ql(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$l,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the signal is currently using its initial value."))}Ql.isMDXComponent=!0;const Jl={toc:[]};function Yl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}Yl.isMDXComponent=!0;const Kl={toc:[]};function tu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}tu.isMDXComponent=!0;const eu={toc:[]};function nu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}nu.isMDXComponent=!0;const ou={toc:[]};function su(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ou,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}su.isMDXComponent=!0;const ru={toc:[]};function pu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ru,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}pu.isMDXComponent=!0;const iu={toc:[]};function cu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}cu.isMDXComponent=!0;const au={toc:[]};function lu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},au,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},du,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the signal is currently using its initial value."))}hu.isMDXComponent=!0;const fu={toc:[]};function yu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}yu.isMDXComponent=!0;const ku={toc:[]};function wu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ku,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}wu.isMDXComponent=!0;const Mu={toc:[]};function Du(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Du.isMDXComponent=!0;const _u={toc:[]};function Xu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_u,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Tween back to the original value."))}Xu.isMDXComponent=!0;const gu={toc:[]};function xu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the tween."))}xu.isMDXComponent=!0;const Cu={toc:[]};function Tu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function of the tween."))}Tu.isMDXComponent=!0;const vu={toc:[]};function bu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interpolation function of the tween."))}bu.isMDXComponent=!0;const Lu={toc:[]};function Zu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoke the given callback."))}Zu.isMDXComponent=!0;const Nu={toc:[]};function Su(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to invoke."))}Su.isMDXComponent=!0;const zu={toc:[]};function Ru(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given task."))}Ru.isMDXComponent=!0;const Pu={toc:[]};function Au(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator to run."))}Au.isMDXComponent=!0;const Iu={toc:[]};function Wu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Tween to the specified value."))}Wu.isMDXComponent=!0;const Eu={toc:[]};function Fu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for the specified duration."))}Fu.isMDXComponent=!0;const Bu={toc:[]};function Ou(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration to wait."))}Ou.isMDXComponent=!0;const Gu={toc:[]};function ju(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread management."))}ju.isMDXComponent=!0;const Uu={toc:[]};function qu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,p.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}qu.isMDXComponent=!0;const Vu={toc:[]};function Hu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A class representing an individual thread."))}Hu.isMDXComponent=!0;const $u={toc:[]};function Qu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$u,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}Qu.isMDXComponent=!0;const Ju={toc:[]};function Yu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ju,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}Yu.isMDXComponent=!0;const Ku={toc:[]};function tm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ku,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Used by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}tm.isMDXComponent=!0;const em={toc:[]};function nm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},em,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current time of this thread."))}nm.isMDXComponent=!0;const om={toc:[]};function sm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},om,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The next value to be passed to the wrapped generator."))}sm.isMDXComponent=!0;const rm={toc:[]};function pm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}pm.isMDXComponent=!0;const im={toc:[]};function cm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},im,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,p.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}cm.isMDXComponent=!0;const am={toc:[]};function lm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},am,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The fixed time of this thread."))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},um,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress the wrapped generator once."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the thread for the next update cycle."))}hm.isMDXComponent=!0;const fm={toc:[]};function ym(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delta time of the next cycle."))}ym.isMDXComponent=!0;const km={toc:[]};function wm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},km,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a normal function that returns a generator."))}wm.isMDXComponent=!0;const Mm={toc:[]};function Dm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,p.kt)("p",null,"Progress to the next frame:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,p.kt)("p",null,"Run another generator synchronously:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,p.kt)("p",null,"Run another generator concurrently:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,p.kt)("p",null,"Await a Promise:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}Dm.isMDXComponent=!0;const _m={toc:[]};function Xm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_m,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}Xm.isMDXComponent=!0;const gm={toc:[]};function xm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Cancel all listed tasks."),(0,p.kt)("p",null,"Example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}xm.isMDXComponent=!0;const Cm={toc:[]};function Tm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to cancel."))}Tm.isMDXComponent=!0;const vm={toc:[]};function bm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}bm.isMDXComponent=!0;const Lm={toc:[]};function Zm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}Zm.isMDXComponent=!0;const Nm={toc:[]};function Sm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Sm.isMDXComponent=!0;const zm={toc:[]};function Rm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible thread ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Rm.isMDXComponent=!0;const Pm={toc:[]};function Am(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}Am.isMDXComponent=!0;const Im={toc:[]};function Wm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Im,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}Wm.isMDXComponent=!0;const Em={toc:[]};function Fm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Em,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}Fm.isMDXComponent=!0;const Bm={toc:[]};function Om(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}Om.isMDXComponent=!0;const Gm={toc:[]};function jm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until listed tasks are finished."))}jm.isMDXComponent=!0;const Um={toc:[]};function qm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Um,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}qm.isMDXComponent=!0;const Vm={toc:[]};function Hm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}Hm.isMDXComponent=!0;const $m={toc:[]};function Qm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$m,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"From the perspective of the external generator, ",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}Qm.isMDXComponent=!0;const Jm={toc:[]};function Ym(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}Ym.isMDXComponent=!0;const Km={toc:[]};function td(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Km,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a context in which generators can be run concurrently."))}td.isMDXComponent=!0;const ed={toc:[]};function nd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ed,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function that returns the generator to run."))}nd.isMDXComponent=!0;const od={toc:[]};function sd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},od,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}sd.isMDXComponent=!0;const rd={toc:[]};function pd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Transitions between scenes."))}pd.isMDXComponent=!0;const id={toc:[]};function cd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},id,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Perform a transition that fades between the scenes."))}cd.isMDXComponent=!0;const ad={toc:[]};function ld(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ad,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ud,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The direction in which to slide."))}hd.isMDXComponent=!0;const fd={toc:[]};function yd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition."))}yd.isMDXComponent=!0;const kd={toc:[]};function wd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}wd.isMDXComponent=!0;const Md={toc:[]};function Dd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Md,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the current scene is rendered."))}Dd.isMDXComponent=!0;const _d={toc:[]};function Xd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_d,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the previous scene is rendered."))}Xd.isMDXComponent=!0;const gd={toc:[]};function xd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}xd.isMDXComponent=!0;const Cd={toc:[]};function Td(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The area on which to zoom in."))}Td.isMDXComponent=!0;const vd={toc:[]};function bd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition."))}bd.isMDXComponent=!0;const Ld={toc:[]};function Zd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ld,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}Zd.isMDXComponent=!0;const Nd={toc:[]};function Sd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The area from which to zoom out."))}Sd.isMDXComponent=!0;const zd={toc:[]};function Rd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition."))}Rd.isMDXComponent=!0;const Pd={toc:[]};function Ad(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolation and timing of tweens."))}Ad.isMDXComponent=!0;const Id={toc:[]};function Wd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Id,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any old key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,p.kt)("ol",null,(0,p.kt)("li",{parentName:"ol"})))}Wd.isMDXComponent=!0;const Ed={toc:[]};function Fd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ed,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}Fd.isMDXComponent=!0;const Bd={toc:[]};function Od(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}Od.isMDXComponent=!0;const Gd={toc:[]};function jd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}jd.isMDXComponent=!0;const Ud={toc:[]};function qd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ud,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}qd.isMDXComponent=!0;const Vd={toc:[]};function Hd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}Hd.isMDXComponent=!0;const $d={toc:[]};function Qd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$d,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}Qd.isMDXComponent=!0;const Jd={toc:[]};function Yd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}Yd.isMDXComponent=!0;const Kd={toc:[]};function th(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}th.isMDXComponent=!0;const eh={toc:[]};function nh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}nh.isMDXComponent=!0;const oh={toc:[]};function sh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}sh.isMDXComponent=!0;const rh={toc:[]};function ph(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Complex types used in animations."))}ph.isMDXComponent=!0;const ih={toc:[]};function ch(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ih,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,p.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,p.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,p.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,p.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,p.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,p.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}ch.isMDXComponent=!0;const ah={toc:[]};function lh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ah,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the determinant of the matrix."))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,p.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}hh.isMDXComponent=!0;const fh={toc:[]};function yh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the inverse of the matrix."))}yh.isMDXComponent=!0;const kh={toc:[]};function wh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}wh.isMDXComponent=!0;const Mh={toc:[]};function Dh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}Dh.isMDXComponent=!0;const _h={toc:[]};function Xh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_h,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the provided matrix to this matrix."))}Xh.isMDXComponent=!0;const gh={toc:[]};function xh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The matrix to add"))}xh.isMDXComponent=!0;const Ch={toc:[]};function Th(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ch,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}Th.isMDXComponent=!0;const vh={toc:[]};function bh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}bh.isMDXComponent=!0;const Lh={toc:[]};function Zh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index of the component vector to retrieve."))}Zh.isMDXComponent=!0;const Nh={toc:[]};function Sh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Sh.isMDXComponent=!0;const zh={toc:[]};function Rh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}Rh.isMDXComponent=!0;const Ph={toc:[]};function Ah(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ph,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}Ah.isMDXComponent=!0;const Ih={toc:[]};function Wh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ih,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The matrix to multiply with"))}Wh.isMDXComponent=!0;const Eh={toc:[]};function Fh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}Fh.isMDXComponent=!0;const Bh={toc:[]};function Oh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}Oh.isMDXComponent=!0;const Gh={toc:[]};function jh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value by which to scale each term"))}jh.isMDXComponent=!0;const Uh={toc:[]};function qh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}qh.isMDXComponent=!0;const Vh={toc:[]};function Hh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}Hh.isMDXComponent=!0;const $h={toc:[]};function Qh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$h,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}Qh.isMDXComponent=!0;const Jh={toc:[]};function Yh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The angle by which to rotate the matrix."))}Yh.isMDXComponent=!0;const Kh={toc:[]};function tf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the angle is provided in degrees."))}tf.isMDXComponent=!0;const ef={toc:[]};function nf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ef,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}nf.isMDXComponent=!0;const of={toc:[]};function sf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},of,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}sf.isMDXComponent=!0;const rf={toc:[]};function pf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index of the row to retrieve."))}pf.isMDXComponent=!0;const cf={toc:[]};function af(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If ",(0,p.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,p.kt)("p",null,"If ",(0,p.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,p.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scale the x and y component vectors of the matrix."))}df.isMDXComponent=!0;const hf={toc:[]};function ff(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The factor by which to scale the matrix"))}ff.isMDXComponent=!0;const yf={toc:[]};function kf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}kf.isMDXComponent=!0;const wf={toc:[]};function Mf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}Mf.isMDXComponent=!0;const Df={toc:[]};function _f(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Df,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subtract the provided matrix from this matrix."))}_f.isMDXComponent=!0;const Xf={toc:[]};function gf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The matrix to subract"))}gf.isMDXComponent=!0;const xf={toc:[]};function Cf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If ",(0,p.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,p.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Cf.isMDXComponent=!0;const Tf={toc:[]};function vf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}vf.isMDXComponent=!0;const bf={toc:[]};function Lf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}Lf.isMDXComponent=!0;const Zf={toc:[]};function Nf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The vector by which to translate the matrix"))}Nf.isMDXComponent=!0;const Sf={toc:[]};function zf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a two-dimensional vector."))}zf.isMDXComponent=!0;const Rf={toc:[]};function Pf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}Pf.isMDXComponent=!0;const Af={toc:[]};function If(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Af,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}If.isMDXComponent=!0;const Wf={toc:[]};function Ef(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}Ef.isMDXComponent=!0;const Ff={toc:[]};function Bf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ff,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,p.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}Bf.isMDXComponent=!0;const Of={toc:[]};function Gf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Of,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if two vectors are equal to each other."))}Gf.isMDXComponent=!0;const jf={toc:[]};function Uf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The vector to compare."))}Uf.isMDXComponent=!0;const qf={toc:[]};function Vf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The allowed error threshold when comparing the vectors."))}Vf.isMDXComponent=!0;const Hf={toc:[]};function $f(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,p.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}$f.isMDXComponent=!0;const Qf={toc:[]};function Jf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if two vectors are exactly equal to each other."))}Jf.isMDXComponent=!0;const Yf={toc:[]};function Kf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The vector to compare."))}Kf.isMDXComponent=!0;const ty={toc:[]};function ey(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ty,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}ey.isMDXComponent=!0;const ny={toc:[]};function oy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ny,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}oy.isMDXComponent=!0;const sy={toc:[]};function ry(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The x component of the vector."))}ry.isMDXComponent=!0;const py={toc:[]};function iy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},py,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The y component of the vector."))}iy.isMDXComponent=!0;const cy={toc:[]};function ay(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}ay.isMDXComponent=!0;const ly={toc:[]};function uy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ly,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The x component of the vector."))}uy.isMDXComponent=!0;const my={toc:[]};function dy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},my,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The y component of the vector."))}dy.isMDXComponent=!0;const hy={toc:[]};function fy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}fy.isMDXComponent=!0;const yy={toc:[]};function ky(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert the given origin to a vector representing its offset."))}ky.isMDXComponent=!0;const wy={toc:[]};function My(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The origin to convert."))}My.isMDXComponent=!0;const Dy={toc:[]};function _y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"General utilities and helper functions."))}_y.isMDXComponent=!0;const Xy={toc:[]};function gy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}gy.isMDXComponent=!0;const xy={toc:[]};function Cy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Optional override for formatting stack traces"))}Cy.isMDXComponent=!0;const Ty={toc:[]};function vy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ty,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create .stack property on a target object"))}vy.isMDXComponent=!0;const by={toc:[]};function Ly(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},by,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}Ly.isMDXComponent=!0;const Zy={toc:[]};function Ny(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A constant for converting degrees to radians"))}Ny.isMDXComponent=!0;const Sy={toc:[]};function zy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}zy.isMDXComponent=!0;const Ry={toc:[]};function Py(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ry,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A constant for converting radians to degrees"))}Py.isMDXComponent=!0;const Ay={toc:[]};function Iy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ay,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is a shortcut for calling ",(0,p.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}Iy.isMDXComponent=!0;const Wy={toc:[]};function Ey(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}Ey.isMDXComponent=!0;const Fy={toc:[]};function By(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Logs a debug message with an arbitrary payload."))}By.isMDXComponent=!0;const Oy={toc:[]};function Gy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The payload to log"))}Gy.isMDXComponent=!0;const jy={toc:[]};function Uy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Mark the given function as deprecated."))}Uy.isMDXComponent=!0;const qy={toc:[]};function Vy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function to deprecate."))}Vy.isMDXComponent=!0;const Hy={toc:[]};function $y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The log message."))}$y.isMDXComponent=!0;const Qy={toc:[]};function Jy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The optional log remarks."))}Jy.isMDXComponent=!0;const Yy={toc:[]};function Ky(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}Ky.isMDXComponent=!0;const tk={toc:[]};function ek(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Mark the current scene as ready to transition out."))}ek.isMDXComponent=!0;const nk={toc:[]};function ok(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}ok.isMDXComponent=!0;const sk={toc:[]};function rk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,p.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}rk.isMDXComponent=!0;const pk={toc:[]};function ik(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}ik.isMDXComponent=!0;const ck={toc:[]};function ak(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ck,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}ak.isMDXComponent=!0;const lk={toc:[]};function uk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The length of the array."))}uk.isMDXComponent=!0;const mk={toc:[]};function dk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}dk.isMDXComponent=!0;const hk={toc:[]};function fk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}fk.isMDXComponent=!0;const yk={toc:[]};function kk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}kk.isMDXComponent=!0;const wk={toc:[]};function Mk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}Mk.isMDXComponent=!0;const Dk={toc:[]};function _k(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}_k.isMDXComponent=!0;const Xk={toc:[]};function gk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}gk.isMDXComponent=!0;const xk={toc:[]};function Ck(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}Ck.isMDXComponent=!0;const Tk={toc:[]};function vk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}vk.isMDXComponent=!0;const bk={toc:[]};function Lk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value by which to increment or decrement."))}Lk.isMDXComponent=!0;const Zk={toc:[]};function Nk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}Nk.isMDXComponent=!0;const Sk={toc:[]};function zk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context before render."))}zk.isMDXComponent=!0;const Rk={toc:[]};function Pk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}Pk.isMDXComponent=!0;const Ak={toc:[]};function Ik(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ak,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context after render."))}Ik.isMDXComponent=!0;const Wk={toc:[]};function Ek(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}Ek.isMDXComponent=!0;const Fk={toc:[]};function Bk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}Bk.isMDXComponent=!0;const Ok={toc:[]};function Gk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ok,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the event in seconds."))}Gk.isMDXComponent=!0;const jk={toc:[]};function Uk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Register a time event and get its duration in seconds."))}Uk.isMDXComponent=!0;const qk={toc:[]};function Vk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the event."))}Vk.isMDXComponent=!0;const Hk={toc:[]};function $k(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the playback status."))}$k.isMDXComponent=!0;const Qk={toc:[]};function Jk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the random number generator for the current scene."))}Jk.isMDXComponent=!0;const Yk={toc:[]};function Kk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the random number generator for the given seed."))}Kk.isMDXComponent=!0;const tw={toc:[]};function ew(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The seed for the generator."))}ew.isMDXComponent=!0;const nw={toc:[]};function ow(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}ow.isMDXComponent=!0;const sw={toc:[]};function rw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current scene."))}rw.isMDXComponent=!0;const pw={toc:[]};function iw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current thread."))}iw.isMDXComponent=!0;const cw={toc:[]};function aw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}aw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the real time since the start of the animation."))}dw.isMDXComponent=!0;const hw={toc:[]};function fw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This rewrites a remote url like ",(0,p.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,p.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}fw.isMDXComponent=!0;const yw={toc:[]};function kw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Route the given url through a local proxy."))}kw.isMDXComponent=!0;const ww={toc:[]};function Mw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ww,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}Mw.isMDXComponent=!0;const Dw={toc:[]};function _w(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n")))}_w.isMDXComponent=!0;const Xw={toc:[]};function gw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node for drawing circular shapes."))}gw.isMDXComponent=!0;const xw={toc:[]};function Cw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}Cw.isMDXComponent=!0;const Tw={toc:[]};function vw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}vw.isMDXComponent=!0;const bw={toc:[]};function Lw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Lw.isMDXComponent=!0;const Zw={toc:[]};function Nw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Nw.isMDXComponent=!0;const Sw={toc:[]};function zw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}zw.isMDXComponent=!0;const Rw={toc:[]};function Pw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}Pw.isMDXComponent=!0;const Aw={toc:[]};function Iw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Aw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Iw.isMDXComponent=!0;const Ww={toc:[]};function Ew(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ww,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Ew.isMDXComponent=!0;const Fw={toc:[]};function Bw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Bw.isMDXComponent=!0;const Ow={toc:[]};function Gw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ow,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Gw.isMDXComponent=!0;const jw={toc:[]};function Uw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Uw.isMDXComponent=!0;const qw={toc:[]};function Vw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Vw.isMDXComponent=!0;const Hw={toc:[]};function $w(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}$w.isMDXComponent=!0;const Qw={toc:[]};function Jw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A closed circle will look like a pie chart:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,p.kt)("p",null,"An open one will look like an arc:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}Jw.isMDXComponent=!0;const Yw={toc:[]};function Kw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"false"))}Kw.isMDXComponent=!0;const tM={toc:[]};function eM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the path of this circle should be closed."))}eM.isMDXComponent=!0;const nM={toc:[]};function oM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property can be used together with ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,p.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}oM.isMDXComponent=!0;const sM={toc:[]};function rM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"360"))}rM.isMDXComponent=!0;const pM={toc:[]};function iM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ending angle in degrees for the circle sector."))}iM.isMDXComponent=!0;const cM={toc:[]};function aM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}aM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}dM.isMDXComponent=!0;const hM={toc:[]};function fM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}fM.isMDXComponent=!0;const yM={toc:[]};function kM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}kM.isMDXComponent=!0;const wM={toc:[]};function MM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}MM.isMDXComponent=!0;const DM={toc:[]};function _M(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}_M.isMDXComponent=!0;const XM={toc:[]};function gM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}gM.isMDXComponent=!0;const xM={toc:[]};function CM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}CM.isMDXComponent=!0;const TM={toc:[]};function vM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}vM.isMDXComponent=!0;const bM={toc:[]};function LM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}LM.isMDXComponent=!0;const ZM={toc:[]};function NM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}NM.isMDXComponent=!0;const SM={toc:[]};function zM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}zM.isMDXComponent=!0;const RM={toc:[]};function PM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}PM.isMDXComponent=!0;const AM={toc:[]};function IM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property can be used together with ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,p.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}IM.isMDXComponent=!0;const WM={toc:[]};function EM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"0"))}EM.isMDXComponent=!0;const FM={toc:[]};function BM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The starting angle in degrees for the circle sector."))}BM.isMDXComponent=!0;const OM={toc:[]};function GM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}GM.isMDXComponent=!0;const jM={toc:[]};function UM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}UM.isMDXComponent=!0;const qM={toc:[]};function VM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}VM.isMDXComponent=!0;const HM={toc:[]};function $M(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}$M.isMDXComponent=!0;const QM={toc:[]};function JM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}JM.isMDXComponent=!0;const YM={toc:[]};function KM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}KM.isMDXComponent=!0;const tD={toc:[]};function eD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}eD.isMDXComponent=!0;const nD={toc:[]};function oD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}oD.isMDXComponent=!0;const sD={toc:[]};function rD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}rD.isMDXComponent=!0;const pD={toc:[]};function iD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}iD.isMDXComponent=!0;const cD={toc:[]};function aD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}aD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}dD.isMDXComponent=!0;const hD={toc:[]};function fD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}fD.isMDXComponent=!0;const yD={toc:[]};function kD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}kD.isMDXComponent=!0;const wD={toc:[]};function MD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}MD.isMDXComponent=!0;const DD={toc:[]};function _D(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}_D.isMDXComponent=!0;const XD={toc:[]};function gD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}gD.isMDXComponent=!0;const xD={toc:[]};function CD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}CD.isMDXComponent=!0;const TD={toc:[]};function vD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}vD.isMDXComponent=!0;const bD={toc:[]};function LD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}LD.isMDXComponent=!0;const ZD={toc:[]};function ND(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}ND.isMDXComponent=!0;const SD={toc:[]};function zD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}zD.isMDXComponent=!0;const RD={toc:[]};function PD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}PD.isMDXComponent=!0;const AD={toc:[]};function ID(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}ID.isMDXComponent=!0;const WD={toc:[]};function ED(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}ED.isMDXComponent=!0;const FD={toc:[]};function BD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}BD.isMDXComponent=!0;const OD={toc:[]};function GD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}GD.isMDXComponent=!0;const jD={toc:[]};function UD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}UD.isMDXComponent=!0;const qD={toc:[]};function VD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}VD.isMDXComponent=!0;const HD={toc:[]};function $D(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}$D.isMDXComponent=!0;const QD={toc:[]};function JD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}JD.isMDXComponent=!0;const YD={toc:[]};function KD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}KD.isMDXComponent=!0;const t_={toc:[]};function e_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},t_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}e_.isMDXComponent=!0;const n_={toc:[]};function o_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},n_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}o_.isMDXComponent=!0;const s_={toc:[]};function r_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},s_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}r_.isMDXComponent=!0;const p_={toc:[]};function i_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},p_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}i_.isMDXComponent=!0;const c_={toc:[]};function a_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},c_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}a_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},l_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},m_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}d_.isMDXComponent=!0;const h_={toc:[]};function f_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},h_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}f_.isMDXComponent=!0;const y_={toc:[]};function k_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},y_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}k_.isMDXComponent=!0;const w_={toc:[]};function M_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},w_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}M_.isMDXComponent=!0;const D_={toc:[]};function __(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},D_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}__.isMDXComponent=!0;const X_={toc:[]};function g_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},X_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}g_.isMDXComponent=!0;const x_={toc:[]};function C_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},x_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}C_.isMDXComponent=!0;const T_={toc:[]};function v_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},T_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}v_.isMDXComponent=!0;const b_={toc:[]};function L_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},b_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}L_.isMDXComponent=!0;const Z_={toc:[]};function N_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Z_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}N_.isMDXComponent=!0;const S_={toc:[]};function z_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},S_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}z_.isMDXComponent=!0;const R_={toc:[]};function P_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},R_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}P_.isMDXComponent=!0;const A_={toc:[]};function I_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},A_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}I_.isMDXComponent=!0;const W_={toc:[]};function E_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},W_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}E_.isMDXComponent=!0;const F_={toc:[]};function B_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},F_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}B_.isMDXComponent=!0;const O_={toc:[]};function G_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},O_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}G_.isMDXComponent=!0;const j_={toc:[]};function U_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},j_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}U_.isMDXComponent=!0;const q_={toc:[]};function V_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},q_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}V_.isMDXComponent=!0;const H_={toc:[]};function $_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},H_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}$_.isMDXComponent=!0;const Q_={toc:[]};function J_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Q_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}J_.isMDXComponent=!0;const Y_={toc:[]};function K_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Y_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}K_.isMDXComponent=!0;const tX={toc:[]};function eX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}eX.isMDXComponent=!0;const nX={toc:[]};function oX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}oX.isMDXComponent=!0;const sX={toc:[]};function rX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}rX.isMDXComponent=!0;const pX={toc:[]};function iX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}iX.isMDXComponent=!0;const cX={toc:[]};function aX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}aX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}dX.isMDXComponent=!0;const hX={toc:[]};function fX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}fX.isMDXComponent=!0;const yX={toc:[]};function kX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}kX.isMDXComponent=!0;const wX={toc:[]};function MX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}MX.isMDXComponent=!0;const DX={toc:[]};function _X(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}_X.isMDXComponent=!0;const XX={toc:[]};function gX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}gX.isMDXComponent=!0;const xX={toc:[]};function CX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}CX.isMDXComponent=!0;const TX={toc:[]};function vX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}vX.isMDXComponent=!0;const bX={toc:[]};function LX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}LX.isMDXComponent=!0;const ZX={toc:[]};function NX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}NX.isMDXComponent=!0;const SX={toc:[]};function zX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}zX.isMDXComponent=!0;const RX={toc:[]};function PX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}PX.isMDXComponent=!0;const AX={toc:[]};function IX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}IX.isMDXComponent=!0;const WX={toc:[]};function EX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}EX.isMDXComponent=!0;const FX={toc:[]};function BX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}BX.isMDXComponent=!0;const OX={toc:[]};function GX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}GX.isMDXComponent=!0;const jX={toc:[]};function UX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}UX.isMDXComponent=!0;const qX={toc:[]};function VX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}VX.isMDXComponent=!0;const HX={toc:[]};function $X(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}$X.isMDXComponent=!0;const QX={toc:[]};function JX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}JX.isMDXComponent=!0;const YX={toc:[]};function KX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}KX.isMDXComponent=!0;const tg={toc:[]};function eg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}eg.isMDXComponent=!0;const ng={toc:[]};function og(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ng,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}og.isMDXComponent=!0;const sg={toc:[]};function rg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}rg.isMDXComponent=!0;const pg={toc:[]};function ig(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}ig.isMDXComponent=!0;const cg={toc:[]};function ag(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}ag.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}dg.isMDXComponent=!0;const hg={toc:[]};function fg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}fg.isMDXComponent=!0;const yg={toc:[]};function kg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}kg.isMDXComponent=!0;const wg={toc:[]};function Mg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Mg.isMDXComponent=!0;const Dg={toc:[]};function _g(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}_g.isMDXComponent=!0;const Xg={toc:[]};function gg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}gg.isMDXComponent=!0;const xg={toc:[]};function Cg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Cg.isMDXComponent=!0;const Tg={toc:[]};function vg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}vg.isMDXComponent=!0;const bg={toc:[]};function Lg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Lg.isMDXComponent=!0;const Zg={toc:[]};function Ng(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Ng.isMDXComponent=!0;const Sg={toc:[]};function zg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}zg.isMDXComponent=!0;const Rg={toc:[]};function Pg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Pg.isMDXComponent=!0;const Ag={toc:[]};function Ig(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ag,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Ig.isMDXComponent=!0;const Wg={toc:[]};function Eg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Eg.isMDXComponent=!0;const Fg={toc:[]};function Bg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Bg.isMDXComponent=!0;const Og={toc:[]};function Gg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Og,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}Gg.isMDXComponent=!0;const jg={toc:[]};function Ug(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Ug.isMDXComponent=!0;const qg={toc:[]};function Vg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}Vg.isMDXComponent=!0;const Hg={toc:[]};function $g(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Defining a cubic B\xe9zier curve using ",(0,p.kt)("inlineCode",{parentName:"p"},"points")," property."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  <CubicBezier\n    lineWidth={4}\n    stroke={'lightseagreen'}\n    p0={[-200, -200]}\n    p1={[100, -200]}\n    p2={[-100, 200]}\n    p3={[200, 200]}\n    end={0}\n  />\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}$g.isMDXComponent=!0;const Qg={toc:[]};function Jg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node for drawing a cubic B\xe9zier curve."))}Jg.isMDXComponent=!0;const Yg={toc:[]};function Kg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}Kg.isMDXComponent=!0;const tx={toc:[]};function ex(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}ex.isMDXComponent=!0;const nx={toc:[]};function ox(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ox.isMDXComponent=!0;const sx={toc:[]};function rx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}rx.isMDXComponent=!0;const px={toc:[]};function ix(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},px,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}ix.isMDXComponent=!0;const cx={toc:[]};function ax(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}ax.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}dx.isMDXComponent=!0;const hx={toc:[]};function fx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}fx.isMDXComponent=!0;const yx={toc:[]};function kx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}kx.isMDXComponent=!0;const wx={toc:[]};function Mx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Mx.isMDXComponent=!0;const Dx={toc:[]};function _x(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}_x.isMDXComponent=!0;const Xx={toc:[]};function gx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}gx.isMDXComponent=!0;const xx={toc:[]};function Cx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Cx.isMDXComponent=!0;const Tx={toc:[]};function vx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}vx.isMDXComponent=!0;const bx={toc:[]};function Lx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}Lx.isMDXComponent=!0;const Zx={toc:[]};function Nx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Nx.isMDXComponent=!0;const Sx={toc:[]};function zx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}zx.isMDXComponent=!0;const Rx={toc:[]};function Px(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Px.isMDXComponent=!0;const Ax={toc:[]};function Ix(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ax,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Ix.isMDXComponent=!0;const Wx={toc:[]};function Ex(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Ex.isMDXComponent=!0;const Fx={toc:[]};function Bx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}Bx.isMDXComponent=!0;const Ox={toc:[]};function Gx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ox,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Gx.isMDXComponent=!0;const jx={toc:[]};function Ux(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Ux.isMDXComponent=!0;const qx={toc:[]};function Vx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Vx.isMDXComponent=!0;const Hx={toc:[]};function $x(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}$x.isMDXComponent=!0;const Qx={toc:[]};function Jx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start point of the B\xe9zier curve."))}Jx.isMDXComponent=!0;const Yx={toc:[]};function Kx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The first control point of the B\xe9zier curve."))}Kx.isMDXComponent=!0;const tC={toc:[]};function eC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The second control point of the B\xe9zier curve."))}eC.isMDXComponent=!0;const nC={toc:[]};function oC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end point of the B\xe9zier curve."))}oC.isMDXComponent=!0;const sC={toc:[]};function rC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}rC.isMDXComponent=!0;const pC={toc:[]};function iC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}iC.isMDXComponent=!0;const cC={toc:[]};function aC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}aC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}dC.isMDXComponent=!0;const hC={toc:[]};function fC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}fC.isMDXComponent=!0;const yC={toc:[]};function kC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}kC.isMDXComponent=!0;const wC={toc:[]};function MC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}MC.isMDXComponent=!0;const DC={toc:[]};function _C(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}_C.isMDXComponent=!0;const XC={toc:[]};function gC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}gC.isMDXComponent=!0;const xC={toc:[]};function CC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}CC.isMDXComponent=!0;const TC={toc:[]};function vC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}vC.isMDXComponent=!0;const bC={toc:[]};function LC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}LC.isMDXComponent=!0;const ZC={toc:[]};function NC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}NC.isMDXComponent=!0;const SC={toc:[]};function zC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}zC.isMDXComponent=!0;const RC={toc:[]};function PC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}PC.isMDXComponent=!0;const AC={toc:[]};function IC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}IC.isMDXComponent=!0;const WC={toc:[]};function EC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}EC.isMDXComponent=!0;const FC={toc:[]};function BC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}BC.isMDXComponent=!0;const OC={toc:[]};function GC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}GC.isMDXComponent=!0;const jC={toc:[]};function UC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}UC.isMDXComponent=!0;const qC={toc:[]};function VC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}VC.isMDXComponent=!0;const HC={toc:[]};function $C(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}$C.isMDXComponent=!0;const QC={toc:[]};function JC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}JC.isMDXComponent=!0;const YC={toc:[]};function KC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}KC.isMDXComponent=!0;const tT={toc:[]};function eT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}eT.isMDXComponent=!0;const nT={toc:[]};function oT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}oT.isMDXComponent=!0;const sT={toc:[]};function rT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}rT.isMDXComponent=!0;const pT={toc:[]};function iT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This arc length accounts for both the offset and the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}iT.isMDXComponent=!0;const cT={toc:[]};function aT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The visible arc length of this curve."))}aT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The base arc length of this curve."))}dT.isMDXComponent=!0;const hT={toc:[]};function fT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}fT.isMDXComponent=!0;const yT={toc:[]};function kT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}kT.isMDXComponent=!0;const wT={toc:[]};function MT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}MT.isMDXComponent=!0;const DT={toc:[]};function _T(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}_T.isMDXComponent=!0;const XT={toc:[]};function gT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}gT.isMDXComponent=!0;const xT={toc:[]};function CT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}CT.isMDXComponent=!0;const TT={toc:[]};function vT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage of the curve that's currently visible."))}vT.isMDXComponent=!0;const bT={toc:[]};function LT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}LT.isMDXComponent=!0;const ZT={toc:[]};function NT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}NT.isMDXComponent=!0;const ST={toc:[]};function zT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ST,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}zT.isMDXComponent=!0;const RT={toc:[]};function PT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a distance along the curve to a percentage."))}PT.isMDXComponent=!0;const AT={toc:[]};function IT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance along the curve."))}IT.isMDXComponent=!0;const WT={toc:[]};function ET(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}ET.isMDXComponent=!0;const FT={toc:[]};function BT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}BT.isMDXComponent=!0;const OT={toc:[]};function GT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}GT.isMDXComponent=!0;const jT={toc:[]};function UT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}UT.isMDXComponent=!0;const qT={toc:[]};function VT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}VT.isMDXComponent=!0;const HT={toc:[]};function $T(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}$T.isMDXComponent=!0;const QT={toc:[]};function JT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}JT.isMDXComponent=!0;const YT={toc:[]};function KT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}KT.isMDXComponent=!0;const tv={toc:[]};function ev(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}ev.isMDXComponent=!0;const nv={toc:[]};function ov(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}ov.isMDXComponent=!0;const sv={toc:[]};function rv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}rv.isMDXComponent=!0;const pv={toc:[]};function iv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}iv.isMDXComponent=!0;const cv={toc:[]};function av(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}av.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}dv.isMDXComponent=!0;const hv={toc:[]};function fv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}fv.isMDXComponent=!0;const yv={toc:[]};function kv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}kv.isMDXComponent=!0;const wv={toc:[]};function Mv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}Mv.isMDXComponent=!0;const Dv={toc:[]};function _v(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}_v.isMDXComponent=!0;const Xv={toc:[]};function gv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}gv.isMDXComponent=!0;const xv={toc:[]};function Cv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}Cv.isMDXComponent=!0;const Tv={toc:[]};function vv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}vv.isMDXComponent=!0;const bv={toc:[]};function Lv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Lv.isMDXComponent=!0;const Zv={toc:[]};function Nv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Nv.isMDXComponent=!0;const Sv={toc:[]};function zv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}zv.isMDXComponent=!0;const Rv={toc:[]};function Pv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Pv.isMDXComponent=!0;const Av={toc:[]};function Iv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Av,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Iv.isMDXComponent=!0;const Wv={toc:[]};function Ev(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}Ev.isMDXComponent=!0;const Fv={toc:[]};function Bv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Bv.isMDXComponent=!0;const Ov={toc:[]};function Gv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ov,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Gv.isMDXComponent=!0;const jv={toc:[]};function Uv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Uv.isMDXComponent=!0;const qv={toc:[]};function Vv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Vv.isMDXComponent=!0;const Hv={toc:[]};function $v(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}$v.isMDXComponent=!0;const Qv={toc:[]};function Jv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Jv.isMDXComponent=!0;const Yv={toc:[]};function Kv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Kv.isMDXComponent=!0;const tb={toc:[]};function eb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}eb.isMDXComponent=!0;const nb={toc:[]};function ob(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}ob.isMDXComponent=!0;const sb={toc:[]};function rb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}rb.isMDXComponent=!0;const pb={toc:[]};function ib(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}ib.isMDXComponent=!0;const cb={toc:[]};function ab(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the length of the curve that accounts for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}ab.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset arc length of this curve."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}db.isMDXComponent=!0;const hb={toc:[]};function fb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a percentage along the curve to a distance."))}fb.isMDXComponent=!0;const yb={toc:[]};function kb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage along the curve."))}kb.isMDXComponent=!0;const wb={toc:[]};function Mb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Mb.isMDXComponent=!0;const Db={toc:[]};function _b(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Db,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}_b.isMDXComponent=!0;const Xb={toc:[]};function gb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}gb.isMDXComponent=!0;const xb={toc:[]};function Cb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}Cb.isMDXComponent=!0;const Tb={toc:[]};function vb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}vb.isMDXComponent=!0;const bb={toc:[]};function Lb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Lb.isMDXComponent=!0;const Zb={toc:[]};function Nb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Nb.isMDXComponent=!0;const Sb={toc:[]};function zb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}zb.isMDXComponent=!0;const Rb={toc:[]};function Pb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Pb.isMDXComponent=!0;const Ab={toc:[]};function Ib(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ab,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}Ib.isMDXComponent=!0;const Wb={toc:[]};function Eb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Eb.isMDXComponent=!0;const Fb={toc:[]};function Bb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Bb.isMDXComponent=!0;const Ob={toc:[]};function Gb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ob,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Gb.isMDXComponent=!0;const jb={toc:[]};function Ub(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Ub.isMDXComponent=!0;const qb={toc:[]};function Vb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Vb.isMDXComponent=!0;const Hb={toc:[]};function $b(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}$b.isMDXComponent=!0;const Qb={toc:[]};function Jb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}Jb.isMDXComponent=!0;const Yb={toc:[]};function Kb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}Kb.isMDXComponent=!0;const tL={toc:[]};function eL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}eL.isMDXComponent=!0;const nL={toc:[]};function oL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}oL.isMDXComponent=!0;const sL={toc:[]};function rL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}rL.isMDXComponent=!0;const pL={toc:[]};function iL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}iL.isMDXComponent=!0;const cL={toc:[]};function aL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}aL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}dL.isMDXComponent=!0;const hL={toc:[]};function fL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}fL.isMDXComponent=!0;const yL={toc:[]};function kL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}kL.isMDXComponent=!0;const wL={toc:[]};function ML(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}ML.isMDXComponent=!0;const DL={toc:[]};function _L(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}_L.isMDXComponent=!0;const XL={toc:[]};function gL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}gL.isMDXComponent=!0;const xL={toc:[]};function CL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}CL.isMDXComponent=!0;const TL={toc:[]};function vL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}vL.isMDXComponent=!0;const bL={toc:[]};function LL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}LL.isMDXComponent=!0;const ZL={toc:[]};function NL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}NL.isMDXComponent=!0;const SL={toc:[]};function zL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}zL.isMDXComponent=!0;const RL={toc:[]};function PL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}PL.isMDXComponent=!0;const AL={toc:[]};function IL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}IL.isMDXComponent=!0;const WL={toc:[]};function EL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}EL.isMDXComponent=!0;const FL={toc:[]};function BL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}BL.isMDXComponent=!0;const OL={toc:[]};function GL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}GL.isMDXComponent=!0;const jL={toc:[]};function UL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}UL.isMDXComponent=!0;const qL={toc:[]};function VL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}VL.isMDXComponent=!0;const HL={toc:[]};function $L(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}$L.isMDXComponent=!0;const QL={toc:[]};function JL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}JL.isMDXComponent=!0;const YL={toc:[]};function KL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}KL.isMDXComponent=!0;const tZ={toc:[]};function eZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}eZ.isMDXComponent=!0;const nZ={toc:[]};function oZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}oZ.isMDXComponent=!0;const sZ={toc:[]};function rZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}rZ.isMDXComponent=!0;const pZ={toc:[]};function iZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}iZ.isMDXComponent=!0;const cZ={toc:[]};function aZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}aZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function fZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}fZ.isMDXComponent=!0;const yZ={toc:[]};function kZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}kZ.isMDXComponent=!0;const wZ={toc:[]};function MZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}MZ.isMDXComponent=!0;const DZ={toc:[]};function _Z(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}_Z.isMDXComponent=!0;const XZ={toc:[]};function gZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}gZ.isMDXComponent=!0;const xZ={toc:[]};function CZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}CZ.isMDXComponent=!0;const TZ={toc:[]};function vZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}vZ.isMDXComponent=!0;const bZ={toc:[]};function LZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}LZ.isMDXComponent=!0;const ZZ={toc:[]};function NZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}NZ.isMDXComponent=!0;const SZ={toc:[]};function zZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}zZ.isMDXComponent=!0;const RZ={toc:[]};function PZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}PZ.isMDXComponent=!0;const AZ={toc:[]};function IZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}IZ.isMDXComponent=!0;const WZ={toc:[]};function EZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}EZ.isMDXComponent=!0;const FZ={toc:[]};function BZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}BZ.isMDXComponent=!0;const OZ={toc:[]};function GZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}GZ.isMDXComponent=!0;const jZ={toc:[]};function UZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}UZ.isMDXComponent=!0;const qZ={toc:[]};function VZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}VZ.isMDXComponent=!0;const HZ={toc:[]};function $Z(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}$Z.isMDXComponent=!0;const QZ={toc:[]};function JZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}JZ.isMDXComponent=!0;const YZ={toc:[]};function KZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}KZ.isMDXComponent=!0;const tN={toc:[]};function eN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}eN.isMDXComponent=!0;const nN={toc:[]};function oN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}oN.isMDXComponent=!0;const sN={toc:[]};function rN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}rN.isMDXComponent=!0;const pN={toc:[]};function iN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}iN.isMDXComponent=!0;const cN={toc:[]};function aN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}aN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}dN.isMDXComponent=!0;const hN={toc:[]};function fN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}fN.isMDXComponent=!0;const yN={toc:[]};function kN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}kN.isMDXComponent=!0;const wN={toc:[]};function MN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}MN.isMDXComponent=!0;const DN={toc:[]};function _N(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}_N.isMDXComponent=!0;const XN={toc:[]};function gN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}gN.isMDXComponent=!0;const xN={toc:[]};function CN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}CN.isMDXComponent=!0;const TN={toc:[]};function vN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}vN.isMDXComponent=!0;const bN={toc:[]};function LN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}LN.isMDXComponent=!0;const ZN={toc:[]};function NN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}NN.isMDXComponent=!0;const SN={toc:[]};function zN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}zN.isMDXComponent=!0;const RN={toc:[]};function PN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}PN.isMDXComponent=!0;const AN={toc:[]};function IN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This arc length accounts for both the offset and the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}IN.isMDXComponent=!0;const WN={toc:[]};function EN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The visible arc length of this curve."))}EN.isMDXComponent=!0;const FN={toc:[]};function BN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}BN.isMDXComponent=!0;const ON={toc:[]};function GN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ON,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The base arc length of this curve."))}GN.isMDXComponent=!0;const jN={toc:[]};function UN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}UN.isMDXComponent=!0;const qN={toc:[]};function VN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}VN.isMDXComponent=!0;const HN={toc:[]};function $N(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}$N.isMDXComponent=!0;const QN={toc:[]};function JN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}JN.isMDXComponent=!0;const YN={toc:[]};function KN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}KN.isMDXComponent=!0;const tS={toc:[]};function eS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}eS.isMDXComponent=!0;const nS={toc:[]};function oS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage of the curve that's currently visible."))}oS.isMDXComponent=!0;const sS={toc:[]};function rS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}rS.isMDXComponent=!0;const pS={toc:[]};function iS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}iS.isMDXComponent=!0;const cS={toc:[]};function aS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}aS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}dS.isMDXComponent=!0;const hS={toc:[]};function fS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}fS.isMDXComponent=!0;const yS={toc:[]};function kS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}kS.isMDXComponent=!0;const wS={toc:[]};function MS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a distance along the curve to a percentage."))}MS.isMDXComponent=!0;const DS={toc:[]};function _S(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance along the curve."))}_S.isMDXComponent=!0;const XS={toc:[]};function gS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}gS.isMDXComponent=!0;const xS={toc:[]};function CS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}CS.isMDXComponent=!0;const TS={toc:[]};function vS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}vS.isMDXComponent=!0;const bS={toc:[]};function LS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}LS.isMDXComponent=!0;const ZS={toc:[]};function NS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}NS.isMDXComponent=!0;const SS={toc:[]};function zS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}zS.isMDXComponent=!0;const RS={toc:[]};function PS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}PS.isMDXComponent=!0;const AS={toc:[]};function IS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}IS.isMDXComponent=!0;const WS={toc:[]};function ES(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}ES.isMDXComponent=!0;const FS={toc:[]};function BS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}BS.isMDXComponent=!0;const OS={toc:[]};function GS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}GS.isMDXComponent=!0;const jS={toc:[]};function US(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}US.isMDXComponent=!0;const qS={toc:[]};function VS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}VS.isMDXComponent=!0;const HS={toc:[]};function $S(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}$S.isMDXComponent=!0;const QS={toc:[]};function JS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}JS.isMDXComponent=!0;const YS={toc:[]};function KS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}KS.isMDXComponent=!0;const tz={toc:[]};function ez(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}ez.isMDXComponent=!0;const nz={toc:[]};function oz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}oz.isMDXComponent=!0;const sz={toc:[]};function rz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}rz.isMDXComponent=!0;const pz={toc:[]};function iz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}iz.isMDXComponent=!0;const cz={toc:[]};function az(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}az.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}dz.isMDXComponent=!0;const hz={toc:[]};function fz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}fz.isMDXComponent=!0;const yz={toc:[]};function kz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}kz.isMDXComponent=!0;const wz={toc:[]};function Mz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Mz.isMDXComponent=!0;const Dz={toc:[]};function _z(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}_z.isMDXComponent=!0;const Xz={toc:[]};function gz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}gz.isMDXComponent=!0;const xz={toc:[]};function Cz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Cz.isMDXComponent=!0;const Tz={toc:[]};function vz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}vz.isMDXComponent=!0;const bz={toc:[]};function Lz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}Lz.isMDXComponent=!0;const Zz={toc:[]};function Nz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Nz.isMDXComponent=!0;const Sz={toc:[]};function zz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}zz.isMDXComponent=!0;const Rz={toc:[]};function Pz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}Pz.isMDXComponent=!0;const Az={toc:[]};function Iz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Az,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Iz.isMDXComponent=!0;const Wz={toc:[]};function Ez(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Ez.isMDXComponent=!0;const Fz={toc:[]};function Bz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Bz.isMDXComponent=!0;const Oz={toc:[]};function Gz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}Gz.isMDXComponent=!0;const jz={toc:[]};function Uz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Uz.isMDXComponent=!0;const qz={toc:[]};function Vz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Vz.isMDXComponent=!0;const Hz={toc:[]};function $z(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}$z.isMDXComponent=!0;const Qz={toc:[]};function Jz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Jz.isMDXComponent=!0;const Yz={toc:[]};function Kz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Kz.isMDXComponent=!0;const tR={toc:[]};function eR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}eR.isMDXComponent=!0;const nR={toc:[]};function oR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}oR.isMDXComponent=!0;const sR={toc:[]};function rR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}rR.isMDXComponent=!0;const pR={toc:[]};function iR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}iR.isMDXComponent=!0;const cR={toc:[]};function aR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}aR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}dR.isMDXComponent=!0;const hR={toc:[]};function fR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}fR.isMDXComponent=!0;const yR={toc:[]};function kR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}kR.isMDXComponent=!0;const wR={toc:[]};function MR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the length of the curve that accounts for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}MR.isMDXComponent=!0;const DR={toc:[]};function _R(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset arc length of this curve."))}_R.isMDXComponent=!0;const XR={toc:[]};function gR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}gR.isMDXComponent=!0;const xR={toc:[]};function CR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a percentage along the curve to a distance."))}CR.isMDXComponent=!0;const TR={toc:[]};function vR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage along the curve."))}vR.isMDXComponent=!0;const bR={toc:[]};function LR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}LR.isMDXComponent=!0;const ZR={toc:[]};function NR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}NR.isMDXComponent=!0;const SR={toc:[]};function zR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}zR.isMDXComponent=!0;const RR={toc:[]};function PR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}PR.isMDXComponent=!0;const AR={toc:[]};function IR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}IR.isMDXComponent=!0;const WR={toc:[]};function ER(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}ER.isMDXComponent=!0;const FR={toc:[]};function BR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}BR.isMDXComponent=!0;const OR={toc:[]};function GR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}GR.isMDXComponent=!0;const jR={toc:[]};function UR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}UR.isMDXComponent=!0;const qR={toc:[]};function VR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}VR.isMDXComponent=!0;const HR={toc:[]};function $R(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}$R.isMDXComponent=!0;const QR={toc:[]};function JR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}JR.isMDXComponent=!0;const YR={toc:[]};function KR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}KR.isMDXComponent=!0;const tP={toc:[]};function eP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}eP.isMDXComponent=!0;const nP={toc:[]};function oP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}oP.isMDXComponent=!0;const sP={toc:[]};function rP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}rP.isMDXComponent=!0;const pP={toc:[]};function iP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}iP.isMDXComponent=!0;const cP={toc:[]};function aP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}aP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}dP.isMDXComponent=!0;const hP={toc:[]};function fP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}fP.isMDXComponent=!0;const yP={toc:[]};function kP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}kP.isMDXComponent=!0;const wP={toc:[]};function MP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}MP.isMDXComponent=!0;const DP={toc:[]};function _P(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}_P.isMDXComponent=!0;const XP={toc:[]};function gP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}gP.isMDXComponent=!0;const xP={toc:[]};function CP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}CP.isMDXComponent=!0;const TP={toc:[]};function vP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}vP.isMDXComponent=!0;const bP={toc:[]};function LP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}LP.isMDXComponent=!0;const ZP={toc:[]};function NP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}NP.isMDXComponent=!0;const SP={toc:[]};function zP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}zP.isMDXComponent=!0;const RP={toc:[]};function PP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}PP.isMDXComponent=!0;const AP={toc:[]};function IP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}IP.isMDXComponent=!0;const WP={toc:[]};function EP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}EP.isMDXComponent=!0;const FP={toc:[]};function BP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}BP.isMDXComponent=!0;const OP={toc:[]};function GP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}GP.isMDXComponent=!0;const jP={toc:[]};function UP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}UP.isMDXComponent=!0;const qP={toc:[]};function VP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}VP.isMDXComponent=!0;const HP={toc:[]};function $P(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}$P.isMDXComponent=!0;const QP={toc:[]};function JP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}JP.isMDXComponent=!0;const YP={toc:[]};function KP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}KP.isMDXComponent=!0;const tA={toc:[]};function eA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}eA.isMDXComponent=!0;const nA={toc:[]};function oA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}oA.isMDXComponent=!0;const sA={toc:[]};function rA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}rA.isMDXComponent=!0;const pA={toc:[]};function iA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}iA.isMDXComponent=!0;const cA={toc:[]};function aA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}aA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}dA.isMDXComponent=!0;const hA={toc:[]};function fA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}fA.isMDXComponent=!0;const yA={toc:[]};function kA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}kA.isMDXComponent=!0;const wA={toc:[]};function MA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}MA.isMDXComponent=!0;const DA={toc:[]};function _A(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}_A.isMDXComponent=!0;const XA={toc:[]};function gA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}gA.isMDXComponent=!0;const xA={toc:[]};function CA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}CA.isMDXComponent=!0;const TA={toc:[]};function vA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}vA.isMDXComponent=!0;const bA={toc:[]};function LA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}LA.isMDXComponent=!0;const ZA={toc:[]};function NA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}NA.isMDXComponent=!0;const SA={toc:[]};function zA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}zA.isMDXComponent=!0;const RA={toc:[]};function PA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}PA.isMDXComponent=!0;const AA={toc:[]};function IA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}IA.isMDXComponent=!0;const WA={toc:[]};function EA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}EA.isMDXComponent=!0;const FA={toc:[]};function BA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}BA.isMDXComponent=!0;const OA={toc:[]};function GA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}GA.isMDXComponent=!0;const jA={toc:[]};function UA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}UA.isMDXComponent=!0;const qA={toc:[]};function VA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}VA.isMDXComponent=!0;const HA={toc:[]};function $A(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}$A.isMDXComponent=!0;const QA={toc:[]};function JA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}JA.isMDXComponent=!0;const YA={toc:[]};function KA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}KA.isMDXComponent=!0;const tI={toc:[]};function eI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}eI.isMDXComponent=!0;const nI={toc:[]};function oI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}oI.isMDXComponent=!0;const sI={toc:[]};function rI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}rI.isMDXComponent=!0;const pI={toc:[]};function iI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}iI.isMDXComponent=!0;const cI={toc:[]};function aI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}aI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}dI.isMDXComponent=!0;const hI={toc:[]};function fI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}fI.isMDXComponent=!0;const yI={toc:[]};function kI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}kI.isMDXComponent=!0;const wI={toc:[]};function MI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}MI.isMDXComponent=!0;const DI={toc:[]};function _I(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}_I.isMDXComponent=!0;const XI={toc:[]};function gI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}gI.isMDXComponent=!0;const xI={toc:[]};function CI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}CI.isMDXComponent=!0;const TI={toc:[]};function vI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}vI.isMDXComponent=!0;const bI={toc:[]};function LI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}LI.isMDXComponent=!0;const ZI={toc:[]};function NI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}NI.isMDXComponent=!0;const SI={toc:[]};function zI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}zI.isMDXComponent=!0;const RI={toc:[]};function PI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}PI.isMDXComponent=!0;const AI={toc:[]};function II(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}II.isMDXComponent=!0;const WI={toc:[]};function EI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}EI.isMDXComponent=!0;const FI={toc:[]};function BI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}BI.isMDXComponent=!0;const OI={toc:[]};function GI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}GI.isMDXComponent=!0;const jI={toc:[]};function UI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}UI.isMDXComponent=!0;const qI={toc:[]};function VI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}VI.isMDXComponent=!0;const HI={toc:[]};function $I(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}$I.isMDXComponent=!0;const QI={toc:[]};function JI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}JI.isMDXComponent=!0;const YI={toc:[]};function KI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}KI.isMDXComponent=!0;const tW={toc:[]};function eW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}eW.isMDXComponent=!0;const nW={toc:[]};function oW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}oW.isMDXComponent=!0;const sW={toc:[]};function rW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}rW.isMDXComponent=!0;const pW={toc:[]};function iW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}iW.isMDXComponent=!0;const cW={toc:[]};function aW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}aW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}dW.isMDXComponent=!0;const hW={toc:[]};function fW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}fW.isMDXComponent=!0;const yW={toc:[]};function kW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}kW.isMDXComponent=!0;const wW={toc:[]};function MW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}MW.isMDXComponent=!0;const DW={toc:[]};function _W(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}_W.isMDXComponent=!0;const XW={toc:[]};function gW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}gW.isMDXComponent=!0;const xW={toc:[]};function CW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}CW.isMDXComponent=!0;const TW={toc:[]};function vW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}vW.isMDXComponent=!0;const bW={toc:[]};function LW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}LW.isMDXComponent=!0;const ZW={toc:[]};function NW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}NW.isMDXComponent=!0;const SW={toc:[]};function zW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}zW.isMDXComponent=!0;const RW={toc:[]};function PW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}PW.isMDXComponent=!0;const AW={toc:[]};function IW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}IW.isMDXComponent=!0;const WW={toc:[]};function EW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}EW.isMDXComponent=!0;const FW={toc:[]};function BW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}BW.isMDXComponent=!0;const OW={toc:[]};function GW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}GW.isMDXComponent=!0;const jW={toc:[]};function UW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}UW.isMDXComponent=!0;const qW={toc:[]};function VW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}VW.isMDXComponent=!0;const HW={toc:[]};function $W(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}$W.isMDXComponent=!0;const QW={toc:[]};function JW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}JW.isMDXComponent=!0;const YW={toc:[]};function KW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}KW.isMDXComponent=!0;const tE={toc:[]};function eE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}eE.isMDXComponent=!0;const nE={toc:[]};function oE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}oE.isMDXComponent=!0;const sE={toc:[]};function rE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}rE.isMDXComponent=!0;const pE={toc:[]};function iE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}iE.isMDXComponent=!0;const cE={toc:[]};function aE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}aE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}dE.isMDXComponent=!0;const hE={toc:[]};function fE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}fE.isMDXComponent=!0;const yE={toc:[]};function kE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}kE.isMDXComponent=!0;const wE={toc:[]};function ME(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}ME.isMDXComponent=!0;const DE={toc:[]};function _E(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}_E.isMDXComponent=!0;const XE={toc:[]};function gE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}gE.isMDXComponent=!0;const xE={toc:[]};function CE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}CE.isMDXComponent=!0;const TE={toc:[]};function vE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}vE.isMDXComponent=!0;const bE={toc:[]};function LE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}LE.isMDXComponent=!0;const ZE={toc:[]};function NE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}NE.isMDXComponent=!0;const SE={toc:[]};function zE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}zE.isMDXComponent=!0;const RE={toc:[]};function PE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}PE.isMDXComponent=!0;const AE={toc:[]};function IE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}IE.isMDXComponent=!0;const WE={toc:[]};function EE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}EE.isMDXComponent=!0;const FE={toc:[]};function BE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}BE.isMDXComponent=!0;const OE={toc:[]};function GE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}GE.isMDXComponent=!0;const jE={toc:[]};function UE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}UE.isMDXComponent=!0;const qE={toc:[]};function VE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}VE.isMDXComponent=!0;const HE={toc:[]};function $E(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}$E.isMDXComponent=!0;const QE={toc:[]};function JE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}JE.isMDXComponent=!0;const YE={toc:[]};function KE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}KE.isMDXComponent=!0;const tF={toc:[]};function eF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}eF.isMDXComponent=!0;const nF={toc:[]};function oF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}oF.isMDXComponent=!0;const sF={toc:[]};function rF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}rF.isMDXComponent=!0;const pF={toc:[]};function iF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}iF.isMDXComponent=!0;const cF={toc:[]};function aF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}aF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}dF.isMDXComponent=!0;const hF={toc:[]};function fF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}fF.isMDXComponent=!0;const yF={toc:[]};function kF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}kF.isMDXComponent=!0;const wF={toc:[]};function MF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}MF.isMDXComponent=!0;const DF={toc:[]};function _F(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}_F.isMDXComponent=!0;const XF={toc:[]};function gF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}gF.isMDXComponent=!0;const xF={toc:[]};function CF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}CF.isMDXComponent=!0;const TF={toc:[]};function vF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}vF.isMDXComponent=!0;const bF={toc:[]};function LF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}LF.isMDXComponent=!0;const ZF={toc:[]};function NF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}NF.isMDXComponent=!0;const SF={toc:[]};function zF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}zF.isMDXComponent=!0;const RF={toc:[]};function PF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}PF.isMDXComponent=!0;const AF={toc:[]};function IF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}IF.isMDXComponent=!0;const WF={toc:[]};function EF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}EF.isMDXComponent=!0;const FF={toc:[]};function BF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}BF.isMDXComponent=!0;const OF={toc:[]};function GF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}GF.isMDXComponent=!0;const jF={toc:[]};function UF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}UF.isMDXComponent=!0;const qF={toc:[]};function VF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}VF.isMDXComponent=!0;const HF={toc:[]};function $F(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}$F.isMDXComponent=!0;const QF={toc:[]};function JF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An Icon Component that provides an easy access to over 150k icons.\nSee ",(0,p.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}JF.isMDXComponent=!0;const YF={toc:[]};function KF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}KF.isMDXComponent=!0;const tB={toc:[]};function eB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}eB.isMDXComponent=!0;const nB={toc:[]};function oB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}oB.isMDXComponent=!0;const sB={toc:[]};function rB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}rB.isMDXComponent=!0;const pB={toc:[]};function iB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}iB.isMDXComponent=!0;const cB={toc:[]};function aB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}aB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The alpha value of this image."))}dB.isMDXComponent=!0;const hB={toc:[]};function fB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}fB.isMDXComponent=!0;const yB={toc:[]};function kB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}kB.isMDXComponent=!0;const wB={toc:[]};function MB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}MB.isMDXComponent=!0;const DB={toc:[]};function _B(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}_B.isMDXComponent=!0;const XB={toc:[]};function gB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}gB.isMDXComponent=!0;const xB={toc:[]};function CB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}CB.isMDXComponent=!0;const TB={toc:[]};function vB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide the color in one of the following formats:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"named color like ",(0,p.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,p.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,p.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,p.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,p.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,p.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,p.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,p.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,p.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}vB.isMDXComponent=!0;const bB={toc:[]};function LB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"'white'"))}LB.isMDXComponent=!0;const ZB={toc:[]};function NB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The color of the icon"))}NB.isMDXComponent=!0;const SB={toc:[]};function zB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}zB.isMDXComponent=!0;const RB={toc:[]};function PB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}PB.isMDXComponent=!0;const AB={toc:[]};function IB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}IB.isMDXComponent=!0;const WB={toc:[]};function EB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"You can find identifiers on ",(0,p.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}EB.isMDXComponent=!0;const FB={toc:[]};function BB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The identifier of the icon."))}BB.isMDXComponent=!0;const OB={toc:[]};function GB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}GB.isMDXComponent=!0;const jB={toc:[]};function UB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}UB.isMDXComponent=!0;const qB={toc:[]};function VB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}VB.isMDXComponent=!0;const HB={toc:[]};function $B(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}$B.isMDXComponent=!0;const QB={toc:[]};function JB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}JB.isMDXComponent=!0;const YB={toc:[]};function KB(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YB,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}KB.isMDXComponent=!0;const tO={toc:[]};function eO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}eO.isMDXComponent=!0;const nO={toc:[]};function oO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}oO.isMDXComponent=!0;const sO={toc:[]};function rO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}rO.isMDXComponent=!0;const pO={toc:[]};function iO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}iO.isMDXComponent=!0;const cO={toc:[]};function aO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}aO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}dO.isMDXComponent=!0;const hO={toc:[]};function fO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}fO.isMDXComponent=!0;const yO={toc:[]};function kO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}kO.isMDXComponent=!0;const wO={toc:[]};function MO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}MO.isMDXComponent=!0;const DO={toc:[]};function _O(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}_O.isMDXComponent=!0;const XO={toc:[]};function gO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}gO.isMDXComponent=!0;const xO={toc:[]};function CO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"true"))}CO.isMDXComponent=!0;const TO={toc:[]};function vO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the image should be smoothed."))}vO.isMDXComponent=!0;const bO={toc:[]};function LO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Using a local image:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,p.kt)("p",null,"Loading an image from the internet:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}LO.isMDXComponent=!0;const ZO={toc:[]};function NO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The source of this image."))}NO.isMDXComponent=!0;const SO={toc:[]};function zO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}zO.isMDXComponent=!0;const RO={toc:[]};function PO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}PO.isMDXComponent=!0;const AO={toc:[]};function IO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}IO.isMDXComponent=!0;const WO={toc:[]};function EO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}EO.isMDXComponent=!0;const FO={toc:[]};function BO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}BO.isMDXComponent=!0;const OO={toc:[]};function GO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}GO.isMDXComponent=!0;const jO={toc:[]};function UO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}UO.isMDXComponent=!0;const qO={toc:[]};function VO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}VO.isMDXComponent=!0;const HO={toc:[]};function $O(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}$O.isMDXComponent=!0;const QO={toc:[]};function JO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}JO.isMDXComponent=!0;const YO={toc:[]};function KO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}KO.isMDXComponent=!0;const tG={toc:[]};function eG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}eG.isMDXComponent=!0;const nG={toc:[]};function oG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}oG.isMDXComponent=!0;const sG={toc:[]};function rG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}rG.isMDXComponent=!0;const pG={toc:[]};function iG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}iG.isMDXComponent=!0;const cG={toc:[]};function aG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}aG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}dG.isMDXComponent=!0;const hG={toc:[]};function fG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}fG.isMDXComponent=!0;const yG={toc:[]};function kG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}kG.isMDXComponent=!0;const wG={toc:[]};function MG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}MG.isMDXComponent=!0;const DG={toc:[]};function _G(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}_G.isMDXComponent=!0;const XG={toc:[]};function gG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}gG.isMDXComponent=!0;const xG={toc:[]};function CG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}CG.isMDXComponent=!0;const TG={toc:[]};function vG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}vG.isMDXComponent=!0;const bG={toc:[]};function LG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}LG.isMDXComponent=!0;const ZG={toc:[]};function NG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}NG.isMDXComponent=!0;const SG={toc:[]};function zG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}zG.isMDXComponent=!0;const RG={toc:[]};function PG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}PG.isMDXComponent=!0;const AG={toc:[]};function IG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}IG.isMDXComponent=!0;const WG={toc:[]};function EG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}EG.isMDXComponent=!0;const FG={toc:[]};function BG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}BG.isMDXComponent=!0;const OG={toc:[]};function GG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}GG.isMDXComponent=!0;const jG={toc:[]};function UG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}UG.isMDXComponent=!0;const qG={toc:[]};function VG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color of the image at the given position."))}VG.isMDXComponent=!0;const HG={toc:[]};function $G(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position in local space at which to sample the color."))}$G.isMDXComponent=!0;const QG={toc:[]};function JG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color of the image at the given pixel."))}JG.isMDXComponent=!0;const YG={toc:[]};function KG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The pixel's position."))}KG.isMDXComponent=!0;const tj={toc:[]};function ej(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"overrides ",(0,p.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}ej.isMDXComponent=!0;const nj={toc:[]};function oj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}oj.isMDXComponent=!0;const sj={toc:[]};function rj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}rj.isMDXComponent=!0;const pj={toc:[]};function ij(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}ij.isMDXComponent=!0;const cj={toc:[]};function aj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}aj.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}dj.isMDXComponent=!0;const hj={toc:[]};function fj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}fj.isMDXComponent=!0;const yj={toc:[]};function kj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}kj.isMDXComponent=!0;const wj={toc:[]};function Mj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Mj.isMDXComponent=!0;const Dj={toc:[]};function _j(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}_j.isMDXComponent=!0;const Xj={toc:[]};function gj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}gj.isMDXComponent=!0;const xj={toc:[]};function Cj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}Cj.isMDXComponent=!0;const Tj={toc:[]};function vj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}vj.isMDXComponent=!0;const bj={toc:[]};function Lj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}Lj.isMDXComponent=!0;const Zj={toc:[]};function Nj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Nj.isMDXComponent=!0;const Sj={toc:[]};function zj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}zj.isMDXComponent=!0;const Rj={toc:[]};function Pj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}Pj.isMDXComponent=!0;const Aj={toc:[]};function Ij(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Aj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Ij.isMDXComponent=!0;const Wj={toc:[]};function Ej(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}Ej.isMDXComponent=!0;const Fj={toc:[]};function Bj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}Bj.isMDXComponent=!0;const Oj={toc:[]};function Gj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Gj.isMDXComponent=!0;const jj={toc:[]};function Uj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Uj.isMDXComponent=!0;const qj={toc:[]};function Vj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}Vj.isMDXComponent=!0;const Hj={toc:[]};function $j(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}$j.isMDXComponent=!0;const Qj={toc:[]};function Jj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Jj.isMDXComponent=!0;const Yj={toc:[]};function Kj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Kj.isMDXComponent=!0;const tU={toc:[]};function eU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}eU.isMDXComponent=!0;const nU={toc:[]};function oU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}oU.isMDXComponent=!0;const sU={toc:[]};function rU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}rU.isMDXComponent=!0;const pU={toc:[]};function iU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}iU.isMDXComponent=!0;const cU={toc:[]};function aU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}aU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}dU.isMDXComponent=!0;const hU={toc:[]};function fU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}fU.isMDXComponent=!0;const yU={toc:[]};function kU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}kU.isMDXComponent=!0;const wU={toc:[]};function MU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}MU.isMDXComponent=!0;const DU={toc:[]};function _U(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}_U.isMDXComponent=!0;const XU={toc:[]};function gU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}gU.isMDXComponent=!0;const xU={toc:[]};function CU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}CU.isMDXComponent=!0;const TU={toc:[]};function vU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}vU.isMDXComponent=!0;const bU={toc:[]};function LU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}LU.isMDXComponent=!0;const ZU={toc:[]};function NU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}NU.isMDXComponent=!0;const SU={toc:[]};function zU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The natural size of this image."))}zU.isMDXComponent=!0;const RU={toc:[]};function PU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}PU.isMDXComponent=!0;const AU={toc:[]};function IU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}IU.isMDXComponent=!0;const WU={toc:[]};function EU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}EU.isMDXComponent=!0;const FU={toc:[]};function BU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}BU.isMDXComponent=!0;const OU={toc:[]};function GU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}GU.isMDXComponent=!0;const jU={toc:[]};function UU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}UU.isMDXComponent=!0;const qU={toc:[]};function VU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}VU.isMDXComponent=!0;const HU={toc:[]};function $U(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}$U.isMDXComponent=!0;const QU={toc:[]};function JU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}JU.isMDXComponent=!0;const YU={toc:[]};function KU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}KU.isMDXComponent=!0;const tq={toc:[]};function eq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}eq.isMDXComponent=!0;const nq={toc:[]};function oq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}oq.isMDXComponent=!0;const sq={toc:[]};function rq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}rq.isMDXComponent=!0;const pq={toc:[]};function iq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}iq.isMDXComponent=!0;const cq={toc:[]};function aq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}aq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}dq.isMDXComponent=!0;const hq={toc:[]};function fq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}fq.isMDXComponent=!0;const yq={toc:[]};function kq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}kq.isMDXComponent=!0;const wq={toc:[]};function Mq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Mq.isMDXComponent=!0;const Dq={toc:[]};function _q(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"overrides ",(0,p.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}_q.isMDXComponent=!0;const Xq={toc:[]};function gq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}gq.isMDXComponent=!0;const xq={toc:[]};function Cq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Cq.isMDXComponent=!0;const Tq={toc:[]};function vq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}vq.isMDXComponent=!0;const bq={toc:[]};function Lq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Lq.isMDXComponent=!0;const Zq={toc:[]};function Nq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Nq.isMDXComponent=!0;const Sq={toc:[]};function zq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}zq.isMDXComponent=!0;const Rq={toc:[]};function Pq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Address to Iconify API for the requested Icon."))}Pq.isMDXComponent=!0;const Aq={toc:[]};function Iq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Aq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create the URL that will be used as the Image source"))}Iq.isMDXComponent=!0;const Wq={toc:[]};function Eq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Eq.isMDXComponent=!0;const Fq={toc:[]};function Bq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Bq.isMDXComponent=!0;const Oq={toc:[]};function Gq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}Gq.isMDXComponent=!0;const jq={toc:[]};function Uq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Uq.isMDXComponent=!0;const qq={toc:[]};function Vq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Vq.isMDXComponent=!0;const Hq={toc:[]};function $q(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}$q.isMDXComponent=!0;const Qq={toc:[]};function Jq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Jq.isMDXComponent=!0;const Yq={toc:[]};function Kq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}Kq.isMDXComponent=!0;const tV={toc:[]};function eV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}eV.isMDXComponent=!0;const nV={toc:[]};function oV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}oV.isMDXComponent=!0;const sV={toc:[]};function rV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}rV.isMDXComponent=!0;const pV={toc:[]};function iV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node for displaying images."))}iV.isMDXComponent=!0;const cV={toc:[]};function aV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}aV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}dV.isMDXComponent=!0;const hV={toc:[]};function fV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}fV.isMDXComponent=!0;const yV={toc:[]};function kV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}kV.isMDXComponent=!0;const wV={toc:[]};function MV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}MV.isMDXComponent=!0;const DV={toc:[]};function _V(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}_V.isMDXComponent=!0;const XV={toc:[]};function gV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The alpha value of this image."))}gV.isMDXComponent=!0;const xV={toc:[]};function CV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}CV.isMDXComponent=!0;const TV={toc:[]};function vV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}vV.isMDXComponent=!0;const bV={toc:[]};function LV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}LV.isMDXComponent=!0;const ZV={toc:[]};function NV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}NV.isMDXComponent=!0;const SV={toc:[]};function zV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}zV.isMDXComponent=!0;const RV={toc:[]};function PV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}PV.isMDXComponent=!0;const AV={toc:[]};function IV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}IV.isMDXComponent=!0;const WV={toc:[]};function EV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}EV.isMDXComponent=!0;const FV={toc:[]};function BV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}BV.isMDXComponent=!0;const OV={toc:[]};function GV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}GV.isMDXComponent=!0;const jV={toc:[]};function UV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}UV.isMDXComponent=!0;const qV={toc:[]};function VV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}VV.isMDXComponent=!0;const HV={toc:[]};function $V(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}$V.isMDXComponent=!0;const QV={toc:[]};function JV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}JV.isMDXComponent=!0;const YV={toc:[]};function KV(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YV,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}KV.isMDXComponent=!0;const tH={toc:[]};function eH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}eH.isMDXComponent=!0;const nH={toc:[]};function oH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}oH.isMDXComponent=!0;const sH={toc:[]};function rH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}rH.isMDXComponent=!0;const pH={toc:[]};function iH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}iH.isMDXComponent=!0;const cH={toc:[]};function aH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}aH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}dH.isMDXComponent=!0;const hH={toc:[]};function fH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}fH.isMDXComponent=!0;const yH={toc:[]};function kH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}kH.isMDXComponent=!0;const wH={toc:[]};function MH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}MH.isMDXComponent=!0;const DH={toc:[]};function _H(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}_H.isMDXComponent=!0;const XH={toc:[]};function gH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}gH.isMDXComponent=!0;const xH={toc:[]};function CH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"true"))}CH.isMDXComponent=!0;const TH={toc:[]};function vH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the image should be smoothed."))}vH.isMDXComponent=!0;const bH={toc:[]};function LH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Using a local image:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,p.kt)("p",null,"Loading an image from the internet:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}LH.isMDXComponent=!0;const ZH={toc:[]};function NH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The source of this image."))}NH.isMDXComponent=!0;const SH={toc:[]};function zH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}zH.isMDXComponent=!0;const RH={toc:[]};function PH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}PH.isMDXComponent=!0;const AH={toc:[]};function IH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}IH.isMDXComponent=!0;const WH={toc:[]};function EH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}EH.isMDXComponent=!0;const FH={toc:[]};function BH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}BH.isMDXComponent=!0;const OH={toc:[]};function GH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}GH.isMDXComponent=!0;const jH={toc:[]};function UH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}UH.isMDXComponent=!0;const qH={toc:[]};function VH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}VH.isMDXComponent=!0;const HH={toc:[]};function $H(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}$H.isMDXComponent=!0;const QH={toc:[]};function JH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}JH.isMDXComponent=!0;const YH={toc:[]};function KH(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YH,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}KH.isMDXComponent=!0;const t$={toc:[]};function e$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},t$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}e$.isMDXComponent=!0;const n$={toc:[]};function o$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},n$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}o$.isMDXComponent=!0;const s$={toc:[]};function r$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},s$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}r$.isMDXComponent=!0;const p$={toc:[]};function i$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},p$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}i$.isMDXComponent=!0;const c$={toc:[]};function a$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},c$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}a$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},l$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},m$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}d$.isMDXComponent=!0;const h$={toc:[]};function f$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},h$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}f$.isMDXComponent=!0;const y$={toc:[]};function k$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},y$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}k$.isMDXComponent=!0;const w$={toc:[]};function M$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},w$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}M$.isMDXComponent=!0;const D$={toc:[]};function _$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},D$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}_$.isMDXComponent=!0;const X$={toc:[]};function g$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},X$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}g$.isMDXComponent=!0;const x$={toc:[]};function C$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},x$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}C$.isMDXComponent=!0;const T$={toc:[]};function v$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},T$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}v$.isMDXComponent=!0;const b$={toc:[]};function L$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},b$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}L$.isMDXComponent=!0;const Z$={toc:[]};function N$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Z$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}N$.isMDXComponent=!0;const S$={toc:[]};function z$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},S$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}z$.isMDXComponent=!0;const R$={toc:[]};function P$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},R$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}P$.isMDXComponent=!0;const A$={toc:[]};function I$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},A$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}I$.isMDXComponent=!0;const W$={toc:[]};function E$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},W$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}E$.isMDXComponent=!0;const F$={toc:[]};function B$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},F$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}B$.isMDXComponent=!0;const O$={toc:[]};function G$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},O$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}G$.isMDXComponent=!0;const j$={toc:[]};function U$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},j$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}U$.isMDXComponent=!0;const q$={toc:[]};function V$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},q$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color of the image at the given position."))}V$.isMDXComponent=!0;const H$={toc:[]};function $$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},H$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position in local space at which to sample the color."))}$$.isMDXComponent=!0;const Q$={toc:[]};function J$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Q$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color of the image at the given pixel."))}J$.isMDXComponent=!0;const Y$={toc:[]};function K$(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Y$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The pixel's position."))}K$.isMDXComponent=!0;const tQ={toc:[]};function eQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}eQ.isMDXComponent=!0;const nQ={toc:[]};function oQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}oQ.isMDXComponent=!0;const sQ={toc:[]};function rQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}rQ.isMDXComponent=!0;const pQ={toc:[]};function iQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}iQ.isMDXComponent=!0;const cQ={toc:[]};function aQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}aQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function fQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}fQ.isMDXComponent=!0;const yQ={toc:[]};function kQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}kQ.isMDXComponent=!0;const wQ={toc:[]};function MQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}MQ.isMDXComponent=!0;const DQ={toc:[]};function _Q(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}_Q.isMDXComponent=!0;const XQ={toc:[]};function gQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}gQ.isMDXComponent=!0;const xQ={toc:[]};function CQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}CQ.isMDXComponent=!0;const TQ={toc:[]};function vQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}vQ.isMDXComponent=!0;const bQ={toc:[]};function LQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}LQ.isMDXComponent=!0;const ZQ={toc:[]};function NQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}NQ.isMDXComponent=!0;const SQ={toc:[]};function zQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}zQ.isMDXComponent=!0;const RQ={toc:[]};function PQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}PQ.isMDXComponent=!0;const AQ={toc:[]};function IQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}IQ.isMDXComponent=!0;const WQ={toc:[]};function EQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}EQ.isMDXComponent=!0;const FQ={toc:[]};function BQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}BQ.isMDXComponent=!0;const OQ={toc:[]};function GQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}GQ.isMDXComponent=!0;const jQ={toc:[]};function UQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}UQ.isMDXComponent=!0;const qQ={toc:[]};function VQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}VQ.isMDXComponent=!0;const HQ={toc:[]};function $Q(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}$Q.isMDXComponent=!0;const QQ={toc:[]};function JQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}JQ.isMDXComponent=!0;const YQ={toc:[]};function KQ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YQ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}KQ.isMDXComponent=!0;const tJ={toc:[]};function eJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}eJ.isMDXComponent=!0;const nJ={toc:[]};function oJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}oJ.isMDXComponent=!0;const sJ={toc:[]};function rJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}rJ.isMDXComponent=!0;const pJ={toc:[]};function iJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}iJ.isMDXComponent=!0;const cJ={toc:[]};function aJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}aJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function fJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}fJ.isMDXComponent=!0;const yJ={toc:[]};function kJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}kJ.isMDXComponent=!0;const wJ={toc:[]};function MJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}MJ.isMDXComponent=!0;const DJ={toc:[]};function _J(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}_J.isMDXComponent=!0;const XJ={toc:[]};function gJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}gJ.isMDXComponent=!0;const xJ={toc:[]};function CJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}CJ.isMDXComponent=!0;const TJ={toc:[]};function vJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}vJ.isMDXComponent=!0;const bJ={toc:[]};function LJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}LJ.isMDXComponent=!0;const ZJ={toc:[]};function NJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The natural size of this image."))}NJ.isMDXComponent=!0;const SJ={toc:[]};function zJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}zJ.isMDXComponent=!0;const RJ={toc:[]};function PJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}PJ.isMDXComponent=!0;const AJ={toc:[]};function IJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}IJ.isMDXComponent=!0;const WJ={toc:[]};function EJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}EJ.isMDXComponent=!0;const FJ={toc:[]};function BJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}BJ.isMDXComponent=!0;const OJ={toc:[]};function GJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}GJ.isMDXComponent=!0;const jJ={toc:[]};function UJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}UJ.isMDXComponent=!0;const qJ={toc:[]};function VJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}VJ.isMDXComponent=!0;const HJ={toc:[]};function $J(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}$J.isMDXComponent=!0;const QJ={toc:[]};function JJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}JJ.isMDXComponent=!0;const YJ={toc:[]};function KJ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YJ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}KJ.isMDXComponent=!0;const tY={toc:[]};function eY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}eY.isMDXComponent=!0;const nY={toc:[]};function oY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}oY.isMDXComponent=!0;const sY={toc:[]};function rY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}rY.isMDXComponent=!0;const pY={toc:[]};function iY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}iY.isMDXComponent=!0;const cY={toc:[]};function aY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}aY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}dY.isMDXComponent=!0;const hY={toc:[]};function fY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}fY.isMDXComponent=!0;const yY={toc:[]};function kY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}kY.isMDXComponent=!0;const wY={toc:[]};function MY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}MY.isMDXComponent=!0;const DY={toc:[]};function _Y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}_Y.isMDXComponent=!0;const XY={toc:[]};function gY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}gY.isMDXComponent=!0;const xY={toc:[]};function CY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}CY.isMDXComponent=!0;const TY={toc:[]};function vY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}vY.isMDXComponent=!0;const bY={toc:[]};function LY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}LY.isMDXComponent=!0;const ZY={toc:[]};function NY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}NY.isMDXComponent=!0;const SY={toc:[]};function zY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}zY.isMDXComponent=!0;const RY={toc:[]};function PY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}PY.isMDXComponent=!0;const AY={toc:[]};function IY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}IY.isMDXComponent=!0;const WY={toc:[]};function EY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}EY.isMDXComponent=!0;const FY={toc:[]};function BY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}BY.isMDXComponent=!0;const OY={toc:[]};function GY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}GY.isMDXComponent=!0;const jY={toc:[]};function UY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}UY.isMDXComponent=!0;const qY={toc:[]};function VY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}VY.isMDXComponent=!0;const HY={toc:[]};function $Y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}$Y.isMDXComponent=!0;const QY={toc:[]};function JY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node representing a knot of a ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,p.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}JY.isMDXComponent=!0;const YY={toc:[]};function KY(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YY,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}KY.isMDXComponent=!0;const tK={toc:[]};function eK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}eK.isMDXComponent=!0;const nK={toc:[]};function oK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}oK.isMDXComponent=!0;const sK={toc:[]};function rK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}rK.isMDXComponent=!0;const pK={toc:[]};function iK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}iK.isMDXComponent=!0;const cK={toc:[]};function aK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}aK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"0"))}dK.isMDXComponent=!0;const hK={toc:[]};function fK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}fK.isMDXComponent=!0;const yK={toc:[]};function kK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,p.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,p.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,p.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,p.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}kK.isMDXComponent=!0;const wK={toc:[]};function MK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Mirrored position of the startHandle."))}MK.isMDXComponent=!0;const DK={toc:[]};function _K(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}_K.isMDXComponent=!0;const XK={toc:[]};function gK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},XK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}gK.isMDXComponent=!0;const xK={toc:[]};function CK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}CK.isMDXComponent=!0;const TK={toc:[]};function vK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},TK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}vK.isMDXComponent=!0;const bK={toc:[]};function LK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}LK.isMDXComponent=!0;const ZK={toc:[]};function NK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}NK.isMDXComponent=!0;const SK={toc:[]};function zK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,p.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,p.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,p.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,p.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}zK.isMDXComponent=!0;const RK={toc:[]};function PK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Mirrored position of the endHandle."))}PK.isMDXComponent=!0;const AK={toc:[]};function IK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}IK.isMDXComponent=!0;const WK={toc:[]};function EK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}EK.isMDXComponent=!0;const FK={toc:[]};function BK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},FK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}BK.isMDXComponent=!0;const OK={toc:[]};function GK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},OK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}GK.isMDXComponent=!0;const jK={toc:[]};function UK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}UK.isMDXComponent=!0;const qK={toc:[]};function VK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}VK.isMDXComponent=!0;const HK={toc:[]};function $K(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}$K.isMDXComponent=!0;const QK={toc:[]};function JK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},QK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}JK.isMDXComponent=!0;const YK={toc:[]};function KK(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YK,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}KK.isMDXComponent=!0;const t0={toc:[]};function e0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},t0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}e0.isMDXComponent=!0;const n0={toc:[]};function o0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},n0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}o0.isMDXComponent=!0;const s0={toc:[]};function r0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},s0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}r0.isMDXComponent=!0;const p0={toc:[]};function i0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},p0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}i0.isMDXComponent=!0;const c0={toc:[]};function a0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},c0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}a0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},l0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},m0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}d0.isMDXComponent=!0;const h0={toc:[]};function f0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},h0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}f0.isMDXComponent=!0;const y0={toc:[]};function k0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},y0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}k0.isMDXComponent=!0;const w0={toc:[]};function M0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},w0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}M0.isMDXComponent=!0;const D0={toc:[]};function _0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},D0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}_0.isMDXComponent=!0;const X0={toc:[]};function g0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},X0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}g0.isMDXComponent=!0;const x0={toc:[]};function C0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},x0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}C0.isMDXComponent=!0;const T0={toc:[]};function v0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},T0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}v0.isMDXComponent=!0;const b0={toc:[]};function L0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},b0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}L0.isMDXComponent=!0;const Z0={toc:[]};function N0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Z0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}N0.isMDXComponent=!0;const S0={toc:[]};function z0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},S0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}z0.isMDXComponent=!0;const R0={toc:[]};function P0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},R0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}P0.isMDXComponent=!0;const A0={toc:[]};function I0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},A0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}I0.isMDXComponent=!0;const W0={toc:[]};function E0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},W0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}E0.isMDXComponent=!0;const F0={toc:[]};function B0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},F0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}B0.isMDXComponent=!0;const O0={toc:[]};function G0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},O0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}G0.isMDXComponent=!0;const j0={toc:[]};function U0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},j0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}U0.isMDXComponent=!0;const q0={toc:[]};function V0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},q0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}V0.isMDXComponent=!0;const H0={toc:[]};function $0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},H0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}$0.isMDXComponent=!0;const Q0={toc:[]};function J0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Q0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}J0.isMDXComponent=!0;const Y0={toc:[]};function K0(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Y0,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}K0.isMDXComponent=!0;const t2={toc:[]};function e2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},t2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}e2.isMDXComponent=!0;const n2={toc:[]};function o2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},n2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}o2.isMDXComponent=!0;const s2={toc:[]};function r2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},s2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}r2.isMDXComponent=!0;const p2={toc:[]};function i2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},p2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}i2.isMDXComponent=!0;const c2={toc:[]};function a2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},c2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}a2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},l2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},m2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}d2.isMDXComponent=!0;const h2={toc:[]};function f2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},h2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}f2.isMDXComponent=!0;const y2={toc:[]};function k2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},y2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}k2.isMDXComponent=!0;const w2={toc:[]};function M2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},w2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}M2.isMDXComponent=!0;const D2={toc:[]};function _2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},D2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}_2.isMDXComponent=!0;const X2={toc:[]};function g2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},X2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}g2.isMDXComponent=!0;const x2={toc:[]};function C2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},x2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}C2.isMDXComponent=!0;const T2={toc:[]};function v2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},T2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}v2.isMDXComponent=!0;const b2={toc:[]};function L2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},b2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}L2.isMDXComponent=!0;const Z2={toc:[]};function N2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Z2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}N2.isMDXComponent=!0;const S2={toc:[]};function z2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},S2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}z2.isMDXComponent=!0;const R2={toc:[]};function P2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},R2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}P2.isMDXComponent=!0;const A2={toc:[]};function I2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},A2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}I2.isMDXComponent=!0;const W2={toc:[]};function E2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},W2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}E2.isMDXComponent=!0;const F2={toc:[]};function B2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},F2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}B2.isMDXComponent=!0;const O2={toc:[]};function G2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},O2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}G2.isMDXComponent=!0;const j2={toc:[]};function U2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},j2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}U2.isMDXComponent=!0;const q2={toc:[]};function V2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},q2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}V2.isMDXComponent=!0;const H2={toc:[]};function $2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},H2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}$2.isMDXComponent=!0;const Q2={toc:[]};function J2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Q2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}J2.isMDXComponent=!0;const Y2={toc:[]};function K2(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Y2,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}K2.isMDXComponent=!0;const t1={toc:[]};function e1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},t1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}e1.isMDXComponent=!0;const n1={toc:[]};function o1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},n1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}o1.isMDXComponent=!0;const s1={toc:[]};function r1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},s1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}r1.isMDXComponent=!0;const p1={toc:[]};function i1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},p1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}i1.isMDXComponent=!0;const c1={toc:[]};function a1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},c1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}a1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},l1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},m1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}d1.isMDXComponent=!0;const h1={toc:[]};function f1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},h1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}f1.isMDXComponent=!0;const y1={toc:[]};function k1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},y1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}k1.isMDXComponent=!0;const w1={toc:[]};function M1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},w1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}M1.isMDXComponent=!0;const D1={toc:[]};function _1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},D1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}_1.isMDXComponent=!0;const X1={toc:[]};function g1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},X1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}g1.isMDXComponent=!0;const x1={toc:[]};function C1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},x1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}C1.isMDXComponent=!0;const T1={toc:[]};function v1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},T1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}v1.isMDXComponent=!0;const b1={toc:[]};function L1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},b1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}L1.isMDXComponent=!0;const Z1={toc:[]};function N1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Z1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}N1.isMDXComponent=!0;const S1={toc:[]};function z1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},S1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}z1.isMDXComponent=!0;const R1={toc:[]};function P1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},R1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}P1.isMDXComponent=!0;const A1={toc:[]};function I1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},A1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}I1.isMDXComponent=!0;const W1={toc:[]};function E1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},W1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}E1.isMDXComponent=!0;const F1={toc:[]};function B1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},F1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}B1.isMDXComponent=!0;const O1={toc:[]};function G1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},O1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}G1.isMDXComponent=!0;const j1={toc:[]};function U1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},j1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}U1.isMDXComponent=!0;const q1={toc:[]};function V1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},q1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}V1.isMDXComponent=!0;const H1={toc:[]};function $1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},H1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}$1.isMDXComponent=!0;const Q1={toc:[]};function J1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Q1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}J1.isMDXComponent=!0;const Y1={toc:[]};function K1(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Y1,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}K1.isMDXComponent=!0;const t4={toc:[]};function e4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},t4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}e4.isMDXComponent=!0;const n4={toc:[]};function o4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},n4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}o4.isMDXComponent=!0;const s4={toc:[]};function r4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},s4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}r4.isMDXComponent=!0;const p4={toc:[]};function i4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},p4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}i4.isMDXComponent=!0;const c4={toc:[]};function a4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},c4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}a4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},l4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},m4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}d4.isMDXComponent=!0;const h4={toc:[]};function f4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},h4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}f4.isMDXComponent=!0;const y4={toc:[]};function k4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},y4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node for displaying images."))}k4.isMDXComponent=!0;const w4={toc:[]};function M4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},w4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}M4.isMDXComponent=!0;const D4={toc:[]};function _4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},D4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}_4.isMDXComponent=!0;const X4={toc:[]};function g4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},X4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}g4.isMDXComponent=!0;const x4={toc:[]};function C4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},x4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}C4.isMDXComponent=!0;const T4={toc:[]};function v4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},T4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}v4.isMDXComponent=!0;const b4={toc:[]};function L4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},b4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}L4.isMDXComponent=!0;const Z4={toc:[]};function N4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Z4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}N4.isMDXComponent=!0;const S4={toc:[]};function z4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},S4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The alpha value of this image."))}z4.isMDXComponent=!0;const R4={toc:[]};function P4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},R4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}P4.isMDXComponent=!0;const A4={toc:[]};function I4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},A4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}I4.isMDXComponent=!0;const W4={toc:[]};function E4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},W4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}E4.isMDXComponent=!0;const F4={toc:[]};function B4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},F4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}B4.isMDXComponent=!0;const O4={toc:[]};function G4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},O4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}G4.isMDXComponent=!0;const j4={toc:[]};function U4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},j4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}U4.isMDXComponent=!0;const q4={toc:[]};function V4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},q4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}V4.isMDXComponent=!0;const H4={toc:[]};function $4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},H4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}$4.isMDXComponent=!0;const Q4={toc:[]};function J4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Q4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}J4.isMDXComponent=!0;const Y4={toc:[]};function K4(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Y4,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}K4.isMDXComponent=!0;const t6={toc:[]};function e6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},t6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}e6.isMDXComponent=!0;const n6={toc:[]};function o6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},n6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}o6.isMDXComponent=!0;const s6={toc:[]};function r6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},s6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}r6.isMDXComponent=!0;const p6={toc:[]};function i6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},p6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}i6.isMDXComponent=!0;const c6={toc:[]};function a6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},c6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}a6.isMDXComponent=!0;const l6={toc:[]};function u6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},l6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}u6.isMDXComponent=!0;const m6={toc:[]};function d6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},m6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}d6.isMDXComponent=!0;const h6={toc:[]};function f6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},h6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}f6.isMDXComponent=!0;const y6={toc:[]};function k6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},y6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}k6.isMDXComponent=!0;const w6={toc:[]};function M6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},w6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}M6.isMDXComponent=!0;const D6={toc:[]};function _6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},D6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}_6.isMDXComponent=!0;const X6={toc:[]};function g6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},X6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}g6.isMDXComponent=!0;const x6={toc:[]};function C6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},x6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}C6.isMDXComponent=!0;const T6={toc:[]};function v6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},T6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}v6.isMDXComponent=!0;const b6={toc:[]};function L6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},b6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}L6.isMDXComponent=!0;const Z6={toc:[]};function N6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Z6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}N6.isMDXComponent=!0;const S6={toc:[]};function z6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},S6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}z6.isMDXComponent=!0;const R6={toc:[]};function P6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},R6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"true"))}P6.isMDXComponent=!0;const A6={toc:[]};function I6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},A6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the image should be smoothed."))}I6.isMDXComponent=!0;const W6={toc:[]};function E6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},W6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Using a local image:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,p.kt)("p",null,"Loading an image from the internet:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}E6.isMDXComponent=!0;const F6={toc:[]};function B6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},F6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The source of this image."))}B6.isMDXComponent=!0;const O6={toc:[]};function G6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},O6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}G6.isMDXComponent=!0;const j6={toc:[]};function U6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},j6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}U6.isMDXComponent=!0;const q6={toc:[]};function V6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},q6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}V6.isMDXComponent=!0;const H6={toc:[]};function $6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},H6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}$6.isMDXComponent=!0;const Q6={toc:[]};function J6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Q6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}J6.isMDXComponent=!0;const Y6={toc:[]};function K6(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Y6,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}K6.isMDXComponent=!0;const t3={toc:[]};function e3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},t3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}e3.isMDXComponent=!0;const n3={toc:[]};function o3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},n3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}o3.isMDXComponent=!0;const s3={toc:[]};function r3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},s3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}r3.isMDXComponent=!0;const p3={toc:[]};function i3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},p3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}i3.isMDXComponent=!0;const c3={toc:[]};function a3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},c3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}a3.isMDXComponent=!0;const l3={toc:[]};function u3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},l3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},m3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}d3.isMDXComponent=!0;const h3={toc:[]};function f3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},h3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}f3.isMDXComponent=!0;const y3={toc:[]};function k3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},y3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}k3.isMDXComponent=!0;const w3={toc:[]};function M3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},w3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}M3.isMDXComponent=!0;const D3={toc:[]};function _3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},D3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}_3.isMDXComponent=!0;const X3={toc:[]};function g3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},X3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}g3.isMDXComponent=!0;const x3={toc:[]};function C3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},x3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}C3.isMDXComponent=!0;const T3={toc:[]};function v3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},T3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}v3.isMDXComponent=!0;const b3={toc:[]};function L3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},b3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}L3.isMDXComponent=!0;const Z3={toc:[]};function N3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Z3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}N3.isMDXComponent=!0;const S3={toc:[]};function z3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},S3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}z3.isMDXComponent=!0;const R3={toc:[]};function P3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},R3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}P3.isMDXComponent=!0;const A3={toc:[]};function I3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},A3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}I3.isMDXComponent=!0;const W3={toc:[]};function E3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},W3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}E3.isMDXComponent=!0;const F3={toc:[]};function B3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},F3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}B3.isMDXComponent=!0;const O3={toc:[]};function G3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},O3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}G3.isMDXComponent=!0;const j3={toc:[]};function U3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},j3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}U3.isMDXComponent=!0;const q3={toc:[]};function V3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},q3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}V3.isMDXComponent=!0;const H3={toc:[]};function $3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},H3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}$3.isMDXComponent=!0;const Q3={toc:[]};function J3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Q3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}J3.isMDXComponent=!0;const Y3={toc:[]};function K3(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Y3,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}K3.isMDXComponent=!0;const t8={toc:[]};function e8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},t8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}e8.isMDXComponent=!0;const n8={toc:[]};function o8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},n8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color of the image at the given position."))}o8.isMDXComponent=!0;const s8={toc:[]};function r8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},s8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position in local space at which to sample the color."))}r8.isMDXComponent=!0;const p8={toc:[]};function i8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},p8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color of the image at the given pixel."))}i8.isMDXComponent=!0;const c8={toc:[]};function a8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},c8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The pixel's position."))}a8.isMDXComponent=!0;const l8={toc:[]};function u8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},l8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}u8.isMDXComponent=!0;const m8={toc:[]};function d8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},m8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}d8.isMDXComponent=!0;const h8={toc:[]};function f8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},h8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}f8.isMDXComponent=!0;const y8={toc:[]};function k8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},y8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}k8.isMDXComponent=!0;const w8={toc:[]};function M8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},w8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}M8.isMDXComponent=!0;const D8={toc:[]};function _8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},D8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}_8.isMDXComponent=!0;const X8={toc:[]};function g8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},X8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}g8.isMDXComponent=!0;const x8={toc:[]};function C8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},x8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}C8.isMDXComponent=!0;const T8={toc:[]};function v8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},T8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}v8.isMDXComponent=!0;const b8={toc:[]};function L8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},b8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}L8.isMDXComponent=!0;const Z8={toc:[]};function N8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Z8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}N8.isMDXComponent=!0;const S8={toc:[]};function z8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},S8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}z8.isMDXComponent=!0;const R8={toc:[]};function P8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},R8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}P8.isMDXComponent=!0;const A8={toc:[]};function I8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},A8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}I8.isMDXComponent=!0;const W8={toc:[]};function E8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},W8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}E8.isMDXComponent=!0;const F8={toc:[]};function B8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},F8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}B8.isMDXComponent=!0;const O8={toc:[]};function G8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},O8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}G8.isMDXComponent=!0;const j8={toc:[]};function U8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},j8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}U8.isMDXComponent=!0;const q8={toc:[]};function V8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},q8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}V8.isMDXComponent=!0;const H8={toc:[]};function $8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},H8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}$8.isMDXComponent=!0;const Q8={toc:[]};function J8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Q8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}J8.isMDXComponent=!0;const Y8={toc:[]};function K8(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Y8,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}K8.isMDXComponent=!0;const t5={toc:[]};function e5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},t5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}e5.isMDXComponent=!0;const n5={toc:[]};function o5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},n5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}o5.isMDXComponent=!0;const s5={toc:[]};function r5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},s5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}r5.isMDXComponent=!0;const p5={toc:[]};function i5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},p5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}i5.isMDXComponent=!0;const c5={toc:[]};function a5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},c5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}a5.isMDXComponent=!0;const l5={toc:[]};function u5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},l5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}u5.isMDXComponent=!0;const m5={toc:[]};function d5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},m5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}d5.isMDXComponent=!0;const h5={toc:[]};function f5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},h5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}f5.isMDXComponent=!0;const y5={toc:[]};function k5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},y5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}k5.isMDXComponent=!0;const w5={toc:[]};function M5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},w5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}M5.isMDXComponent=!0;const D5={toc:[]};function _5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},D5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}_5.isMDXComponent=!0;const X5={toc:[]};function g5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},X5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}g5.isMDXComponent=!0;const x5={toc:[]};function C5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},x5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}C5.isMDXComponent=!0;const T5={toc:[]};function v5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},T5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}v5.isMDXComponent=!0;const b5={toc:[]};function L5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},b5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}L5.isMDXComponent=!0;const Z5={toc:[]};function N5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Z5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}N5.isMDXComponent=!0;const S5={toc:[]};function z5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},S5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}z5.isMDXComponent=!0;const R5={toc:[]};function P5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},R5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}P5.isMDXComponent=!0;const A5={toc:[]};function I5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},A5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}I5.isMDXComponent=!0;const W5={toc:[]};function E5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},W5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}E5.isMDXComponent=!0;const F5={toc:[]};function B5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},F5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The natural size of this image."))}B5.isMDXComponent=!0;const O5={toc:[]};function G5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},O5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}G5.isMDXComponent=!0;const j5={toc:[]};function U5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},j5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}U5.isMDXComponent=!0;const q5={toc:[]};function V5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},q5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}V5.isMDXComponent=!0;const H5={toc:[]};function $5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},H5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}$5.isMDXComponent=!0;const Q5={toc:[]};function J5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Q5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}J5.isMDXComponent=!0;const Y5={toc:[]};function K5(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Y5,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}K5.isMDXComponent=!0;const t7={toc:[]};function e7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},t7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}e7.isMDXComponent=!0;const n7={toc:[]};function o7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},n7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}o7.isMDXComponent=!0;const s7={toc:[]};function r7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},s7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}r7.isMDXComponent=!0;const p7={toc:[]};function i7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},p7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}i7.isMDXComponent=!0;const c7={toc:[]};function a7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},c7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}a7.isMDXComponent=!0;const l7={toc:[]};function u7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},l7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}u7.isMDXComponent=!0;const m7={toc:[]};function d7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},m7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}d7.isMDXComponent=!0;const h7={toc:[]};function f7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},h7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}f7.isMDXComponent=!0;const y7={toc:[]};function k7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},y7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}k7.isMDXComponent=!0;const w7={toc:[]};function M7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},w7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}M7.isMDXComponent=!0;const D7={toc:[]};function _7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},D7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}_7.isMDXComponent=!0;const X7={toc:[]};function g7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},X7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}g7.isMDXComponent=!0;const x7={toc:[]};function C7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},x7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}C7.isMDXComponent=!0;const T7={toc:[]};function v7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},T7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}v7.isMDXComponent=!0;const b7={toc:[]};function L7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},b7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}L7.isMDXComponent=!0;const Z7={toc:[]};function N7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Z7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}N7.isMDXComponent=!0;const S7={toc:[]};function z7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},S7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}z7.isMDXComponent=!0;const R7={toc:[]};function P7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},R7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}P7.isMDXComponent=!0;const A7={toc:[]};function I7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},A7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}I7.isMDXComponent=!0;const W7={toc:[]};function E7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},W7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}E7.isMDXComponent=!0;const F7={toc:[]};function B7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},F7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}B7.isMDXComponent=!0;const O7={toc:[]};function G7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},O7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}G7.isMDXComponent=!0;const j7={toc:[]};function U7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},j7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}U7.isMDXComponent=!0;const q7={toc:[]};function V7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},q7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}V7.isMDXComponent=!0;const H7={toc:[]};function $7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},H7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}$7.isMDXComponent=!0;const Q7={toc:[]};function J7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Q7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}J7.isMDXComponent=!0;const Y7={toc:[]};function K7(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Y7,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}K7.isMDXComponent=!0;const t9={toc:[]};function e9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},t9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}e9.isMDXComponent=!0;const n9={toc:[]};function o9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},n9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}o9.isMDXComponent=!0;const s9={toc:[]};function r9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},s9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}r9.isMDXComponent=!0;const p9={toc:[]};function i9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},p9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}i9.isMDXComponent=!0;const c9={toc:[]};function a9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},c9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}a9.isMDXComponent=!0;const l9={toc:[]};function u9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},l9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}u9.isMDXComponent=!0;const m9={toc:[]};function d9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},m9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}d9.isMDXComponent=!0;const h9={toc:[]};function f9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},h9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}f9.isMDXComponent=!0;const y9={toc:[]};function k9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},y9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}k9.isMDXComponent=!0;const w9={toc:[]};function M9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},w9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}M9.isMDXComponent=!0;const D9={toc:[]};function _9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},D9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}_9.isMDXComponent=!0;const X9={toc:[]};function g9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},X9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}g9.isMDXComponent=!0;const x9={toc:[]};function C9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},x9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}C9.isMDXComponent=!0;const T9={toc:[]};function v9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},T9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}v9.isMDXComponent=!0;const b9={toc:[]};function L9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},b9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}L9.isMDXComponent=!0;const Z9={toc:[]};function N9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Z9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}N9.isMDXComponent=!0;const S9={toc:[]};function z9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},S9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}z9.isMDXComponent=!0;const R9={toc:[]};function P9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},R9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}P9.isMDXComponent=!0;const A9={toc:[]};function I9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},A9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}I9.isMDXComponent=!0;const W9={toc:[]};function E9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},W9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}E9.isMDXComponent=!0;const F9={toc:[]};function B9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},F9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}B9.isMDXComponent=!0;const O9={toc:[]};function G9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},O9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}G9.isMDXComponent=!0;const j9={toc:[]};function U9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},j9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}U9.isMDXComponent=!0;const q9={toc:[]};function V9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},q9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}V9.isMDXComponent=!0;const H9={toc:[]};function $9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},H9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}$9.isMDXComponent=!0;const Q9={toc:[]};function J9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Q9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}J9.isMDXComponent=!0;const Y9={toc:[]};function K9(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Y9,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}K9.isMDXComponent=!0;const ttt={toc:[]};function ett(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ttt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ett.isMDXComponent=!0;const ntt={toc:[]};function ott(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ntt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}ott.isMDXComponent=!0;const stt={toc:[]};function rtt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},stt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}rtt.isMDXComponent=!0;const ptt={toc:[]};function itt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ptt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}itt.isMDXComponent=!0;const ctt={toc:[]};function att(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ctt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}att.isMDXComponent=!0;const ltt={toc:[]};function utt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ltt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}utt.isMDXComponent=!0;const mtt={toc:[]};function dtt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}dtt.isMDXComponent=!0;const htt={toc:[]};function ftt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},htt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}ftt.isMDXComponent=!0;const ytt={toc:[]};function ktt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ytt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}ktt.isMDXComponent=!0;const wtt={toc:[]};function Mtt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Mtt.isMDXComponent=!0;const Dtt={toc:[]};function _tt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}_tt.isMDXComponent=!0;const Xtt={toc:[]};function gtt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}gtt.isMDXComponent=!0;const xtt={toc:[]};function Ctt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Ctt.isMDXComponent=!0;const Ttt={toc:[]};function vtt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ttt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}vtt.isMDXComponent=!0;const btt={toc:[]};function Ltt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},btt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Ltt.isMDXComponent=!0;const Ztt={toc:[]};function Ntt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ztt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Ntt.isMDXComponent=!0;const Stt={toc:[]};function ztt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Stt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}ztt.isMDXComponent=!0;const Rtt={toc:[]};function Ptt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Ptt.isMDXComponent=!0;const Att={toc:[]};function Itt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Att,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Itt.isMDXComponent=!0;const Wtt={toc:[]};function Ett(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Ett.isMDXComponent=!0;const Ftt={toc:[]};function Btt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ftt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Btt.isMDXComponent=!0;const Ott={toc:[]};function Gtt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ott,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Gtt.isMDXComponent=!0;const jtt={toc:[]};function Utt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}Utt.isMDXComponent=!0;const qtt={toc:[]};function Vtt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Vtt.isMDXComponent=!0;const Htt={toc:[]};function $tt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Htt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}$tt.isMDXComponent=!0;const Qtt={toc:[]};function Jtt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qtt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Jtt.isMDXComponent=!0;const Ytt={toc:[]};function Ktt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ytt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Ktt.isMDXComponent=!0;const tet={toc:[]};function eet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}eet.isMDXComponent=!0;const net={toc:[]};function oet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},net,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}oet.isMDXComponent=!0;const set={toc:[]};function ret(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},set,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}ret.isMDXComponent=!0;const pet={toc:[]};function iet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}iet.isMDXComponent=!0;const cet={toc:[]};function aet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}aet.isMDXComponent=!0;const uet={toc:[]};function met(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}met.isMDXComponent=!0;const det={toc:[]};function het(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},det,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}het.isMDXComponent=!0;const fet={toc:[]};function yet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}yet.isMDXComponent=!0;const ket={toc:[]};function wet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ket,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}wet.isMDXComponent=!0;const Met={toc:[]};function Det(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Met,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Det.isMDXComponent=!0;const _et={toc:[]};function Xet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_et,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}Xet.isMDXComponent=!0;const get={toc:[]};function xet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},get,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}xet.isMDXComponent=!0;const Cet={toc:[]};function Tet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Tet.isMDXComponent=!0;const vet={toc:[]};function bet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}bet.isMDXComponent=!0;const Let={toc:[]};function Zet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Let,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Zet.isMDXComponent=!0;const Net={toc:[]};function Set(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Net,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}Set.isMDXComponent=!0;const zet={toc:[]};function Ret(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}Ret.isMDXComponent=!0;const Pet={toc:[]};function Aet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Aet.isMDXComponent=!0;const Iet={toc:[]};function Wet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Wet.isMDXComponent=!0;const Eet={toc:[]};function Fet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Fet.isMDXComponent=!0;const Bet={toc:[]};function Oet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}Oet.isMDXComponent=!0;const Get={toc:[]};function jet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Get,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}jet.isMDXComponent=!0;const Uet={toc:[]};function qet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}qet.isMDXComponent=!0;const Vet={toc:[]};function Het(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Het.isMDXComponent=!0;const $et={toc:[]};function Qet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$et,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Qet.isMDXComponent=!0;const Jet={toc:[]};function Yet(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jet,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}Yet.isMDXComponent=!0;const Ket={toc:[]};function tnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ket,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}tnt.isMDXComponent=!0;const ent={toc:[]};function nnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ent,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}nnt.isMDXComponent=!0;const ont={toc:[]};function snt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ont,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}snt.isMDXComponent=!0;const rnt={toc:[]};function pnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}pnt.isMDXComponent=!0;const int={toc:[]};function cnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},int,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}cnt.isMDXComponent=!0;const ant={toc:[]};function lnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ant,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}lnt.isMDXComponent=!0;const unt={toc:[]};function mnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},unt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}mnt.isMDXComponent=!0;const dnt={toc:[]};function hnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}hnt.isMDXComponent=!0;const fnt={toc:[]};function ynt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}ynt.isMDXComponent=!0;const knt={toc:[]};function wnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},knt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}wnt.isMDXComponent=!0;const Mnt={toc:[]};function Dnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Dnt.isMDXComponent=!0;const _nt={toc:[]};function Xnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_nt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Xnt.isMDXComponent=!0;const gnt={toc:[]};function xnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}xnt.isMDXComponent=!0;const Cnt={toc:[]};function Tnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Tnt.isMDXComponent=!0;const vnt={toc:[]};function bnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}bnt.isMDXComponent=!0;const Lnt={toc:[]};function Znt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Znt.isMDXComponent=!0;const Nnt={toc:[]};function Snt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Snt.isMDXComponent=!0;const znt={toc:[]};function Rnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},znt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}Rnt.isMDXComponent=!0;const Pnt={toc:[]};function Ant(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Ant.isMDXComponent=!0;const Int={toc:[]};function Wnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Int,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Wnt.isMDXComponent=!0;const Ent={toc:[]};function Fnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ent,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Fnt.isMDXComponent=!0;const Bnt={toc:[]};function Ont(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}Ont.isMDXComponent=!0;const Gnt={toc:[]};function jnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}jnt.isMDXComponent=!0;const Unt={toc:[]};function qnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Unt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}qnt.isMDXComponent=!0;const Vnt={toc:[]};function Hnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Hnt.isMDXComponent=!0;const $nt={toc:[]};function Qnt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$nt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Qnt.isMDXComponent=!0;const Jnt={toc:[]};function Ynt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jnt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Ynt.isMDXComponent=!0;const Knt={toc:[]};function tot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Knt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}tot.isMDXComponent=!0;const eot={toc:[]};function not(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}not.isMDXComponent=!0;const oot={toc:[]};function sot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}sot.isMDXComponent=!0;const rot={toc:[]};function pot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}pot.isMDXComponent=!0;const iot={toc:[]};function cot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}cot.isMDXComponent=!0;const aot={toc:[]};function lot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}lot.isMDXComponent=!0;const uot={toc:[]};function mot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}mot.isMDXComponent=!0;const dot={toc:[]};function hot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}hot.isMDXComponent=!0;const fot={toc:[]};function yot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}yot.isMDXComponent=!0;const kot={toc:[]};function wot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}wot.isMDXComponent=!0;const Mot={toc:[]};function Dot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Dot.isMDXComponent=!0;const _ot={toc:[]};function Xot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_ot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Xot.isMDXComponent=!0;const got={toc:[]};function xot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},got,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}xot.isMDXComponent=!0;const Cot={toc:[]};function Tot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}Tot.isMDXComponent=!0;const vot={toc:[]};function bot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}bot.isMDXComponent=!0;const Lot={toc:[]};function Zot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Zot.isMDXComponent=!0;const Not={toc:[]};function Sot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Not,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Sot.isMDXComponent=!0;const zot={toc:[]};function Rot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Rot.isMDXComponent=!0;const Pot={toc:[]};function Aot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Aot.isMDXComponent=!0;const Iot={toc:[]};function Wot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}Wot.isMDXComponent=!0;const Eot={toc:[]};function Fot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Fot.isMDXComponent=!0;const Bot={toc:[]};function Oot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Oot.isMDXComponent=!0;const Got={toc:[]};function jot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Got,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}jot.isMDXComponent=!0;const Uot={toc:[]};function qot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}qot.isMDXComponent=!0;const Vot={toc:[]};function Hot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Hot.isMDXComponent=!0;const $ot={toc:[]};function Qot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$ot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}Qot.isMDXComponent=!0;const Jot={toc:[]};function Yot(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Yot.isMDXComponent=!0;const Kot={toc:[]};function tst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}tst.isMDXComponent=!0;const est={toc:[]};function nst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},est,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}nst.isMDXComponent=!0;const ost={toc:[]};function sst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ost,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}sst.isMDXComponent=!0;const rst={toc:[]};function pst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}pst.isMDXComponent=!0;const ist={toc:[]};function cst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ist,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}cst.isMDXComponent=!0;const ast={toc:[]};function lst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ast,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}lst.isMDXComponent=!0;const ust={toc:[]};function mst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ust,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}mst.isMDXComponent=!0;const dst={toc:[]};function hst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}hst.isMDXComponent=!0;const fst={toc:[]};function yst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}yst.isMDXComponent=!0;const kst={toc:[]};function wst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}wst.isMDXComponent=!0;const Mst={toc:[]};function Dst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}Dst.isMDXComponent=!0;const _st={toc:[]};function Xst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_st,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}Xst.isMDXComponent=!0;const gst={toc:[]};function xst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}xst.isMDXComponent=!0;const Cst={toc:[]};function Tst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}Tst.isMDXComponent=!0;const vst={toc:[]};function bst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}bst.isMDXComponent=!0;const Lst={toc:[]};function Zst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Zst.isMDXComponent=!0;const Nst={toc:[]};function Sst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Sst.isMDXComponent=!0;const zst={toc:[]};function Rst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Rst.isMDXComponent=!0;const Pst={toc:[]};function Ast(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Ast.isMDXComponent=!0;const Ist={toc:[]};function Wst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ist,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Wst.isMDXComponent=!0;const Est={toc:[]};function Fst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Est,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}Fst.isMDXComponent=!0;const Bst={toc:[]};function Ost(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}Ost.isMDXComponent=!0;const Gst={toc:[]};function jst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}jst.isMDXComponent=!0;const Ust={toc:[]};function qst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ust,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}qst.isMDXComponent=!0;const Vst={toc:[]};function Hst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Hst.isMDXComponent=!0;const $st={toc:[]};function Qst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$st,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Qst.isMDXComponent=!0;const Jst={toc:[]};function Yst(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Yst.isMDXComponent=!0;const Kst={toc:[]};function trt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kst,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}trt.isMDXComponent=!0;const ert={toc:[]};function nrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ert,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}nrt.isMDXComponent=!0;const ort={toc:[]};function srt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ort,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}srt.isMDXComponent=!0;const rrt={toc:[]};function prt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rrt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}prt.isMDXComponent=!0;const irt={toc:[]};function crt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},irt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}crt.isMDXComponent=!0;const art={toc:[]};function lrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},art,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lrt.isMDXComponent=!0;const urt={toc:[]};function mrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},urt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}mrt.isMDXComponent=!0;const drt={toc:[]};function hrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},drt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}hrt.isMDXComponent=!0;const frt={toc:[]};function yrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},frt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}yrt.isMDXComponent=!0;const krt={toc:[]};function wrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},krt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}wrt.isMDXComponent=!0;const Mrt={toc:[]};function Drt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mrt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Drt.isMDXComponent=!0;const _rt={toc:[]};function Xrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_rt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Xrt.isMDXComponent=!0;const grt={toc:[]};function xrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},grt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}xrt.isMDXComponent=!0;const Crt={toc:[]};function Trt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Crt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Trt.isMDXComponent=!0;const vrt={toc:[]};function brt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vrt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}brt.isMDXComponent=!0;const Lrt={toc:[]};function Zrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lrt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Zrt.isMDXComponent=!0;const Nrt={toc:[]};function Srt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nrt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Srt.isMDXComponent=!0;const zrt={toc:[]};function Rrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zrt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Rrt.isMDXComponent=!0;const Prt={toc:[]};function Art(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Prt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Art.isMDXComponent=!0;const Irt={toc:[]};function Wrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Irt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Wrt.isMDXComponent=!0;const Ert={toc:[]};function Frt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ert,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}Frt.isMDXComponent=!0;const Brt={toc:[]};function Ort(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Brt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Ort.isMDXComponent=!0;const Grt={toc:[]};function jrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Grt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}jrt.isMDXComponent=!0;const Urt={toc:[]};function qrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Urt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}qrt.isMDXComponent=!0;const Vrt={toc:[]};function Hrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vrt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Hrt.isMDXComponent=!0;const $rt={toc:[]};function Qrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$rt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Qrt.isMDXComponent=!0;const Jrt={toc:[]};function Yrt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jrt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Yrt.isMDXComponent=!0;const Krt={toc:[]};function tpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Krt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}tpt.isMDXComponent=!0;const ept={toc:[]};function npt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ept,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}npt.isMDXComponent=!0;const opt={toc:[]};function spt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},opt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}spt.isMDXComponent=!0;const rpt={toc:[]};function ppt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}ppt.isMDXComponent=!0;const ipt={toc:[]};function cpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ipt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}cpt.isMDXComponent=!0;const apt={toc:[]};function lpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},apt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}lpt.isMDXComponent=!0;const upt={toc:[]};function mpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},upt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This arc length accounts for both the offset and the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}mpt.isMDXComponent=!0;const dpt={toc:[]};function hpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The visible arc length of this curve."))}hpt.isMDXComponent=!0;const fpt={toc:[]};function ypt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}ypt.isMDXComponent=!0;const kpt={toc:[]};function wpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The base arc length of this curve."))}wpt.isMDXComponent=!0;const Mpt={toc:[]};function Dpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Dpt.isMDXComponent=!0;const _pt={toc:[]};function Xpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_pt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Xpt.isMDXComponent=!0;const gpt={toc:[]};function xpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}xpt.isMDXComponent=!0;const Cpt={toc:[]};function Tpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Tpt.isMDXComponent=!0;const vpt={toc:[]};function bpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}bpt.isMDXComponent=!0;const Lpt={toc:[]};function Zpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Zpt.isMDXComponent=!0;const Npt={toc:[]};function Spt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Npt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage of the curve that's currently visible."))}Spt.isMDXComponent=!0;const zpt={toc:[]};function Rpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Rpt.isMDXComponent=!0;const Ppt={toc:[]};function Apt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ppt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Apt.isMDXComponent=!0;const Ipt={toc:[]};function Wpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ipt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Wpt.isMDXComponent=!0;const Ept={toc:[]};function Fpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ept,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}Fpt.isMDXComponent=!0;const Bpt={toc:[]};function Opt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Opt.isMDXComponent=!0;const Gpt={toc:[]};function jpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}jpt.isMDXComponent=!0;const Upt={toc:[]};function qpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Upt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}qpt.isMDXComponent=!0;const Vpt={toc:[]};function Hpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a distance along the curve to a percentage."))}Hpt.isMDXComponent=!0;const $pt={toc:[]};function Qpt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$pt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance along the curve."))}Qpt.isMDXComponent=!0;const Jpt={toc:[]};function Ypt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Ypt.isMDXComponent=!0;const Kpt={toc:[]};function tit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kpt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}tit.isMDXComponent=!0;const eit={toc:[]};function nit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}nit.isMDXComponent=!0;const oit={toc:[]};function sit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}sit.isMDXComponent=!0;const rit={toc:[]};function pit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}pit.isMDXComponent=!0;const iit={toc:[]};function cit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}cit.isMDXComponent=!0;const ait={toc:[]};function lit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ait,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}lit.isMDXComponent=!0;const uit={toc:[]};function mit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}mit.isMDXComponent=!0;const dit={toc:[]};function hit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}hit.isMDXComponent=!0;const fit={toc:[]};function yit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}yit.isMDXComponent=!0;const kit={toc:[]};function wit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}wit.isMDXComponent=!0;const Mit={toc:[]};function Dit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Dit.isMDXComponent=!0;const _it={toc:[]};function Xit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_it,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}Xit.isMDXComponent=!0;const git={toc:[]};function xit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},git,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}xit.isMDXComponent=!0;const Cit={toc:[]};function Tit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Tit.isMDXComponent=!0;const vit={toc:[]};function bit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}bit.isMDXComponent=!0;const Lit={toc:[]};function Zit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Zit.isMDXComponent=!0;const Nit={toc:[]};function Sit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}Sit.isMDXComponent=!0;const zit={toc:[]};function Rit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}Rit.isMDXComponent=!0;const Pit={toc:[]};function Ait(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Ait.isMDXComponent=!0;const Iit={toc:[]};function Wit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Wit.isMDXComponent=!0;const Eit={toc:[]};function Fit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Fit.isMDXComponent=!0;const Bit={toc:[]};function Oit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}Oit.isMDXComponent=!0;const Git={toc:[]};function jit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Git,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}jit.isMDXComponent=!0;const Uit={toc:[]};function qit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}qit.isMDXComponent=!0;const Vit={toc:[]};function Hit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Hit.isMDXComponent=!0;const $it={toc:[]};function Qit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$it,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Qit.isMDXComponent=!0;const Jit={toc:[]};function Yit(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}Yit.isMDXComponent=!0;const Kit={toc:[]};function tct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kit,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}tct.isMDXComponent=!0;const ect={toc:[]};function nct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ect,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}nct.isMDXComponent=!0;const oct={toc:[]};function sct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}sct.isMDXComponent=!0;const rct={toc:[]};function pct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}pct.isMDXComponent=!0;const ict={toc:[]};function cct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ict,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}cct.isMDXComponent=!0;const act={toc:[]};function lct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},act,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}lct.isMDXComponent=!0;const uct={toc:[]};function mct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}mct.isMDXComponent=!0;const dct={toc:[]};function hct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}hct.isMDXComponent=!0;const fct={toc:[]};function yct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}yct.isMDXComponent=!0;const kct={toc:[]};function wct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}wct.isMDXComponent=!0;const Mct={toc:[]};function Dct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Dct.isMDXComponent=!0;const _ct={toc:[]};function Xct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_ct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Xct.isMDXComponent=!0;const gct={toc:[]};function xct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}xct.isMDXComponent=!0;const Cct={toc:[]};function Tct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Tct.isMDXComponent=!0;const vct={toc:[]};function bct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}bct.isMDXComponent=!0;const Lct={toc:[]};function Zct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Zct.isMDXComponent=!0;const Nct={toc:[]};function Sct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Sct.isMDXComponent=!0;const zct={toc:[]};function Rct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}Rct.isMDXComponent=!0;const Pct={toc:[]};function Act(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Act.isMDXComponent=!0;const Ict={toc:[]};function Wct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ict,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Wct.isMDXComponent=!0;const Ect={toc:[]};function Fct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ect,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Fct.isMDXComponent=!0;const Bct={toc:[]};function Oct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}Oct.isMDXComponent=!0;const Gct={toc:[]};function jct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}jct.isMDXComponent=!0;const Uct={toc:[]};function qct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}qct.isMDXComponent=!0;const Vct={toc:[]};function Hct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the length of the curve that accounts for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Hct.isMDXComponent=!0;const $ct={toc:[]};function Qct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$ct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset arc length of this curve."))}Qct.isMDXComponent=!0;const Jct={toc:[]};function Yct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Yct.isMDXComponent=!0;const Kct={toc:[]};function tat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a percentage along the curve to a distance."))}tat.isMDXComponent=!0;const eat={toc:[]};function nat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage along the curve."))}nat.isMDXComponent=!0;const oat={toc:[]};function sat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}sat.isMDXComponent=!0;const rat={toc:[]};function pat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}pat.isMDXComponent=!0;const iat={toc:[]};function cat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}cat.isMDXComponent=!0;const aat={toc:[]};function lat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}lat.isMDXComponent=!0;const uat={toc:[]};function mat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}mat.isMDXComponent=!0;const dat={toc:[]};function hat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}hat.isMDXComponent=!0;const fat={toc:[]};function yat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}yat.isMDXComponent=!0;const kat={toc:[]};function wat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}wat.isMDXComponent=!0;const Mat={toc:[]};function Dat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Dat.isMDXComponent=!0;const _at={toc:[]};function Xat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_at,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}Xat.isMDXComponent=!0;const gat={toc:[]};function xat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}xat.isMDXComponent=!0;const Cat={toc:[]};function Tat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Tat.isMDXComponent=!0;const vat={toc:[]};function bat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}bat.isMDXComponent=!0;const Lat={toc:[]};function Zat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Zat.isMDXComponent=!0;const Nat={toc:[]};function Sat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Sat.isMDXComponent=!0;const zat={toc:[]};function Rat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}Rat.isMDXComponent=!0;const Pat={toc:[]};function Aat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}Aat.isMDXComponent=!0;const Iat={toc:[]};function Wat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}Wat.isMDXComponent=!0;const Eat={toc:[]};function Fat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Fat.isMDXComponent=!0;const Bat={toc:[]};function Oat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Oat.isMDXComponent=!0;const Gat={toc:[]};function jat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}jat.isMDXComponent=!0;const Uat={toc:[]};function qat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}qat.isMDXComponent=!0;const Vat={toc:[]};function Hat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}Hat.isMDXComponent=!0;const $at={toc:[]};function Qat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$at,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Qat.isMDXComponent=!0;const Jat={toc:[]};function Yat(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Yat.isMDXComponent=!0;const Kat={toc:[]};function tlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kat,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}tlt.isMDXComponent=!0;const elt={toc:[]};function nlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},elt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}nlt.isMDXComponent=!0;const olt={toc:[]};function slt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},olt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}slt.isMDXComponent=!0;const rlt={toc:[]};function plt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rlt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}plt.isMDXComponent=!0;const ilt={toc:[]};function clt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ilt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}clt.isMDXComponent=!0;const alt={toc:[]};function llt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},alt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}llt.isMDXComponent=!0;const ult={toc:[]};function mlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ult,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}mlt.isMDXComponent=!0;const dlt={toc:[]};function hlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dlt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}hlt.isMDXComponent=!0;const flt={toc:[]};function ylt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},flt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}ylt.isMDXComponent=!0;const klt={toc:[]};function wlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},klt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}wlt.isMDXComponent=!0;const Mlt={toc:[]};function Dlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mlt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}Dlt.isMDXComponent=!0;const _lt={toc:[]};function Xlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_lt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}Xlt.isMDXComponent=!0;const glt={toc:[]};function xlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},glt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}xlt.isMDXComponent=!0;const Clt={toc:[]};function Tlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Clt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Tlt.isMDXComponent=!0;const vlt={toc:[]};function blt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vlt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}blt.isMDXComponent=!0;const Llt={toc:[]};function Zlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Llt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}Zlt.isMDXComponent=!0;const Nlt={toc:[]};function Slt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nlt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}Slt.isMDXComponent=!0;const zlt={toc:[]};function Rlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zlt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Rlt.isMDXComponent=!0;const Plt={toc:[]};function Alt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Plt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}Alt.isMDXComponent=!0;const Ilt={toc:[]};function Wlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ilt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Wlt.isMDXComponent=!0;const Elt={toc:[]};function Flt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Elt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Flt.isMDXComponent=!0;const Blt={toc:[]};function Olt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Blt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Olt.isMDXComponent=!0;const Glt={toc:[]};function jlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Glt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}jlt.isMDXComponent=!0;const Ult={toc:[]};function qlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ult,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}qlt.isMDXComponent=!0;const Vlt={toc:[]};function Hlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vlt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}Hlt.isMDXComponent=!0;const $lt={toc:[]};function Qlt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$lt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}Qlt.isMDXComponent=!0;const Jlt={toc:[]};function Ylt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jlt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Ylt.isMDXComponent=!0;const Klt={toc:[]};function tut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Klt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}tut.isMDXComponent=!0;const eut={toc:[]};function nut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}nut.isMDXComponent=!0;const out={toc:[]};function sut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},out,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}sut.isMDXComponent=!0;const rut={toc:[]};function put(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}put.isMDXComponent=!0;const iut={toc:[]};function cut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}cut.isMDXComponent=!0;const aut={toc:[]};function lut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}lut.isMDXComponent=!0;const uut={toc:[]};function mut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}mut.isMDXComponent=!0;const dut={toc:[]};function hut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}hut.isMDXComponent=!0;const fut={toc:[]};function yut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}yut.isMDXComponent=!0;const kut={toc:[]};function wut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}wut.isMDXComponent=!0;const Mut={toc:[]};function Dut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Dut.isMDXComponent=!0;const _ut={toc:[]};function Xut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_ut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Xut.isMDXComponent=!0;const gut={toc:[]};function xut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}xut.isMDXComponent=!0;const Cut={toc:[]};function Tut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Tut.isMDXComponent=!0;const vut={toc:[]};function but(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}but.isMDXComponent=!0;const Lut={toc:[]};function Zut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Zut.isMDXComponent=!0;const Nut={toc:[]};function Sut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Sut.isMDXComponent=!0;const zut={toc:[]};function Rut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}Rut.isMDXComponent=!0;const Put={toc:[]};function Aut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Put,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Aut.isMDXComponent=!0;const Iut={toc:[]};function Wut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}Wut.isMDXComponent=!0;const Eut={toc:[]};function Fut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Fut.isMDXComponent=!0;const But={toc:[]};function Out(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},But,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Out.isMDXComponent=!0;const Gut={toc:[]};function jut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}jut.isMDXComponent=!0;const Uut={toc:[]};function qut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}qut.isMDXComponent=!0;const Vut={toc:[]};function Hut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Hut.isMDXComponent=!0;const $ut={toc:[]};function Qut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$ut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Qut.isMDXComponent=!0;const Jut={toc:[]};function Yut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Yut.isMDXComponent=!0;const Kut={toc:[]};function tmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}tmt.isMDXComponent=!0;const emt={toc:[]};function nmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},emt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}nmt.isMDXComponent=!0;const omt={toc:[]};function smt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},omt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}smt.isMDXComponent=!0;const rmt={toc:[]};function pmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}pmt.isMDXComponent=!0;const imt={toc:[]};function cmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},imt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}cmt.isMDXComponent=!0;const amt={toc:[]};function lmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},amt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}lmt.isMDXComponent=!0;const umt={toc:[]};function mmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},umt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}mmt.isMDXComponent=!0;const dmt={toc:[]};function hmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}hmt.isMDXComponent=!0;const fmt={toc:[]};function ymt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}ymt.isMDXComponent=!0;const kmt={toc:[]};function wmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}wmt.isMDXComponent=!0;const Mmt={toc:[]};function Dmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}Dmt.isMDXComponent=!0;const _mt={toc:[]};function Xmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_mt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}Xmt.isMDXComponent=!0;const gmt={toc:[]};function xmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}xmt.isMDXComponent=!0;const Cmt={toc:[]};function Tmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Tmt.isMDXComponent=!0;const vmt={toc:[]};function bmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}bmt.isMDXComponent=!0;const Lmt={toc:[]};function Zmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Zmt.isMDXComponent=!0;const Nmt={toc:[]};function Smt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Smt.isMDXComponent=!0;const zmt={toc:[]};function Rmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Rmt.isMDXComponent=!0;const Pmt={toc:[]};function Amt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}Amt.isMDXComponent=!0;const Imt={toc:[]};function Wmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Imt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Wmt.isMDXComponent=!0;const Emt={toc:[]};function Fmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Emt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Fmt.isMDXComponent=!0;const Bmt={toc:[]};function Omt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}Omt.isMDXComponent=!0;const Gmt={toc:[]};function jmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}jmt.isMDXComponent=!0;const Umt={toc:[]};function qmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Umt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}qmt.isMDXComponent=!0;const Vmt={toc:[]};function Hmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}Hmt.isMDXComponent=!0;const $mt={toc:[]};function Qmt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$mt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Qmt.isMDXComponent=!0;const Jmt={toc:[]};function Ymt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Ymt.isMDXComponent=!0;const Kmt={toc:[]};function tdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kmt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}tdt.isMDXComponent=!0;const edt={toc:[]};function ndt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},edt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}ndt.isMDXComponent=!0;const odt={toc:[]};function sdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},odt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}sdt.isMDXComponent=!0;const rdt={toc:[]};function pdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}pdt.isMDXComponent=!0;const idt={toc:[]};function cdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},idt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}cdt.isMDXComponent=!0;const adt={toc:[]};function ldt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},adt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}ldt.isMDXComponent=!0;const udt={toc:[]};function mdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},udt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}mdt.isMDXComponent=!0;const ddt={toc:[]};function hdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ddt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}hdt.isMDXComponent=!0;const fdt={toc:[]};function ydt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}ydt.isMDXComponent=!0;const kdt={toc:[]};function wdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}wdt.isMDXComponent=!0;const Mdt={toc:[]};function Ddt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Ddt.isMDXComponent=!0;const _dt={toc:[]};function Xdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_dt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Xdt.isMDXComponent=!0;const gdt={toc:[]};function xdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}xdt.isMDXComponent=!0;const Cdt={toc:[]};function Tdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}Tdt.isMDXComponent=!0;const vdt={toc:[]};function bdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}bdt.isMDXComponent=!0;const Ldt={toc:[]};function Zdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ldt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Zdt.isMDXComponent=!0;const Ndt={toc:[]};function Sdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ndt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Sdt.isMDXComponent=!0;const zdt={toc:[]};function Rdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}Rdt.isMDXComponent=!0;const Pdt={toc:[]};function Adt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}Adt.isMDXComponent=!0;const Idt={toc:[]};function Wdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Idt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}Wdt.isMDXComponent=!0;const Edt={toc:[]};function Fdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Edt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Fdt.isMDXComponent=!0;const Bdt={toc:[]};function Odt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Odt.isMDXComponent=!0;const Gdt={toc:[]};function jdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}jdt.isMDXComponent=!0;const Udt={toc:[]};function qdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Udt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}qdt.isMDXComponent=!0;const Vdt={toc:[]};function Hdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}Hdt.isMDXComponent=!0;const $dt={toc:[]};function Qdt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$dt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Qdt.isMDXComponent=!0;const Jdt={toc:[]};function Ydt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Ydt.isMDXComponent=!0;const Kdt={toc:[]};function tht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kdt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}tht.isMDXComponent=!0;const eht={toc:[]};function nht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}nht.isMDXComponent=!0;const oht={toc:[]};function sht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}sht.isMDXComponent=!0;const rht={toc:[]};function pht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}pht.isMDXComponent=!0;const iht={toc:[]};function cht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}cht.isMDXComponent=!0;const aht={toc:[]};function lht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}lht.isMDXComponent=!0;const uht={toc:[]};function mht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}mht.isMDXComponent=!0;const dht={toc:[]};function hht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}hht.isMDXComponent=!0;const fht={toc:[]};function yht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}yht.isMDXComponent=!0;const kht={toc:[]};function wht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}wht.isMDXComponent=!0;const Mht={toc:[]};function Dht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,p.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,p.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticable if the number of sides is low, e.g. for a\ntriangle."))}Dht.isMDXComponent=!0;const _ht={toc:[]};function Xht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_ht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}Xht.isMDXComponent=!0;const ght={toc:[]};function xht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ght,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node for drawing regular polygons."))}xht.isMDXComponent=!0;const Cht={toc:[]};function Tht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}Tht.isMDXComponent=!0;const vht={toc:[]};function bht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}bht.isMDXComponent=!0;const Lht={toc:[]};function Zht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Zht.isMDXComponent=!0;const Nht={toc:[]};function Sht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Sht.isMDXComponent=!0;const zht={toc:[]};function Rht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}Rht.isMDXComponent=!0;const Pht={toc:[]};function Aht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}Aht.isMDXComponent=!0;const Iht={toc:[]};function Wht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Wht.isMDXComponent=!0;const Eht={toc:[]};function Fht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Fht.isMDXComponent=!0;const Bht={toc:[]};function Oht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Oht.isMDXComponent=!0;const Ght={toc:[]};function jht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ght,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}jht.isMDXComponent=!0;const Uht={toc:[]};function qht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}qht.isMDXComponent=!0;const Vht={toc:[]};function Hht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Hht.isMDXComponent=!0;const $ht={toc:[]};function Qht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$ht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Qht.isMDXComponent=!0;const Jht={toc:[]};function Yht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Yht.isMDXComponent=!0;const Kht={toc:[]};function tft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}tft.isMDXComponent=!0;const eft={toc:[]};function nft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}nft.isMDXComponent=!0;const oft={toc:[]};function sft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}sft.isMDXComponent=!0;const rft={toc:[]};function pft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}pft.isMDXComponent=!0;const ift={toc:[]};function cft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ift,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}cft.isMDXComponent=!0;const aft={toc:[]};function lft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}lft.isMDXComponent=!0;const uft={toc:[]};function mft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}mft.isMDXComponent=!0;const dft={toc:[]};function hft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}hft.isMDXComponent=!0;const fft={toc:[]};function yft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}yft.isMDXComponent=!0;const kft={toc:[]};function wft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"For example, a value of 6 creates a hexagon."))}wft.isMDXComponent=!0;const Mft={toc:[]};function Dft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}Dft.isMDXComponent=!0;const _ft={toc:[]};function Xft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_ft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Sets the number of sides of the polygon."))}Xft.isMDXComponent=!0;const gft={toc:[]};function xft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}xft.isMDXComponent=!0;const Cft={toc:[]};function Tft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Tft.isMDXComponent=!0;const vft={toc:[]};function bft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}bft.isMDXComponent=!0;const Lft={toc:[]};function Zft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Zft.isMDXComponent=!0;const Nft={toc:[]};function Sft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}Sft.isMDXComponent=!0;const zft={toc:[]};function Rft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Rft.isMDXComponent=!0;const Pft={toc:[]};function Aft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Aft.isMDXComponent=!0;const Ift={toc:[]};function Wft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ift,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Wft.isMDXComponent=!0;const Eft={toc:[]};function Fft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Fft.isMDXComponent=!0;const Bft={toc:[]};function Oft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}Oft.isMDXComponent=!0;const Gft={toc:[]};function jft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}jft.isMDXComponent=!0;const Uft={toc:[]};function qft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}qft.isMDXComponent=!0;const Vft={toc:[]};function Hft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}Hft.isMDXComponent=!0;const $ft={toc:[]};function Qft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$ft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Qft.isMDXComponent=!0;const Jft={toc:[]};function Yft(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}Yft.isMDXComponent=!0;const Kft={toc:[]};function tyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}tyt.isMDXComponent=!0;const eyt={toc:[]};function nyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nyt.isMDXComponent=!0;const oyt={toc:[]};function syt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}syt.isMDXComponent=!0;const ryt={toc:[]};function pyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ryt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}pyt.isMDXComponent=!0;const iyt={toc:[]};function cyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}cyt.isMDXComponent=!0;const ayt={toc:[]};function lyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ayt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}lyt.isMDXComponent=!0;const uyt={toc:[]};function myt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}myt.isMDXComponent=!0;const dyt={toc:[]};function hyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}hyt.isMDXComponent=!0;const fyt={toc:[]};function yyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}yyt.isMDXComponent=!0;const kyt={toc:[]};function wyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}wyt.isMDXComponent=!0;const Myt={toc:[]};function Dyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Myt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}Dyt.isMDXComponent=!0;const _yt={toc:[]};function Xyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_yt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Xyt.isMDXComponent=!0;const gyt={toc:[]};function xyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}xyt.isMDXComponent=!0;const Cyt={toc:[]};function Tyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Tyt.isMDXComponent=!0;const vyt={toc:[]};function byt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}byt.isMDXComponent=!0;const Lyt={toc:[]};function Zyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Zyt.isMDXComponent=!0;const Nyt={toc:[]};function Syt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Syt.isMDXComponent=!0;const zyt={toc:[]};function Ryt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Ryt.isMDXComponent=!0;const Pyt={toc:[]};function Ayt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}Ayt.isMDXComponent=!0;const Iyt={toc:[]};function Wyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Wyt.isMDXComponent=!0;const Eyt={toc:[]};function Fyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}Fyt.isMDXComponent=!0;const Byt={toc:[]};function Oyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Byt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Oyt.isMDXComponent=!0;const Gyt={toc:[]};function jyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}jyt.isMDXComponent=!0;const Uyt={toc:[]};function qyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}qyt.isMDXComponent=!0;const Vyt={toc:[]};function Hyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Hyt.isMDXComponent=!0;const $yt={toc:[]};function Qyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$yt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Qyt.isMDXComponent=!0;const Jyt={toc:[]};function Yyt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Yyt.isMDXComponent=!0;const Kyt={toc:[]};function tkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kyt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}tkt.isMDXComponent=!0;const ekt={toc:[]};function nkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ekt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}nkt.isMDXComponent=!0;const okt={toc:[]};function skt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},okt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}skt.isMDXComponent=!0;const rkt={toc:[]};function pkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}pkt.isMDXComponent=!0;const ikt={toc:[]};function ckt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ikt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}ckt.isMDXComponent=!0;const akt={toc:[]};function lkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},akt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}lkt.isMDXComponent=!0;const ukt={toc:[]};function mkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ukt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}mkt.isMDXComponent=!0;const dkt={toc:[]};function hkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}hkt.isMDXComponent=!0;const fkt={toc:[]};function ykt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}ykt.isMDXComponent=!0;const kkt={toc:[]};function wkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wkt.isMDXComponent=!0;const Mkt={toc:[]};function Dkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Dkt.isMDXComponent=!0;const _kt={toc:[]};function Xkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_kt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}Xkt.isMDXComponent=!0;const gkt={toc:[]};function xkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}xkt.isMDXComponent=!0;const Ckt={toc:[]};function Tkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ckt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}Tkt.isMDXComponent=!0;const vkt={toc:[]};function bkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}bkt.isMDXComponent=!0;const Lkt={toc:[]};function Zkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Zkt.isMDXComponent=!0;const Nkt={toc:[]};function Skt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Skt.isMDXComponent=!0;const zkt={toc:[]};function Rkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}Rkt.isMDXComponent=!0;const Pkt={toc:[]};function Akt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Akt.isMDXComponent=!0;const Ikt={toc:[]};function Wkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ikt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Wkt.isMDXComponent=!0;const Ekt={toc:[]};function Fkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ekt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Fkt.isMDXComponent=!0;const Bkt={toc:[]};function Okt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}Okt.isMDXComponent=!0;const Gkt={toc:[]};function jkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}jkt.isMDXComponent=!0;const Ukt={toc:[]};function qkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ukt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qkt.isMDXComponent=!0;const Vkt={toc:[]};function Hkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}Hkt.isMDXComponent=!0;const $kt={toc:[]};function Qkt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$kt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Qkt.isMDXComponent=!0;const Jkt={toc:[]};function Ykt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Ykt.isMDXComponent=!0;const Kkt={toc:[]};function twt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kkt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}twt.isMDXComponent=!0;const ewt={toc:[]};function nwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ewt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}nwt.isMDXComponent=!0;const owt={toc:[]};function swt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},owt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}swt.isMDXComponent=!0;const rwt={toc:[]};function pwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}pwt.isMDXComponent=!0;const iwt={toc:[]};function cwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}cwt.isMDXComponent=!0;const awt={toc:[]};function lwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},awt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}lwt.isMDXComponent=!0;const uwt={toc:[]};function mwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}mwt.isMDXComponent=!0;const dwt={toc:[]};function hwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}hwt.isMDXComponent=!0;const fwt={toc:[]};function ywt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}ywt.isMDXComponent=!0;const kwt={toc:[]};function wwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}wwt.isMDXComponent=!0;const Mwt={toc:[]};function Dwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Dwt.isMDXComponent=!0;const _wt={toc:[]};function Xwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_wt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Xwt.isMDXComponent=!0;const gwt={toc:[]};function xwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}xwt.isMDXComponent=!0;const Cwt={toc:[]};function Twt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}Twt.isMDXComponent=!0;const vwt={toc:[]};function bwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}bwt.isMDXComponent=!0;const Lwt={toc:[]};function Zwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Zwt.isMDXComponent=!0;const Nwt={toc:[]};function Swt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Swt.isMDXComponent=!0;const zwt={toc:[]};function Rwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Rwt.isMDXComponent=!0;const Pwt={toc:[]};function Awt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}Awt.isMDXComponent=!0;const Iwt={toc:[]};function Wwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Wwt.isMDXComponent=!0;const Ewt={toc:[]};function Fwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ewt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Fwt.isMDXComponent=!0;const Bwt={toc:[]};function Owt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Owt.isMDXComponent=!0;const Gwt={toc:[]};function jwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}jwt.isMDXComponent=!0;const Uwt={toc:[]};function qwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qwt.isMDXComponent=!0;const Vwt={toc:[]};function Hwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}Hwt.isMDXComponent=!0;const $wt={toc:[]};function Qwt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$wt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}Qwt.isMDXComponent=!0;const Jwt={toc:[]};function Ywt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}Ywt.isMDXComponent=!0;const Kwt={toc:[]};function tMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kwt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}tMt.isMDXComponent=!0;const eMt={toc:[]};function nMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}nMt.isMDXComponent=!0;const oMt={toc:[]};function sMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}sMt.isMDXComponent=!0;const rMt={toc:[]};function pMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}pMt.isMDXComponent=!0;const iMt={toc:[]};function cMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}cMt.isMDXComponent=!0;const aMt={toc:[]};function lMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lMt.isMDXComponent=!0;const uMt={toc:[]};function mMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}mMt.isMDXComponent=!0;const dMt={toc:[]};function hMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}hMt.isMDXComponent=!0;const fMt={toc:[]};function yMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}yMt.isMDXComponent=!0;const kMt={toc:[]};function wMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}wMt.isMDXComponent=!0;const MMt={toc:[]};function DMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}DMt.isMDXComponent=!0;const _Mt={toc:[]};function XMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Mt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}XMt.isMDXComponent=!0;const gMt={toc:[]};function xMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}xMt.isMDXComponent=!0;const CMt={toc:[]};function TMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}TMt.isMDXComponent=!0;const vMt={toc:[]};function bMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}bMt.isMDXComponent=!0;const LMt={toc:[]};function ZMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}ZMt.isMDXComponent=!0;const NMt={toc:[]};function SMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}SMt.isMDXComponent=!0;const zMt={toc:[]};function RMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}RMt.isMDXComponent=!0;const PMt={toc:[]};function AMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}AMt.isMDXComponent=!0;const IMt={toc:[]};function WMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}WMt.isMDXComponent=!0;const EMt={toc:[]};function FMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}FMt.isMDXComponent=!0;const BMt={toc:[]};function OMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}OMt.isMDXComponent=!0;const GMt={toc:[]};function jMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}jMt.isMDXComponent=!0;const UMt={toc:[]};function qMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}qMt.isMDXComponent=!0;const VMt={toc:[]};function HMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}HMt.isMDXComponent=!0;const $Mt={toc:[]};function QMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Mt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}QMt.isMDXComponent=!0;const JMt={toc:[]};function YMt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}YMt.isMDXComponent=!0;const KMt={toc:[]};function tDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KMt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}tDt.isMDXComponent=!0;const eDt={toc:[]};function nDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}nDt.isMDXComponent=!0;const oDt={toc:[]};function sDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}sDt.isMDXComponent=!0;const rDt={toc:[]};function pDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}pDt.isMDXComponent=!0;const iDt={toc:[]};function cDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}cDt.isMDXComponent=!0;const aDt={toc:[]};function lDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}lDt.isMDXComponent=!0;const uDt={toc:[]};function mDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}mDt.isMDXComponent=!0;const dDt={toc:[]};function hDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}hDt.isMDXComponent=!0;const fDt={toc:[]};function yDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}yDt.isMDXComponent=!0;const kDt={toc:[]};function wDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wDt.isMDXComponent=!0;const MDt={toc:[]};function DDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}DDt.isMDXComponent=!0;const _Dt={toc:[]};function XDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Dt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}XDt.isMDXComponent=!0;const gDt={toc:[]};function xDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}xDt.isMDXComponent=!0;const CDt={toc:[]};function TDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}TDt.isMDXComponent=!0;const vDt={toc:[]};function bDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}bDt.isMDXComponent=!0;const LDt={toc:[]};function ZDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}ZDt.isMDXComponent=!0;const NDt={toc:[]};function SDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}SDt.isMDXComponent=!0;const zDt={toc:[]};function RDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}RDt.isMDXComponent=!0;const PDt={toc:[]};function ADt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}ADt.isMDXComponent=!0;const IDt={toc:[]};function WDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start point of the B\xe9zier curve."))}WDt.isMDXComponent=!0;const EDt={toc:[]};function FDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The control point of the B\xe9zier curve."))}FDt.isMDXComponent=!0;const BDt={toc:[]};function ODt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end point of the B\xe9zier curve."))}ODt.isMDXComponent=!0;const GDt={toc:[]};function jDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}jDt.isMDXComponent=!0;const UDt={toc:[]};function qDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}qDt.isMDXComponent=!0;const VDt={toc:[]};function HDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}HDt.isMDXComponent=!0;const $Dt={toc:[]};function QDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Dt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}QDt.isMDXComponent=!0;const JDt={toc:[]};function YDt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}YDt.isMDXComponent=!0;const KDt={toc:[]};function t_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KDt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}t_t.isMDXComponent=!0;const e_t={toc:[]};function n_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},e_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}n_t.isMDXComponent=!0;const o_t={toc:[]};function s_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},o_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}s_t.isMDXComponent=!0;const r_t={toc:[]};function p_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},r_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}p_t.isMDXComponent=!0;const i_t={toc:[]};function c_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},i_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}c_t.isMDXComponent=!0;const a_t={toc:[]};function l_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},a_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}l_t.isMDXComponent=!0;const u_t={toc:[]};function m_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},u_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}m_t.isMDXComponent=!0;const d_t={toc:[]};function h_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},d_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}h_t.isMDXComponent=!0;const f_t={toc:[]};function y_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},f_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}y_t.isMDXComponent=!0;const k_t={toc:[]};function w_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},k_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}w_t.isMDXComponent=!0;const M_t={toc:[]};function D_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},M_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}D_t.isMDXComponent=!0;const __t={toc:[]};function X_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},__t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}X_t.isMDXComponent=!0;const g_t={toc:[]};function x_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},g_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}x_t.isMDXComponent=!0;const C_t={toc:[]};function T_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},C_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}T_t.isMDXComponent=!0;const v_t={toc:[]};function b_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},v_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}b_t.isMDXComponent=!0;const L_t={toc:[]};function Z_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},L_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Z_t.isMDXComponent=!0;const N_t={toc:[]};function S_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},N_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}S_t.isMDXComponent=!0;const z_t={toc:[]};function R_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},z_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}R_t.isMDXComponent=!0;const P_t={toc:[]};function A_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},P_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}A_t.isMDXComponent=!0;const I_t={toc:[]};function W_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},I_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}W_t.isMDXComponent=!0;const E_t={toc:[]};function F_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},E_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}F_t.isMDXComponent=!0;const B_t={toc:[]};function O_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},B_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}O_t.isMDXComponent=!0;const G_t={toc:[]};function j_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},G_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}j_t.isMDXComponent=!0;const U_t={toc:[]};function q_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},U_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This arc length accounts for both the offset and the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}q_t.isMDXComponent=!0;const V_t={toc:[]};function H_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},V_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The visible arc length of this curve."))}H_t.isMDXComponent=!0;const $_t={toc:[]};function Q_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Q_t.isMDXComponent=!0;const J_t={toc:[]};function Y_t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},J_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The base arc length of this curve."))}Y_t.isMDXComponent=!0;const K_t={toc:[]};function tXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},K_t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}tXt.isMDXComponent=!0;const eXt={toc:[]};function nXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nXt.isMDXComponent=!0;const oXt={toc:[]};function sXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}sXt.isMDXComponent=!0;const rXt={toc:[]};function pXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}pXt.isMDXComponent=!0;const iXt={toc:[]};function cXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}cXt.isMDXComponent=!0;const aXt={toc:[]};function lXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}lXt.isMDXComponent=!0;const uXt={toc:[]};function mXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage of the curve that's currently visible."))}mXt.isMDXComponent=!0;const dXt={toc:[]};function hXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}hXt.isMDXComponent=!0;const fXt={toc:[]};function yXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}yXt.isMDXComponent=!0;const kXt={toc:[]};function wXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}wXt.isMDXComponent=!0;const MXt={toc:[]};function DXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a distance along the curve to a percentage."))}DXt.isMDXComponent=!0;const _Xt={toc:[]};function XXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Xt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance along the curve."))}XXt.isMDXComponent=!0;const gXt={toc:[]};function xXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}xXt.isMDXComponent=!0;const CXt={toc:[]};function TXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}TXt.isMDXComponent=!0;const vXt={toc:[]};function bXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}bXt.isMDXComponent=!0;const LXt={toc:[]};function ZXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}ZXt.isMDXComponent=!0;const NXt={toc:[]};function SXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}SXt.isMDXComponent=!0;const zXt={toc:[]};function RXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}RXt.isMDXComponent=!0;const PXt={toc:[]};function AXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}AXt.isMDXComponent=!0;const IXt={toc:[]};function WXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}WXt.isMDXComponent=!0;const EXt={toc:[]};function FXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}FXt.isMDXComponent=!0;const BXt={toc:[]};function OXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}OXt.isMDXComponent=!0;const GXt={toc:[]};function jXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}jXt.isMDXComponent=!0;const UXt={toc:[]};function qXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}qXt.isMDXComponent=!0;const VXt={toc:[]};function HXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}HXt.isMDXComponent=!0;const $Xt={toc:[]};function QXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Xt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}QXt.isMDXComponent=!0;const JXt={toc:[]};function YXt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}YXt.isMDXComponent=!0;const KXt={toc:[]};function tgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KXt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}tgt.isMDXComponent=!0;const egt={toc:[]};function ngt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},egt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}ngt.isMDXComponent=!0;const ogt={toc:[]};function sgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ogt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}sgt.isMDXComponent=!0;const rgt={toc:[]};function pgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}pgt.isMDXComponent=!0;const igt={toc:[]};function cgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},igt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}cgt.isMDXComponent=!0;const agt={toc:[]};function lgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},agt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}lgt.isMDXComponent=!0;const ugt={toc:[]};function mgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ugt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}mgt.isMDXComponent=!0;const dgt={toc:[]};function hgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}hgt.isMDXComponent=!0;const fgt={toc:[]};function ygt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}ygt.isMDXComponent=!0;const kgt={toc:[]};function wgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}wgt.isMDXComponent=!0;const Mgt={toc:[]};function Dgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Dgt.isMDXComponent=!0;const _gt={toc:[]};function Xgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_gt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Xgt.isMDXComponent=!0;const ggt={toc:[]};function xgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ggt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}xgt.isMDXComponent=!0;const Cgt={toc:[]};function Tgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Tgt.isMDXComponent=!0;const vgt={toc:[]};function bgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}bgt.isMDXComponent=!0;const Lgt={toc:[]};function Zgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Zgt.isMDXComponent=!0;const Ngt={toc:[]};function Sgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ngt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Sgt.isMDXComponent=!0;const zgt={toc:[]};function Rgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}Rgt.isMDXComponent=!0;const Pgt={toc:[]};function Agt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Agt.isMDXComponent=!0;const Igt={toc:[]};function Wgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Igt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Wgt.isMDXComponent=!0;const Egt={toc:[]};function Fgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Egt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Fgt.isMDXComponent=!0;const Bgt={toc:[]};function Ogt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}Ogt.isMDXComponent=!0;const Ggt={toc:[]};function jgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ggt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}jgt.isMDXComponent=!0;const Ugt={toc:[]};function qgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ugt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}qgt.isMDXComponent=!0;const Vgt={toc:[]};function Hgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the length of the curve that accounts for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Hgt.isMDXComponent=!0;const $gt={toc:[]};function Qgt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$gt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset arc length of this curve."))}Qgt.isMDXComponent=!0;const Jgt={toc:[]};function Ygt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Ygt.isMDXComponent=!0;const Kgt={toc:[]};function txt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kgt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a percentage along the curve to a distance."))}txt.isMDXComponent=!0;const ext={toc:[]};function nxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ext,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage along the curve."))}nxt.isMDXComponent=!0;const oxt={toc:[]};function sxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}sxt.isMDXComponent=!0;const rxt={toc:[]};function pxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}pxt.isMDXComponent=!0;const ixt={toc:[]};function cxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ixt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}cxt.isMDXComponent=!0;const axt={toc:[]};function lxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},axt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}lxt.isMDXComponent=!0;const uxt={toc:[]};function mxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}mxt.isMDXComponent=!0;const dxt={toc:[]};function hxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}hxt.isMDXComponent=!0;const fxt={toc:[]};function yxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}yxt.isMDXComponent=!0;const kxt={toc:[]};function wxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}wxt.isMDXComponent=!0;const Mxt={toc:[]};function Dxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Dxt.isMDXComponent=!0;const _xt={toc:[]};function Xxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_xt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}Xxt.isMDXComponent=!0;const gxt={toc:[]};function xxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}xxt.isMDXComponent=!0;const Cxt={toc:[]};function Txt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Txt.isMDXComponent=!0;const vxt={toc:[]};function bxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}bxt.isMDXComponent=!0;const Lxt={toc:[]};function Zxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Zxt.isMDXComponent=!0;const Nxt={toc:[]};function Sxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Sxt.isMDXComponent=!0;const zxt={toc:[]};function Rxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}Rxt.isMDXComponent=!0;const Pxt={toc:[]};function Axt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}Axt.isMDXComponent=!0;const Ixt={toc:[]};function Wxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ixt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}Wxt.isMDXComponent=!0;const Ext={toc:[]};function Fxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ext,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Fxt.isMDXComponent=!0;const Bxt={toc:[]};function Oxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Oxt.isMDXComponent=!0;const Gxt={toc:[]};function jxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}jxt.isMDXComponent=!0;const Uxt={toc:[]};function qxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}qxt.isMDXComponent=!0;const Vxt={toc:[]};function Hxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}Hxt.isMDXComponent=!0;const $xt={toc:[]};function Qxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$xt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Qxt.isMDXComponent=!0;const Jxt={toc:[]};function Yxt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Yxt.isMDXComponent=!0;const Kxt={toc:[]};function tCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kxt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}tCt.isMDXComponent=!0;const eCt={toc:[]};function nCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}nCt.isMDXComponent=!0;const oCt={toc:[]};function sCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}sCt.isMDXComponent=!0;const rCt={toc:[]};function pCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}pCt.isMDXComponent=!0;const iCt={toc:[]};function cCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}cCt.isMDXComponent=!0;const aCt={toc:[]};function lCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}lCt.isMDXComponent=!0;const uCt={toc:[]};function mCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}mCt.isMDXComponent=!0;const dCt={toc:[]};function hCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}hCt.isMDXComponent=!0;const fCt={toc:[]};function yCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}yCt.isMDXComponent=!0;const kCt={toc:[]};function wCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}wCt.isMDXComponent=!0;const MCt={toc:[]};function DCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}DCt.isMDXComponent=!0;const _Ct={toc:[]};function XCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Ct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@motion-canvas/2d';\nimport {Ray} from '@motion-canvas/2d/lib/components';\nimport {createRef} from '@motion-canvas/core/lib/utils';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}XCt.isMDXComponent=!0;const gCt={toc:[]};function xCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node for drawing an individual line segment."))}xCt.isMDXComponent=!0;const CCt={toc:[]};function TCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}TCt.isMDXComponent=!0;const vCt={toc:[]};function bCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}bCt.isMDXComponent=!0;const LCt={toc:[]};function ZCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ZCt.isMDXComponent=!0;const NCt={toc:[]};function SCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}SCt.isMDXComponent=!0;const zCt={toc:[]};function RCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}RCt.isMDXComponent=!0;const PCt={toc:[]};function ACt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}ACt.isMDXComponent=!0;const ICt={toc:[]};function WCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ICt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}WCt.isMDXComponent=!0;const ECt={toc:[]};function FCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ECt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}FCt.isMDXComponent=!0;const BCt={toc:[]};function OCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}OCt.isMDXComponent=!0;const GCt={toc:[]};function jCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}jCt.isMDXComponent=!0;const UCt={toc:[]};function qCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}qCt.isMDXComponent=!0;const VCt={toc:[]};function HCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}HCt.isMDXComponent=!0;const $Ct={toc:[]};function QCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Ct,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}QCt.isMDXComponent=!0;const JCt={toc:[]};function YCt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}YCt.isMDXComponent=!0;const KCt={toc:[]};function tTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KCt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}tTt.isMDXComponent=!0;const eTt={toc:[]};function nTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}nTt.isMDXComponent=!0;const oTt={toc:[]};function sTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}sTt.isMDXComponent=!0;const rTt={toc:[]};function pTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}pTt.isMDXComponent=!0;const iTt={toc:[]};function cTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cTt.isMDXComponent=!0;const aTt={toc:[]};function lTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}lTt.isMDXComponent=!0;const uTt={toc:[]};function mTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}mTt.isMDXComponent=!0;const dTt={toc:[]};function hTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}hTt.isMDXComponent=!0;const fTt={toc:[]};function yTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The starting point of the ray."))}yTt.isMDXComponent=!0;const kTt={toc:[]};function wTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}wTt.isMDXComponent=!0;const MTt={toc:[]};function DTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}DTt.isMDXComponent=!0;const _Tt={toc:[]};function XTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Tt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}XTt.isMDXComponent=!0;const gTt={toc:[]};function xTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}xTt.isMDXComponent=!0;const CTt={toc:[]};function TTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}TTt.isMDXComponent=!0;const vTt={toc:[]};function bTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}bTt.isMDXComponent=!0;const LTt={toc:[]};function ZTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}ZTt.isMDXComponent=!0;const NTt={toc:[]};function STt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}STt.isMDXComponent=!0;const zTt={toc:[]};function RTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}RTt.isMDXComponent=!0;const PTt={toc:[]};function ATt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}ATt.isMDXComponent=!0;const ITt={toc:[]};function WTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ITt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}WTt.isMDXComponent=!0;const ETt={toc:[]};function FTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ETt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}FTt.isMDXComponent=!0;const BTt={toc:[]};function OTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}OTt.isMDXComponent=!0;const GTt={toc:[]};function jTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}jTt.isMDXComponent=!0;const UTt={toc:[]};function qTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qTt.isMDXComponent=!0;const VTt={toc:[]};function HTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}HTt.isMDXComponent=!0;const $Tt={toc:[]};function QTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Tt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}QTt.isMDXComponent=!0;const JTt={toc:[]};function YTt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}YTt.isMDXComponent=!0;const KTt={toc:[]};function tvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KTt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}tvt.isMDXComponent=!0;const evt={toc:[]};function nvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},evt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}nvt.isMDXComponent=!0;const ovt={toc:[]};function svt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ovt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ending point of the ray."))}svt.isMDXComponent=!0;const rvt={toc:[]};function pvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}pvt.isMDXComponent=!0;const ivt={toc:[]};function cvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ivt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}cvt.isMDXComponent=!0;const avt={toc:[]};function lvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},avt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}lvt.isMDXComponent=!0;const uvt={toc:[]};function mvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}mvt.isMDXComponent=!0;const dvt={toc:[]};function hvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}hvt.isMDXComponent=!0;const fvt={toc:[]};function yvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}yvt.isMDXComponent=!0;const kvt={toc:[]};function wvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}wvt.isMDXComponent=!0;const Mvt={toc:[]};function Dvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Dvt.isMDXComponent=!0;const _vt={toc:[]};function Xvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_vt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}Xvt.isMDXComponent=!0;const gvt={toc:[]};function xvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}xvt.isMDXComponent=!0;const Cvt={toc:[]};function Tvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Tvt.isMDXComponent=!0;const vvt={toc:[]};function bvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}bvt.isMDXComponent=!0;const Lvt={toc:[]};function Zvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This arc length accounts for both the offset and the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Zvt.isMDXComponent=!0;const Nvt={toc:[]};function Svt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The visible arc length of this curve."))}Svt.isMDXComponent=!0;const zvt={toc:[]};function Rvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Rvt.isMDXComponent=!0;const Pvt={toc:[]};function Avt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The base arc length of this curve."))}Avt.isMDXComponent=!0;const Ivt={toc:[]};function Wvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ivt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Wvt.isMDXComponent=!0;const Evt={toc:[]};function Fvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Evt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Fvt.isMDXComponent=!0;const Bvt={toc:[]};function Ovt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Ovt.isMDXComponent=!0;const Gvt={toc:[]};function jvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}jvt.isMDXComponent=!0;const Uvt={toc:[]};function qvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}qvt.isMDXComponent=!0;const Vvt={toc:[]};function Hvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Hvt.isMDXComponent=!0;const $vt={toc:[]};function Qvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$vt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage of the curve that's currently visible."))}Qvt.isMDXComponent=!0;const Jvt={toc:[]};function Yvt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Yvt.isMDXComponent=!0;const Kvt={toc:[]};function tbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kvt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}tbt.isMDXComponent=!0;const ebt={toc:[]};function nbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ebt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}nbt.isMDXComponent=!0;const obt={toc:[]};function sbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},obt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}sbt.isMDXComponent=!0;const rbt={toc:[]};function pbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}pbt.isMDXComponent=!0;const ibt={toc:[]};function cbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ibt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}cbt.isMDXComponent=!0;const abt={toc:[]};function lbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},abt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}lbt.isMDXComponent=!0;const ubt={toc:[]};function mbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ubt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a distance along the curve to a percentage."))}mbt.isMDXComponent=!0;const dbt={toc:[]};function hbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance along the curve."))}hbt.isMDXComponent=!0;const fbt={toc:[]};function ybt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ybt.isMDXComponent=!0;const kbt={toc:[]};function wbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}wbt.isMDXComponent=!0;const Mbt={toc:[]};function Dbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Dbt.isMDXComponent=!0;const _bt={toc:[]};function Xbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_bt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Xbt.isMDXComponent=!0;const gbt={toc:[]};function xbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}xbt.isMDXComponent=!0;const Cbt={toc:[]};function Tbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Tbt.isMDXComponent=!0;const vbt={toc:[]};function bbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}bbt.isMDXComponent=!0;const Lbt={toc:[]};function Zbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}Zbt.isMDXComponent=!0;const Nbt={toc:[]};function Sbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Sbt.isMDXComponent=!0;const zbt={toc:[]};function Rbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}Rbt.isMDXComponent=!0;const Pbt={toc:[]};function Abt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Abt.isMDXComponent=!0;const Ibt={toc:[]};function Wbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ibt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Wbt.isMDXComponent=!0;const Ebt={toc:[]};function Fbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ebt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}Fbt.isMDXComponent=!0;const Bbt={toc:[]};function Obt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Obt.isMDXComponent=!0;const Gbt={toc:[]};function jbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}jbt.isMDXComponent=!0;const Ubt={toc:[]};function qbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ubt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}qbt.isMDXComponent=!0;const Vbt={toc:[]};function Hbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Hbt.isMDXComponent=!0;const $bt={toc:[]};function Qbt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$bt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}Qbt.isMDXComponent=!0;const Jbt={toc:[]};function Ybt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}Ybt.isMDXComponent=!0;const Kbt={toc:[]};function tLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kbt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}tLt.isMDXComponent=!0;const eLt={toc:[]};function nLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}nLt.isMDXComponent=!0;const oLt={toc:[]};function sLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}sLt.isMDXComponent=!0;const rLt={toc:[]};function pLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}pLt.isMDXComponent=!0;const iLt={toc:[]};function cLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}cLt.isMDXComponent=!0;const aLt={toc:[]};function lLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}lLt.isMDXComponent=!0;const uLt={toc:[]};function mLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}mLt.isMDXComponent=!0;const dLt={toc:[]};function hLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}hLt.isMDXComponent=!0;const fLt={toc:[]};function yLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}yLt.isMDXComponent=!0;const kLt={toc:[]};function wLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}wLt.isMDXComponent=!0;const MLt={toc:[]};function DLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}DLt.isMDXComponent=!0;const _Lt={toc:[]};function XLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Lt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}XLt.isMDXComponent=!0;const gLt={toc:[]};function xLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}xLt.isMDXComponent=!0;const CLt={toc:[]};function TLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}TLt.isMDXComponent=!0;const vLt={toc:[]};function bLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}bLt.isMDXComponent=!0;const LLt={toc:[]};function ZLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}ZLt.isMDXComponent=!0;const NLt={toc:[]};function SLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}SLt.isMDXComponent=!0;const zLt={toc:[]};function RLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}RLt.isMDXComponent=!0;const PLt={toc:[]};function ALt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}ALt.isMDXComponent=!0;const ILt={toc:[]};function WLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ILt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}WLt.isMDXComponent=!0;const ELt={toc:[]};function FLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ELt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}FLt.isMDXComponent=!0;const BLt={toc:[]};function OLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}OLt.isMDXComponent=!0;const GLt={toc:[]};function jLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}jLt.isMDXComponent=!0;const ULt={toc:[]};function qLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ULt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}qLt.isMDXComponent=!0;const VLt={toc:[]};function HLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}HLt.isMDXComponent=!0;const $Lt={toc:[]};function QLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Lt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}QLt.isMDXComponent=!0;const JLt={toc:[]};function YLt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}YLt.isMDXComponent=!0;const KLt={toc:[]};function tZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KLt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}tZt.isMDXComponent=!0;const eZt={toc:[]};function nZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}nZt.isMDXComponent=!0;const oZt={toc:[]};function sZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}sZt.isMDXComponent=!0;const rZt={toc:[]};function pZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}pZt.isMDXComponent=!0;const iZt={toc:[]};function cZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}cZt.isMDXComponent=!0;const aZt={toc:[]};function lZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}lZt.isMDXComponent=!0;const uZt={toc:[]};function mZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the length of the curve that accounts for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}mZt.isMDXComponent=!0;const dZt={toc:[]};function hZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset arc length of this curve."))}hZt.isMDXComponent=!0;const fZt={toc:[]};function yZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}yZt.isMDXComponent=!0;const kZt={toc:[]};function wZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a percentage along the curve to a distance."))}wZt.isMDXComponent=!0;const MZt={toc:[]};function DZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage along the curve."))}DZt.isMDXComponent=!0;const _Zt={toc:[]};function XZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Zt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}XZt.isMDXComponent=!0;const gZt={toc:[]};function xZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}xZt.isMDXComponent=!0;const CZt={toc:[]};function TZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}TZt.isMDXComponent=!0;const vZt={toc:[]};function bZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}bZt.isMDXComponent=!0;const LZt={toc:[]};function ZZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}ZZt.isMDXComponent=!0;const NZt={toc:[]};function SZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}SZt.isMDXComponent=!0;const zZt={toc:[]};function RZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}RZt.isMDXComponent=!0;const PZt={toc:[]};function AZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}AZt.isMDXComponent=!0;const IZt={toc:[]};function WZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}WZt.isMDXComponent=!0;const EZt={toc:[]};function FZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}FZt.isMDXComponent=!0;const BZt={toc:[]};function OZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}OZt.isMDXComponent=!0;const GZt={toc:[]};function jZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}jZt.isMDXComponent=!0;const UZt={toc:[]};function qZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}qZt.isMDXComponent=!0;const VZt={toc:[]};function HZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}HZt.isMDXComponent=!0;const $Zt={toc:[]};function QZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Zt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}QZt.isMDXComponent=!0;const JZt={toc:[]};function YZt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}YZt.isMDXComponent=!0;const KZt={toc:[]};function tNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KZt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}tNt.isMDXComponent=!0;const eNt={toc:[]};function nNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}nNt.isMDXComponent=!0;const oNt={toc:[]};function sNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}sNt.isMDXComponent=!0;const rNt={toc:[]};function pNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}pNt.isMDXComponent=!0;const iNt={toc:[]};function cNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}cNt.isMDXComponent=!0;const aNt={toc:[]};function lNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}lNt.isMDXComponent=!0;const uNt={toc:[]};function mNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}mNt.isMDXComponent=!0;const dNt={toc:[]};function hNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}hNt.isMDXComponent=!0;const fNt={toc:[]};function yNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}yNt.isMDXComponent=!0;const kNt={toc:[]};function wNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}wNt.isMDXComponent=!0;const MNt={toc:[]};function DNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}DNt.isMDXComponent=!0;const _Nt={toc:[]};function XNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Nt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}XNt.isMDXComponent=!0;const gNt={toc:[]};function xNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}xNt.isMDXComponent=!0;const CNt={toc:[]};function TNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}TNt.isMDXComponent=!0;const vNt={toc:[]};function bNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}bNt.isMDXComponent=!0;const LNt={toc:[]};function ZNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}ZNt.isMDXComponent=!0;const NNt={toc:[]};function SNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}SNt.isMDXComponent=!0;const zNt={toc:[]};function RNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}RNt.isMDXComponent=!0;const PNt={toc:[]};function ANt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}ANt.isMDXComponent=!0;const INt={toc:[]};function WNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},INt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}WNt.isMDXComponent=!0;const ENt={toc:[]};function FNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ENt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}FNt.isMDXComponent=!0;const BNt={toc:[]};function ONt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}ONt.isMDXComponent=!0;const GNt={toc:[]};function jNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}jNt.isMDXComponent=!0;const UNt={toc:[]};function qNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}qNt.isMDXComponent=!0;const VNt={toc:[]};function HNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}HNt.isMDXComponent=!0;const $Nt={toc:[]};function QNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Nt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}QNt.isMDXComponent=!0;const JNt={toc:[]};function YNt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}YNt.isMDXComponent=!0;const KNt={toc:[]};function tSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KNt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}tSt.isMDXComponent=!0;const eSt={toc:[]};function nSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}nSt.isMDXComponent=!0;const oSt={toc:[]};function sSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}sSt.isMDXComponent=!0;const rSt={toc:[]};function pSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}pSt.isMDXComponent=!0;const iSt={toc:[]};function cSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}cSt.isMDXComponent=!0;const aSt={toc:[]};function lSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}lSt.isMDXComponent=!0;const uSt={toc:[]};function mSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}mSt.isMDXComponent=!0;const dSt={toc:[]};function hSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}hSt.isMDXComponent=!0;const fSt={toc:[]};function ySt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}ySt.isMDXComponent=!0;const kSt={toc:[]};function wSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}wSt.isMDXComponent=!0;const MSt={toc:[]};function DSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}DSt.isMDXComponent=!0;const _St={toc:[]};function XSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_St,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}XSt.isMDXComponent=!0;const gSt={toc:[]};function xSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}xSt.isMDXComponent=!0;const CSt={toc:[]};function TSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}TSt.isMDXComponent=!0;const vSt={toc:[]};function bSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}bSt.isMDXComponent=!0;const LSt={toc:[]};function ZSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}ZSt.isMDXComponent=!0;const NSt={toc:[]};function SSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}SSt.isMDXComponent=!0;const zSt={toc:[]};function RSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}RSt.isMDXComponent=!0;const PSt={toc:[]};function ASt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}ASt.isMDXComponent=!0;const ISt={toc:[]};function WSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ISt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}WSt.isMDXComponent=!0;const ESt={toc:[]};function FSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ESt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}FSt.isMDXComponent=!0;const BSt={toc:[]};function OSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}OSt.isMDXComponent=!0;const GSt={toc:[]};function jSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}jSt.isMDXComponent=!0;const USt={toc:[]};function qSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},USt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}qSt.isMDXComponent=!0;const VSt={toc:[]};function HSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}HSt.isMDXComponent=!0;const $St={toc:[]};function QSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$St,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}QSt.isMDXComponent=!0;const JSt={toc:[]};function YSt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}YSt.isMDXComponent=!0;const KSt={toc:[]};function tzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KSt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}tzt.isMDXComponent=!0;const ezt={toc:[]};function nzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ezt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}nzt.isMDXComponent=!0;const ozt={toc:[]};function szt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ozt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}szt.isMDXComponent=!0;const rzt={toc:[]};function pzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}pzt.isMDXComponent=!0;const izt={toc:[]};function czt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},izt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}czt.isMDXComponent=!0;const azt={toc:[]};function lzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},azt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}lzt.isMDXComponent=!0;const uzt={toc:[]};function mzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}mzt.isMDXComponent=!0;const dzt={toc:[]};function hzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}hzt.isMDXComponent=!0;const fzt={toc:[]};function yzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}yzt.isMDXComponent=!0;const kzt={toc:[]};function wzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}wzt.isMDXComponent=!0;const Mzt={toc:[]};function Dzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Dzt.isMDXComponent=!0;const _zt={toc:[]};function Xzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_zt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Xzt.isMDXComponent=!0;const gzt={toc:[]};function xzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}xzt.isMDXComponent=!0;const Czt={toc:[]};function Tzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Czt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Tzt.isMDXComponent=!0;const vzt={toc:[]};function bzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}bzt.isMDXComponent=!0;const Lzt={toc:[]};function Zzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Zzt.isMDXComponent=!0;const Nzt={toc:[]};function Szt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Szt.isMDXComponent=!0;const zzt={toc:[]};function Rzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Rzt.isMDXComponent=!0;const Pzt={toc:[]};function Azt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}Azt.isMDXComponent=!0;const Izt={toc:[]};function Wzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Izt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Wzt.isMDXComponent=!0;const Ezt={toc:[]};function Fzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ezt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}Fzt.isMDXComponent=!0;const Bzt={toc:[]};function Ozt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Ozt.isMDXComponent=!0;const Gzt={toc:[]};function jzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}jzt.isMDXComponent=!0;const Uzt={toc:[]};function qzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}qzt.isMDXComponent=!0;const Vzt={toc:[]};function Hzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Hzt.isMDXComponent=!0;const $zt={toc:[]};function Qzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$zt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Qzt.isMDXComponent=!0;const Jzt={toc:[]};function Yzt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Yzt.isMDXComponent=!0;const Kzt={toc:[]};function tRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kzt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}tRt.isMDXComponent=!0;const eRt={toc:[]};function nRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}nRt.isMDXComponent=!0;const oRt={toc:[]};function sRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}sRt.isMDXComponent=!0;const rRt={toc:[]};function pRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}pRt.isMDXComponent=!0;const iRt={toc:[]};function cRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}cRt.isMDXComponent=!0;const aRt={toc:[]};function lRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}lRt.isMDXComponent=!0;const uRt={toc:[]};function mRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}mRt.isMDXComponent=!0;const dRt={toc:[]};function hRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}hRt.isMDXComponent=!0;const fRt={toc:[]};function yRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}yRt.isMDXComponent=!0;const kRt={toc:[]};function wRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}wRt.isMDXComponent=!0;const MRt={toc:[]};function DRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}DRt.isMDXComponent=!0;const _Rt={toc:[]};function XRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Rt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}XRt.isMDXComponent=!0;const gRt={toc:[]};function xRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}xRt.isMDXComponent=!0;const CRt={toc:[]};function TRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}TRt.isMDXComponent=!0;const vRt={toc:[]};function bRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}bRt.isMDXComponent=!0;const LRt={toc:[]};function ZRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ZRt.isMDXComponent=!0;const NRt={toc:[]};function SRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}SRt.isMDXComponent=!0;const zRt={toc:[]};function RRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}RRt.isMDXComponent=!0;const PRt={toc:[]};function ARt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}ARt.isMDXComponent=!0;const IRt={toc:[]};function WRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}WRt.isMDXComponent=!0;const ERt={toc:[]};function FRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ERt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}FRt.isMDXComponent=!0;const BRt={toc:[]};function ORt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}ORt.isMDXComponent=!0;const GRt={toc:[]};function jRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}jRt.isMDXComponent=!0;const URt={toc:[]};function qRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},URt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}qRt.isMDXComponent=!0;const VRt={toc:[]};function HRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}HRt.isMDXComponent=!0;const $Rt={toc:[]};function QRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Rt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}QRt.isMDXComponent=!0;const JRt={toc:[]};function YRt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}YRt.isMDXComponent=!0;const KRt={toc:[]};function tPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KRt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}tPt.isMDXComponent=!0;const ePt={toc:[]};function nPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ePt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}nPt.isMDXComponent=!0;const oPt={toc:[]};function sPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}sPt.isMDXComponent=!0;const rPt={toc:[]};function pPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}pPt.isMDXComponent=!0;const iPt={toc:[]};function cPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}cPt.isMDXComponent=!0;const aPt={toc:[]};function lPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}lPt.isMDXComponent=!0;const uPt={toc:[]};function mPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}mPt.isMDXComponent=!0;const dPt={toc:[]};function hPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}hPt.isMDXComponent=!0;const fPt={toc:[]};function yPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}yPt.isMDXComponent=!0;const kPt={toc:[]};function wPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}wPt.isMDXComponent=!0;const MPt={toc:[]};function DPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}DPt.isMDXComponent=!0;const _Pt={toc:[]};function XPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Pt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}XPt.isMDXComponent=!0;const gPt={toc:[]};function xPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}xPt.isMDXComponent=!0;const CPt={toc:[]};function TPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}TPt.isMDXComponent=!0;const vPt={toc:[]};function bPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}bPt.isMDXComponent=!0;const LPt={toc:[]};function ZPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}ZPt.isMDXComponent=!0;const NPt={toc:[]};function SPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}SPt.isMDXComponent=!0;const zPt={toc:[]};function RPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}RPt.isMDXComponent=!0;const PPt={toc:[]};function APt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}APt.isMDXComponent=!0;const IPt={toc:[]};function WPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}WPt.isMDXComponent=!0;const EPt={toc:[]};function FPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}FPt.isMDXComponent=!0;const BPt={toc:[]};function OPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}OPt.isMDXComponent=!0;const GPt={toc:[]};function jPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}jPt.isMDXComponent=!0;const UPt={toc:[]};function qPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}qPt.isMDXComponent=!0;const VPt={toc:[]};function HPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}HPt.isMDXComponent=!0;const $Pt={toc:[]};function QPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Pt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}QPt.isMDXComponent=!0;const JPt={toc:[]};function YPt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}YPt.isMDXComponent=!0;const KPt={toc:[]};function tAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KPt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}tAt.isMDXComponent=!0;const eAt={toc:[]};function nAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}nAt.isMDXComponent=!0;const oAt={toc:[]};function sAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}sAt.isMDXComponent=!0;const rAt={toc:[]};function pAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}pAt.isMDXComponent=!0;const iAt={toc:[]};function cAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}cAt.isMDXComponent=!0;const aAt={toc:[]};function lAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}lAt.isMDXComponent=!0;const uAt={toc:[]};function mAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}mAt.isMDXComponent=!0;const dAt={toc:[]};function hAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}hAt.isMDXComponent=!0;const fAt={toc:[]};function yAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}yAt.isMDXComponent=!0;const kAt={toc:[]};function wAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}wAt.isMDXComponent=!0;const MAt={toc:[]};function DAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}DAt.isMDXComponent=!0;const _At={toc:[]};function XAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_At,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}XAt.isMDXComponent=!0;const gAt={toc:[]};function xAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}xAt.isMDXComponent=!0;const CAt={toc:[]};function TAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}TAt.isMDXComponent=!0;const vAt={toc:[]};function bAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}bAt.isMDXComponent=!0;const LAt={toc:[]};function ZAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ZAt.isMDXComponent=!0;const NAt={toc:[]};function SAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}SAt.isMDXComponent=!0;const zAt={toc:[]};function RAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}RAt.isMDXComponent=!0;const PAt={toc:[]};function AAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}AAt.isMDXComponent=!0;const IAt={toc:[]};function WAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}WAt.isMDXComponent=!0;const EAt={toc:[]};function FAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}FAt.isMDXComponent=!0;const BAt={toc:[]};function OAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}OAt.isMDXComponent=!0;const GAt={toc:[]};function jAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}jAt.isMDXComponent=!0;const UAt={toc:[]};function qAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}qAt.isMDXComponent=!0;const VAt={toc:[]};function HAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}HAt.isMDXComponent=!0;const $At={toc:[]};function QAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$At,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}QAt.isMDXComponent=!0;const JAt={toc:[]};function YAt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}YAt.isMDXComponent=!0;const KAt={toc:[]};function tIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KAt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}tIt.isMDXComponent=!0;const eIt={toc:[]};function nIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}nIt.isMDXComponent=!0;const oIt={toc:[]};function sIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}sIt.isMDXComponent=!0;const rIt={toc:[]};function pIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}pIt.isMDXComponent=!0;const iIt={toc:[]};function cIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}cIt.isMDXComponent=!0;const aIt={toc:[]};function lIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}lIt.isMDXComponent=!0;const uIt={toc:[]};function mIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}mIt.isMDXComponent=!0;const dIt={toc:[]};function hIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}hIt.isMDXComponent=!0;const fIt={toc:[]};function yIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}yIt.isMDXComponent=!0;const kIt={toc:[]};function wIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}wIt.isMDXComponent=!0;const MIt={toc:[]};function DIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}DIt.isMDXComponent=!0;const _It={toc:[]};function XIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_It,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}XIt.isMDXComponent=!0;const gIt={toc:[]};function xIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}xIt.isMDXComponent=!0;const CIt={toc:[]};function TIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}TIt.isMDXComponent=!0;const vIt={toc:[]};function bIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}bIt.isMDXComponent=!0;const LIt={toc:[]};function ZIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}ZIt.isMDXComponent=!0;const NIt={toc:[]};function SIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}SIt.isMDXComponent=!0;const zIt={toc:[]};function RIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}RIt.isMDXComponent=!0;const PIt={toc:[]};function AIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}AIt.isMDXComponent=!0;const IIt={toc:[]};function WIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}WIt.isMDXComponent=!0;const EIt={toc:[]};function FIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}FIt.isMDXComponent=!0;const BIt={toc:[]};function OIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}OIt.isMDXComponent=!0;const GIt={toc:[]};function jIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}jIt.isMDXComponent=!0;const UIt={toc:[]};function qIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}qIt.isMDXComponent=!0;const VIt={toc:[]};function HIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}HIt.isMDXComponent=!0;const $It={toc:[]};function QIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$It,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}QIt.isMDXComponent=!0;const JIt={toc:[]};function YIt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}YIt.isMDXComponent=!0;const KIt={toc:[]};function tWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KIt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}tWt.isMDXComponent=!0;const eWt={toc:[]};function nWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}nWt.isMDXComponent=!0;const oWt={toc:[]};function sWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}sWt.isMDXComponent=!0;const rWt={toc:[]};function pWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}pWt.isMDXComponent=!0;const iWt={toc:[]};function cWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}cWt.isMDXComponent=!0;const aWt={toc:[]};function lWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}lWt.isMDXComponent=!0;const uWt={toc:[]};function mWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}mWt.isMDXComponent=!0;const dWt={toc:[]};function hWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}hWt.isMDXComponent=!0;const fWt={toc:[]};function yWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}yWt.isMDXComponent=!0;const kWt={toc:[]};function wWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}wWt.isMDXComponent=!0;const MWt={toc:[]};function DWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}DWt.isMDXComponent=!0;const _Wt={toc:[]};function XWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Wt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}XWt.isMDXComponent=!0;const gWt={toc:[]};function xWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}xWt.isMDXComponent=!0;const CWt={toc:[]};function TWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}TWt.isMDXComponent=!0;const vWt={toc:[]};function bWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}bWt.isMDXComponent=!0;const LWt={toc:[]};function ZWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}ZWt.isMDXComponent=!0;const NWt={toc:[]};function SWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}SWt.isMDXComponent=!0;const zWt={toc:[]};function RWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}RWt.isMDXComponent=!0;const PWt={toc:[]};function AWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}AWt.isMDXComponent=!0;const IWt={toc:[]};function WWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}WWt.isMDXComponent=!0;const EWt={toc:[]};function FWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}FWt.isMDXComponent=!0;const BWt={toc:[]};function OWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}OWt.isMDXComponent=!0;const GWt={toc:[]};function jWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}jWt.isMDXComponent=!0;const UWt={toc:[]};function qWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}qWt.isMDXComponent=!0;const VWt={toc:[]};function HWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}HWt.isMDXComponent=!0;const $Wt={toc:[]};function QWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Wt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}QWt.isMDXComponent=!0;const JWt={toc:[]};function YWt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}YWt.isMDXComponent=!0;const KWt={toc:[]};function tEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KWt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}tEt.isMDXComponent=!0;const eEt={toc:[]};function nEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}nEt.isMDXComponent=!0;const oEt={toc:[]};function sEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}sEt.isMDXComponent=!0;const rEt={toc:[]};function pEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}pEt.isMDXComponent=!0;const iEt={toc:[]};function cEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}cEt.isMDXComponent=!0;const aEt={toc:[]};function lEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}lEt.isMDXComponent=!0;const uEt={toc:[]};function mEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}mEt.isMDXComponent=!0;const dEt={toc:[]};function hEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}hEt.isMDXComponent=!0;const fEt={toc:[]};function yEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}yEt.isMDXComponent=!0;const kEt={toc:[]};function wEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}wEt.isMDXComponent=!0;const MEt={toc:[]};function DEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}DEt.isMDXComponent=!0;const _Et={toc:[]};function XEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Et,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}XEt.isMDXComponent=!0;const gEt={toc:[]};function xEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}xEt.isMDXComponent=!0;const CEt={toc:[]};function TEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}TEt.isMDXComponent=!0;const vEt={toc:[]};function bEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}bEt.isMDXComponent=!0;const LEt={toc:[]};function ZEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}ZEt.isMDXComponent=!0;const NEt={toc:[]};function SEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}SEt.isMDXComponent=!0;const zEt={toc:[]};function REt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}REt.isMDXComponent=!0;const PEt={toc:[]};function AEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}AEt.isMDXComponent=!0;const IEt={toc:[]};function WEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}WEt.isMDXComponent=!0;const EEt={toc:[]};function FEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}FEt.isMDXComponent=!0;const BEt={toc:[]};function OEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}OEt.isMDXComponent=!0;const GEt={toc:[]};function jEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}jEt.isMDXComponent=!0;const UEt={toc:[]};function qEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}qEt.isMDXComponent=!0;const VEt={toc:[]};function HEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}HEt.isMDXComponent=!0;const $Et={toc:[]};function QEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Et,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}QEt.isMDXComponent=!0;const JEt={toc:[]};function YEt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}YEt.isMDXComponent=!0;const KEt={toc:[]};function tFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KEt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}tFt.isMDXComponent=!0;const eFt={toc:[]};function nFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}nFt.isMDXComponent=!0;const oFt={toc:[]};function sFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}sFt.isMDXComponent=!0;const rFt={toc:[]};function pFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}pFt.isMDXComponent=!0;const iFt={toc:[]};function cFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}cFt.isMDXComponent=!0;const aFt={toc:[]};function lFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}lFt.isMDXComponent=!0;const uFt={toc:[]};function mFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}mFt.isMDXComponent=!0;const dFt={toc:[]};function hFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}hFt.isMDXComponent=!0;const fFt={toc:[]};function yFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}yFt.isMDXComponent=!0;const kFt={toc:[]};function wFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}wFt.isMDXComponent=!0;const MFt={toc:[]};function DFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}DFt.isMDXComponent=!0;const _Ft={toc:[]};function XFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Ft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}XFt.isMDXComponent=!0;const gFt={toc:[]};function xFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}xFt.isMDXComponent=!0;const CFt={toc:[]};function TFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}TFt.isMDXComponent=!0;const vFt={toc:[]};function bFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}bFt.isMDXComponent=!0;const LFt={toc:[]};function ZFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}ZFt.isMDXComponent=!0;const NFt={toc:[]};function SFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}SFt.isMDXComponent=!0;const zFt={toc:[]};function RFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}RFt.isMDXComponent=!0;const PFt={toc:[]};function AFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}AFt.isMDXComponent=!0;const IFt={toc:[]};function WFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}WFt.isMDXComponent=!0;const EFt={toc:[]};function FFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}FFt.isMDXComponent=!0;const BFt={toc:[]};function OFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}OFt.isMDXComponent=!0;const GFt={toc:[]};function jFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}jFt.isMDXComponent=!0;const UFt={toc:[]};function qFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}qFt.isMDXComponent=!0;const VFt={toc:[]};function HFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}HFt.isMDXComponent=!0;const $Ft={toc:[]};function QFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Ft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}QFt.isMDXComponent=!0;const JFt={toc:[]};function YFt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}YFt.isMDXComponent=!0;const KFt={toc:[]};function tBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KFt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}tBt.isMDXComponent=!0;const eBt={toc:[]};function nBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}nBt.isMDXComponent=!0;const oBt={toc:[]};function sBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}sBt.isMDXComponent=!0;const rBt={toc:[]};function pBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}pBt.isMDXComponent=!0;const iBt={toc:[]};function cBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}cBt.isMDXComponent=!0;const aBt={toc:[]};function lBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}lBt.isMDXComponent=!0;const uBt={toc:[]};function mBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}mBt.isMDXComponent=!0;const dBt={toc:[]};function hBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}hBt.isMDXComponent=!0;const fBt={toc:[]};function yBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}yBt.isMDXComponent=!0;const kBt={toc:[]};function wBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}wBt.isMDXComponent=!0;const MBt={toc:[]};function DBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}DBt.isMDXComponent=!0;const _Bt={toc:[]};function XBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Bt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}XBt.isMDXComponent=!0;const gBt={toc:[]};function xBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}xBt.isMDXComponent=!0;const CBt={toc:[]};function TBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}TBt.isMDXComponent=!0;const vBt={toc:[]};function bBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}bBt.isMDXComponent=!0;const LBt={toc:[]};function ZBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}ZBt.isMDXComponent=!0;const NBt={toc:[]};function SBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}SBt.isMDXComponent=!0;const zBt={toc:[]};function RBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}RBt.isMDXComponent=!0;const PBt={toc:[]};function ABt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}ABt.isMDXComponent=!0;const IBt={toc:[]};function WBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}WBt.isMDXComponent=!0;const EBt={toc:[]};function FBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}FBt.isMDXComponent=!0;const BBt={toc:[]};function OBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}OBt.isMDXComponent=!0;const GBt={toc:[]};function jBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}jBt.isMDXComponent=!0;const UBt={toc:[]};function qBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qBt.isMDXComponent=!0;const VBt={toc:[]};function HBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}HBt.isMDXComponent=!0;const $Bt={toc:[]};function QBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Bt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}QBt.isMDXComponent=!0;const JBt={toc:[]};function YBt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}YBt.isMDXComponent=!0;const KBt={toc:[]};function tOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KBt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}tOt.isMDXComponent=!0;const eOt={toc:[]};function nOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}nOt.isMDXComponent=!0;const oOt={toc:[]};function sOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}sOt.isMDXComponent=!0;const rOt={toc:[]};function pOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}pOt.isMDXComponent=!0;const iOt={toc:[]};function cOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Defining knots using the ",(0,p.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,p.kt)("p",null,"Defining knots with ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,p.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}cOt.isMDXComponent=!0;const aOt={toc:[]};function lOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node for drawing a smooth line through a number of points."))}lOt.isMDXComponent=!0;const uOt={toc:[]};function mOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}mOt.isMDXComponent=!0;const dOt={toc:[]};function hOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}hOt.isMDXComponent=!0;const fOt={toc:[]};function yOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}yOt.isMDXComponent=!0;const kOt={toc:[]};function wOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}wOt.isMDXComponent=!0;const MOt={toc:[]};function DOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}DOt.isMDXComponent=!0;const _Ot={toc:[]};function XOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Ot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}XOt.isMDXComponent=!0;const gOt={toc:[]};function xOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}xOt.isMDXComponent=!0;const COt={toc:[]};function TOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},COt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}TOt.isMDXComponent=!0;const vOt={toc:[]};function bOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}bOt.isMDXComponent=!0;const LOt={toc:[]};function ZOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}ZOt.isMDXComponent=!0;const NOt={toc:[]};function SOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}SOt.isMDXComponent=!0;const zOt={toc:[]};function ROt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}ROt.isMDXComponent=!0;const POt={toc:[]};function AOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},POt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}AOt.isMDXComponent=!0;const IOt={toc:[]};function WOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}WOt.isMDXComponent=!0;const EOt={toc:[]};function FOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}FOt.isMDXComponent=!0;const BOt={toc:[]};function OOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}OOt.isMDXComponent=!0;const GOt={toc:[]};function jOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}jOt.isMDXComponent=!0;const UOt={toc:[]};function qOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}qOt.isMDXComponent=!0;const VOt={toc:[]};function HOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}HOt.isMDXComponent=!0;const $Ot={toc:[]};function QOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Ot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}QOt.isMDXComponent=!0;const JOt={toc:[]};function YOt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}YOt.isMDXComponent=!0;const KOt={toc:[]};function tGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KOt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}tGt.isMDXComponent=!0;const eGt={toc:[]};function nGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}nGt.isMDXComponent=!0;const oGt={toc:[]};function sGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}sGt.isMDXComponent=!0;const rGt={toc:[]};function pGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}pGt.isMDXComponent=!0;const iGt={toc:[]};function cGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}cGt.isMDXComponent=!0;const aGt={toc:[]};function lGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lGt.isMDXComponent=!0;const uGt={toc:[]};function mGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}mGt.isMDXComponent=!0;const dGt={toc:[]};function hGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}hGt.isMDXComponent=!0;const fGt={toc:[]};function yGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}yGt.isMDXComponent=!0;const kGt={toc:[]};function wGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}wGt.isMDXComponent=!0;const MGt={toc:[]};function DGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}DGt.isMDXComponent=!0;const _Gt={toc:[]};function XGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Gt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}XGt.isMDXComponent=!0;const gGt={toc:[]};function xGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}xGt.isMDXComponent=!0;const CGt={toc:[]};function TGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}TGt.isMDXComponent=!0;const vGt={toc:[]};function bGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}bGt.isMDXComponent=!0;const LGt={toc:[]};function ZGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}ZGt.isMDXComponent=!0;const NGt={toc:[]};function SGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"0.4"))}SGt.isMDXComponent=!0;const zGt={toc:[]};function RGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}RGt.isMDXComponent=!0;const PGt={toc:[]};function AGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}AGt.isMDXComponent=!0;const IGt={toc:[]};function WGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}WGt.isMDXComponent=!0;const EGt={toc:[]};function FGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}FGt.isMDXComponent=!0;const BGt={toc:[]};function OGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}OGt.isMDXComponent=!0;const GGt={toc:[]};function jGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}jGt.isMDXComponent=!0;const UGt={toc:[]};function qGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}qGt.isMDXComponent=!0;const VGt={toc:[]};function HGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}HGt.isMDXComponent=!0;const $Gt={toc:[]};function QGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Gt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}QGt.isMDXComponent=!0;const JGt={toc:[]};function YGt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}YGt.isMDXComponent=!0;const KGt={toc:[]};function tjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KGt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}tjt.isMDXComponent=!0;const ejt={toc:[]};function njt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ejt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}njt.isMDXComponent=!0;const ojt={toc:[]};function sjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ojt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}sjt.isMDXComponent=!0;const rjt={toc:[]};function pjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}pjt.isMDXComponent=!0;const ijt={toc:[]};function cjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ijt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}cjt.isMDXComponent=!0;const ajt={toc:[]};function ljt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ajt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}ljt.isMDXComponent=!0;const ujt={toc:[]};function mjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ujt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}mjt.isMDXComponent=!0;const djt={toc:[]};function hjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},djt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}hjt.isMDXComponent=!0;const fjt={toc:[]};function yjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}yjt.isMDXComponent=!0;const kjt={toc:[]};function wjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This arc length accounts for both the offset and the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}wjt.isMDXComponent=!0;const Mjt={toc:[]};function Djt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The visible arc length of this curve."))}Djt.isMDXComponent=!0;const _jt={toc:[]};function Xjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_jt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Xjt.isMDXComponent=!0;const gjt={toc:[]};function xjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The base arc length of this curve."))}xjt.isMDXComponent=!0;const Cjt={toc:[]};function Tjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Tjt.isMDXComponent=!0;const vjt={toc:[]};function bjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}bjt.isMDXComponent=!0;const Ljt={toc:[]};function Zjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ljt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Zjt.isMDXComponent=!0;const Njt={toc:[]};function Sjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Njt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Sjt.isMDXComponent=!0;const zjt={toc:[]};function Rjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Rjt.isMDXComponent=!0;const Pjt={toc:[]};function Ajt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Ajt.isMDXComponent=!0;const Ijt={toc:[]};function Wjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ijt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage of the curve that's currently visible."))}Wjt.isMDXComponent=!0;const Ejt={toc:[]};function Fjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ejt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Fjt.isMDXComponent=!0;const Bjt={toc:[]};function Ojt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Ojt.isMDXComponent=!0;const Gjt={toc:[]};function jjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}jjt.isMDXComponent=!0;const Ujt={toc:[]};function qjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ujt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}qjt.isMDXComponent=!0;const Vjt={toc:[]};function Hjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Hjt.isMDXComponent=!0;const $jt={toc:[]};function Qjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$jt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}Qjt.isMDXComponent=!0;const Jjt={toc:[]};function Yjt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Yjt.isMDXComponent=!0;const Kjt={toc:[]};function tUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kjt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a distance along the curve to a percentage."))}tUt.isMDXComponent=!0;const eUt={toc:[]};function nUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The distance along the curve."))}nUt.isMDXComponent=!0;const oUt={toc:[]};function sUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}sUt.isMDXComponent=!0;const rUt={toc:[]};function pUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}pUt.isMDXComponent=!0;const iUt={toc:[]};function cUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}cUt.isMDXComponent=!0;const aUt={toc:[]};function lUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}lUt.isMDXComponent=!0;const uUt={toc:[]};function mUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}mUt.isMDXComponent=!0;const dUt={toc:[]};function hUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}hUt.isMDXComponent=!0;const fUt={toc:[]};function yUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}yUt.isMDXComponent=!0;const kUt={toc:[]};function wUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}wUt.isMDXComponent=!0;const MUt={toc:[]};function DUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}DUt.isMDXComponent=!0;const _Ut={toc:[]};function XUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Ut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}XUt.isMDXComponent=!0;const gUt={toc:[]};function xUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}xUt.isMDXComponent=!0;const CUt={toc:[]};function TUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}TUt.isMDXComponent=!0;const vUt={toc:[]};function bUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}bUt.isMDXComponent=!0;const LUt={toc:[]};function ZUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}ZUt.isMDXComponent=!0;const NUt={toc:[]};function SUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}SUt.isMDXComponent=!0;const zUt={toc:[]};function RUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}RUt.isMDXComponent=!0;const PUt={toc:[]};function AUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}AUt.isMDXComponent=!0;const IUt={toc:[]};function WUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}WUt.isMDXComponent=!0;const EUt={toc:[]};function FUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}FUt.isMDXComponent=!0;const BUt={toc:[]};function OUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}OUt.isMDXComponent=!0;const GUt={toc:[]};function jUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}jUt.isMDXComponent=!0;const UUt={toc:[]};function qUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}qUt.isMDXComponent=!0;const VUt={toc:[]};function HUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}HUt.isMDXComponent=!0;const $Ut={toc:[]};function QUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Ut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}QUt.isMDXComponent=!0;const JUt={toc:[]};function YUt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}YUt.isMDXComponent=!0;const KUt={toc:[]};function tqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KUt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}tqt.isMDXComponent=!0;const eqt={toc:[]};function nqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}nqt.isMDXComponent=!0;const oqt={toc:[]};function sqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}sqt.isMDXComponent=!0;const rqt={toc:[]};function pqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}pqt.isMDXComponent=!0;const iqt={toc:[]};function cqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}cqt.isMDXComponent=!0;const aqt={toc:[]};function lqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}lqt.isMDXComponent=!0;const uqt={toc:[]};function mqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}mqt.isMDXComponent=!0;const dqt={toc:[]};function hqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}hqt.isMDXComponent=!0;const fqt={toc:[]};function yqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}yqt.isMDXComponent=!0;const kqt={toc:[]};function wqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}wqt.isMDXComponent=!0;const Mqt={toc:[]};function Dqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Dqt.isMDXComponent=!0;const _qt={toc:[]};function Xqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_qt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Xqt.isMDXComponent=!0;const gqt={toc:[]};function xqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}xqt.isMDXComponent=!0;const Cqt={toc:[]};function Tqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Tqt.isMDXComponent=!0;const vqt={toc:[]};function bqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}bqt.isMDXComponent=!0;const Lqt={toc:[]};function Zqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}Zqt.isMDXComponent=!0;const Nqt={toc:[]};function Sqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Sqt.isMDXComponent=!0;const zqt={toc:[]};function Rqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Rqt.isMDXComponent=!0;const Pqt={toc:[]};function Aqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Aqt.isMDXComponent=!0;const Iqt={toc:[]};function Wqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Wqt.isMDXComponent=!0;const Eqt={toc:[]};function Fqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}Fqt.isMDXComponent=!0;const Bqt={toc:[]};function Oqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Oqt.isMDXComponent=!0;const Gqt={toc:[]};function jqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}jqt.isMDXComponent=!0;const Uqt={toc:[]};function qqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}qqt.isMDXComponent=!0;const Vqt={toc:[]};function Hqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}Hqt.isMDXComponent=!0;const $qt={toc:[]};function Qqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$qt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Qqt.isMDXComponent=!0;const Jqt={toc:[]};function Yqt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}Yqt.isMDXComponent=!0;const Kqt={toc:[]};function tVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kqt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the length of the curve that accounts for\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}tVt.isMDXComponent=!0;const eVt={toc:[]};function nVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset arc length of this curve."))}nVt.isMDXComponent=!0;const oVt={toc:[]};function sVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}sVt.isMDXComponent=!0;const rVt={toc:[]};function pVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert a percentage along the curve to a distance."))}pVt.isMDXComponent=!0;const iVt={toc:[]};function cVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The percentage along the curve."))}cVt.isMDXComponent=!0;const aVt={toc:[]};function lVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}lVt.isMDXComponent=!0;const uVt={toc:[]};function mVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}mVt.isMDXComponent=!0;const dVt={toc:[]};function hVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}hVt.isMDXComponent=!0;const fVt={toc:[]};function yVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}yVt.isMDXComponent=!0;const kVt={toc:[]};function wVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}wVt.isMDXComponent=!0;const MVt={toc:[]};function DVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}DVt.isMDXComponent=!0;const _Vt={toc:[]};function XVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Vt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}XVt.isMDXComponent=!0;const gVt={toc:[]};function xVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}xVt.isMDXComponent=!0;const CVt={toc:[]};function TVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}TVt.isMDXComponent=!0;const vVt={toc:[]};function bVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}bVt.isMDXComponent=!0;const LVt={toc:[]};function ZVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}ZVt.isMDXComponent=!0;const NVt={toc:[]};function SVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}SVt.isMDXComponent=!0;const zVt={toc:[]};function RVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}RVt.isMDXComponent=!0;const PVt={toc:[]};function AVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}AVt.isMDXComponent=!0;const IVt={toc:[]};function WVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}WVt.isMDXComponent=!0;const EVt={toc:[]};function FVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}FVt.isMDXComponent=!0;const BVt={toc:[]};function OVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}OVt.isMDXComponent=!0;const GVt={toc:[]};function jVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}jVt.isMDXComponent=!0;const UVt={toc:[]};function qVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}qVt.isMDXComponent=!0;const VVt={toc:[]};function HVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}HVt.isMDXComponent=!0;const $Vt={toc:[]};function QVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Vt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}QVt.isMDXComponent=!0;const JVt={toc:[]};function YVt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}YVt.isMDXComponent=!0;const KVt={toc:[]};function tHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KVt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}tHt.isMDXComponent=!0;const eHt={toc:[]};function nHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}nHt.isMDXComponent=!0;const oHt={toc:[]};function sHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}sHt.isMDXComponent=!0;const rHt={toc:[]};function pHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}pHt.isMDXComponent=!0;const iHt={toc:[]};function cHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}cHt.isMDXComponent=!0;const aHt={toc:[]};function lHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lHt.isMDXComponent=!0;const uHt={toc:[]};function mHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}mHt.isMDXComponent=!0;const dHt={toc:[]};function hHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}hHt.isMDXComponent=!0;const fHt={toc:[]};function yHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}yHt.isMDXComponent=!0;const kHt={toc:[]};function wHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wHt.isMDXComponent=!0;const MHt={toc:[]};function DHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}DHt.isMDXComponent=!0;const _Ht={toc:[]};function XHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Ht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}XHt.isMDXComponent=!0;const gHt={toc:[]};function xHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}xHt.isMDXComponent=!0;const CHt={toc:[]};function THt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}THt.isMDXComponent=!0;const vHt={toc:[]};function bHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}bHt.isMDXComponent=!0;const LHt={toc:[]};function ZHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}ZHt.isMDXComponent=!0;const NHt={toc:[]};function SHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}SHt.isMDXComponent=!0;const zHt={toc:[]};function RHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}RHt.isMDXComponent=!0;const PHt={toc:[]};function AHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}AHt.isMDXComponent=!0;const IHt={toc:[]};function WHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}WHt.isMDXComponent=!0;const EHt={toc:[]};function FHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}FHt.isMDXComponent=!0;const BHt={toc:[]};function OHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}OHt.isMDXComponent=!0;const GHt={toc:[]};function jHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}jHt.isMDXComponent=!0;const UHt={toc:[]};function qHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}qHt.isMDXComponent=!0;const VHt={toc:[]};function HHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}HHt.isMDXComponent=!0;const $Ht={toc:[]};function QHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Ht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}QHt.isMDXComponent=!0;const JHt={toc:[]};function YHt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}YHt.isMDXComponent=!0;const KHt={toc:[]};function t$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KHt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}t$t.isMDXComponent=!0;const e$t={toc:[]};function n$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},e$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}n$t.isMDXComponent=!0;const o$t={toc:[]};function s$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},o$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}s$t.isMDXComponent=!0;const r$t={toc:[]};function p$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},r$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}p$t.isMDXComponent=!0;const i$t={toc:[]};function c$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},i$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}c$t.isMDXComponent=!0;const a$t={toc:[]};function l$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},a$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}l$t.isMDXComponent=!0;const u$t={toc:[]};function m$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},u$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}m$t.isMDXComponent=!0;const d$t={toc:[]};function h$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},d$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}h$t.isMDXComponent=!0;const f$t={toc:[]};function y$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},f$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}y$t.isMDXComponent=!0;const k$t={toc:[]};function w$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},k$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}w$t.isMDXComponent=!0;const M$t={toc:[]};function D$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},M$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}D$t.isMDXComponent=!0;const _$t={toc:[]};function X$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}X$t.isMDXComponent=!0;const g$t={toc:[]};function x$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},g$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}x$t.isMDXComponent=!0;const C$t={toc:[]};function T$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},C$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}T$t.isMDXComponent=!0;const v$t={toc:[]};function b$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},v$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}b$t.isMDXComponent=!0;const L$t={toc:[]};function Z$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},L$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Z$t.isMDXComponent=!0;const N$t={toc:[]};function S$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},N$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}S$t.isMDXComponent=!0;const z$t={toc:[]};function R$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},z$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}R$t.isMDXComponent=!0;const P$t={toc:[]};function A$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},P$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}A$t.isMDXComponent=!0;const I$t={toc:[]};function W$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},I$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}W$t.isMDXComponent=!0;const E$t={toc:[]};function F$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},E$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}F$t.isMDXComponent=!0;const B$t={toc:[]};function O$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},B$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}O$t.isMDXComponent=!0;const G$t={toc:[]};function j$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},G$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}j$t.isMDXComponent=!0;const U$t={toc:[]};function q$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},U$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}q$t.isMDXComponent=!0;const V$t={toc:[]};function H$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},V$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}H$t.isMDXComponent=!0;const $$t={toc:[]};function Q$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Q$t.isMDXComponent=!0;const J$t={toc:[]};function Y$t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},J$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Y$t.isMDXComponent=!0;const K$t={toc:[]};function tQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},K$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}tQt.isMDXComponent=!0;const eQt={toc:[]};function nQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}nQt.isMDXComponent=!0;const oQt={toc:[]};function sQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}sQt.isMDXComponent=!0;const rQt={toc:[]};function pQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}pQt.isMDXComponent=!0;const iQt={toc:[]};function cQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}cQt.isMDXComponent=!0;const aQt={toc:[]};function lQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}lQt.isMDXComponent=!0;const uQt={toc:[]};function mQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}mQt.isMDXComponent=!0;const dQt={toc:[]};function hQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}hQt.isMDXComponent=!0;const fQt={toc:[]};function yQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}yQt.isMDXComponent=!0;const kQt={toc:[]};function wQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}wQt.isMDXComponent=!0;const MQt={toc:[]};function DQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}DQt.isMDXComponent=!0;const _Qt={toc:[]};function XQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Qt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}XQt.isMDXComponent=!0;const gQt={toc:[]};function xQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}xQt.isMDXComponent=!0;const CQt={toc:[]};function TQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}TQt.isMDXComponent=!0;const vQt={toc:[]};function bQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}bQt.isMDXComponent=!0;const LQt={toc:[]};function ZQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}ZQt.isMDXComponent=!0;const NQt={toc:[]};function SQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}SQt.isMDXComponent=!0;const zQt={toc:[]};function RQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}RQt.isMDXComponent=!0;const PQt={toc:[]};function AQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}AQt.isMDXComponent=!0;const IQt={toc:[]};function WQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}WQt.isMDXComponent=!0;const EQt={toc:[]};function FQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}FQt.isMDXComponent=!0;const BQt={toc:[]};function OQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}OQt.isMDXComponent=!0;const GQt={toc:[]};function jQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}jQt.isMDXComponent=!0;const UQt={toc:[]};function qQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}qQt.isMDXComponent=!0;const VQt={toc:[]};function HQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}HQt.isMDXComponent=!0;const $Qt={toc:[]};function QQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Qt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}QQt.isMDXComponent=!0;const JQt={toc:[]};function YQt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}YQt.isMDXComponent=!0;const KQt={toc:[]};function tJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KQt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}tJt.isMDXComponent=!0;const eJt={toc:[]};function nJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}nJt.isMDXComponent=!0;const oJt={toc:[]};function sJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}sJt.isMDXComponent=!0;const rJt={toc:[]};function pJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}pJt.isMDXComponent=!0;const iJt={toc:[]};function cJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}cJt.isMDXComponent=!0;const aJt={toc:[]};function lJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}lJt.isMDXComponent=!0;const uJt={toc:[]};function mJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}mJt.isMDXComponent=!0;const dJt={toc:[]};function hJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}hJt.isMDXComponent=!0;const fJt={toc:[]};function yJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}yJt.isMDXComponent=!0;const kJt={toc:[]};function wJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}wJt.isMDXComponent=!0;const MJt={toc:[]};function DJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}DJt.isMDXComponent=!0;const _Jt={toc:[]};function XJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Jt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}XJt.isMDXComponent=!0;const gJt={toc:[]};function xJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}xJt.isMDXComponent=!0;const CJt={toc:[]};function TJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}TJt.isMDXComponent=!0;const vJt={toc:[]};function bJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}bJt.isMDXComponent=!0;const LJt={toc:[]};function ZJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}ZJt.isMDXComponent=!0;const NJt={toc:[]};function SJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}SJt.isMDXComponent=!0;const zJt={toc:[]};function RJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}RJt.isMDXComponent=!0;const PJt={toc:[]};function AJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}AJt.isMDXComponent=!0;const IJt={toc:[]};function WJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}WJt.isMDXComponent=!0;const EJt={toc:[]};function FJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}FJt.isMDXComponent=!0;const BJt={toc:[]};function OJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}OJt.isMDXComponent=!0;const GJt={toc:[]};function jJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}jJt.isMDXComponent=!0;const UJt={toc:[]};function qJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}qJt.isMDXComponent=!0;const VJt={toc:[]};function HJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}HJt.isMDXComponent=!0;const $Jt={toc:[]};function QJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Jt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}QJt.isMDXComponent=!0;const JJt={toc:[]};function YJt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}YJt.isMDXComponent=!0;const KJt={toc:[]};function tYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KJt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}tYt.isMDXComponent=!0;const eYt={toc:[]};function nYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}nYt.isMDXComponent=!0;const oYt={toc:[]};function sYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}sYt.isMDXComponent=!0;const rYt={toc:[]};function pYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}pYt.isMDXComponent=!0;const iYt={toc:[]};function cYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}cYt.isMDXComponent=!0;const aYt={toc:[]};function lYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}lYt.isMDXComponent=!0;const uYt={toc:[]};function mYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}mYt.isMDXComponent=!0;const dYt={toc:[]};function hYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}hYt.isMDXComponent=!0;const fYt={toc:[]};function yYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}yYt.isMDXComponent=!0;const kYt={toc:[]};function wYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}wYt.isMDXComponent=!0;const MYt={toc:[]};function DYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}DYt.isMDXComponent=!0;const _Yt={toc:[]};function XYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Yt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}XYt.isMDXComponent=!0;const gYt={toc:[]};function xYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}xYt.isMDXComponent=!0;const CYt={toc:[]};function TYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}TYt.isMDXComponent=!0;const vYt={toc:[]};function bYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}bYt.isMDXComponent=!0;const LYt={toc:[]};function ZYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}ZYt.isMDXComponent=!0;const NYt={toc:[]};function SYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}SYt.isMDXComponent=!0;const zYt={toc:[]};function RYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}RYt.isMDXComponent=!0;const PYt={toc:[]};function AYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}AYt.isMDXComponent=!0;const IYt={toc:[]};function WYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}WYt.isMDXComponent=!0;const EYt={toc:[]};function FYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}FYt.isMDXComponent=!0;const BYt={toc:[]};function OYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}OYt.isMDXComponent=!0;const GYt={toc:[]};function jYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}jYt.isMDXComponent=!0;const UYt={toc:[]};function qYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}qYt.isMDXComponent=!0;const VYt={toc:[]};function HYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}HYt.isMDXComponent=!0;const $Yt={toc:[]};function QYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Yt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}QYt.isMDXComponent=!0;const JYt={toc:[]};function YYt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}YYt.isMDXComponent=!0;const KYt={toc:[]};function tKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KYt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}tKt.isMDXComponent=!0;const eKt={toc:[]};function nKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}nKt.isMDXComponent=!0;const oKt={toc:[]};function sKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}sKt.isMDXComponent=!0;const rKt={toc:[]};function pKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}pKt.isMDXComponent=!0;const iKt={toc:[]};function cKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}cKt.isMDXComponent=!0;const aKt={toc:[]};function lKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}lKt.isMDXComponent=!0;const uKt={toc:[]};function mKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}mKt.isMDXComponent=!0;const dKt={toc:[]};function hKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}hKt.isMDXComponent=!0;const fKt={toc:[]};function yKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}yKt.isMDXComponent=!0;const kKt={toc:[]};function wKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}wKt.isMDXComponent=!0;const MKt={toc:[]};function DKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}DKt.isMDXComponent=!0;const _Kt={toc:[]};function XKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Kt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}XKt.isMDXComponent=!0;const gKt={toc:[]};function xKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}xKt.isMDXComponent=!0;const CKt={toc:[]};function TKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}TKt.isMDXComponent=!0;const vKt={toc:[]};function bKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}bKt.isMDXComponent=!0;const LKt={toc:[]};function ZKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}ZKt.isMDXComponent=!0;const NKt={toc:[]};function SKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}SKt.isMDXComponent=!0;const zKt={toc:[]};function RKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}RKt.isMDXComponent=!0;const PKt={toc:[]};function AKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}AKt.isMDXComponent=!0;const IKt={toc:[]};function WKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}WKt.isMDXComponent=!0;const EKt={toc:[]};function FKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}FKt.isMDXComponent=!0;const BKt={toc:[]};function OKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}OKt.isMDXComponent=!0;const GKt={toc:[]};function jKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}jKt.isMDXComponent=!0;const UKt={toc:[]};function qKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The alpha value of this video."))}qKt.isMDXComponent=!0;const VKt={toc:[]};function HKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}HKt.isMDXComponent=!0;const $Kt={toc:[]};function QKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Kt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}QKt.isMDXComponent=!0;const JKt={toc:[]};function YKt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}YKt.isMDXComponent=!0;const KKt={toc:[]};function t0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KKt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}t0t.isMDXComponent=!0;const e0t={toc:[]};function n0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},e0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}n0t.isMDXComponent=!0;const o0t={toc:[]};function s0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},o0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}s0t.isMDXComponent=!0;const r0t={toc:[]};function p0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},r0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}p0t.isMDXComponent=!0;const i0t={toc:[]};function c0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},i0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}c0t.isMDXComponent=!0;const a0t={toc:[]};function l0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},a0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}l0t.isMDXComponent=!0;const u0t={toc:[]};function m0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},u0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}m0t.isMDXComponent=!0;const d0t={toc:[]};function h0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},d0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}h0t.isMDXComponent=!0;const f0t={toc:[]};function y0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},f0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this video should loop upon reaching the end."))}y0t.isMDXComponent=!0;const k0t={toc:[]};function w0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},k0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}w0t.isMDXComponent=!0;const M0t={toc:[]};function D0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},M0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}D0t.isMDXComponent=!0;const _0t={toc:[]};function X0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}X0t.isMDXComponent=!0;const g0t={toc:[]};function x0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},g0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}x0t.isMDXComponent=!0;const C0t={toc:[]};function T0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},C0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}T0t.isMDXComponent=!0;const v0t={toc:[]};function b0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},v0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}b0t.isMDXComponent=!0;const L0t={toc:[]};function Z0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},L0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Z0t.isMDXComponent=!0;const N0t={toc:[]};function S0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},N0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}S0t.isMDXComponent=!0;const z0t={toc:[]};function R0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},z0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}R0t.isMDXComponent=!0;const P0t={toc:[]};function A0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},P0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}A0t.isMDXComponent=!0;const I0t={toc:[]};function W0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},I0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}W0t.isMDXComponent=!0;const E0t={toc:[]};function F0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},E0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}F0t.isMDXComponent=!0;const B0t={toc:[]};function O0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},B0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}O0t.isMDXComponent=!0;const G0t={toc:[]};function j0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},G0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}j0t.isMDXComponent=!0;const U0t={toc:[]};function q0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},U0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}q0t.isMDXComponent=!0;const V0t={toc:[]};function H0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},V0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}H0t.isMDXComponent=!0;const $0t={toc:[]};function Q0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"true"))}Q0t.isMDXComponent=!0;const J0t={toc:[]};function Y0t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},J0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the video should be smoothed."))}Y0t.isMDXComponent=!0;const K0t={toc:[]};function t2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},K0t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Using a local video:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"import video from './example.mp4';\n// ...\nview.add(<Video src={video} />)\n")),(0,p.kt)("p",null,"Loading an image from the internet:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Video src="https://example.com/video.mp4" />)\n')))}t2t.isMDXComponent=!0;const e2t={toc:[]};function n2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},e2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The source of this video."))}n2t.isMDXComponent=!0;const o2t={toc:[]};function s2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},o2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}s2t.isMDXComponent=!0;const r2t={toc:[]};function p2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},r2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}p2t.isMDXComponent=!0;const i2t={toc:[]};function c2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},i2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}c2t.isMDXComponent=!0;const a2t={toc:[]};function l2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},a2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}l2t.isMDXComponent=!0;const u2t={toc:[]};function m2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},u2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}m2t.isMDXComponent=!0;const d2t={toc:[]};function h2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},d2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}h2t.isMDXComponent=!0;const f2t={toc:[]};function y2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},f2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}y2t.isMDXComponent=!0;const k2t={toc:[]};function w2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},k2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}w2t.isMDXComponent=!0;const M2t={toc:[]};function D2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},M2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}D2t.isMDXComponent=!0;const _2t={toc:[]};function X2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}X2t.isMDXComponent=!0;const g2t={toc:[]};function x2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},g2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}x2t.isMDXComponent=!0;const C2t={toc:[]};function T2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},C2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}T2t.isMDXComponent=!0;const v2t={toc:[]};function b2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},v2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}b2t.isMDXComponent=!0;const L2t={toc:[]};function Z2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},L2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Z2t.isMDXComponent=!0;const N2t={toc:[]};function S2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},N2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}S2t.isMDXComponent=!0;const z2t={toc:[]};function R2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},z2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}R2t.isMDXComponent=!0;const P2t={toc:[]};function A2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},P2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}A2t.isMDXComponent=!0;const I2t={toc:[]};function W2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},I2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}W2t.isMDXComponent=!0;const E2t={toc:[]};function F2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},E2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}F2t.isMDXComponent=!0;const B2t={toc:[]};function O2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},B2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}O2t.isMDXComponent=!0;const G2t={toc:[]};function j2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},G2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}j2t.isMDXComponent=!0;const U2t={toc:[]};function q2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},U2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}q2t.isMDXComponent=!0;const V2t={toc:[]};function H2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},V2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}H2t.isMDXComponent=!0;const $2t={toc:[]};function Q2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Q2t.isMDXComponent=!0;const J2t={toc:[]};function Y2t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},J2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Y2t.isMDXComponent=!0;const K2t={toc:[]};function t1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},K2t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}t1t.isMDXComponent=!0;const e1t={toc:[]};function n1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},e1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}n1t.isMDXComponent=!0;const o1t={toc:[]};function s1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},o1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}s1t.isMDXComponent=!0;const r1t={toc:[]};function p1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},r1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}p1t.isMDXComponent=!0;const i1t={toc:[]};function c1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},i1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}c1t.isMDXComponent=!0;const a1t={toc:[]};function l1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},a1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}l1t.isMDXComponent=!0;const u1t={toc:[]};function m1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},u1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}m1t.isMDXComponent=!0;const d1t={toc:[]};function h1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},d1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}h1t.isMDXComponent=!0;const f1t={toc:[]};function y1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},f1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}y1t.isMDXComponent=!0;const k1t={toc:[]};function w1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},k1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}w1t.isMDXComponent=!0;const M1t={toc:[]};function D1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},M1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}D1t.isMDXComponent=!0;const _1t={toc:[]};function X1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}X1t.isMDXComponent=!0;const g1t={toc:[]};function x1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},g1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}x1t.isMDXComponent=!0;const C1t={toc:[]};function T1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},C1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}T1t.isMDXComponent=!0;const v1t={toc:[]};function b1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},v1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}b1t.isMDXComponent=!0;const L1t={toc:[]};function Z1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},L1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}Z1t.isMDXComponent=!0;const N1t={toc:[]};function S1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},N1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}S1t.isMDXComponent=!0;const z1t={toc:[]};function R1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},z1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}R1t.isMDXComponent=!0;const P1t={toc:[]};function A1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},P1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}A1t.isMDXComponent=!0;const I1t={toc:[]};function W1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},I1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}W1t.isMDXComponent=!0;const E1t={toc:[]};function F1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},E1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}F1t.isMDXComponent=!0;const B1t={toc:[]};function O1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},B1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}O1t.isMDXComponent=!0;const G1t={toc:[]};function j1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},G1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}j1t.isMDXComponent=!0;const U1t={toc:[]};function q1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},U1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}q1t.isMDXComponent=!0;const V1t={toc:[]};function H1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},V1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}H1t.isMDXComponent=!0;const $1t={toc:[]};function Q1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}Q1t.isMDXComponent=!0;const J1t={toc:[]};function Y1t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},J1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Y1t.isMDXComponent=!0;const K1t={toc:[]};function t4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},K1t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}t4t.isMDXComponent=!0;const e4t={toc:[]};function n4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},e4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}n4t.isMDXComponent=!0;const o4t={toc:[]};function s4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},o4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}s4t.isMDXComponent=!0;const r4t={toc:[]};function p4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},r4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}p4t.isMDXComponent=!0;const i4t={toc:[]};function c4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},i4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}c4t.isMDXComponent=!0;const a4t={toc:[]};function l4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},a4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}l4t.isMDXComponent=!0;const u4t={toc:[]};function m4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},u4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}m4t.isMDXComponent=!0;const d4t={toc:[]};function h4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},d4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}h4t.isMDXComponent=!0;const f4t={toc:[]};function y4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},f4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}y4t.isMDXComponent=!0;const k4t={toc:[]};function w4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},k4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}w4t.isMDXComponent=!0;const M4t={toc:[]};function D4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},M4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}D4t.isMDXComponent=!0;const _4t={toc:[]};function X4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}X4t.isMDXComponent=!0;const g4t={toc:[]};function x4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},g4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}x4t.isMDXComponent=!0;const C4t={toc:[]};function T4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},C4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}T4t.isMDXComponent=!0;const v4t={toc:[]};function b4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},v4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}b4t.isMDXComponent=!0;const L4t={toc:[]};function Z4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},L4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Z4t.isMDXComponent=!0;const N4t={toc:[]};function S4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},N4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}S4t.isMDXComponent=!0;const z4t={toc:[]};function R4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},z4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}R4t.isMDXComponent=!0;const P4t={toc:[]};function A4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},P4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}A4t.isMDXComponent=!0;const I4t={toc:[]};function W4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},I4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}W4t.isMDXComponent=!0;const E4t={toc:[]};function F4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},E4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}F4t.isMDXComponent=!0;const B4t={toc:[]};function O4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},B4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}O4t.isMDXComponent=!0;const G4t={toc:[]};function j4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},G4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}j4t.isMDXComponent=!0;const U4t={toc:[]};function q4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},U4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}q4t.isMDXComponent=!0;const V4t={toc:[]};function H4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},V4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}H4t.isMDXComponent=!0;const $4t={toc:[]};function Q4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Q4t.isMDXComponent=!0;const J4t={toc:[]};function Y4t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},J4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}Y4t.isMDXComponent=!0;const K4t={toc:[]};function t6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},K4t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}t6t.isMDXComponent=!0;const e6t={toc:[]};function n6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},e6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}n6t.isMDXComponent=!0;const o6t={toc:[]};function s6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},o6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}s6t.isMDXComponent=!0;const r6t={toc:[]};function p6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},r6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}p6t.isMDXComponent=!0;const i6t={toc:[]};function c6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},i6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}c6t.isMDXComponent=!0;const a6t={toc:[]};function l6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},a6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}l6t.isMDXComponent=!0;const u6t={toc:[]};function m6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},u6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}m6t.isMDXComponent=!0;const d6t={toc:[]};function h6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},d6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}h6t.isMDXComponent=!0;const f6t={toc:[]};function y6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},f6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}y6t.isMDXComponent=!0;const k6t={toc:[]};function w6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},k6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}w6t.isMDXComponent=!0;const M6t={toc:[]};function D6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},M6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}D6t.isMDXComponent=!0;const _6t={toc:[]};function X6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}X6t.isMDXComponent=!0;const g6t={toc:[]};function x6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},g6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}x6t.isMDXComponent=!0;const C6t={toc:[]};function T6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},C6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}T6t.isMDXComponent=!0;const v6t={toc:[]};function b6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},v6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}b6t.isMDXComponent=!0;const L6t={toc:[]};function Z6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},L6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Z6t.isMDXComponent=!0;const N6t={toc:[]};function S6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},N6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}S6t.isMDXComponent=!0;const z6t={toc:[]};function R6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},z6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}R6t.isMDXComponent=!0;const P6t={toc:[]};function A6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},P6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}A6t.isMDXComponent=!0;const I6t={toc:[]};function W6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},I6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}W6t.isMDXComponent=!0;const E6t={toc:[]};function F6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},E6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}F6t.isMDXComponent=!0;const B6t={toc:[]};function O6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},B6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}O6t.isMDXComponent=!0;const G6t={toc:[]};function j6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},G6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}j6t.isMDXComponent=!0;const U6t={toc:[]};function q6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},U6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}q6t.isMDXComponent=!0;const V6t={toc:[]};function H6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},V6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}H6t.isMDXComponent=!0;const $6t={toc:[]};function Q6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Q6t.isMDXComponent=!0;const J6t={toc:[]};function Y6t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},J6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Y6t.isMDXComponent=!0;const K6t={toc:[]};function t3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},K6t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}t3t.isMDXComponent=!0;const e3t={toc:[]};function n3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},e3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}n3t.isMDXComponent=!0;const o3t={toc:[]};function s3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},o3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}s3t.isMDXComponent=!0;const r3t={toc:[]};function p3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},r3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}p3t.isMDXComponent=!0;const i3t={toc:[]};function c3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},i3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}c3t.isMDXComponent=!0;const a3t={toc:[]};function l3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},a3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}l3t.isMDXComponent=!0;const u3t={toc:[]};function m3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},u3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the position in world space."))}m3t.isMDXComponent=!0;const d3t={toc:[]};function h3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},d3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,p.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}h3t.isMDXComponent=!0;const f3t={toc:[]};function y3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},f3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the rotation in world space."))}y3t.isMDXComponent=!0;const k3t={toc:[]};function w3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},k3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,p.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,p.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"y")," components."))}w3t.isMDXComponent=!0;const M3t={toc:[]};function D3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},M3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A helper signal for operating on the scale in world space."))}D3t.isMDXComponent=!0;const _3t={toc:[]};function X3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}X3t.isMDXComponent=!0;const g3t={toc:[]};function x3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},g3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}x3t.isMDXComponent=!0;const C3t={toc:[]};function T3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},C3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}T3t.isMDXComponent=!0;const v3t={toc:[]};function b3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},v3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}b3t.isMDXComponent=!0;const L3t={toc:[]};function Z3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},L3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Z3t.isMDXComponent=!0;const N3t={toc:[]};function S3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},N3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}S3t.isMDXComponent=!0;const z3t={toc:[]};function R3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},z3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}R3t.isMDXComponent=!0;const P3t={toc:[]};function A3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},P3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}A3t.isMDXComponent=!0;const I3t={toc:[]};function W3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},I3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}W3t.isMDXComponent=!0;const E3t={toc:[]};function F3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},E3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}F3t.isMDXComponent=!0;const B3t={toc:[]};function O3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},B3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}O3t.isMDXComponent=!0;const G3t={toc:[]};function j3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},G3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,p.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}j3t.isMDXComponent=!0;const U3t={toc:[]};function q3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},U3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the offset of this node's origin."))}q3t.isMDXComponent=!0;const V3t={toc:[]};function H3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},V3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,p.kt)("p",null,"Accessing the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,p.kt)("p",null,"Setting the position:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}H3t.isMDXComponent=!0;const $3t={toc:[]};function Q3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the position of this node in local space of its parent."))}Q3t.isMDXComponent=!0;const J3t={toc:[]};function Y3t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},J3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Y3t.isMDXComponent=!0;const K3t={toc:[]};function t8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},K3t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}t8t.isMDXComponent=!0;const e8t={toc:[]};function n8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},e8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}n8t.isMDXComponent=!0;const o8t={toc:[]};function s8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},o8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,p.kt)("p",null,"Accessing the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,p.kt)("p",null,"Setting the scale:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}s8t.isMDXComponent=!0;const r8t={toc:[]};function p8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},r8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the scale of this node in local space of its parent."))}p8t.isMDXComponent=!0;const i8t={toc:[]};function c8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},i8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A size is a two-dimensional vector, where ",(0,p.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,p.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,p.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,p.kt)("p",null,"The value of both x and y is of type ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,p.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,p.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,p.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,p.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,p.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,p.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}c8t.isMDXComponent=!0;const a8t={toc:[]};function l8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},a8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Initializing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,p.kt)("p",null,"Accessing the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,p.kt)("p",null,"Setting the size:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}l8t.isMDXComponent=!0;const u8t={toc:[]};function m8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},u8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the size of this node."))}m8t.isMDXComponent=!0;const d8t={toc:[]};function h8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},d8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}h8t.isMDXComponent=!0;const f8t={toc:[]};function y8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},f8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}y8t.isMDXComponent=!0;const k8t={toc:[]};function w8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},k8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}w8t.isMDXComponent=!0;const M8t={toc:[]};function D8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},M8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}D8t.isMDXComponent=!0;const _8t={toc:[]};function X8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}X8t.isMDXComponent=!0;const g8t={toc:[]};function x8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},g8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}x8t.isMDXComponent=!0;const C8t={toc:[]};function T8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},C8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}T8t.isMDXComponent=!0;const v8t={toc:[]};function b8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},v8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,p.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}b8t.isMDXComponent=!0;const L8t={toc:[]};function Z8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},L8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Z8t.isMDXComponent=!0;const N8t={toc:[]};function S8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},N8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}S8t.isMDXComponent=!0;const z8t={toc:[]};function R8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},z8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}R8t.isMDXComponent=!0;const P8t={toc:[]};function A8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},P8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}A8t.isMDXComponent=!0;const I8t={toc:[]};function W8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},I8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}W8t.isMDXComponent=!0;const E8t={toc:[]};function F8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},E8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}F8t.isMDXComponent=!0;const B8t={toc:[]};function O8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},B8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The state to apply to the node."))}O8t.isMDXComponent=!0;const G8t={toc:[]};function j8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},G8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}j8t.isMDXComponent=!0;const U8t={toc:[]};function q8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},U8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}q8t.isMDXComponent=!0;const V8t={toc:[]};function H8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},V8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}H8t.isMDXComponent=!0;const $8t={toc:[]};function Q8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Q8t.isMDXComponent=!0;const J8t={toc:[]};function Y8t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},J8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Y8t.isMDXComponent=!0;const K8t={toc:[]};function t5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},K8t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}t5t.isMDXComponent=!0;const e5t={toc:[]};function n5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},e5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}n5t.isMDXComponent=!0;const o5t={toc:[]};function s5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},o5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}s5t.isMDXComponent=!0;const r5t={toc:[]};function p5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},r5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the desired size of this node."))}p5t.isMDXComponent=!0;const i5t={toc:[]};function c5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},i5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}c5t.isMDXComponent=!0;const a5t={toc:[]};function l5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},a5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}l5t.isMDXComponent=!0;const u5t={toc:[]};function m5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},u5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}m5t.isMDXComponent=!0;const d5t={toc:[]};function h5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},d5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}h5t.isMDXComponent=!0;const f5t={toc:[]};function y5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},f5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}y5t.isMDXComponent=!0;const k5t={toc:[]};function w5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},k5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}w5t.isMDXComponent=!0;const M5t={toc:[]};function D5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},M5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}D5t.isMDXComponent=!0;const _5t={toc:[]};function X5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}X5t.isMDXComponent=!0;const g5t={toc:[]};function x5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},g5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}x5t.isMDXComponent=!0;const C5t={toc:[]};function T5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},C5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}T5t.isMDXComponent=!0;const v5t={toc:[]};function b5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},v5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}b5t.isMDXComponent=!0;const L5t={toc:[]};function Z5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},L5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned bounding box should be in local space."))}Z5t.isMDXComponent=!0;const N5t={toc:[]};function S5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},N5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}S5t.isMDXComponent=!0;const z5t={toc:[]};function R5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},z5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}R5t.isMDXComponent=!0;const P5t={toc:[]};function A5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},P5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return a snapshot of the node's current signal values."))}A5t.isMDXComponent=!0;const I5t={toc:[]};function W5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},I5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}W5t.isMDXComponent=!0;const E5t={toc:[]};function F5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},E5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}F5t.isMDXComponent=!0;const B5t={toc:[]};function O5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},B5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}O5t.isMDXComponent=!0;const G5t={toc:[]};function j5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},G5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}j5t.isMDXComponent=!0;const U5t={toc:[]};function q5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},U5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}q5t.isMDXComponent=!0;const V5t={toc:[]};function H5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},V5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}H5t.isMDXComponent=!0;const $5t={toc:[]};function Q5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Q5t.isMDXComponent=!0;const J5t={toc:[]};function Y5t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},J5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Y5t.isMDXComponent=!0;const K5t={toc:[]};function t7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},K5t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}t7t.isMDXComponent=!0;const e7t={toc:[]};function n7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},e7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}n7t.isMDXComponent=!0;const o7t={toc:[]};function s7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},o7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}s7t.isMDXComponent=!0;const r7t={toc:[]};function p7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},r7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-parent matrix for this node."))}p7t.isMDXComponent=!0;const i7t={toc:[]};function c7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},i7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}c7t.isMDXComponent=!0;const a7t={toc:[]};function l7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},a7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}l7t.isMDXComponent=!0;const u7t={toc:[]};function m7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},u7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the local-to-world matrix for this node."))}m7t.isMDXComponent=!0;const d7t={toc:[]};function h7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},d7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}h7t.isMDXComponent=!0;const f7t={toc:[]};function y7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},f7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}y7t.isMDXComponent=!0;const k7t={toc:[]};function w7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},k7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}w7t.isMDXComponent=!0;const M7t={toc:[]};function D7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},M7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}D7t.isMDXComponent=!0;const _7t={toc:[]};function X7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node above the provided node in the parent's layout."))}X7t.isMDXComponent=!0;const g7t={toc:[]};function x7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},g7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}x7t.isMDXComponent=!0;const C7t={toc:[]};function T7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},C7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}T7t.isMDXComponent=!0;const v7t={toc:[]};function b7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},v7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}b7t.isMDXComponent=!0;const L7t={toc:[]};function Z7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},L7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Z7t.isMDXComponent=!0;const N7t={toc:[]};function S7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},N7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The sibling node below which to move."))}S7t.isMDXComponent=!0;const z7t={toc:[]};function R7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},z7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}R7t.isMDXComponent=!0;const P7t={toc:[]};function A7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},P7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}A7t.isMDXComponent=!0;const I7t={toc:[]};function W7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},I7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}W7t.isMDXComponent=!0;const E7t={toc:[]};function F7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},E7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}F7t.isMDXComponent=!0;const B7t={toc:[]};function O7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},B7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}O7t.isMDXComponent=!0;const G7t={toc:[]};function j7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},G7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}j7t.isMDXComponent=!0;const U7t={toc:[]};function q7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},U7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the provided position relative to its siblings."))}q7t.isMDXComponent=!0;const V7t={toc:[]};function H7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},V7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The index to move the node to."))}H7t.isMDXComponent=!0;const $7t={toc:[]};function Q7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Q7t.isMDXComponent=!0;const J7t={toc:[]};function Y7t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},J7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Y7t.isMDXComponent=!0;const K7t={toc:[]};function t9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},K7t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}t9t.isMDXComponent=!0;const e9t={toc:[]};function n9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},e9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}n9t.isMDXComponent=!0;const o9t={toc:[]};function s9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},o9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}s9t.isMDXComponent=!0;const r9t={toc:[]};function p9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},r9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}p9t.isMDXComponent=!0;const i9t={toc:[]};function c9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},i9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}c9t.isMDXComponent=!0;const a9t={toc:[]};function l9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},a9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}l9t.isMDXComponent=!0;const u9t={toc:[]};function m9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},u9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}m9t.isMDXComponent=!0;const d9t={toc:[]};function h9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},d9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}h9t.isMDXComponent=!0;const f9t={toc:[]};function y9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},f9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}y9t.isMDXComponent=!0;const k9t={toc:[]};function w9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},k9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}w9t.isMDXComponent=!0;const M9t={toc:[]};function D9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},M9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}D9t.isMDXComponent=!0;const _9t={toc:[]};function X9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}X9t.isMDXComponent=!0;const g9t={toc:[]};function x9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},g9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}x9t.isMDXComponent=!0;const C9t={toc:[]};function T9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},C9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new parent of this node."))}T9t.isMDXComponent=!0;const v9t={toc:[]};function b9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},v9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}b9t.isMDXComponent=!0;const L9t={toc:[]};function Z9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},L9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Z9t.isMDXComponent=!0;const N9t={toc:[]};function S9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},N9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}S9t.isMDXComponent=!0;const z9t={toc:[]};function R9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},z9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,p.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}R9t.isMDXComponent=!0;const P9t={toc:[]};function A9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},P9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}A9t.isMDXComponent=!0;const I9t={toc:[]};function W9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},I9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Restore the node to its last saved state."))}W9t.isMDXComponent=!0;const E9t={toc:[]};function F9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},E9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The duration of the transition"))}F9t.isMDXComponent=!0;const B9t={toc:[]};function O9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},B9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The timing function to use for the transition"))}O9t.isMDXComponent=!0;const G9t={toc:[]};function j9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},G9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used together with the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,p.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,p.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}j9t.isMDXComponent=!0;const U9t={toc:[]};function q9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},U9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}q9t.isMDXComponent=!0;const V9t={toc:[]};function H9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},V9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}H9t.isMDXComponent=!0;const $9t={toc:[]};function Q9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Q9t.isMDXComponent=!0;const J9t={toc:[]};function Y9t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},J9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}Y9t.isMDXComponent=!0;const K9t={toc:[]};function tte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},K9t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}tte.isMDXComponent=!0;const ete={toc:[]};function nte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ete,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}nte.isMDXComponent=!0;const ote={toc:[]};function ste(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ote,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}ste.isMDXComponent=!0;const rte={toc:[]};function pte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}pte.isMDXComponent=!0;const ite={toc:[]};function cte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ite,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}cte.isMDXComponent=!0;const ate={toc:[]};function lte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ate,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}lte.isMDXComponent=!0;const ute={toc:[]};function mte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ute,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the same the bounding box returned by ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,p.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}mte.isMDXComponent=!0;const dte={toc:[]};function hte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}hte.isMDXComponent=!0;const fte={toc:[]};function yte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}yte.isMDXComponent=!0;const kte={toc:[]};function wte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}wte.isMDXComponent=!0;const Mte={toc:[]};function Dte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-local matrix for this node."))}Dte.isMDXComponent=!0;const _te={toc:[]};function Xte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_te,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Xte.isMDXComponent=!0;const gte={toc:[]};function xte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the world-to-parent matrix for this node."))}xte.isMDXComponent=!0;const Cte={toc:[]};function Tte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tte.isMDXComponent=!0;const vte={toc:[]};function bte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}bte.isMDXComponent=!0;const Lte={toc:[]};function Zte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Zte.isMDXComponent=!0;const Nte={toc:[]};function Ste(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Ste.isMDXComponent=!0;const zte={toc:[]};function Rte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Rte.isMDXComponent=!0;const Pte={toc:[]};function Ate(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Ate.isMDXComponent=!0;const Ite={toc:[]};function Wte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ite,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}Wte.isMDXComponent=!0;const Ete={toc:[]};function Fte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ete,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the path of this circle should be closed."))}Fte.isMDXComponent=!0;const Bte={toc:[]};function Ote(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property can be used together with ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,p.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Ote.isMDXComponent=!0;const Gte={toc:[]};function jte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ending angle in degrees for the circle sector."))}jte.isMDXComponent=!0;const Ute={toc:[]};function qte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ute,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qte.isMDXComponent=!0;const Vte={toc:[]};function Hte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Hte.isMDXComponent=!0;const $te={toc:[]};function Qte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$te,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qte.isMDXComponent=!0;const Jte={toc:[]};function Yte(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Yte.isMDXComponent=!0;const Kte={toc:[]};function tee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kte,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property can be used together with ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,p.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}tee.isMDXComponent=!0;const eee={toc:[]};function nee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The starting angle in degrees for the circle sector."))}nee.isMDXComponent=!0;const oee={toc:[]};function see(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}see.isMDXComponent=!0;const ree={toc:[]};function pee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ree,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}pee.isMDXComponent=!0;const iee={toc:[]};function cee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cee.isMDXComponent=!0;const aee={toc:[]};function lee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}lee.isMDXComponent=!0;const uee={toc:[]};function mee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mee.isMDXComponent=!0;const dee={toc:[]};function hee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}hee.isMDXComponent=!0;const fee={toc:[]};function yee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}yee.isMDXComponent=!0;const kee={toc:[]};function wee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}wee.isMDXComponent=!0;const Mee={toc:[]};function Dee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Dee.isMDXComponent=!0;const _ee={toc:[]};function Xee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_ee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Xee.isMDXComponent=!0;const gee={toc:[]};function xee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xee.isMDXComponent=!0;const Cee={toc:[]};function Tee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Tee.isMDXComponent=!0;const vee={toc:[]};function bee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bee.isMDXComponent=!0;const Lee={toc:[]};function Zee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Zee.isMDXComponent=!0;const Nee={toc:[]};function See(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}See.isMDXComponent=!0;const zee={toc:[]};function Ree(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}Ree.isMDXComponent=!0;const Pee={toc:[]};function Aee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Aee.isMDXComponent=!0;const Iee={toc:[]};function Wee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Wee.isMDXComponent=!0;const Eee={toc:[]};function Fee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Fee.isMDXComponent=!0;const Bee={toc:[]};function Oee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Oee.isMDXComponent=!0;const Gee={toc:[]};function jee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}jee.isMDXComponent=!0;const Uee={toc:[]};function qee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}qee.isMDXComponent=!0;const Vee={toc:[]};function Hee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hee.isMDXComponent=!0;const $ee={toc:[]};function Qee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$ee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Qee.isMDXComponent=!0;const Jee={toc:[]};function Yee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yee.isMDXComponent=!0;const Kee={toc:[]};function tne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}tne.isMDXComponent=!0;const ene={toc:[]};function nne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ene,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}nne.isMDXComponent=!0;const one={toc:[]};function sne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},one,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}sne.isMDXComponent=!0;const rne={toc:[]};function pne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pne.isMDXComponent=!0;const ine={toc:[]};function cne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ine,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}cne.isMDXComponent=!0;const ane={toc:[]};function lne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ane,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lne.isMDXComponent=!0;const une={toc:[]};function mne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},une,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}mne.isMDXComponent=!0;const dne={toc:[]};function hne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hne.isMDXComponent=!0;const fne={toc:[]};function yne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}yne.isMDXComponent=!0;const kne={toc:[]};function wne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wne.isMDXComponent=!0;const Mne={toc:[]};function Dne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Dne.isMDXComponent=!0;const _ne={toc:[]};function Xne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_ne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xne.isMDXComponent=!0;const gne={toc:[]};function xne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}xne.isMDXComponent=!0;const Cne={toc:[]};function Tne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Tne.isMDXComponent=!0;const vne={toc:[]};function bne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}bne.isMDXComponent=!0;const Lne={toc:[]};function Zne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Zne.isMDXComponent=!0;const Nne={toc:[]};function Sne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Sne.isMDXComponent=!0;const zne={toc:[]};function Rne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Rne.isMDXComponent=!0;const Pne={toc:[]};function Ane(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Ane.isMDXComponent=!0;const Ine={toc:[]};function Wne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ine,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wne.isMDXComponent=!0;const Ene={toc:[]};function Fne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ene,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Fne.isMDXComponent=!0;const Bne={toc:[]};function One(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}One.isMDXComponent=!0;const Gne={toc:[]};function jne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}jne.isMDXComponent=!0;const Une={toc:[]};function qne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Une,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qne.isMDXComponent=!0;const Vne={toc:[]};function Hne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Hne.isMDXComponent=!0;const $ne={toc:[]};function Qne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$ne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Qne.isMDXComponent=!0;const Jne={toc:[]};function Yne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Yne.isMDXComponent=!0;const Kne={toc:[]};function toe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}toe.isMDXComponent=!0;const eoe={toc:[]};function noe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eoe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}noe.isMDXComponent=!0;const ooe={toc:[]};function soe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ooe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}soe.isMDXComponent=!0;const roe={toc:[]};function poe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},roe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}poe.isMDXComponent=!0;const ioe={toc:[]};function coe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ioe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}coe.isMDXComponent=!0;const aoe={toc:[]};function loe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aoe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}loe.isMDXComponent=!0;const uoe={toc:[]};function moe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uoe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}moe.isMDXComponent=!0;const doe={toc:[]};function hoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},doe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}hoe.isMDXComponent=!0;const foe={toc:[]};function yoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},foe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}yoe.isMDXComponent=!0;const koe={toc:[]};function woe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},koe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}woe.isMDXComponent=!0;const Moe={toc:[]};function Doe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Moe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Doe.isMDXComponent=!0;const _oe={toc:[]};function Xoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_oe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}Xoe.isMDXComponent=!0;const goe={toc:[]};function xoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},goe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xoe.isMDXComponent=!0;const Coe={toc:[]};function Toe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Coe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}Toe.isMDXComponent=!0;const voe={toc:[]};function boe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},voe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}boe.isMDXComponent=!0;const Loe={toc:[]};function Zoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Loe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Zoe.isMDXComponent=!0;const Noe={toc:[]};function Soe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Noe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Soe.isMDXComponent=!0;const zoe={toc:[]};function Roe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zoe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Roe.isMDXComponent=!0;const Poe={toc:[]};function Aoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Poe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Aoe.isMDXComponent=!0;const Ioe={toc:[]};function Woe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ioe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Woe.isMDXComponent=!0;const Eoe={toc:[]};function Foe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eoe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Foe.isMDXComponent=!0;const Boe={toc:[]};function Ooe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Boe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Ooe.isMDXComponent=!0;const Goe={toc:[]};function joe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Goe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}joe.isMDXComponent=!0;const Uoe={toc:[]};function qoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uoe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}qoe.isMDXComponent=!0;const Voe={toc:[]};function Hoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Voe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hoe.isMDXComponent=!0;const $oe={toc:[]};function Qoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$oe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Qoe.isMDXComponent=!0;const Joe={toc:[]};function Yoe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Joe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yoe.isMDXComponent=!0;const Koe={toc:[]};function tse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Koe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}tse.isMDXComponent=!0;const ese={toc:[]};function nse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ese,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nse.isMDXComponent=!0;const ose={toc:[]};function sse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ose,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}sse.isMDXComponent=!0;const rse={toc:[]};function pse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pse.isMDXComponent=!0;const ise={toc:[]};function cse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ise,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}cse.isMDXComponent=!0;const ase={toc:[]};function lse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ase,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lse.isMDXComponent=!0;const use={toc:[]};function mse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},use,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}mse.isMDXComponent=!0;const dse={toc:[]};function hse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}hse.isMDXComponent=!0;const fse={toc:[]};function yse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The alpha value of this image."))}yse.isMDXComponent=!0;const kse={toc:[]};function wse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wse.isMDXComponent=!0;const Mse={toc:[]};function Dse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Dse.isMDXComponent=!0;const _se={toc:[]};function Xse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_se,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xse.isMDXComponent=!0;const gse={toc:[]};function xse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}xse.isMDXComponent=!0;const Cse={toc:[]};function Tse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tse.isMDXComponent=!0;const vse={toc:[]};function bse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}bse.isMDXComponent=!0;const Lse={toc:[]};function Zse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide the color in one of the following formats:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"named color like ",(0,p.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,p.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,p.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,p.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,p.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,p.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,p.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,p.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,p.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}Zse.isMDXComponent=!0;const Nse={toc:[]};function Sse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The color of the icon"))}Sse.isMDXComponent=!0;const zse={toc:[]};function Rse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Rse.isMDXComponent=!0;const Pse={toc:[]};function Ase(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}Ase.isMDXComponent=!0;const Ise={toc:[]};function Wse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ise,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"You can find identifiers on ",(0,p.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}Wse.isMDXComponent=!0;const Ese={toc:[]};function Fse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ese,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The identifier of the icon."))}Fse.isMDXComponent=!0;const Bse={toc:[]};function Ose(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ose.isMDXComponent=!0;const Gse={toc:[]};function jse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}jse.isMDXComponent=!0;const Use={toc:[]};function qse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Use,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qse.isMDXComponent=!0;const Vse={toc:[]};function Hse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Hse.isMDXComponent=!0;const $se={toc:[]};function Qse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$se,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Qse.isMDXComponent=!0;const Jse={toc:[]};function Yse(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Yse.isMDXComponent=!0;const Kse={toc:[]};function tre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kse,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}tre.isMDXComponent=!0;const ere={toc:[]};function nre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ere,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the image should be smoothed."))}nre.isMDXComponent=!0;const ore={toc:[]};function sre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ore,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The source of this image."))}sre.isMDXComponent=!0;const rre={toc:[]};function pre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pre.isMDXComponent=!0;const ire={toc:[]};function cre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ire,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}cre.isMDXComponent=!0;const are={toc:[]};function lre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},are,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lre.isMDXComponent=!0;const ure={toc:[]};function mre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ure,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}mre.isMDXComponent=!0;const dre={toc:[]};function hre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hre.isMDXComponent=!0;const fre={toc:[]};function yre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}yre.isMDXComponent=!0;const kre={toc:[]};function wre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}wre.isMDXComponent=!0;const Mre={toc:[]};function Dre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The alpha value of this image."))}Dre.isMDXComponent=!0;const _re={toc:[]};function Xre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_re,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xre.isMDXComponent=!0;const gre={toc:[]};function xre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}xre.isMDXComponent=!0;const Cre={toc:[]};function Tre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tre.isMDXComponent=!0;const vre={toc:[]};function bre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}bre.isMDXComponent=!0;const Lre={toc:[]};function Zre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Zre.isMDXComponent=!0;const Nre={toc:[]};function Sre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Sre.isMDXComponent=!0;const zre={toc:[]};function Rre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Rre.isMDXComponent=!0;const Pre={toc:[]};function Are(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}Are.isMDXComponent=!0;const Ire={toc:[]};function Wre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ire,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wre.isMDXComponent=!0;const Ere={toc:[]};function Fre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ere,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Fre.isMDXComponent=!0;const Bre={toc:[]};function Ore(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ore.isMDXComponent=!0;const Gre={toc:[]};function jre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}jre.isMDXComponent=!0;const Ure={toc:[]};function qre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ure,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}qre.isMDXComponent=!0;const Vre={toc:[]};function Hre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Hre.isMDXComponent=!0;const $re={toc:[]};function Qre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$re,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Qre.isMDXComponent=!0;const Jre={toc:[]};function Yre(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the image should be smoothed."))}Yre.isMDXComponent=!0;const Kre={toc:[]};function tpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kre,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The source of this image."))}tpe.isMDXComponent=!0;const epe={toc:[]};function npe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},epe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}npe.isMDXComponent=!0;const ope={toc:[]};function spe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ope,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}spe.isMDXComponent=!0;const rpe={toc:[]};function ppe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ppe.isMDXComponent=!0;const ipe={toc:[]};function cpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ipe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}cpe.isMDXComponent=!0;const ape={toc:[]};function lpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ape,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lpe.isMDXComponent=!0;const upe={toc:[]};function mpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},upe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}mpe.isMDXComponent=!0;const dpe={toc:[]};function hpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}hpe.isMDXComponent=!0;const fpe={toc:[]};function ype(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}ype.isMDXComponent=!0;const kpe={toc:[]};function wpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,p.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,p.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,p.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,p.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}wpe.isMDXComponent=!0;const Mpe={toc:[]};function Dpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}Dpe.isMDXComponent=!0;const _pe={toc:[]};function Xpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_pe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,p.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,p.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,p.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,p.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Xpe.isMDXComponent=!0;const gpe={toc:[]};function xpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}xpe.isMDXComponent=!0;const Cpe={toc:[]};function Tpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Tpe.isMDXComponent=!0;const vpe={toc:[]};function bpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The alpha value of this image."))}bpe.isMDXComponent=!0;const Lpe={toc:[]};function Zpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Zpe.isMDXComponent=!0;const Npe={toc:[]};function Spe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Npe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Spe.isMDXComponent=!0;const zpe={toc:[]};function Rpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Rpe.isMDXComponent=!0;const Ppe={toc:[]};function Ape(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ppe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Ape.isMDXComponent=!0;const Ipe={toc:[]};function Wpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ipe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wpe.isMDXComponent=!0;const Epe={toc:[]};function Fpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Epe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Fpe.isMDXComponent=!0;const Bpe={toc:[]};function Ope(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Ope.isMDXComponent=!0;const Gpe={toc:[]};function jpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}jpe.isMDXComponent=!0;const Upe={toc:[]};function qpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Upe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qpe.isMDXComponent=!0;const Vpe={toc:[]};function Hpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Hpe.isMDXComponent=!0;const $pe={toc:[]};function Qpe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$pe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qpe.isMDXComponent=!0;const Jpe={toc:[]};function Ype(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Ype.isMDXComponent=!0;const Kpe={toc:[]};function tie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kpe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}tie.isMDXComponent=!0;const eie={toc:[]};function nie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}nie.isMDXComponent=!0;const oie={toc:[]};function sie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}sie.isMDXComponent=!0;const rie={toc:[]};function pie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the image should be smoothed."))}pie.isMDXComponent=!0;const iie={toc:[]};function cie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The source of this image."))}cie.isMDXComponent=!0;const aie={toc:[]};function lie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lie.isMDXComponent=!0;const uie={toc:[]};function mie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}mie.isMDXComponent=!0;const die={toc:[]};function hie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},die,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hie.isMDXComponent=!0;const fie={toc:[]};function yie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}yie.isMDXComponent=!0;const kie={toc:[]};function wie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wie.isMDXComponent=!0;const Mie={toc:[]};function Die(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Die.isMDXComponent=!0;const _ie={toc:[]};function Xie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_ie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xie.isMDXComponent=!0;const gie={toc:[]};function xie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}xie.isMDXComponent=!0;const Cie={toc:[]};function Tie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tie.isMDXComponent=!0;const vie={toc:[]};function bie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}bie.isMDXComponent=!0;const Lie={toc:[]};function Zie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Zie.isMDXComponent=!0;const Nie={toc:[]};function Sie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Sie.isMDXComponent=!0;const zie={toc:[]};function Rie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Rie.isMDXComponent=!0;const Pie={toc:[]};function Aie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Aie.isMDXComponent=!0;const Iie={toc:[]};function Wie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wie.isMDXComponent=!0;const Eie={toc:[]};function Fie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Fie.isMDXComponent=!0;const Bie={toc:[]};function Oie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Oie.isMDXComponent=!0;const Gie={toc:[]};function jie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}jie.isMDXComponent=!0;const Uie={toc:[]};function qie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qie.isMDXComponent=!0;const Vie={toc:[]};function Hie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Hie.isMDXComponent=!0;const $ie={toc:[]};function Qie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$ie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qie.isMDXComponent=!0;const Jie={toc:[]};function Yie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Yie.isMDXComponent=!0;const Kie={toc:[]};function tce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}tce.isMDXComponent=!0;const ece={toc:[]};function nce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ece,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}nce.isMDXComponent=!0;const oce={toc:[]};function sce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sce.isMDXComponent=!0;const rce={toc:[]};function pce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}pce.isMDXComponent=!0;const ice={toc:[]};function cce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ice,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cce.isMDXComponent=!0;const ace={toc:[]};function lce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ace,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}lce.isMDXComponent=!0;const uce={toc:[]};function mce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mce.isMDXComponent=!0;const dce={toc:[]};function hce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}hce.isMDXComponent=!0;const fce={toc:[]};function yce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}yce.isMDXComponent=!0;const kce={toc:[]};function wce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}wce.isMDXComponent=!0;const Mce={toc:[]};function Dce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Dce.isMDXComponent=!0;const _ce={toc:[]};function Xce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_ce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Xce.isMDXComponent=!0;const gce={toc:[]};function xce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xce.isMDXComponent=!0;const Cce={toc:[]};function Tce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Tce.isMDXComponent=!0;const vce={toc:[]};function bce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}bce.isMDXComponent=!0;const Lce={toc:[]};function Zce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}Zce.isMDXComponent=!0;const Nce={toc:[]};function Sce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Sce.isMDXComponent=!0;const zce={toc:[]};function Rce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Rce.isMDXComponent=!0;const Pce={toc:[]};function Ace(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ace.isMDXComponent=!0;const Ice={toc:[]};function Wce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ice,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Wce.isMDXComponent=!0;const Ece={toc:[]};function Fce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ece,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Fce.isMDXComponent=!0;const Bce={toc:[]};function Oce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Oce.isMDXComponent=!0;const Gce={toc:[]};function jce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}jce.isMDXComponent=!0;const Uce={toc:[]};function qce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}qce.isMDXComponent=!0;const Vce={toc:[]};function Hce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Hce.isMDXComponent=!0;const $ce={toc:[]};function Qce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$ce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}Qce.isMDXComponent=!0;const Jce={toc:[]};function Yce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yce.isMDXComponent=!0;const Kce={toc:[]};function tae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kce,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}tae.isMDXComponent=!0;const eae={toc:[]};function nae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nae.isMDXComponent=!0;const oae={toc:[]};function sae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}sae.isMDXComponent=!0;const rae={toc:[]};function pae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pae.isMDXComponent=!0;const iae={toc:[]};function cae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}cae.isMDXComponent=!0;const aae={toc:[]};function lae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lae.isMDXComponent=!0;const uae={toc:[]};function mae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}mae.isMDXComponent=!0;const dae={toc:[]};function hae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hae.isMDXComponent=!0;const fae={toc:[]};function yae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}yae.isMDXComponent=!0;const kae={toc:[]};function wae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wae.isMDXComponent=!0;const Mae={toc:[]};function Dae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Dae.isMDXComponent=!0;const _ae={toc:[]};function Xae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_ae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xae.isMDXComponent=!0;const gae={toc:[]};function xae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}xae.isMDXComponent=!0;const Cae={toc:[]};function Tae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tae.isMDXComponent=!0;const vae={toc:[]};function bae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}bae.isMDXComponent=!0;const Lae={toc:[]};function Zae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"For example, a value of 6 creates a hexagon."))}Zae.isMDXComponent=!0;const Nae={toc:[]};function Sae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Sets the number of sides of the polygon."))}Sae.isMDXComponent=!0;const zae={toc:[]};function Rae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Rae.isMDXComponent=!0;const Pae={toc:[]};function Aae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}Aae.isMDXComponent=!0;const Iae={toc:[]};function Wae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wae.isMDXComponent=!0;const Eae={toc:[]};function Fae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Fae.isMDXComponent=!0;const Bae={toc:[]};function Oae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Oae.isMDXComponent=!0;const Gae={toc:[]};function jae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}jae.isMDXComponent=!0;const Uae={toc:[]};function qae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}qae.isMDXComponent=!0;const Vae={toc:[]};function Hae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}Hae.isMDXComponent=!0;const $ae={toc:[]};function Qae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$ae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qae.isMDXComponent=!0;const Jae={toc:[]};function Yae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Yae.isMDXComponent=!0;const Kae={toc:[]};function tle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tle.isMDXComponent=!0;const ele={toc:[]};function nle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ele,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}nle.isMDXComponent=!0;const ole={toc:[]};function sle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ole,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sle.isMDXComponent=!0;const rle={toc:[]};function ple(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}ple.isMDXComponent=!0;const ile={toc:[]};function cle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ile,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}cle.isMDXComponent=!0;const ale={toc:[]};function lle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ale,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}lle.isMDXComponent=!0;const ule={toc:[]};function mle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ule,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}mle.isMDXComponent=!0;const dle={toc:[]};function hle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}hle.isMDXComponent=!0;const fle={toc:[]};function yle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}yle.isMDXComponent=!0;const kle={toc:[]};function wle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}wle.isMDXComponent=!0;const Mle={toc:[]};function Dle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Dle.isMDXComponent=!0;const _le={toc:[]};function Xle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_le,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}Xle.isMDXComponent=!0;const gle={toc:[]};function xle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xle.isMDXComponent=!0;const Cle={toc:[]};function Tle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Tle.isMDXComponent=!0;const vle={toc:[]};function ble(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ble.isMDXComponent=!0;const Lle={toc:[]};function Zle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Zle.isMDXComponent=!0;const Nle={toc:[]};function Sle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Sle.isMDXComponent=!0;const zle={toc:[]};function Rle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Rle.isMDXComponent=!0;const Ple={toc:[]};function Ale(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ple,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ale.isMDXComponent=!0;const Ile={toc:[]};function Wle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ile,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Wle.isMDXComponent=!0;const Ele={toc:[]};function Fle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ele,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Fle.isMDXComponent=!0;const Ble={toc:[]};function Ole(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ble,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}Ole.isMDXComponent=!0;const Gle={toc:[]};function jle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}jle.isMDXComponent=!0;const Ule={toc:[]};function qle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ule,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}qle.isMDXComponent=!0;const Vle={toc:[]};function Hle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hle.isMDXComponent=!0;const $le={toc:[]};function Qle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$le,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Qle.isMDXComponent=!0;const Jle={toc:[]};function Yle(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yle.isMDXComponent=!0;const Kle={toc:[]};function tue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kle,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}tue.isMDXComponent=!0;const eue={toc:[]};function nue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}nue.isMDXComponent=!0;const oue={toc:[]};function sue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}sue.isMDXComponent=!0;const rue={toc:[]};function pue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pue.isMDXComponent=!0;const iue={toc:[]};function cue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}cue.isMDXComponent=!0;const aue={toc:[]};function lue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lue.isMDXComponent=!0;const uue={toc:[]};function mue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}mue.isMDXComponent=!0;const due={toc:[]};function hue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},due,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hue.isMDXComponent=!0;const fue={toc:[]};function yue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}yue.isMDXComponent=!0;const kue={toc:[]};function wue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}wue.isMDXComponent=!0;const Mue={toc:[]};function Due(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}Due.isMDXComponent=!0;const _ue={toc:[]};function Xue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_ue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Xue.isMDXComponent=!0;const gue={toc:[]};function xue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}xue.isMDXComponent=!0;const Cue={toc:[]};function Tue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Tue.isMDXComponent=!0;const vue={toc:[]};function bue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}bue.isMDXComponent=!0;const Lue={toc:[]};function Zue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Zue.isMDXComponent=!0;const Nue={toc:[]};function Sue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}Sue.isMDXComponent=!0;const zue={toc:[]};function Rue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The starting point of the ray."))}Rue.isMDXComponent=!0;const Pue={toc:[]};function Aue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Aue.isMDXComponent=!0;const Iue={toc:[]};function Wue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Wue.isMDXComponent=!0;const Eue={toc:[]};function Fue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Fue.isMDXComponent=!0;const Bue={toc:[]};function Oue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Oue.isMDXComponent=!0;const Gue={toc:[]};function jue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}jue.isMDXComponent=!0;const Uue={toc:[]};function que(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}que.isMDXComponent=!0;const Vue={toc:[]};function Hue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Hue.isMDXComponent=!0;const $ue={toc:[]};function Que(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$ue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Que.isMDXComponent=!0;const Jue={toc:[]};function Yue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Yue.isMDXComponent=!0;const Kue={toc:[]};function tme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}tme.isMDXComponent=!0;const eme={toc:[]};function nme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ending point of the ray."))}nme.isMDXComponent=!0;const ome={toc:[]};function sme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ome,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sme.isMDXComponent=!0;const rme={toc:[]};function pme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}pme.isMDXComponent=!0;const ime={toc:[]};function cme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ime,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cme.isMDXComponent=!0;const ame={toc:[]};function lme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ame,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}lme.isMDXComponent=!0;const ume={toc:[]};function mme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ume,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mme.isMDXComponent=!0;const dme={toc:[]};function hme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}hme.isMDXComponent=!0;const fme={toc:[]};function yme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}yme.isMDXComponent=!0;const kme={toc:[]};function wme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}wme.isMDXComponent=!0;const Mme={toc:[]};function Dme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Dme.isMDXComponent=!0;const _me={toc:[]};function Xme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_me,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Xme.isMDXComponent=!0;const gme={toc:[]};function xme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xme.isMDXComponent=!0;const Cme={toc:[]};function Tme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Tme.isMDXComponent=!0;const vme={toc:[]};function bme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}bme.isMDXComponent=!0;const Lme={toc:[]};function Zme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}Zme.isMDXComponent=!0;const Nme={toc:[]};function Sme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Sme.isMDXComponent=!0;const zme={toc:[]};function Rme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Rme.isMDXComponent=!0;const Pme={toc:[]};function Ame(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ame.isMDXComponent=!0;const Ime={toc:[]};function Wme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ime,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Wme.isMDXComponent=!0;const Eme={toc:[]};function Fme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Fme.isMDXComponent=!0;const Bme={toc:[]};function Ome(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Ome.isMDXComponent=!0;const Gme={toc:[]};function jme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}jme.isMDXComponent=!0;const Ume={toc:[]};function qme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ume,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}qme.isMDXComponent=!0;const Vme={toc:[]};function Hme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hme.isMDXComponent=!0;const $me={toc:[]};function Qme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$me,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Qme.isMDXComponent=!0;const Jme={toc:[]};function Yme(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yme.isMDXComponent=!0;const Kme={toc:[]};function tde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kme,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}tde.isMDXComponent=!0;const ede={toc:[]};function nde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ede,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nde.isMDXComponent=!0;const ode={toc:[]};function sde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ode,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}sde.isMDXComponent=!0;const rde={toc:[]};function pde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pde.isMDXComponent=!0;const ide={toc:[]};function cde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ide,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}cde.isMDXComponent=!0;const ade={toc:[]};function lde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ade,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lde.isMDXComponent=!0;const ude={toc:[]};function mde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ude,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}mde.isMDXComponent=!0;const dde={toc:[]};function hde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hde.isMDXComponent=!0;const fde={toc:[]};function yde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}yde.isMDXComponent=!0;const kde={toc:[]};function wde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wde.isMDXComponent=!0;const Mde={toc:[]};function Dde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Dde.isMDXComponent=!0;const _de={toc:[]};function Xde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_de,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xde.isMDXComponent=!0;const gde={toc:[]};function xde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}xde.isMDXComponent=!0;const Cde={toc:[]};function Tde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tde.isMDXComponent=!0;const vde={toc:[]};function bde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}bde.isMDXComponent=!0;const Lde={toc:[]};function Zde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Zde.isMDXComponent=!0;const Nde={toc:[]};function Sde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Sde.isMDXComponent=!0;const zde={toc:[]};function Rde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"To make the arrows visible make sure to enable ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,p.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Rde.isMDXComponent=!0;const Pde={toc:[]};function Ade(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the size of the end and start arrows."))}Ade.isMDXComponent=!0;const Ide={toc:[]};function Wde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ide,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wde.isMDXComponent=!0;const Ede={toc:[]};function Fde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ede,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Fde.isMDXComponent=!0;const Bde={toc:[]};function Ode(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ode.isMDXComponent=!0;const Gde={toc:[]};function jde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}jde.isMDXComponent=!0;const Ude={toc:[]};function qde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ude,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qde.isMDXComponent=!0;const Vde={toc:[]};function Hde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Hde.isMDXComponent=!0;const $de={toc:[]};function Qde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$de,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Closed curves have their start and end points connected."))}Qde.isMDXComponent=!0;const Jde={toc:[]};function Yde(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the curve should be closed."))}Yde.isMDXComponent=!0;const Kde={toc:[]};function the(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kde,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}the.isMDXComponent=!0;const ehe={toc:[]};function nhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ehe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}nhe.isMDXComponent=!0;const ohe={toc:[]};function she(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ohe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}she.isMDXComponent=!0;const rhe={toc:[]};function phe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}phe.isMDXComponent=!0;const ihe={toc:[]};function che(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ihe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,p.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}che.isMDXComponent=!0;const ahe={toc:[]};function lhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ahe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the end of the curve."))}lhe.isMDXComponent=!0;const uhe={toc:[]};function mhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mhe.isMDXComponent=!0;const dhe={toc:[]};function hhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}hhe.isMDXComponent=!0;const fhe={toc:[]};function yhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Spline.points"))}yhe.isMDXComponent=!0;const khe={toc:[]};function whe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},khe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}whe.isMDXComponent=!0;const Mhe={toc:[]};function Dhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Dhe.isMDXComponent=!0;const _he={toc:[]};function Xhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_he,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}Xhe.isMDXComponent=!0;const ghe={toc:[]};function xhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ghe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}xhe.isMDXComponent=!0;const Che={toc:[]};function The(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Che,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,p.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,p.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,p.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}The.isMDXComponent=!0;const vhe={toc:[]};function bhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}bhe.isMDXComponent=!0;const Lhe={toc:[]};function Zhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,p.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Zhe.isMDXComponent=!0;const Nhe={toc:[]};function She(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}She.isMDXComponent=!0;const zhe={toc:[]};function Rhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,p.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,p.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,p.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Rhe.isMDXComponent=!0;const Phe={toc:[]};function Ahe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Phe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The offset in pixels from the start of the curve."))}Ahe.isMDXComponent=!0;const Ihe={toc:[]};function Whe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ihe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Whe.isMDXComponent=!0;const Ehe={toc:[]};function Fhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ehe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}Fhe.isMDXComponent=!0;const Bhe={toc:[]};function Ohe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ohe.isMDXComponent=!0;const Ghe={toc:[]};function jhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ghe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}jhe.isMDXComponent=!0;const Uhe={toc:[]};function qhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qhe.isMDXComponent=!0;const Vhe={toc:[]};function Hhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Hhe.isMDXComponent=!0;const $he={toc:[]};function Qhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$he,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qhe.isMDXComponent=!0;const Jhe={toc:[]};function Yhe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jhe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Yhe.isMDXComponent=!0;const Khe={toc:[]};function tfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Khe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tfe.isMDXComponent=!0;const efe={toc:[]};function nfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},efe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}nfe.isMDXComponent=!0;const ofe={toc:[]};function sfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ofe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sfe.isMDXComponent=!0;const rfe={toc:[]};function pfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}pfe.isMDXComponent=!0;const ife={toc:[]};function cfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ife,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cfe.isMDXComponent=!0;const afe={toc:[]};function lfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},afe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}lfe.isMDXComponent=!0;const ufe={toc:[]};function mfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ufe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mfe.isMDXComponent=!0;const dfe={toc:[]};function hfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}hfe.isMDXComponent=!0;const ffe={toc:[]};function yfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ffe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}yfe.isMDXComponent=!0;const kfe={toc:[]};function wfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}wfe.isMDXComponent=!0;const Mfe={toc:[]};function Dfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Dfe.isMDXComponent=!0;const _fe={toc:[]};function Xfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_fe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Xfe.isMDXComponent=!0;const gfe={toc:[]};function xfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xfe.isMDXComponent=!0;const Cfe={toc:[]};function Tfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Tfe.isMDXComponent=!0;const vfe={toc:[]};function bfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}bfe.isMDXComponent=!0;const Lfe={toc:[]};function Zfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The alpha value of this video."))}Zfe.isMDXComponent=!0;const Nfe={toc:[]};function Sfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Sfe.isMDXComponent=!0;const zfe={toc:[]};function Rfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Rfe.isMDXComponent=!0;const Pfe={toc:[]};function Afe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Afe.isMDXComponent=!0;const Ife={toc:[]};function Wfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ife,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Wfe.isMDXComponent=!0;const Efe={toc:[]};function Ffe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Efe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ffe.isMDXComponent=!0;const Bfe={toc:[]};function Ofe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Ofe.isMDXComponent=!0;const Gfe={toc:[]};function jfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}jfe.isMDXComponent=!0;const Ufe={toc:[]};function qfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ufe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}qfe.isMDXComponent=!0;const Vfe={toc:[]};function Hfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hfe.isMDXComponent=!0;const $fe={toc:[]};function Qfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$fe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}Qfe.isMDXComponent=!0;const Jfe={toc:[]};function Yfe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this video should loop upon reaching the end."))}Yfe.isMDXComponent=!0;const Kfe={toc:[]};function tye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kfe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tye.isMDXComponent=!0;const eye={toc:[]};function nye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}nye.isMDXComponent=!0;const oye={toc:[]};function sye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}sye.isMDXComponent=!0;const rye={toc:[]};function pye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}pye.isMDXComponent=!0;const iye={toc:[]};function cye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}cye.isMDXComponent=!0;const aye={toc:[]};function lye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the video should be smoothed."))}lye.isMDXComponent=!0;const uye={toc:[]};function mye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The source of this video."))}mye.isMDXComponent=!0;const dye={toc:[]};function hye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The starting time for this video in seconds."))}hye.isMDXComponent=!0;const fye={toc:[]};function yye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}yye.isMDXComponent=!0;const kye={toc:[]};function wye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}wye.isMDXComponent=!0;const Mye={toc:[]};function Dye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Dye.isMDXComponent=!0;const _ye={toc:[]};function Xye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_ye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}Xye.isMDXComponent=!0;const gye={toc:[]};function xye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xye.isMDXComponent=!0;const Cye={toc:[]};function Tye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}Tye.isMDXComponent=!0;const vye={toc:[]};function bye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bye.isMDXComponent=!0;const Lye={toc:[]};function Zye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom edge of this node."))}Zye.isMDXComponent=!0;const Nye={toc:[]};function Sye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Sye.isMDXComponent=!0;const zye={toc:[]};function Rye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom left corner of this node."))}Rye.isMDXComponent=!0;const Pye={toc:[]};function Aye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Aye.isMDXComponent=!0;const Iye={toc:[]};function Wye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the bottom right corner of this node."))}Wye.isMDXComponent=!0;const Eye={toc:[]};function Fye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"By default the ",(0,p.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,p.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Fye.isMDXComponent=!0;const Bye={toc:[]};function Oye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Controls the sharpness of the corners. ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,p.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}Oye.isMDXComponent=!0;const Gye={toc:[]};function jye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}jye.isMDXComponent=!0;const Uye={toc:[]};function qye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the left edge of this node."))}qye.isMDXComponent=!0;const Vye={toc:[]};function Hye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hye.isMDXComponent=!0;const $ye={toc:[]};function Qye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$ye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the right edge of this node."))}Qye.isMDXComponent=!0;const Jye={toc:[]};function Yye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,p.kt)("p",null,"When ",(0,p.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,p.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Yye.isMDXComponent=!0;const Kye={toc:[]};function tke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will set the corner drawing method to smooth corners."))}tke.isMDXComponent=!0;const eke={toc:[]};function nke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nke.isMDXComponent=!0;const oke={toc:[]};function ske(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top edge of this node."))}ske.isMDXComponent=!0;const rke={toc:[]};function pke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pke.isMDXComponent=!0;const ike={toc:[]};function cke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ike,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top left corner of this node."))}cke.isMDXComponent=!0;const ake={toc:[]};function lke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ake,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,p.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lke.isMDXComponent=!0;const uke={toc:[]};function mke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The position of the top right corner of this node."))}mke.isMDXComponent=!0;const dke={toc:[]};function hke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}hke.isMDXComponent=!0;const fke={toc:[]};function yke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Evaluate the polynomial at the given t value."))}yke.isMDXComponent=!0;const kke={toc:[]};function wke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The t value at which to evaluate the curve."))}wke.isMDXComponent=!0;const Mke={toc:[]};function Dke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}Dke.isMDXComponent=!0;const _ke={toc:[]};function Xke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_ke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The t value at which to evaluate the curve."))}Xke.isMDXComponent=!0;const gke={toc:[]};function xke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,p.kt)("p",null,"Source code liberally taken from:\n",(0,p.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}xke.isMDXComponent=!0;const Cke={toc:[]};function Tke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constant coefficient"))}Tke.isMDXComponent=!0;const vke={toc:[]};function bke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constant coefficient"))}bke.isMDXComponent=!0;const Lke={toc:[]};function Zke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The linear coefficient"))}Zke.isMDXComponent=!0;const Nke={toc:[]};function Ske(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constant coefficient"))}Ske.isMDXComponent=!0;const zke={toc:[]};function Rke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The linear coefficient"))}Rke.isMDXComponent=!0;const Pke={toc:[]};function Ake(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The quadratic coefficient"))}Ake.isMDXComponent=!0;const Ike={toc:[]};function Wke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ike,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constant coefficient"))}Wke.isMDXComponent=!0;const Eke={toc:[]};function Fke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The linear coefficient"))}Fke.isMDXComponent=!0;const Bke={toc:[]};function Oke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The quadratic coefficient"))}Oke.isMDXComponent=!0;const Gke={toc:[]};function jke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The cubic coefficient"))}jke.isMDXComponent=!0;const Uke={toc:[]};function qke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The degree of the polynomial"))}qke.isMDXComponent=!0;const Vke={toc:[]};function Hke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the nth derivative of the polynomial."))}Hke.isMDXComponent=!0;const $ke={toc:[]};function Qke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$ke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The number of times to differentiate the polynomial."))}Qke.isMDXComponent=!0;const Jke={toc:[]};function Yke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Evaluate the polynomial at the given value t."))}Yke.isMDXComponent=!0;const Kke={toc:[]};function twe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value to sample at"))}twe.isMDXComponent=!0;const ewe={toc:[]};function nwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ewe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}nwe.isMDXComponent=!0;const owe={toc:[]};function swe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},owe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value to sample at"))}swe.isMDXComponent=!0;const rwe={toc:[]};function pwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The derivative of the polynomial to sample from"))}pwe.isMDXComponent=!0;const iwe={toc:[]};function cwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the local extrema of the polynomial."))}cwe.isMDXComponent=!0;const awe={toc:[]};function lwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},awe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}lwe.isMDXComponent=!0;const uwe={toc:[]};function mwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the output value range within the unit interval."))}mwe.isMDXComponent=!0;const dwe={toc:[]};function hwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}hwe.isMDXComponent=!0;const fwe={toc:[]};function ywe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}ywe.isMDXComponent=!0;const kwe={toc:[]};function wwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}wwe.isMDXComponent=!0;const Mwe={toc:[]};function Dwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The point at which to split the polynomial."))}Dwe.isMDXComponent=!0;const _we={toc:[]};function Xwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_we,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Constructs a constant polynomial"))}Xwe.isMDXComponent=!0;const gwe={toc:[]};function xwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constant coefficient"))}xwe.isMDXComponent=!0;const Cwe={toc:[]};function Twe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Constructs a cubic polynomial"))}Twe.isMDXComponent=!0;const vwe={toc:[]};function bwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constant coefficient"))}bwe.isMDXComponent=!0;const Lwe={toc:[]};function Zwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The linear coefficient"))}Zwe.isMDXComponent=!0;const Nwe={toc:[]};function Swe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The quadratic coefficient"))}Swe.isMDXComponent=!0;const zwe={toc:[]};function Rwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The cubic coefficient"))}Rwe.isMDXComponent=!0;const Pwe={toc:[]};function Awe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Constructs a linear polynomial"))}Awe.isMDXComponent=!0;const Iwe={toc:[]};function Wwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constant coefficient"))}Wwe.isMDXComponent=!0;const Ewe={toc:[]};function Fwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ewe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The linear coefficient"))}Fwe.isMDXComponent=!0;const Bwe={toc:[]};function Owe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Constructs a quadratic polynomial"))}Owe.isMDXComponent=!0;const Gwe={toc:[]};function jwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constant coefficient"))}jwe.isMDXComponent=!0;const Uwe={toc:[]};function qwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The linear coefficient"))}qwe.isMDXComponent=!0;const Vwe={toc:[]};function Hwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The quadratic coefficient"))}Hwe.isMDXComponent=!0;const $we={toc:[]};function Qwe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$we,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}Qwe.isMDXComponent=!0;const Jwe={toc:[]};function Ywe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}Ywe.isMDXComponent=!0;const Kwe={toc:[]};function tMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kwe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Evaluate the polynomial at the given t value."))}tMe.isMDXComponent=!0;const eMe={toc:[]};function nMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The t value at which to evaluate the curve."))}nMe.isMDXComponent=!0;const oMe={toc:[]};function sMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}sMe.isMDXComponent=!0;const rMe={toc:[]};function pMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The t value at which to evaluate the curve."))}pMe.isMDXComponent=!0;const iMe={toc:[]};function cMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,p.kt)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}cMe.isMDXComponent=!0;const aMe={toc:[]};function lMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aMe,n,{components:e,mdxType:"MDXLayout"}))}lMe.isMDXComponent=!0;const uMe={toc:[]};function mMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}mMe.isMDXComponent=!0;const dMe={toc:[]};function hMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The knots defining the spline"))}hMe.isMDXComponent=!0;const fMe={toc:[]};function yMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the spline should be closed or not"))}yMe.isMDXComponent=!0;const kMe={toc:[]};function wMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}wMe.isMDXComponent=!0;const MMe={toc:[]};function DMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}DMe.isMDXComponent=!0;const _Me={toc:[]};function XMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Me,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the signal is currently using its initial value."))}XMe.isMDXComponent=!0;const gMe={toc:[]};function xMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}xMe.isMDXComponent=!0;const CMe={toc:[]};function TMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}TMe.isMDXComponent=!0;const vMe={toc:[]};function bMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}bMe.isMDXComponent=!0;const LMe={toc:[]};function ZMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}ZMe.isMDXComponent=!0;const NMe={toc:[]};function SMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}SMe.isMDXComponent=!0;const zMe={toc:[]};function RMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}RMe.isMDXComponent=!0;const PMe={toc:[]};function AMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}AMe.isMDXComponent=!0;const IMe={toc:[]};function WMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}WMe.isMDXComponent=!0;const EMe={toc:[]};function FMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,p.kt)("p",null,"By default, any property is cloneable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}FMe.isMDXComponent=!0;const BMe={toc:[]};function OMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}OMe.isMDXComponent=!0;const GMe={toc:[]};function jMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a cloneable property decorator."))}jMe.isMDXComponent=!0;const UMe={toc:[]};function qMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be cloneable."))}qMe.isMDXComponent=!0;const VMe={toc:[]};function HMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}HMe.isMDXComponent=!0;const $Me={toc:[]};function QMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Me,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}QMe.isMDXComponent=!0;const JMe={toc:[]};function YMe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a compound property decorator."))}YMe.isMDXComponent=!0;const KMe={toc:[]};function tDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KMe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}tDe.isMDXComponent=!0;const eDe={toc:[]};function nDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,p.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,p.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}nDe.isMDXComponent=!0;const oDe={toc:[]};function sDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a computed method decorator."))}sDe.isMDXComponent=!0;const rDe={toc:[]};function pDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the initial value of a property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}pDe.isMDXComponent=!0;const iDe={toc:[]};function cDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}cDe.isMDXComponent=!0;const aDe={toc:[]};function lDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an initial signal value decorator."))}lDe.isMDXComponent=!0;const uDe={toc:[]};function mDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value of the property."))}mDe.isMDXComponent=!0;const dDe={toc:[]};function hDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,p.kt)("p",null,"By default, any property is inspectable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}hDe.isMDXComponent=!0;const fDe={toc:[]};function yDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}yDe.isMDXComponent=!0;const kDe={toc:[]};function wDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an inspectable property decorator."))}wDe.isMDXComponent=!0;const MDe={toc:[]};function DDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be inspectable."))}DDe.isMDXComponent=!0;const _De={toc:[]};function XDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_De,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}XDe.isMDXComponent=!0;const gDe={toc:[]};function xDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}xDe.isMDXComponent=!0;const CDe={toc:[]};function TDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal interpolation function decorator."))}TDe.isMDXComponent=!0;const vDe={toc:[]};function bDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interpolation function for the property."))}bDe.isMDXComponent=!0;const LDe={toc:[]};function ZDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,p.kt)("p",null,"If the wrapper class has a method called ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}ZDe.isMDXComponent=!0;const NDe={toc:[]};function SDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},NDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}SDe.isMDXComponent=!0;const zDe={toc:[]};function RDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal parser decorator."))}RDe.isMDXComponent=!0;const PDe={toc:[]};function ADe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}ADe.isMDXComponent=!0;const IDe={toc:[]};function WDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given property into a signal."),(0,p.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}WDe.isMDXComponent=!0;const EDe={toc:[]};function FDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}FDe.isMDXComponent=!0;const BDe={toc:[]};function ODe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal decorator."))}ODe.isMDXComponent=!0;const GDe={toc:[]};function jDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,p.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,p.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,p.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}jDe.isMDXComponent=!0;const UDe={toc:[]};function qDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}qDe.isMDXComponent=!0;const VDe={toc:[]};function HDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal wrapper decorator."))}HDe.isMDXComponent=!0;const $De={toc:[]};function QDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$De,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}QDe.isMDXComponent=!0;const JDe={toc:[]};function YDe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A unified abstraction for all CSS filters."))}YDe.isMDXComponent=!0;const KDe={toc:[]};function t_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KDe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the desired length is set to ",(0,p.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}t_e.isMDXComponent=!0;const e_e={toc:[]};function n_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},e_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}n_e.isMDXComponent=!0;const o_e={toc:[]};function s_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},o_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value can be either:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,p.kt)("inlineCode",{parentName:"li"},"'50%'"))))}s_e.isMDXComponent=!0;const r_e={toc:[]};function p_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},r_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a length used by most layout properties."))}p_e.isMDXComponent=!0;const i_e={toc:[]};function c_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},i_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,p.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}c_e.isMDXComponent=!0;const a_e={toc:[]};function l_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},a_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,p.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}l_e.isMDXComponent=!0;const u_e={toc:[]};function m_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},u_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter in pixels."))}m_e.isMDXComponent=!0;const d_e={toc:[]};function h_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},d_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,p.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}h_e.isMDXComponent=!0;const f_e={toc:[]};function y_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},f_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}y_e.isMDXComponent=!0;const k_e={toc:[]};function w_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},k_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,p.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}w_e.isMDXComponent=!0;const M_e={toc:[]};function D_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},M_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}D_e.isMDXComponent=!0;const __e={toc:[]};function X_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},__e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,p.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}X_e.isMDXComponent=!0;const g_e={toc:[]};function x_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},g_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}x_e.isMDXComponent=!0;const C_e={toc:[]};function T_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},C_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,p.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}T_e.isMDXComponent=!0;const v_e={toc:[]};function b_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},v_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter in degrees."))}b_e.isMDXComponent=!0;const L_e={toc:[]};function Z_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},L_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,p.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}Z_e.isMDXComponent=!0;const N_e={toc:[]};function S_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},N_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}S_e.isMDXComponent=!0;const z_e={toc:[]};function R_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},z_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,p.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}R_e.isMDXComponent=!0;const P_e={toc:[]};function A_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},P_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}A_e.isMDXComponent=!0;const I_e={toc:[]};function W_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},I_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,p.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}W_e.isMDXComponent=!0;const E_e={toc:[]};function F_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},E_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}F_e.isMDXComponent=!0;const B_e={toc:[]};function O_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},B_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}O_e.isMDXComponent=!0;const G_e={toc:[]};function j_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},G_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoke the given callback in the context of this scene."))}j_e.isMDXComponent=!0;const U_e={toc:[]};function q_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},U_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to invoke."))}q_e.isMDXComponent=!0;const V_e={toc:[]};function H_e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},V_e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}function $_e(t){let{id:e}=t;const n=o[e]??s.Fragment;return s.createElement(n,null)}H_e.isMDXComponent=!0},79322:(t,e,n)=>{"use strict";n.d(e,{Z:()=>m});var o=n(2784),s=n(99703),r=n(28698);const p="toggle_S_IX",i="collapsed_wdUB",c="collapse_TjTN",a="inverse_g6vW",l="clearFix_HQ1T";var u=n(6277);function m(t){let{comment:e,full:n=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@remarks"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(s.Z,{id:null==e?void 0:e.summaryId}),o.createElement(s.Z,{id:null==r?void 0:r.contentId}),n&&o.createElement(d,{comment:e}))}function d(t){let{comment:e}=t;const[n,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@preview"===e}))}),[e]),h=(0,o.useMemo)((()=>{var t;return(null==e||null==(t=e.blockTags)?void 0:t.filter((t=>{let{tag:e}=t;return"@example"===e})))??[]}),[e]),f=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@defaultValue"===e}))}),[e]),y=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@deprecated"===e}))}),[e]),k=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@see"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(s.Z,{id:null==d?void 0:d.contentId}),h.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(p,n&&i),onClick:t=>{t.preventDefault(),m(!n)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:n},o.createElement("div",{className:c},h.map((t=>o.createElement(s.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,a)})),f&&o.createElement(o.Fragment,null,"Default Value:"," ",o.createElement("code",null,f.content.map((t=>t.text)).join(""))),y&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(s.Z,{id:y.contentId})),k&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(s.Z,{id:k.contentId})))}},31930:(t,e,n)=>{"use strict";n.d(e,{Z:()=>Ot});var o=n(2784),s=n(37390),r=n(66835),p=n(80068),i=n(6277),c=n(68569);const a={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=n(7896);function u(t){let{width:e=24,height:n=24,...s}=t;return o.createElement("svg",(0,l.Z)({width:e,height:n,"aria-hidden":"true",viewBox:"0 0 24 24"},s),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:e,highlight:n,onClick:s,link:l}=t;const m=(0,r.F)(),d=(0,p.s2)();return o.createElement("div",{className:(0,i.Z)(c.Z.codeBlockContent,a.codeBlock,n&&a.highlight,s&&a.pointer)},o.createElement("pre",{onClick:s,onKeyDown:t=>{"Enter"===t.key&&(null==s||s())},tabIndex:0,ref:m.codeBlockRef,className:(0,i.Z)(c.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:c.Z.codeBlockLines,style:d},e)),l&&o.createElement("div",{className:c.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=n(39318);function h(t){let{children:e}=t;return o.createElement(d.Z,{as:"div",className:(0,i.Z)(a.codeBlockContainer,"language-typescript")},e)}var f=n(89817);function y(t){let{children:e,type:n,to:s,id:r,tooltip:i}=t;const c=(0,p.Ld)(n);return s?o.createElement(f.Z,(0,l.Z)({id:r,to:s,"data-tooltip":i},c),e):o.createElement("span",(0,l.Z)({id:r},c),e)}let k,w;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(k||(k={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(w||(w={}));const M={[k.None]:a.none,[k.Angle]:a.angle,[k.Curly]:a.curly,[k.Square]:a.square,[k.Parentheses]:a.parentheses};function D(t){let{children:e,type:n,separator:s=w.Comma}=t;return o.createElement("span",{className:(0,i.Z)(a.list,M[n??k.None])},o.createElement("span",{className:(0,i.Z)(a.elements,s!==w.Comma&&a.left)},(Array.isArray(e)?e:[e]).flatMap(((t,e)=>o.createElement("span",{"data-separator":s,key:e,className:a.element},t)))))}var _=n(88617);function X(t){var e;let{type:n}=t;const s=(0,_.RU)(n.project),r=null==s?void 0:s[n.id],p=n.externalUrl??(0,_.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(y,{to:p,type:p?"class-name":"constant",tooltip:!0},n.name),!(null==(e=n.typeArguments)||!e.length)&&o.createElement(D,{type:k.Angle},n.typeArguments.map(((t,e)=>o.createElement(E,{key:e,type:t})))))}function g(t){let{type:e}=t;return o.createElement(y,{type:"keyword"},e.name)}function x(t){let{type:e}=t;return e.elements?o.createElement(D,{type:k.Square},e.elements.map(((t,e)=>o.createElement(E,{key:e,type:t})))):o.createElement(o.Fragment,null,"[]")}function C(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:e.elementType}),"[]")}function T(t){let{type:e}=t;return o.createElement(D,{type:k.Parentheses,separator:w.Pipe},e.types.map(((t,e)=>o.createElement(E,{key:e,type:t}))))}function v(t){let{type:e}=t;const[n,s]=(0,o.useMemo)((()=>{if(null===e.value)return["null","keyword"];switch(typeof e.value){case"object":return[(e.value.negative?"-":"")+e.value.value,"number"];case"boolean":return[e.value,"keyword"];case"number":return[e.value,"number"];case"string":return[`'${e.value}'`,"string"];default:return[e.value,"constant"]}}),[e.value]);return o.createElement(y,{type:s},n)}function b(t){let{type:e}=t;return e.asserts?o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"asserts "),o.createElement(y,null,e.name," ")):o.createElement(o.Fragment,null,o.createElement(y,null,e.name," "),o.createElement(y,{type:"keyword"},"is "),o.createElement(E,{type:e.targetType}))}function L(t){let{type:e}=t;const n=(0,_.in)();return o.createElement(Q,{reflection:n(e.declaration)})}function Z(t){let{type:e}=t;return o.createElement(D,{type:k.Parentheses,separator:w.Ampersand},e.types.map(((t,e)=>o.createElement(E,{key:e,type:t}))))}function N(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"string"},"`",e.head),e.tail.map(((t,e)=>{let[n,s]=t;return o.createElement(o.Fragment,null,"${",o.createElement(E,{key:e,type:n}),"}",o.createElement(y,{type:"string"},s))})),o.createElement(y,{type:"string"},"`"))}function S(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"typeof "),o.createElement(E,{type:e.queryType}))}function z(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:e.checkType}),o.createElement(y,{type:"keyword"}," extends "),o.createElement(E,{type:e.extendsType})," ? ",o.createElement(E,{type:e.trueType})," : ",o.createElement(E,{type:e.falseType}))}function R(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"infer "),o.createElement(y,{type:"constant"},e.name))}function P(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:e.objectType}),"[",o.createElement(E,{type:e.indexType}),"]")}function A(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},e.operator," "),o.createElement(E,{type:e.target}))}function I(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(D,{type:k.Curly},o.createElement(o.Fragment,null,"[",o.createElement(y,{type:"class"},e.parameter),o.createElement(y,{type:"keyword"}," in "),o.createElement(E,{type:e.parameterType}),"]: ",o.createElement(E,{type:e.templateType}))))}function W(t){let{type:e}=t;return o.createElement(o.Fragment,null,e.name,": ",o.createElement(E,{type:e.element}))}function E(t){const e=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return A;case"conditional":return z;case"reflection":return L;case"query":return S;case"named-tuple-member":return W;case"union":return T;case"intrinsic":return g;case"literal":return v;case"reference":return X;case"predicate":return b;case"tuple":return x;case"array":return C;case"intersection":return Z;case"inferred":return R;case"mapped":return I;case"template-literal":return N;case"indexedAccess":return P}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(e,t)}function F(t){let{flags:e,explicitAccessModifier:n}=t;const s=[];return null!=e&&e.isAbstract&&s.push("abstract"),null!=e&&e.isStatic&&s.push("static"),null!=e&&e.isConst&&s.push("const"),null!=e&&e.isReadonly&&s.push("readonly"),null!=e&&e.isPrivate&&s.push("private"),null!=e&&e.isProtected&&s.push("protected"),(null==e||!e.isPublic)&&(!n||null!=e&&e.isProtected||null!=e&&e.isPrivate)||s.push("public"),o.createElement(o.Fragment,null,s.map((t=>o.createElement(y,{key:t,type:"keyword"},t," "))))}function B(t){let{reflection:e}=t;const n="__namedParameters"===e.name?"{...}":e.name;return o.createElement(o.Fragment,null,o.createElement(F,{flags:e.flags}),e.flags.isRest&&"...",o.createElement(y,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"plain"},n),e.flags.isOptional&&"?",": ",e.type&&o.createElement(E,{type:e.type}),e.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(y,{type:"plain"},e.defaultValue)))}function O(t){let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(F,{flags:e.flags}),e.varianceModifier&&o.createElement(y,{type:"keyword"},e.varianceModifier," "),o.createElement(y,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"class-name"},e.name),e.type&&o.createElement(o.Fragment,null," extends ",o.createElement(E,{type:e.type})),e.default&&o.createElement(o.Fragment,null," = ",o.createElement(E,{type:e.default})))}function G(t){var e,n;let{reflection:r,flags:p}=t;const i=(0,_.in)(),c="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(F,{flags:p??r.flags,explicitAccessModifier:!c}),r.kind===s.W.GetSignature&&o.createElement(y,{type:"keyword"},"get "),r.kind===s.W.SetSignature&&o.createElement(y,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(y,{to:r.overwrites.externalUrl??(0,_.Gr)(i(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===s.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(y,{to:"#",type:"keyword"},"new")," ",o.createElement(y,{type:"plain"},r.type.name)):c?"":o.createElement(y,{type:"function"},r.name),!(null==(e=r.typeParameter)||!e.length)&&o.createElement(D,{type:k.Angle},r.typeParameter.map((t=>o.createElement(O,{key:t.id,reflection:i(t)})))),null!=(n=r.parameters)&&n.length?o.createElement(D,{type:k.Parentheses},r.parameters.map((t=>o.createElement(B,{key:t,reflection:i(t)})))):"()",r.type&&o.createElement(o.Fragment,null,c?" => ":": ",o.createElement(E,{type:r.type})))}function j(t){let{reflection:e}=t;return o.createElement(B,{reflection:e})}const U={[s.W.Namespace]:"namespace",[s.W.Enum]:"enum",[s.W.Class]:"class",[s.W.Interface]:"interface"};function q(t){var e,n,s;let{reflection:r}=t;const p=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(F,{flags:r.flags}),o.createElement(y,{type:"keyword"},U[r.kind]," "),o.createElement(y,{type:"class-name"},r.name),!(null==(e=r.typeParameters)||!e.length)&&o.createElement(D,{type:k.Angle},r.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:p(t)}))))," ",!(null==(n=r.extendedTypes)||!n.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"extends "),o.createElement(D,null,r.extendedTypes.map(((t,e)=>o.createElement(E,{key:e,type:t}))))),!(null==(s=r.implementedTypes)||!s.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"implements "),o.createElement(D,null,r.implementedTypes.map(((t,e)=>o.createElement(E,{key:e,type:t}))))))}function V(t){let{reflection:e}=t;const n=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(F,{flags:e.flags}),o.createElement(y,{type:"keyword"},"type "),o.createElement(y,{type:"class-name"},e.name),e.typeParameters&&o.createElement(D,{type:k.Angle},e.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:n(t)}))))," = ",o.createElement(E,{type:e.type}))}function H(t){let{reflection:e}=t;const n=(0,_.in)();return e.signatures?o.createElement(G,{reflection:e.signatures[0]}):e.children?o.createElement(D,{type:k.Curly},e.children.map((t=>o.createElement(Q,{key:t.id,reflection:n(t)})))):o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"unknown"))}function $(t){var e;let{reflection:n}=t;const s=(null==(e=n.signatures)?void 0:e[0])??n.getSignature??n.setSignature??n.indexSignature;return o.createElement(G,{reflection:s})}function Q(t){let{reflection:e}=t;const n=(0,o.useMemo)((()=>{switch(e.kind){case s.W.Project:case s.W.Module:case s.W.EnumMember:case s.W.Variable:case s.W.Function:break;case s.W.Namespace:case s.W.Enum:case s.W.Class:case s.W.Interface:return q;case s.W.Constructor:return G;case s.W.Property:return j;case s.W.Method:return $;case s.W.CallSignature:case s.W.IndexSignature:case s.W.ConstructorSignature:case s.W.Parameter:break;case s.W.TypeLiteral:return H;case s.W.TypeParameter:return O;case s.W.Accessor:case s.W.GetSignature:case s.W.SetSignature:case s.W.ObjectLiteral:break;case s.W.TypeAlias:return V;case s.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.id]);return o.createElement(n,{reflection:e})}function J(t){let{children:e}=t;const n=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!n.current)return;const t=n.current.closest("pre");if(t.scrollWidth>t.clientWidth){const e=Array.from(n.current.querySelectorAll(`.${a.elements}`)).sort(((t,e)=>function(t,e){return t>e?1:t<e?-1:0}(e.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&e.length>0;)e.shift().classList.add(a.wrap)}})),o.createElement(o.Fragment,null,e&&o.createElement("span",{ref:n,className:(0,i.Z)(a.line,"token-line")},e),o.createElement("br",null))}var Y=n(79322),K=n(99703);function tt(t){let{parameters:e}=t;const n=(0,_.in)(),s=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=s&&s.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,s.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(O,{reflection:t})),o.createElement(K.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{parameters:e}=t;const n=(0,_.in)(),s=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=s&&s.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,s.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(B,{reflection:t})),o.createElement(K.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{signatures:e,flags:n,source:s}=t;const r=(0,_.in)(),p=(0,o.useMemo)((()=>e.map(r)),[e]),[i,c]=(0,o.useState)(p[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,p.map((t=>o.createElement(m,{link:null==s?void 0:s.url,key:t.id,highlight:e.length>1&&t.id===i.id,onClick:e.length>1?()=>c(t):void 0},o.createElement(J,null,o.createElement(G,{reflection:t,flags:n})))))),o.createElement(Y.Z,{comment:i.comment}),o.createElement(tt,{parameters:i.typeParameter}),o.createElement(et,{parameters:i.parameters}))}var ot=n(57708);function st(t){let{width:e=24,height:n=24,...s}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},s),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",pt="filters_z1iC",it="icon_ROIU";function ct(){const t=(0,o.useRef)(null),[e,n]=(0,o.useState)(!1),[s,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const e=e=>{t.current&&!t.current.contains(e.target)&&n(!1)};return document.addEventListener("mousedown",e),document.addEventListener("touchstart",e),()=>{document.removeEventListener("mousedown",e),document.removeEventListener("touchstart",e)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,i.Z)("dropdown dropdown--right margin-bottom--md",e&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),n(!e)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),n(!e))}},"Filters",o.createElement(st,{className:it})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,i.Z)("dropdown__link",s.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:s.private,onChange:t=>{r({...s,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&n(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,i.Z)("dropdown__link",s.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:s.inherited,onChange:t=>{r({...s,inherited:t.target.checked})}}),"Inherited members")))))}function at(t){let{children:e,kind:n}=t;return n===s.W.Class||n===s.W.Interface?o.createElement("div",{className:(0,i.Z)("row",rt)},o.createElement("div",{className:(0,i.Z)("col",pt)},o.createElement(ct,null)),o.createElement("div",{className:"col"},e)):o.createElement(o.Fragment,null,e)}var lt=n(53181),ut=n(83851),mt=n(24126),dt=n(32424),ht=n(42244),ft=n(24155);function yt(t){return function(t){var e;return(null==(e=o.Children.map(t,(t=>{if(!t||(0,o.isValidElement)(t)&&function(t){const{props:e}=t;return!!e&&"object"==typeof e&&"value"in e}(t))return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:e.filter(Boolean))??[]}(t).map((t=>{let{props:{value:e,label:n,attributes:o,default:s}}=t;return{value:e,label:n,attributes:o,default:s}}))}function kt(t){const{values:e,children:n}=t;return(0,o.useMemo)((()=>{const t=e??yt(n);return function(t){const e=(0,ht.l)(t,((t,e)=>t.value===e.value));if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[e,n])}function wt(t){let{value:e,tabValues:n}=t;return n.some((t=>t.value===e))}function Mt(t){let{queryString:e=!1,groupId:n}=t;const s=(0,lt.k6)(),r=function(t){let{queryString:e=!1,groupId:n}=t;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,dt._X)(r),(0,o.useCallback)((t=>{if(!r)return;const e=new URLSearchParams(s.location.search);e.set(r,t),s.replace({...s.location,search:e.toString()})}),[r,s])]}function Dt(t){const{defaultValue:e,queryString:n=!1,groupId:s}=t,r=kt(t),[p,i]=(0,o.useState)((()=>function(t){let{defaultValue:e,tabValues:n}=t;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!wt({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const o=n.find((t=>t.default))??n[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:e,tabValues:r}))),[c,a]=Mt({queryString:n,groupId:s}),[l,u]=function(t){let{groupId:e}=t;const n=function(t){return t?`docusaurus.tab.${t}`:null}(e),[s,r]=(0,ft.Nk)(n);return[s,(0,o.useCallback)((t=>{n&&r.set(t)}),[n,r])]}({groupId:s}),m=(()=>{const t=c??l;return wt({value:t,tabValues:r})?t:null})();(0,o.useLayoutEffect)((()=>{m&&i(m)}),[m]);return{selectedValue:p,selectValue:(0,o.useCallback)((t=>{if(!wt({value:t,tabValues:r}))throw new Error(`Can't select invalid tab value=${t}`);i(t),a(t),u(t)}),[a,u,r]),tabValues:r}}var _t=n(89741);const Xt="tabList_M0Dn",gt="tabItem_ysIP";function xt(t){let{className:e,block:n,selectedValue:s,selectValue:r,tabValues:p}=t;const c=[],{blockElementScrollPositionUntilNextRender:a}=(0,mt.o5)(),u=t=>{const e=t.currentTarget,n=c.indexOf(e),o=p[n].value;o!==s&&(a(e),r(o))},m=t=>{var e;let n=null;switch(t.key){case"Enter":u(t);break;case"ArrowRight":{const e=c.indexOf(t.currentTarget)+1;n=c[e]??c[0];break}case"ArrowLeft":{const e=c.indexOf(t.currentTarget)-1;n=c[e]??c[c.length-1];break}}null==(e=n)||e.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},e)},p.map((t=>{let{value:e,label:n,attributes:r}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:s===e?0:-1,"aria-selected":s===e,key:e,ref:t=>c.push(t),onKeyDown:m,onClick:u},r,{className:(0,i.Z)("tabs__item",gt,null==r?void 0:r.className,{"tabs__item--active":s===e})}),n??e)})))}function Ct(t){let{lazy:e,children:n,selectedValue:s}=t;const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const t=r.find((t=>t.props.value===s));return t?(0,o.cloneElement)(t,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},r.map(((t,e)=>(0,o.cloneElement)(t,{key:e,hidden:t.props.value!==s}))))}function Tt(t){const e=Dt(t);return o.createElement("div",{className:(0,i.Z)("tabs-container",Xt)},o.createElement(xt,(0,l.Z)({},t,e)),o.createElement(Ct,(0,l.Z)({},t,e)))}function vt(t){const e=(0,_t.Z)();return o.createElement(Tt,(0,l.Z)({key:String(e)},t))}const bt="tabItem_OMyP";function Lt(t){let{children:e,hidden:n,className:s}=t;return o.createElement("div",{role:"tabpanel",className:(0,i.Z)(bt,s),hidden:n},e)}function Zt(t){let{group:e}=t;return"Constructors"===e.title&&0===e.external.length&&1===e.nested.length?o.createElement(Ot,{reflection:e.nested[0]}):o.createElement(o.Fragment,null,e.external.length>0&&o.createElement("ul",null,e.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t})))))),e.nested.length>0&&e.nested.map(((t,e)=>o.createElement(o.Fragment,{key:t.id},e>0&&o.createElement("hr",null),o.createElement(Ot,{reflection:t})))))}function Nt(t){let{group:e,project:n}=t;const s=(0,lt.TH)(),r=(0,_.RU)(n),p=s.hash.split("-")[0].slice(1),[i]=(0,ot.mN)(),c=(0,o.useMemo)((()=>(e.categories??[e]).map((t=>function(t,e,n){const o=[],s=[],r=[];for(const p of t.children){const t=e[p];t&&(0,ot.It)(n,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):s.push(t))}if(o.length>0||s.length>0)return{title:t.title,external:o,nested:s,anchors:r}}(t,r,i))).filter((t=>!!t))),[e,r,i]);return(0,o.useEffect)((()=>{if(1===c.length)return;const t=s.hash.split("-")[0].slice(1);for(const e of c)if(e.anchors.includes(t))return}),[s.hash,c]),0===c.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h2",id:e.title},e.title),c.length>1?o.createElement(vt,{groupId:e.title},c.map((t=>o.createElement(Lt,{default:t.anchors.includes(p),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(Zt,{group:t}))))):o.createElement(Zt,{group:c[0]}))}function St(t){var e,n,s,r,p;let{reflection:i}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(e=i.sources)||null==(n=e[0])?void 0:n.url},o.createElement(J,null,o.createElement(Q,{reflection:i})))),o.createElement(at,{kind:i.kind},o.createElement(Y.Z,{comment:i.comment})),o.createElement(tt,{parameters:i.typeParameters}),(null==(s=i.implementedBy)?void 0:s.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,i.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),(null==(r=i.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,i.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),i.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:i.signatures})),null==(p=i.groups)?void 0:p.map((t=>o.createElement(Nt,{group:t,key:t.title,project:i.project}))))}function zt(t){var e;let{reflection:n,headless:s}=t;const r=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!s&&(n.hasOwnPage?o.createElement("h1",null,n.name):o.createElement(ut.Z,{as:"h3",id:n.anchor},o.createElement("code",null,n.name))),o.createElement(nt,{signatures:r,flags:n.flags,source:null==(e=n.sources)?void 0:e[0]}),n.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:n.inheritedFrom}))),n.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(X,{type:n.overwrites}))))}function Rt(t){var e,n;let{reflection:s,headless:r}=t;return o.createElement(o.Fragment,null,!r&&(s.hasOwnPage?o.createElement("h1",null,s.name):o.createElement(ut.Z,{as:"h3",id:s.anchor},o.createElement("code",null,s.name))),o.createElement(h,null,o.createElement(m,{link:null==(e=s.sources)||null==(n=e[0])?void 0:n.url},o.createElement(J,null,o.createElement(j,{reflection:s})))),o.createElement(Y.Z,{comment:s.comment}),s.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:s.inheritedFrom}))))}function Pt(t){var e,n,s;let{reflection:r}=t;const p=(0,_.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(e=r.sources)||null==(n=e[0])?void 0:n.url},o.createElement(J,null,o.createElement(Q,{reflection:r})))),o.createElement(Y.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:r.signatures})),null==(s=r.groups)?void 0:s.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>p[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Ot,{key:t.id,reflection:t})))))))}var At=n(78128);function It(t){var e;let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(At.Z,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),o.createElement(at,{kind:n.kind},o.createElement(Y.Z,{comment:n.comment})),null==(e=n.groups)?void 0:e.map((t=>o.createElement(Nt,{group:t,key:t.title,project:n.project}))))}const Wt="cardContainer_ybwo",Et="cardTitle_Ehd1",Ft="cardDescription_b6wr";function Bt(t){let{reflection:e}=t;const n=(0,_.RU)(e.project),s=e.groups[0].children.map((t=>n[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,i.Z)("row")},s.map((t=>{var e;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(f.Z,{href:t.href,className:(0,i.Z)("card padding--lg",Wt)},o.createElement("h2",{className:(0,i.Z)("text--truncate",Et)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,i.Z)("text--truncate",Ft)},(null==(e=t.comment)?void 0:e.summaryText)??"\xa0")))}))))}function Ot(t){let{reflection:e,headless:n=!1}=t;const r=(0,o.useMemo)((()=>{switch(e.kind){case s.W.Project:return Bt;case s.W.Module:return It;case s.W.Namespace:case s.W.Enum:case s.W.Class:case s.W.Interface:return St;case s.W.Function:case s.W.Accessor:case s.W.Constructor:case s.W.Method:return zt;case s.W.Variable:case s.W.Property:case s.W.EnumMember:return Rt;case s.W.CallSignature:case s.W.IndexSignature:case s.W.ConstructorSignature:case s.W.Parameter:case s.W.TypeLiteral:case s.W.TypeParameter:case s.W.GetSignature:case s.W.SetSignature:case s.W.ObjectLiteral:break;case s.W.TypeAlias:return Pt;case s.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.kind]);return o.createElement(r,{reflection:e,headless:n})}},37390:(t,e,n)=>{"use strict";let o;n.d(e,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},26773:(t,e,n)=>{"use strict";n.d(e,{Z:()=>Ct});var o=n(2784),s=n(18888),r=n(35565),p=n(1727),i=n(99387),c=n(77120),a=n(53947),l=n(86253);const u=c.Qf.define([{tag:l.pJ.comment,color:"var(--hl-comment)"},{tag:l.pJ.docComment,color:"var(--hl-comment)"},{tag:l.pJ.blockComment,color:"var(--hl-comment)"},{tag:l.pJ.keyword,color:"var(--hl-keyword)"},{tag:l.pJ.number,color:"var(--hl-number)"},{tag:l.pJ.inserted,color:"var(--hl-number)"},{tag:l.pJ.constant(l.pJ.propertyName),color:"var(--hl-constant)"},{tag:l.pJ.attributeName,color:"var(--hl-variable)"},{tag:l.pJ.variableName,color:"var(--hl-variable)"},{tag:l.pJ.propertyName,color:"var(--hl-variable)"},{tag:l.pJ.deleted,color:"var(--hl-string)"},{tag:l.pJ.string,color:"var(--hl-string)"},{tag:l.pJ.attributeValue,color:"var(--hl-string)"},{tag:l.pJ.tagName,color:"var(--hl-tag)"},{tag:l.pJ.typeName,color:"var(--hl-tag)"},{tag:l.pJ.punctuation,color:"var(--hl-punctuation)"},{tag:l.pJ.operator,color:"var(--hl-punctuation)"},{tag:l.pJ.function(l.pJ.variableName),color:"var(--hl-function)"},{tag:l.pJ.function(l.pJ.propertyName),color:"var(--hl-function)"},{tag:l.pJ.className,color:"var(--hl-class)"},{tag:l.pJ.character,color:"var(--hl-char)"}]),m=r.tk.theme({"&":{fontSize:"var(--ifm-code-font-size)",lineHeight:"21.04px",fontFamily:"var(--ifm-font-family-monospace)",color:"var(--hl-color)",backgroundColor:"var(--hl-background)"},"&.cm-focused .cm-cursor":{borderLeftColor:"var(--hl-color)"},"&.cm-focused":{outline:"none"},".cm-gutters":{backgroundColor:"var(--hl-background)",color:"var(--ifm-color-secondary-darkest)",borderRight:"1px solid var(--ifm-background-color)"},"& .cm-lineNumbers .cm-gutterElement":{paddingLeft:"var(--ifm-pre-padding)"},".cm-activeLineGutter":{backgroundColor:"var(--ifm-code-active-color)"},".cm-scroller":{fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",paddingTop:"var(--ifm-pre-padding)",paddingBottom:"var(--ifm-pre-padding)"},".cm-content":{padding:"0"},"& .cm-line":{paddingRight:"var(--ifm-pre-padding)"},"& .cm-selectionBackground, &.cm-focused .cm-selectionBackground, ::selection":{backgroundColor:"var(--ifm-code-selection-color)"},".cm-activeLine":{backgroundColor:"var(--ifm-code-active-color)"},".cm-selectionMatch":{backgroundColor:"var(--ifm-code-selection-color)"},".cm-foldPlaceholder":{backgroundColor:"var(--ifm-code-selection-color)",borderColor:"var(--ifm-color-emphasis-300)"},".cm-tooltip":{backgroundColor:"var(--ifm-background-surface-color)"}});var d=n(78128);function h(t){const[e,n]=(0,o.useState)(null==t?void 0:t.current);return(0,o.useEffect)((()=>t&&t.subscribe(n)),[t]),e}function f(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M6 6h2v12H6zm3.5 6l8.5 6V6z"}))}function y(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"}))}function k(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M8 5v14l11-7z"}))}function w(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M6 19h4V5H6v14zm8-14v14h4V5h-4z"}))}var M=n(48015),D=n(10700),_=n(69573),X=n(74391);const g=Object.entries(X.Z).map((t=>{let[e,n]=t;return{label:e,type:"function"==typeof n?(o=n,o.prototype&&o.prototype.constructor.name?"class":"function"):"variable"};var o}));var x,C=n(96881);!function(t){t.Error="error",t.Warn="warn",t.Info="info",t.Http="http",t.Verbose="verbose",t.Debug="debug",t.Silly="silly"}(x||(x={}));class T{constructor(){this.logged=new C.p,this.history=[],this.profilers={}}get onLogged(){return this.logged.subscribable}log(t){this.logged.dispatch(t),this.history.push(t)}error(t){this.logLevel(x.Error,t)}warn(t){this.logLevel(x.Warn,t)}info(t){this.logLevel(x.Info,t)}http(t){this.logLevel(x.Http,t)}verbose(t){this.logLevel(x.Verbose,t)}debug(t){this.logLevel(x.Debug,t)}silly(t){this.logLevel(x.Silly,t)}logLevel(t,e){const n="string"==typeof e?{message:e}:e;n.level=t,this.log(n)}profile(t,e){const n=performance.now();if(this.profilers[t]){const o=this.profilers[t];delete this.profilers[t];const s=e??{message:t};return s.level??(s.level=x.Debug),s.durationMs=n-o,void this.log(s)}this.profilers[t]=n}}var v=n(82344),b=n(92673),L=n(30204);class Z extends v.C{constructor(){super(...arguments),this.type=L.I.symbol}parse(t){return null===t?null:new L.I(t)}serialize(){var t;return(null==(t=this.value.current)?void 0:t.serialize())??null}}var N=n(57292),S=n(13170);class z extends v.C{constructor(){super(...arguments),this.type=z.symbol}parse(t){return this.parseRange(1/0,t[0],t[1]??1/0)}update(t,e,n,o){this.value.current=this.parseRange(n/o-N.I,t/o-N.I,e/o-N.I)}parseRange(t,e,n){return void 0===e&&(e=this.value.current[0]),void 0===n&&(n=this.value.current[1]),(e=(0,S.uZ)(0,t,e))>(n=(0,S.uZ)(0,t,n??1/0))&&([e,n]=[n,e]),n>=t&&(n=1/0),[e,n]}}z.symbol=Symbol.for("@motion-canvas/core/meta/RangeMetaField");var R=n(29797);class P extends v.C{constructor(){super(...arguments),this.type=R.F.symbol}parse(t){return new R.F(t)}serialize(){return this.value.current.serialize()}}class A extends v.C{constructor(){super(...arguments),this.type=Number,this.presets=[]}parse(t){let e=parseFloat(t);return void 0!==this.min&&e<this.min&&(e=this.min),void 0!==this.max&&e>this.max&&(e=this.max),e}getPresets(){return this.presets}setPresets(t){return this.presets=t,this}setRange(t,e){return this.min=t,this.max=e,this}}class I extends v.C{constructor(t,e,n){void 0===n&&(n=e[0].value),super(t,n),this.options=e,this.type=I.symbol}set(t){super.set(this.getOption(t).value)}parse(t){return this.getOption(t).value}getOption(t){return this.options.find((e=>e.value===t))??this.options[0]}}I.symbol=Symbol.for("@motion-canvas/core/meta/EnumMetaField");var W=n(1323);class E extends v.C{get onFieldsChanged(){return this.fields.subscribable}get options(){return this.optionFields[this.current]}constructor(t,e,n){void 0===n&&(n=0);const o=e.plugins.flatMap((t=>(null==t.exporters?void 0:t.exporters(e))??[])),s=o.map((t=>t.meta(e))),r=new I("exporter",o.map((t=>({value:t.id,text:t.displayName}))),o[n].id);super(t,{name:r.get(),options:s[n].get()}),this.current=n,this.type=Object,this.handleChange=()=>{const t=this.exporterField.get(),e=Math.max(this.exporters.findIndex((e=>e.id===t)),0);this.current!==e&&(this.options.onChanged.unsubscribe(this.handleChange),this.current=e,this.options.onChanged.subscribe(this.handleChange,!1),this.fields.current=[this.exporterField,this.options]),this.value.current={name:this.exporterField.get(),options:this.options.get()}},this.exporters=o,this.exporterField=r,this.exporterField.onChanged.subscribe(this.handleChange,!1),this.exporterField.disable(s.length<2).space(),this.optionFields=s,this.optionFields[n].onChanged.subscribe(this.handleChange,!1),this.fields=new W.G([this.exporterField,this.options])}set(t){this.exporterField.set(t.name),this.options.set(t.options)}serialize(){return{name:this.exporterField.serialize(),options:this.options.serialize()}}clone(){return new this.constructor(this.name,this.exporters,this.current)}}const F=[{value:.25,text:"0.25x (Quarter)"},{value:.5,text:"0.5x (Half)"},{value:1,text:"1.0x (Full)"},{value:2,text:"2.0x (Double)"}],B=[{value:"srgb",text:"sRGB"},{value:"display-p3",text:"DCI-P3"}],O=[{value:"image/png",text:"png"},{value:"image/jpeg",text:"jpeg"},{value:"image/webp",text:"webp"}],G=[{value:30,text:"30 FPS"},{value:60,text:"60 FPS"}];class j extends b.v{constructor(t){super("project",function(t){const e={version:new v.C("version",1),shared:new b.v("General",{background:new Z("background",null),range:new z("range",[0,1/0]),size:new P("resolution",new R.F(1920,1080)),audioOffset:new A("audio offset",0)}),preview:new b.v("Preview",{fps:new A("frame rate",30).setPresets(G),resolutionScale:new I("scale",F,1)}),rendering:new b.v("Rendering",{fps:new A("frame rate",60).setPresets(G),resolutionScale:new I("scale",F,1),colorSpace:new I("color space",B),exporter:new E("exporter",t)})};return e.shared.audioOffset.disable(!t.audio),e}(t))}getFullPreviewSettings(){return{...this.shared.get(),...this.preview.get()}}getFullRenderingSettings(){return{...this.shared.get(),...this.rendering.get()}}}var U=n(2672),q=n(9989),V=n(15914);class H extends v.C{constructor(){super(...arguments),this.type=Boolean}parse(t){return!!t}}class ${static meta(){const t=new b.v(this.name,{fileType:new I("file type",O),quality:new A("quality",100).setRange(0,100).describe("A number between 0 and 100 indicating the image quality."),groupByScene:new H("group by scene",!1).describe("Group exported images by scene. When checked, separates the sequence into subdirectories for each scene in the project.")});return t.fileType.onChanged.subscribe((e=>{t.quality.disable("image/png"===e)})),t}static async create(t,e){return new $(t.logger,e)}constructor(t,e){this.logger=t,this.settings=e,this.frameLookup=new Set,this.handleResponse=t=>{let{frame:e}=t;this.frameLookup.delete(e)};const n=e.exporter.options;this.projectName=e.name,this.quality=(0,S.uZ)(0,1,n.quality/100),this.fileType=n.fileType,this.groupByScene=n.groupByScene}async start(){$.response.subscribe(this.handleResponse)}async handleFrame(t,e,n,o,s){this.frameLookup.has(e)&&this.logger.warn(`Frame no. ${e} is already being exported.`)}async stop(){for(;this.frameLookup.size>0;)await new Promise((t=>setTimeout(t,1e3)));$.response.unsubscribe(this.handleResponse)}}$.id="@motion-canvas/core/image-sequence",$.displayName="Image sequence",$.response=new C.p;const Q={name:"mc-default-plugin",exporters:()=>[$]};let J=null,Y=null,K=null,tt=null,et=null,nt=null,ot=1;function st(t,e,n){var o;if(t!==et)return J||(window.mc={...X.Z,makeScene2D:t=>(Y.config=t,Y.onReplaced.current=Y,Y)},Y=(0,V.r)((function*(){yield})),Y.onReplaced=new W.G(Y),J={name:"fiddle",logger:new T,plugins:[Q],scenes:[Y]},J.meta=new j(J),J.meta.shared.size.set(960),K=new U.J(J,{size:J.meta.shared.size.get()}),tt=new q.H,tt.configure({size:J.meta.shared.size.get()}),K.onRender.subscribe((async()=>{await tt.render(K.playback.currentScene,K.playback.previousScene)})),K.onRecalculated.subscribe((()=>{var t;tt.finalBuffer.parentElement!==nt&&(null==(t=nt)||t.append(tt.finalBuffer),et(K))}))),null==(o=nt)||o.removeChild(tt.finalBuffer),null==et||et(null),et=t,nt=e,ot!==n&&(J.meta.shared.size.set([960,Math.floor(960/n)]),Y.onReplaced.current={...Y.onReplaced.current,size:J.meta.shared.size.get()},tt.configure({size:J.meta.shared.size.get()}),ot=n),K.activate(),K.requestReset(),K}const rt="root_icgl",pt="layoutControl_X__N",it="icon_brRG",ct="active_qxTr",at="progress_HsLC",lt="controls_R4ai",ut="previewOnly_FFUw",mt="section_UscS",dt="error_N64d",ht="editor_xQGp",ft="source_Dq6N",yt="preview_C9cZ",kt="button_ESGX",wt="picker_Whdf",Mt="codeOnly_lee0";var Dt=n(53487);const _t=/ *\/\/ ?(\S+) ?(.*)/,Xt=["highlight-next-line","highlight-start","highlight-end"];var gt=n(6277);function xt(t){var e;let{options:n,value:s,className:r,onChange:p}=t;const i=(0,o.useRef)(),c=(0,o.useRef)(),[a,l]=(0,o.useState)(!1);return(0,o.useEffect)((()=>{const t=t=>{i.current&&!i.current.contains(t.target)&&l(!1)};return document.addEventListener("mousedown",t),document.addEventListener("touchstart",t),()=>{document.removeEventListener("mousedown",t),document.removeEventListener("touchstart",t)}}),[i]),o.createElement("div",{ref:i,className:(0,gt.Z)("dropdown dropdown--right",a&&"dropdown--show",r)},o.createElement("a",{ref:c,className:"navbar__link",href:"#",onClick:t=>{t.preventDefault(),l(!a)}},(null==(e=n.find((t=>t.value===s)))?void 0:e.name)??s),o.createElement("ul",{className:"dropdown__menu"},n.map(((t,e)=>o.createElement("li",{key:t.value},o.createElement("a",{href:"#",className:(0,gt.Z)("dropdown__link",s===t.value&&"dropdown__link--active"),onClick:e=>{e.preventDefault(),p(t.value),l(!1),c.current.focus()},onKeyDown:t=>{e!==n.length-1||"Tab"!==t.key||t.shiftKey||(t.preventDefault(),l(!1),c.current.focus())}},t.name))))))}function Ct(t){let{children:e,className:n,mode:l="editor",ratio:X="4"}=t;const[x,C]=(0,o.useState)(null),T=(0,o.useRef)(null),v=(0,o.useRef)(),b=(0,o.useRef)(),[L,Z]=(0,o.useState)(l),[N,S]=(0,o.useState)(null),z=h(null==x?void 0:x.onDurationChanged),R=h(null==x?void 0:x.onFrameChanged),P=h(null==x?void 0:x.onStateChanged),[A,I]=(0,o.useState)(null),[W,E]=(0,o.useState)(null),F=(0,o.useMemo)((()=>{if(X.includes("/")){const t=X.split("/"),e=parseFloat(t[0])/parseFloat(t[1]);if(!isNaN(e))return e}const t=parseFloat(X);return isNaN(t)?4:t}),[X]),B=function(t,e){void 0===e&&(e=!0),st(C,b.current,F);const n=(0,Dt.v)(t.sliceString(0));var o;S(n),n||(E(t),!e||null!=W&&W.eq(t)||b.current.animate((void 0===o&&(o=4),[{boxShadow:"0 0 0px 0 #ccc inset",easing:"cubic-bezier(0.33, 1, 0.68, 1)"},{boxShadow:`0 0 0px ${o}px #ccc inset`,easing:"cubic-bezier(0.32, 0, 0.67, 0)"},{boxShadow:"0 0 0px 0 #ccc inset"}]),{duration:300}))},[O,G]=(0,o.useState)(0),j=(0,o.useMemo)((()=>function(t){let e={name:"Default",lines:[]};const n=[e];for(const o of t.split("\n")){const t=_t.exec(o);if(!t){e.lines.push(o);continue}const[,s,r]=t;Xt.includes(s)||("snippet"===s?e.lines.length>0?(e={name:r,lines:[]},n.push(e)):e.name=r:e.lines.push(o))}return n}(e).map((t=>({name:t.name,state:p.yy.create({doc:p.xv.of(t.lines),extensions:[s.Xy,r.$f.of([a.oc,{key:"Mod-s",preventDefault:!0,run:t=>(B(t.state.doc),!0)}]),r.tk.updateListener.of((t=>{I(t.state.doc),S(null)})),i.Lz.data.of({autocomplete:t=>{if("String"===(0,c.qz)(t.state).resolveInner(t.pos,-1).name)return;const e=t.matchBefore(/\w*/);return e.from!=e.to||t.explicit?{from:e.from,options:g}:null}}),(0,i.eJ)({jsx:!0,typescript:!0}),(0,c.nF)(u),m]})})))),[e]);(0,o.useEffect)((()=>{T.current=new r.tk({parent:v.current,state:j[O].state});const t=function(t,e,n){return et?null:st(t,e,n)}(C,b.current,F);return t&&(B(j[O].state.doc,!1),"code"!==L&&t.togglePlayback(!0)),()=>{et===C&&J&&(K.deactivate(),et=null,nt=null,tt.finalBuffer.remove()),T.current.destroy()}}),[]);const U=W&&A&&!A.eq(W),q=A&&!A.eq(j[O].state.doc)||U;return o.createElement("div",{className:(0,gt.Z)(rt,n,{[Mt]:"code"===L,[ut]:"preview"===L})},o.createElement("div",{className:pt},o.createElement("button",{className:(0,gt.Z)(it,"code"===L&&ct),onClick:()=>{Z("code"),null==x||x.togglePlayback(!1)},title:"Source code"},o.createElement(M.Z,null)),o.createElement("button",{className:(0,gt.Z)(it,"editor"===L&&ct),onClick:()=>Z("editor"),title:"Editor with preview"},o.createElement(D.Z,null)),o.createElement("button",{className:(0,gt.Z)(it,"preview"===L&&ct),onClick:()=>Z("preview"),title:"Preview"},o.createElement(_.Z,null))),o.createElement("div",{className:yt,style:{aspectRatio:X},ref:b},!x&&o.createElement("div",null,"Press play to preview the animation")),z>0&&o.createElement("div",{className:at,style:{width:x?R/z*100+"%":0}}),o.createElement("div",{className:lt},o.createElement("div",{className:mt},U&&o.createElement("button",{onClick:()=>B(T.current.state.doc),className:kt},o.createElement("kbd",null,"CTRL"),o.createElement("kbd",null,"S"),o.createElement("small",null,"Update preview"))),o.createElement("div",{className:mt},o.createElement("button",{className:it,onClick:()=>null==x?void 0:x.requestPreviousFrame()},o.createElement(f,null)),o.createElement("button",{className:it,onClick:()=>{if(x)W||B(T.current.state.doc),x.togglePlayback();else{const t=st(C,b.current,F);B(T.current.state.doc),t.togglePlayback(!0)}}},!x||((null==P?void 0:P.paused)??1)?o.createElement(k,null):o.createElement(w,null)),o.createElement("button",{className:it,onClick:()=>null==x?void 0:x.requestNextFrame()},o.createElement(y,null))),o.createElement("div",{className:mt},0===j.length&&q&&o.createElement("button",{className:kt,onClick:()=>{T.current.setState(j[O].state),B(j[O].state.doc),I(j[O].state.doc)}},o.createElement("small",null,"Reset example")),j.length>1&&o.createElement(xt,{className:wt,value:q?-1:O,onChange:t=>{G(t),T.current.setState(j[t].state),B(j[t].state.doc)},options:j.map(((t,e)=>({value:e,name:t.name}))).concat(q?{value:-1,name:"Custom"}:[])}))),N&&o.createElement("pre",{className:dt},N.message),o.createElement("div",{className:ht,ref:v},o.createElement(d.Z,{className:ft,language:"tsx"},j[0].state.doc.toString()+("code"===L?"":"\n"))))}},74391:(t,e,n)=>{"use strict";n.d(e,{Z:()=>$e});var o={};n.r(o),n.d(o,{Circle:()=>k,CubicBezier:()=>W,Curve:()=>R,Grid:()=>Y,Icon:()=>Q,Img:()=>V,Knot:()=>nt,Latex:()=>mt,Layout:()=>dt.A,Line:()=>wt,Node:()=>K.N,Polygon:()=>Xt,QuadBezier:()=>Tt,Ray:()=>Dt,Rect:()=>F.U,Shape:()=>d.b,Spline:()=>St,Txt:()=>Pt,Video:()=>Et,View2D:()=>zt.h});var s={};n.r(s),n.d(s,{all:()=>Ft.$,any:()=>jt,chain:()=>qt,delay:()=>Ht,every:()=>Qt,loop:()=>Jt,loopFor:()=>Yt,loopUntil:()=>te,noop:()=>ee,run:()=>ne.K,sequence:()=>oe,waitFor:()=>Vt.X,waitUntil:()=>Vt.A});var r={};n.r(r),n.d(r,{DEG2RAD:()=>f.q,DetailedError:()=>ae.t,RAD2DEG:()=>f.I,Semaphore:()=>de.L,beginSlide:()=>se,capitalize:()=>re.k,createRef:()=>ye,debug:()=>ie,deprecate:()=>ce,endPlayback:()=>$t.Mh,endScene:()=>O.ug,endThread:()=>At.kw,errorToLog:()=>le.d,finishScene:()=>O.vl,getContext:()=>ue.f,isProxyEnabled:()=>j,makeRef:()=>ke,makeRefs:()=>we,range:()=>me.w,startPlayback:()=>$t.wA,startScene:()=>O.DO,startThread:()=>At.h$,useContext:()=>De,useContextAfter:()=>_e,useDuration:()=>Kt.Y,useLogger:()=>O.wL,usePlayback:()=>$t.te,useRandom:()=>fe,useScene:()=>O.$r,useThread:()=>At.nn,useTime:()=>Me,viaProxy:()=>G});var p={};n.r(p),n.d(p,{CompoundSignalContext:()=>Xe.N,ComputedContext:()=>ge.h,DEFAULT:()=>be.T,DependencyContext:()=>B.k,SignalContext:()=>ve.V,createComputed:()=>xe.D,createComputedAsync:()=>Te,createSignal:()=>Ce.g,isReactive:()=>ht.PG,modify:()=>ht.Pj,unwrap:()=>ht.Wg});var i={};n.r(i),n.d(i,{BBox:()=>x.b,Center:()=>Se.M5,Color:()=>E.I,Direction:()=>Se.Nm,EPSILON:()=>Ze.I,Matrix2D:()=>Ne,Origin:()=>Se.aP,Spacing:()=>ze.K,Vector2:()=>w.F,flipOrigin:()=>Se.lk,isType:()=>Ze.P,originToOffset:()=>Se.WS,transformAngle:()=>Le.$,transformScalar:()=>Le.X});var c={};n.r(c),n.d(c,{BeatSpring:()=>We,BounceSpring:()=>Fe,JumpSpring:()=>Oe,PlopSpring:()=>Ee,SmoothSpring:()=>je,StrikeSpring:()=>Ge,SwingSpring:()=>Be,arcLerp:()=>_.Vz,clamp:()=>_.uZ,clampRemap:()=>_.vl,cos:()=>Re.mC,createEaseInBack:()=>Re.j$,createEaseInBounce:()=>Re.jv,createEaseInElastic:()=>Re.qS,createEaseInOutBack:()=>Re.Bl,createEaseInOutBounce:()=>Re.Ij,createEaseInOutElastic:()=>Re.du,createEaseOutBack:()=>Re.lj,createEaseOutBounce:()=>Re.zk,createEaseOutElastic:()=>Re.Kx,deepLerp:()=>_.o0,easeInBack:()=>Re.Yw,easeInBounce:()=>Re.SJ,easeInCirc:()=>Re.Mg,easeInCubic:()=>Re.Q9,easeInElastic:()=>Re.eE,easeInExpo:()=>Re.e_,easeInOutBack:()=>Re.BH,easeInOutBounce:()=>Re.en,easeInOutCirc:()=>Re.Ge,easeInOutCubic:()=>Re.qb,easeInOutElastic:()=>Re.cv,easeInOutExpo:()=>Re.hN,easeInOutQuad:()=>Re.to,easeInOutQuart:()=>Re.J7,easeInOutQuint:()=>Re.rz,easeInOutSine:()=>Re.Fs,easeInQuad:()=>Re.FG,easeInQuart:()=>Re.g4,easeInQuint:()=>Re.n5,easeInSine:()=>Re.N1,easeOutBack:()=>Re.UE,easeOutBounce:()=>Re.C6,easeOutCirc:()=>Re.ei,easeOutCubic:()=>Re.w2,easeOutElastic:()=>Re.sK,easeOutExpo:()=>Re.ad,easeOutQuad:()=>Re.hl,easeOutQuart:()=>Re.Y3,easeOutQuint:()=>Re.pl,easeOutSine:()=>Re.vh,linear:()=>Re.GE,makeSpring:()=>Ie,map:()=>_.UI,remap:()=>_.a2,sin:()=>Re.O$,spring:()=>Ae,textLerp:()=>_.JC,tween:()=>Pe.i});var a={};n.r(a),n.d(a,{Thread:()=>Ve.j,cancel:()=>Ue,getTaskName:()=>qe.z,isPromisable:()=>Ut.x,isPromise:()=>He.t,isThreadGenerator:()=>Ut.R,join:()=>Bt.v,setTaskName:()=>qe.i,threads:()=>He.C});var l=n(15914);const u=Symbol.for("@motion-canvas/2d/fragment");function m(t,e){const{ref:n,children:o,...s}=e,r=Array.isArray(o)?o.flat():o;if(t===u)return r;if(null!=(p=t.prototype)&&p.isClass){const e=new t({...s,children:r});return null==n||n(e),e}return t({...s,ref:n,children:r});var p}var d=n(13730),h=n(93091),f=n(48733),y=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class k extends d.b{constructor(t){super(t)}getPath(){return this.createPath()}getRipplePath(){return this.createPath(this.rippleSize())}createPath(t){void 0===t&&(t=0);const e=new Path2D,n=this.startAngle()*f.q,o=this.endAngle()*f.q,s=this.size().scale(.5),r=this.closed();return r&&e.moveTo(0,0),e.ellipse(0,0,s.x+t,s.y+t,0,n,o),r&&e.closePath(),e}}y([(0,h.nn)(0),(0,h.td)()],k.prototype,"startAngle",void 0),y([(0,h.nn)(360),(0,h.td)()],k.prototype,"endAngle",void 0),y([(0,h.nn)(!1),(0,h.td)()],k.prototype,"closed",void 0);var w=n(29797),M=n(11258);class D{}var _=n(13170);class X{constructor(t,e){void 0===e&&(e=20),this.curve=t,this.sampledDistances=[],this.resample(e)}resample(t){this.sampledDistances=[0];let e=0,n=this.curve.eval(0).position;for(let o=1;o<t;o++){const s=o/(t-1),r=this.curve.eval(s);e+=n.sub(r.position).magnitude,this.sampledDistances.push(e),n=r.position}this.sampledDistances[this.sampledDistances.length-1]=this.curve.arcLength}pointAtDistance(t){return this.curve.eval(this.distanceToT(t))}distanceToT(t){const e=this.sampledDistances.length;t=(0,_.uZ)(0,this.curve.arcLength,t);for(let n=0;n<e;n++){const o=this.sampledDistances[n],s=this.sampledDistances[n+1];if(t>=o&&t<=s)return(0,_.a2)(o,s,n/(e-1),(n+1)/(e-1),t)}return 1}}class g extends D{get arcLength(){return this.length}constructor(t,e){super(),this.curve=t,this.length=e,this.pointSampler=new X(this)}getBBox(){return this.curve.getBounds()}eval(t){const e=this.tangent(t);return{position:this.curve.eval(t),tangent:e,normal:e.perpendicular}}getPoint(t){const e=this.pointSampler.pointAtDistance(this.arcLength*t);return{position:e.position,tangent:e.tangent,normal:e.tangent.perpendicular}}transformPoints(t){return this.points.map((e=>e.transformAsPoint(t)))}tangent(t){return this.curve.evalDerivative(t).normalized}draw(t,e,n,o){void 0===e&&(e=0),void 0===n&&(n=1),void 0===o&&(o=!0);let s=null,r=e,p=n,i=this.points;if(0!==e||1!==n){const t=this.length*e,o=this.length*n;r=this.pointSampler.distanceToT(t),p=this.pointSampler.distanceToT(o);const c=(p-r)/(1-r),[,a]=this.split(r);[s]=a.split(c),i=s.points}o&&(0,M.Ao)(t,i[0]),(s??this).doDraw(t);const c=this.tangent(r),a=this.tangent(p);return[{position:i[0],tangent:c,normal:c.perpendicular},{position:i.at(-1),tangent:a,normal:a.perpendicular}]}}var x=n(23357);class C{static constant(t){return new C(t)}static linear(t,e){return new C(t,e)}static quadratic(t,e,n){return new C(t,e,n)}static cubic(t,e,n,o){return new C(t,e,n,o)}get degree(){return 0!==this.c3?3:0!==this.c2?2:0!==this.c1?1:0}constructor(t,e,n,o){this.c0=t,this.c1=e??0,this.c2=n??0,this.c3=o??0}differentiate(t){switch(void 0===t&&(t=1),t){case 0:return this;case 1:return new C(this.c1,2*this.c2,3*this.c3,0);case 2:return new C(2*this.c2,6*this.c3,0,0);case 3:return new C(6*this.c3,0,0,0);default:throw new Error("Unsupported derivative")}}eval(t,e){return void 0===e&&(e=0),0!==e?this.differentiate(e).eval(t):this.c3*(t*t*t)+this.c2*(t*t)+this.c1*t+this.c0}split(t){const e=1-t;return[new C(this.c0,this.c1*t,this.c2*t*t,this.c3*t*t*t),new C(this.eval(0),e*this.differentiate(1).eval(t),e*e/2*this.differentiate(2).eval(t),e*e*e/6*this.differentiate(3).eval(t))]}roots(){switch(this.degree){case 3:return this.solveCubicRoots();case 2:return this.solveQuadraticRoots();case 1:return this.solveLinearRoot();case 0:return[];default:throw new Error(`Unsupported polynomial degree: ${this.degree}`)}}localExtrema(){return this.differentiate().roots()}localExtrema01(){const t=this.localExtrema(),e=[];for(let n=0;n<t.length;n++){const o=t[n];o>=0&&o<=1&&e.push(t[n])}return e}outputRange01(){let t=[this.eval(0),this.eval(1)];return this.localExtrema01().forEach((e=>{return n=this.eval(e),void(t=t[1]>t[0]?[Math.min(t[0],n),Math.max(t[1],n)]:[Math.min(t[1],n),Math.max(t[0],n)]);var n})),t}solveCubicRoots(){const t=this.c0,e=this.c1,n=this.c2,o=this.c3,s=t*t,r=t*n,p=e*e,i=(3*r-p)/(3*s),c=(2*p*e-9*r*e+27*s*o)/(27*s*t),a=this.solveDepressedCubicRoots(i,c),l=n=>n-e/(3*t);switch(a.length){case 1:return[l(a[0])];case 2:return[l(a[0]),l(a[1])];case 3:return[l(a[0]),l(a[1]),l(a[2])];default:return[]}}solveDepressedCubicRoots(t,e){if(this.almostZero(t))return[Math.cbrt(-e)];const n=2*Math.PI,o=4*t*t*t+27*e*e;if(o<1e-5){const o=2*Math.sqrt(-t/3),s=3*e/(2*t)*Math.sqrt(-3/t),r=t=>o*Math.cos(1/3*Math.acos((0,_.uZ)(-1,1,s))-n/3*t);return s>=.9999?[r(0),r(2)]:s<=-.9999?[r(1),r(2)]:[r(0),r(1),r(2)]}if(o>0&&t<0){const n=1/3*Math.acosh(-3*Math.abs(e)/(2*t)*Math.sqrt(-3/t));return[-2*Math.sign(e)*Math.sqrt(-t/3)*Math.cosh(n)]}if(t>0){const n=1/3*Math.asinh(3*e/(2*t)*Math.sqrt(3/t));return[-2*Math.sqrt(t/3)*Math.sinh(n)]}return[]}solveQuadraticRoots(){const t=this.c2,e=this.c1,n=e*e-4*t*this.c0;if(this.almostZero(n))return[-e/(2*t)];if(n>=0){const o=Math.sqrt(n),s=(-e-o)/(2*t),r=(-e+o)/(2*t);return[Math.min(s,r),Math.max(s,r)]}return[]}solveLinearRoot(){return[-this.c0/this.c1]}almostZero(t){return Math.abs(0-t)<=Number.EPSILON}}class T{constructor(t,e,n,o){this.c0=t,this.c1=e,this.c2=n,this.c3=o,t instanceof C?(this.x=t,this.y=e):void 0!==o?(this.x=new C(t.x,e.x,n.x,o.x),this.y=new C(t.y,e.y,n.y,o.y)):(this.x=new C(t.x,e.x,n.x),this.y=new C(t.y,e.y,n.y))}eval(t,e){return void 0===e&&(e=0),new w.F(this.x.differentiate(e).eval(t),this.y.differentiate(e).eval(t))}split(t){const[e,n]=this.x.split(t),[o,s]=this.y.split(t);return[new T(e,o),new T(n,s)]}differentiate(t){return void 0===t&&(t=1),new T(this.x.differentiate(t),this.y.differentiate(t))}evalDerivative(t){return this.differentiate().eval(t)}getBounds(){const t=this.x.outputRange01(),e=this.y.outputRange01();return x.b.fromPoints(new w.F(Math.min(...t),Math.max(...e)),new w.F(Math.max(...t),Math.min(...e)))}}var v=n(79116),b=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class L extends g{get points(){return[this.p0,this.p1,this.p2,this.p3]}constructor(t,e,n,o){super(new T(t,t.flipped.add(e).scale(3),t.scale(3).sub(e.scale(6)).add(n.scale(3)),t.flipped.add(e.scale(3)).sub(n.scale(3)).add(o)),L.getLength(t,e,n,o)),this.p0=t,this.p1=e,this.p2=n,this.p3=o}split(t){const e=new w.F(this.p0.x+(this.p1.x-this.p0.x)*t,this.p0.y+(this.p1.y-this.p0.y)*t),n=new w.F(this.p1.x+(this.p2.x-this.p1.x)*t,this.p1.y+(this.p2.y-this.p1.y)*t),o=new w.F(this.p2.x+(this.p3.x-this.p2.x)*t,this.p2.y+(this.p3.y-this.p2.y)*t),s=new w.F(e.x+(n.x-e.x)*t,e.y+(n.y-e.y)*t),r=new w.F(n.x+(o.x-n.x)*t,n.y+(o.y-n.y)*t),p=new w.F(s.x+(r.x-s.x)*t,s.y+(r.y-s.y)*t);return[new L(this.p0,e,s,p),new L(p,r,o,this.p3)]}doDraw(t){(0,M.JQ)(t,this.p1,this.p2,this.p3)}static getLength(t,e,n,o){return L.el.setAttribute("d",`M ${t.x} ${t.y} C ${e.x} ${e.y} ${n.x} ${n.y} ${o.x} ${o.y}`),L.el.getTotalLength()}}b([(0,v.V)((()=>document.createElementNS("http://www.w3.org/2000/svg","path")))],L,"el",void 0);var Z=n(88104),N=n(46350);function S(t,e){const n=(0,_.uZ)(0,t.arcLength,e);let o=0;for(const s of t.segments){const t=o;if(o+=s.arcLength,o>=n){const e=(n-t)/s.arcLength;return s.getPoint((0,_.uZ)(0,1,e))}}return{position:w.F.zero,tangent:w.F.up,normal:w.F.up}}var z=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class R extends d.b{desiredSize(){return this.childrenBBox().size}constructor(t){super(t)}percentageToDistance(t){return(0,_.uZ)(0,this.baseArcLength(),this.startOffset()+this.offsetArcLength()*t)}distanceToPercentage(t){return(t-this.startOffset())/this.offsetArcLength()}baseArcLength(){return this.profile().arcLength}offsetArcLength(){const t=this.startOffset(),e=this.endOffset(),n=this.baseArcLength();return(0,_.uZ)(0,n,n-t-e)}arcLength(){return this.offsetArcLength()*Math.abs(this.start()-this.end())}completion(){return Math.abs(this.start()-this.end())}curveDrawingInfo(){const t=new Path2D,e=this.profile();let n=this.percentageToDistance(this.start()),o=this.percentageToDistance(this.end());n>o&&([n,o]=[o,n]);const s=o-n,r=Math.min(s/2,this.arrowSize());this.startArrow()&&(n+=r/2),this.endArrow()&&(o-=r/2);let p=0,i=null,c=null,a=null,l=null;for(const u of e.segments){const e=p;if(p+=u.arcLength,p<n)continue;const s=(n-e)/u.arcLength,r=(o-e)/u.arcLength,m=(0,_.uZ)(0,1,s),d=(0,_.uZ)(0,1,r),[h,f]=u.draw(t,m,d,null===i);if(null===i&&(i=h.position,c=h.normal.flipped.perpendicular),a=f.position,l=f.normal.flipped.perpendicular,p>o)break}return 1===this.end()&&this.closed()&&t.closePath(),{startPoint:i??w.F.zero,startTangent:c??w.F.right,endPoint:a??w.F.zero,endTangent:l??w.F.right,arrowSize:r,path:t,startOffset:n}}getPointAtDistance(t){return S(this.profile(),t+this.startOffset())}getPointAtPercentage(t){return S(this.profile(),this.percentageToDistance(t))}applyStyle(t){super.applyStyle(t);const{arcLength:e}=this.profile();t.lineDashOffset-=e/2}getComputedLayout(){return this.offsetComputedLayout(super.getComputedLayout())}offsetComputedLayout(t){return t.position=t.position.sub(this.childrenBBox().center),t}getPath(){return this.curveDrawingInfo().path}getCacheBBox(){const t=this.childrenBBox(),e=this.arrowSize(),n=this.lineWidth(),o=this.lineWidthCoefficient();return t.expand(Math.max(0,e,n*o))}lineWidthCoefficient(){return"square"===this.lineCap()?.70715:.5}drawShape(t){super.drawShape(t);const{startPoint:e,startTangent:n,endPoint:o,endTangent:s,arrowSize:r}=this.curveDrawingInfo();r<.001||(t.save(),t.beginPath(),this.endArrow()&&this.drawArrow(t,o,s.flipped,r),this.startArrow()&&this.drawArrow(t,e,n,r),t.fillStyle=(0,M.ho)(this.stroke(),t),t.closePath(),t.fill(),t.restore())}drawArrow(t,e,n,o){const s=n.perpendicular,r=e.add(n.scale(-o/2));(0,M.Ao)(t,r),(0,M.kZ)(t,r.add(n.add(s).scale(o))),(0,M.kZ)(t,r.add(n.sub(s).scale(o))),(0,M.kZ)(t,r),t.closePath()}}z([(0,h.nn)(!1),(0,h.td)()],R.prototype,"closed",void 0),z([(0,h.nn)(0),(0,h.td)()],R.prototype,"start",void 0),z([(0,h.nn)(0),(0,h.td)()],R.prototype,"startOffset",void 0),z([(0,h.nn)(!1),(0,h.td)()],R.prototype,"startArrow",void 0),z([(0,h.nn)(1),(0,h.td)()],R.prototype,"end",void 0),z([(0,h.nn)(0),(0,h.td)()],R.prototype,"endOffset",void 0),z([(0,h.nn)(!1),(0,h.td)()],R.prototype,"endArrow",void 0),z([(0,h.nn)(24),(0,h.td)()],R.prototype,"arrowSize",void 0),z([(0,N.F)()],R.prototype,"arcLength",null),z([(0,N.F)()],R.prototype,"curveDrawingInfo",null);var P=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class A extends R{profile(){const t=this.segment();return{segments:[t],arcLength:t.arcLength,minSin:0}}childrenBBox(){return x.b.fromPoints(...this.segment().points)}desiredSize(){return this.segment().getBBox().size}offsetComputedLayout(t){return t.position=t.position.sub(this.segment().getBBox().center),t}drawOverlay(t,e){const n=this.computedSize(),o=this.childrenBBox().transformCorners(e),s=n.mul(this.offset()).scale(.5).transformAsPoint(e),r=this.overlayInfo(e);t.lineWidth=1,t.strokeStyle="white",t.fillStyle="white",t.stroke(r.curve),t.fillStyle="white",t.globalAlpha=.5,t.beginPath(),t.stroke(r.handleLines),t.globalAlpha=1,t.lineWidth=2;for(const p of[r.startPoint,r.endPoint])(0,M.Ao)(t,p),t.beginPath(),(0,M.Nb)(t,p,4),t.closePath(),t.stroke(),t.fill();t.fillStyle="black";for(const p of r.controlPoints)(0,M.Ao)(t,p),t.beginPath(),(0,M.Nb)(t,p,4),t.closePath(),t.fill(),t.stroke();t.lineWidth=1,t.beginPath(),(0,M.wp)(t,s),t.stroke(),t.beginPath(),(0,M.pS)(t,o),t.closePath(),t.stroke()}}P([(0,N.F)()],A.prototype,"childrenBBox",null);var I=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class W extends A{constructor(t){super(t)}segment(){return new L(this.p0(),this.p1(),this.p2(),this.p3())}overlayInfo(t){const[e,n,o,s]=this.segment().transformPoints(t),r=new Path2D;(0,M.Ao)(r,e),(0,M.JQ)(r,n,o,s);const p=new Path2D;return(0,M.Ao)(p,e),(0,M.kZ)(p,n),(0,M.Ao)(p,o),(0,M.kZ)(p,s),{curve:r,startPoint:e,endPoint:s,controlPoints:[n,o],handleLines:p}}}I([(0,Z.y)("p0")],W.prototype,"p0",void 0),I([(0,Z.y)("p1")],W.prototype,"p1",void 0),I([(0,Z.y)("p2")],W.prototype,"p2",void 0),I([(0,Z.y)("p3")],W.prototype,"p3",void 0),I([(0,N.F)()],W.prototype,"segment",null);var E=n(30204),F=n(15498),B=n(76062),O=n(3163);function G(t){if(!j())return t;if(t.startsWith("/cors-proxy/"))return t;const e=new URL(window.location.toString());try{const n=new URL(t,e);if(!n.protocol.startsWith("http"))return t;if(e.host===n.host)return t;if(!function(t){const e=function(){if("true"!==(void 0).VITEST&&U)return[...U];const t=(j(),[]);return U=t,[...U]}();if(0===e.length)return!0;for(const n of e)if(n.toLowerCase().trim()===t)return!0;return!1}(n.host))return t}catch(n){return t}return`/cors-proxy/${encodeURIComponent(t)}`}function j(){return!1}let U;var q=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class V extends F.U{constructor(t){super(t)}desiredSize(){const t=super.desiredSize();if(null===t.x&&null===t.y){const t=this.image();return{x:t.naturalWidth,y:t.naturalHeight}}return t}image(){const t=G(this.src()),e=this.view().assetHash();let n=V.pool[t];return n||(n=document.createElement("img"),n.crossOrigin="anonymous",n.src=`${t}?${e}`,V.pool[t]=n),n.complete||B.k.collectPromise(new Promise(((t,e)=>{n.addEventListener("load",t),n.addEventListener("error",e)}))),n}imageCanvas(){const t=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});if(!t)throw new Error("Could not create an image canvas");return t}filledImageCanvas(){const t=this.imageCanvas(),e=this.image();return t.canvas.width=e.naturalWidth,t.canvas.height=e.naturalHeight,t.imageSmoothingEnabled=this.smoothing(),t.drawImage(e,0,0),t}draw(t){this.drawShape(t),this.clip()&&t.clip(this.getPath());const e=this.alpha();if(e>0){const n=x.b.fromSizeCentered(this.computedSize());t.save(),e<1&&(t.globalAlpha*=e),t.imageSmoothingEnabled=this.smoothing(),(0,M.AE)(t,this.image(),n),t.restore()}this.drawChildren(t)}applyFlex(){super.applyFlex();const t=this.image();this.element.style.aspectRatio=(this.ratio()??t.naturalWidth/t.naturalHeight).toString()}getColorAtPoint(t){const e=this.computedSize(),n=this.naturalSize(),o=new w.F(t).add(this.computedSize().scale(.5)).mul(n.div(e).safe);return this.getPixelColor(o)}naturalSize(){const t=this.image();return new w.F(t.naturalWidth,t.naturalHeight)}getPixelColor(t){const e=this.filledImageCanvas(),n=new w.F(t),o=e.getImageData(n.x,n.y,1,1).data;return new E.I({r:o[0],g:o[1],b:o[2],a:o[3]/255})}collectAsyncResources(){super.collectAsyncResources(),this.image()}}V.pool={},q([(0,h.td)()],V.prototype,"src",void 0),q([(0,h.nn)(1),(0,h.td)()],V.prototype,"alpha",void 0),q([(0,h.nn)(!0),(0,h.td)()],V.prototype,"smoothing",void 0),q([(0,N.F)()],V.prototype,"image",null),q([(0,N.F)()],V.prototype,"imageCanvas",null),q([(0,N.F)()],V.prototype,"filledImageCanvas",null),q([(0,N.F)()],V.prototype,"naturalSize",null);var H=n(43595),$=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class Q extends V{constructor(t){super(t)}svgUrl(){return`https://api.iconify.design/${this.icon().replace(":","/")}.svg?color=${encodeURIComponent(this.color().hex())}`}getSrc(){return this.svgUrl()}setSrc(){(0,O.wL)().warn("The Icon Component does not accept setting the `src`. If you need access to `src`, use '<Img/>` instead.")}}$([(0,h.td)()],Q.prototype,"icon",void 0),$([(0,h.nn)("white"),(0,H.j)()],Q.prototype,"color",void 0),$([(0,N.F)()],Q.prototype,"svgUrl",null);var J=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class Y extends d.b{constructor(t){super(t)}drawShape(t){t.save(),this.applyStyle(t),this.drawRipple(t);const e=this.spacing(),n=this.computedSize().scale(.5),o=n.div(e).floored;for(let s=-o.x;s<=o.x;s++)t.beginPath(),t.moveTo(e.x*s,-n.height),t.lineTo(e.x*s,n.height),t.stroke();for(let s=-o.y;s<=o.y;s++)t.beginPath(),t.moveTo(-n.width,e.y*s),t.lineTo(n.width,e.y*s),t.stroke();t.restore()}}J([(0,h.nn)(80),(0,Z.y)("spacing")],Y.prototype,"spacing",void 0);var K=n(20092),tt=n(37060),et=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class nt extends K.N{get startHandleAuto(){return this.auto.startHandle}get endHandleAuto(){return this.auto.endHandle}constructor(t){super(void 0===t.startHandle&&void 0===t.endHandle?{auto:1,...t}:t)}points(){const t=!this.startHandle.isInitial()||!this.endHandle.isInitial(),e=t?this.startHandle():w.F.zero,n=t?this.endHandle():w.F.zero;return{position:this.position(),startHandle:e.transformAsPoint(this.localToParent()),endHandle:n.transformAsPoint(this.localToParent()),auto:{start:this.startHandleAuto(),end:this.endHandleAuto()}}}getDefaultEndHandle(){return this.startHandle().flipped}getDefaultStartHandle(){return this.endHandle().flipped}}et([(0,h.YS)(w.F),(0,h.td)()],nt.prototype,"startHandle",void 0),et([(0,h.YS)(w.F),(0,h.td)()],nt.prototype,"endHandle",void 0),et([(0,h.r_)(!1),(0,h.nn)((()=>({startHandle:0,endHandle:0}))),(0,h.E2)((t=>"object"!=typeof t||Array.isArray(t)?("number"==typeof t&&(t=[t,t]),{startHandle:t[0],endHandle:t[1]}):t)),(0,tt.I)({startHandle:"startHandleAuto",endHandle:"endHandleAuto"})],nt.prototype,"auto",void 0),et([(0,N.F)()],nt.prototype,"points",null);var ot=n(98911),st=n(2322),rt=n(64238),pt=n(81962),it=n(86226),ct=n(50099),at=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};const lt=(0,it.liteAdaptor)();(0,ct.Q)(lt);const ut=ot.mathjax.document("",{InputJax:new st.TeX({packages:pt.b}),OutputJax:new rt.SVG({fontCache:"local"})});class mt extends V{constructor(t){super(t),this.imageElement=document.createElement("img")}image(){const t=`${this.tex()}::${JSON.stringify(this.options())}`;if(mt.svgContentsPool[t])return this.imageElement.src=mt.svgContentsPool[t],this.imageElement.complete||B.k.collectPromise(new Promise(((t,e)=>{this.imageElement.addEventListener("load",t),this.imageElement.addEventListener("error",e)}))),this.imageElement;const e=this.tex(),n=lt.innerHTML(ut.convert(e,this.options()));if(n.includes("data-mjx-error")){const t=n.match(/data-mjx-error="(.*?)"/);t&&t.length>0&&(0,O.wL)().error(`Invalid MathJax: ${t[1]}`)}const o=`data:image/svg+xml;base64,${btoa(`<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n${n}`)}`;mt.svgContentsPool[t]=o;const s=document.createElement("img");return s.src=o,s.src=o,s.complete||B.k.collectPromise(new Promise(((t,e)=>{s.addEventListener("load",t),s.addEventListener("error",e)}))),s}}mt.svgContentsPool={},at([(0,h.nn)({}),(0,h.td)()],mt.prototype,"options",void 0),at([(0,h.td)()],mt.prototype,"tex",void 0);var dt=n(70989),ht=n(68003);class ft extends D{constructor(t,e){super(),this.from=t,this.to=e,this.vector=e.sub(t),this.length=this.vector.magnitude,this.normal=this.vector.perpendicular.normalized.safe}get arcLength(){return this.length}draw(t,e,n,o){void 0===e&&(e=0),void 0===n&&(n=1),void 0===o&&(o=!1);const s=this.from.add(this.vector.scale(e)),r=this.from.add(this.vector.scale(n));return o&&(0,M.Ao)(t,s),(0,M.kZ)(t,r),[{position:s,tangent:this.normal.flipped,normal:this.normal},{position:r,tangent:this.normal,normal:this.normal}]}getPoint(t){return{position:this.from.add(this.vector.scale(t)),tangent:this.normal.flipped,normal:this.normal}}}class yt extends D{constructor(t,e,n,o,s){super(),this.center=t,this.radius=e,this.from=n,this.to=o,this.counter=s,this.angle=Math.acos((0,_.uZ)(-1,1,n.dot(o))),this.length=Math.abs(this.angle*e)}get arcLength(){return this.length}draw(t,e,n){const o=this.counter?-1:1,s=this.from.radians+e*this.angle*o,r=this.to.radians-(1-n)*this.angle*o;Math.abs(this.angle)>1e-4&&t.arc(this.center.x,this.center.y,this.radius,s,r,this.counter);const p=w.F.fromRadians(s),i=w.F.fromRadians(r);return[{position:this.center.add(p.scale(this.radius)),tangent:this.counter?p:p.flipped,normal:this.counter?p:p.flipped},{position:this.center.add(i.scale(this.radius)),tangent:this.counter?i.flipped:i,normal:this.counter?i.flipped:i}]}getPoint(t){const e=this.counter?-1:1,n=this.from.radians+t*this.angle*e,o=w.F.fromRadians(n);return{position:this.center.add(o.scale(this.radius)),tangent:this.counter?o:o.flipped,normal:this.counter?o:o.flipped}}}var kt=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class wt extends R{constructor(t){super(t),void 0===t.children&&void 0===t.points&&(0,O.wL)().warn({message:"No points specified for the line",remarks:'<p>The line won&#39;t be visible unless you specify at least two points:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span>\n  stroke=<span class="hljs-string">&quot;#fff&quot;</span>\n  lineWidth={<span class="hljs-number">8</span>}\n  points={[\n    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],\n  ]}\n/&gt;\n</code></pre>\n<p>Alternatively, you can define the points using the children:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>\n&lt;/<span class="hljs-title class_">Line</span>&gt;\n</code></pre>\n<p>If you did this intentionally, and want to disable this message, set the\n<code>points</code> property to <code>null</code>:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>} points={<span class="hljs-literal">null</span>} /&gt;\n</code></pre>\n',inspect:this.key})}childrenBBox(){const t=this.points(),e=t?t.map((t=>new w.F((0,ht.Wg)(t)))):this.children().filter((t=>!(t instanceof dt.A)||t.isLayoutRoot())).map((t=>t.position()));return x.b.fromPoints(...e)}parsedPoints(){const t=this.points();return t?t.map((t=>new w.F((0,ht.Wg)(t)))):this.children().map((t=>t.position()))}profile(){return function(t,e,n){const o={arcLength:0,segments:[],minSin:1};if(0===t.length)return o;if(n){const e=t[0].add(t[t.length-1]).scale(.5);t.unshift(e),t.push(e)}let s=t[0];for(let p=2;p<t.length;p++){const n=t[p-2],r=t[p-1],i=t[p],c=n.sub(r),a=i.sub(r),l=c.normalized.safe,u=a.normalized.safe,m=Math.acos((0,_.uZ)(-1,1,l.dot(u))),d=Math.tan(m/2),h=Math.sin(m/2),f=Math.min(e,d*c.magnitude*(2===p?1:.5),d*a.magnitude*(p===t.length-1?1:.5)),y=0===h?0:f/h,k=0===d?0:f/d,w=l.add(u).scale(.5).normalized.safe.scale(y).add(r),M=l.perpendicular.dot(u)<0,D=new ft(s,r.add(l.scale(k))),X=new yt(w,f,l.perpendicular.scale(M?1:-1),u.perpendicular.scale(M?-1:1),M);o.segments.push(D),o.segments.push(X),o.arcLength+=D.arcLength,o.arcLength+=X.arcLength,o.minSin=Math.min(o.minSin,Math.abs(h)),s=r.add(u.scale(k))}const r=new ft(s,t[t.length-1]);return o.segments.push(r),o.arcLength+=r.arcLength,o}(this.parsedPoints(),this.radius(),this.closed())}lineWidthCoefficient(){const t=this.radius(),e=this.lineJoin();let n=super.lineWidthCoefficient();if(0===t&&"miter"===e){const{minSin:t}=this.profile();t>0&&(n=Math.max(n,.5/t))}return n}drawOverlay(t,e){const n=this.childrenBBox().transformCorners(e),o=this.computedSize().mul(this.offset()).scale(.5).transformAsPoint(e);t.fillStyle="white",t.strokeStyle="black",t.lineWidth=1;const s=new Path2D,r=this.parsedPoints().map((t=>t.transformAsPoint(e)));if(r.length>0){(0,M.Ao)(s,r[0]);for(const e of r)(0,M.kZ)(s,e),t.beginPath(),(0,M.Nb)(t,e,4),t.closePath(),t.fill(),t.stroke()}t.strokeStyle="white",t.stroke(s),t.beginPath(),(0,M.wp)(t,o),t.stroke(),t.beginPath(),(0,M.pS)(t,n),t.closePath(),t.stroke()}}kt([(0,h.nn)(0),(0,h.td)()],wt.prototype,"radius",void 0),kt([(0,h.nn)(null),(0,h.td)()],wt.prototype,"points",void 0),kt([(0,N.F)()],wt.prototype,"childrenBBox",null),kt([(0,N.F)()],wt.prototype,"parsedPoints",null),kt([(0,N.F)()],wt.prototype,"profile",null);var Mt=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class Dt extends R{constructor(t){super(t)}childrenBBox(){return x.b.fromPoints(this.from(),this.to())}profile(){const t=new ft(this.from(),this.to());return{arcLength:t.arcLength,minSin:1,segments:[t]}}drawOverlay(t,e){const n=this.childrenBBox().transformCorners(e),o=this.computedSize().mul(this.offset()).scale(.5).transformAsPoint(e),s=this.from().transformAsPoint(e),r=this.to().transformAsPoint(e);t.fillStyle="white",t.strokeStyle="black",t.lineWidth=1,t.beginPath(),(0,M.Nb)(t,s,4),t.fill(),t.stroke(),t.beginPath(),(0,M.Nb)(t,r,4),t.fill(),t.stroke(),t.strokeStyle="white",t.beginPath(),(0,M.pS)(t,[s,r]),t.stroke(),t.beginPath(),(0,M.wp)(t,o),t.stroke(),t.beginPath(),(0,M.pS)(t,n),t.closePath(),t.stroke()}}Mt([(0,Z.y)("from")],Dt.prototype,"from",void 0),Mt([(0,Z.y)("to")],Dt.prototype,"to",void 0);var _t=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class Xt extends d.b{constructor(t){super(t)}getPath(){const t=new Path2D,e=this.sides(),n=x.b.fromSizeCentered(this.size());return(0,M.is)(t,n,e),t}getRipplePath(){const t=new Path2D,e=this.sides(),n=this.rippleSize(),o=x.b.fromSizeCentered(this.size()).expand(n);return(0,M.is)(t,o,e),t}}_t([(0,h.nn)(6),(0,h.td)()],Xt.prototype,"sides",void 0);var gt=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class xt extends g{get points(){return[this.p0,this.p1,this.p2]}constructor(t,e,n){super(new T(t,t.flipped.add(e).scale(2),t.sub(e.scale(2)).add(n)),xt.getLength(t,e,n)),this.p0=t,this.p1=e,this.p2=n}split(t){const e=new w.F(this.p0.x+(this.p1.x-this.p0.x)*t,this.p0.y+(this.p1.y-this.p0.y)*t),n=new w.F(this.p1.x+(this.p2.x-this.p1.x)*t,this.p1.y+(this.p2.y-this.p1.y)*t),o=new w.F(e.x+(n.x-e.x)*t,e.y+(n.y-e.y)*t);return[new xt(this.p0,e,o),new xt(o,n,this.p2)]}static getLength(t,e,n){return xt.el.setAttribute("d",`M ${t.x} ${t.y} Q ${e.x} ${e.y} ${n.x} ${n.y}`),xt.el.getTotalLength()}doDraw(t){(0,M.pt)(t,this.p1,this.p2)}}gt([(0,v.V)((()=>document.createElementNS("http://www.w3.org/2000/svg","path")))],xt,"el",void 0);var Ct=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class Tt extends A{constructor(t){super(t)}segment(){return new xt(this.p0(),this.p1(),this.p2())}overlayInfo(t){const[e,n,o]=this.segment().transformPoints(t),s=new Path2D;(0,M.Ao)(s,e),(0,M.pt)(s,n,o);const r=new Path2D;return(0,M.Ao)(r,e),(0,M.kZ)(r,n),(0,M.kZ)(r,o),{curve:s,startPoint:e,endPoint:o,controlPoints:[n],handleLines:r}}}function vt(t){return t instanceof L}function bt(t,e,n,o){if(0===t.auto.start&&0===t.auto.end)return;const s=t.position.sub(e.position).magnitude,r=o*s/(s+n.position.sub(t.position).magnitude),p=o-r,i=new w.F(t.position.x-r*(n.position.x-e.position.x),t.position.y-r*(n.position.y-e.position.y)),c=new w.F(t.position.x+p*(n.position.x-e.position.x),t.position.y+p*(n.position.y-e.position.y));t.startHandle=t.startHandle.lerp(i,t.auto.start),t.endHandle=t.endHandle.lerp(c,t.auto.end)}function Lt(t,e,n,o,s){const r=void 0!==s?new L(e,n,o,s):new xt(e,n,o);t.segments.push(r),t.arcLength+=r.arcLength}function Zt(t,e,n){const o={segments:[],arcLength:0,minSin:1},s=t.length;for(let a=0;a<s;a++){const e=(a-1+s)%s,o=(a+1)%s;bt(t[a],t[e],t[o],n)}const r=t[0],p=t[1];e||1!==r.auto.start||1!==r.auto.end?Lt(o,r.position,r.endHandle,p.startHandle,p.position):Lt(o,r.position,p.startHandle,p.position);for(let a=1;a<s-2;a++){const e=t[a],n=t[a+1];Lt(o,e.position,e.endHandle,n.startHandle,n.position)}const i=t.at(-1),c=t.at(-2);return t.length>2&&(e||1!==i.auto.start||1!==i.auto.end?Lt(o,c.position,c.endHandle,i.startHandle,i.position):Lt(o,c.position,c.endHandle,i.position)),e&&Lt(o,i.position,i.endHandle,r.startHandle,r.position),function(t){for(let e=0;e<t.segments.length;e++){const n=t.segments[e],o=t.segments[(e+1)%t.segments.length];if(!vt(n)||!vt(o))continue;const s=n.p2.sub(n.p3).normalized.safe,r=o.p1.sub(o.p0).normalized.safe,p=s.dot(r);if(!(1-Math.abs(p)>1e-4))continue;const i=Math.acos((0,_.uZ)(-1,1,p)),c=Math.sin(i/2);t.minSin=Math.min(t.minSin,Math.abs(c))}}(o),o}Ct([(0,Z.y)("p0")],Tt.prototype,"p0",void 0),Ct([(0,Z.y)("p1")],Tt.prototype,"p1",void 0),Ct([(0,Z.y)("p2")],Tt.prototype,"p2",void 0),Ct([(0,N.F)()],Tt.prototype,"segment",null);var Nt=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class St extends R{constructor(t){super(t),(void 0===t.children||!Array.isArray(t.children)||t.children.length<2)&&(void 0===t.points||t.points.length<2)&&void 0===t.spawner&&(0,O.wL)().warn({message:"Insufficient number of knots specified for spline. A spline needs at least two knots.",remarks:'<p>The spline won&#39;t be visible unless you specify at least two knots:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Spline</span>\n  stroke=<span class="hljs-string">&quot;#fff&quot;</span>\n  lineWidth={<span class="hljs-number">8</span>}\n  points={[\n    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],\n  ]}\n/&gt;\n</code></pre>\n<p>For more control over the knot handles, you can alternatively provide the knots\nas children to the spline using the <code>Knot</code> component:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Spline</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Knot</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> <span class="hljs-attr">endHandle</span>=<span class="hljs-string">{[-50,</span> <span class="hljs-attr">0</span>]} /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Knot</span> /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Knot</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> <span class="hljs-attr">startHandle</span>=<span class="hljs-string">{[-100,</span> <span class="hljs-attr">50</span>]} /&gt;</span></span>\n&lt;/<span class="hljs-title class_">Spline</span>&gt;\n</code></pre>\n',inspect:this.key})}profile(){return Zt(this.knots(),this.closed(),this.smoothness())}knots(){const t=this.points();return t?t.map((t=>{const e=new w.F((0,ht.Wg)(t));return{position:e,startHandle:e,endHandle:e,auto:{start:1,end:1}}})):this.children().filter(this.isKnot).map((t=>t.points()))}childrenBBox(){const t=this.profile().segments.flatMap((t=>t.points));return x.b.fromPoints(...t)}lineWidthCoefficient(){const t=this.lineJoin();let e=super.lineWidthCoefficient();if("miter"!==t)return e;const{minSin:n}=this.profile();return n>0&&(e=Math.max(e,.5/n)),e}desiredSize(){return this.getTightBBox().size}offsetComputedLayout(t){return t.position=t.position.sub(this.getTightBBox().center),t}getTightBBox(){const t=this.profile().segments.map((t=>t.getBBox()));return x.b.fromBBoxes(...t)}drawOverlay(t,e){const n=this.computedSize(),o=this.childrenBBox().transformCorners(e),s=n.mul(this.offset()).scale(.5).transformAsPoint(e),r=this.profile().segments;t.lineWidth=1,t.strokeStyle="white",t.fillStyle="white";const p=new Path2D;for(let i=0;i<r.length;i++){const t=r[i],[n,o,s,c]=t.transformPoints(e);(0,M.Ao)(p,n),t instanceof L?(0,M.JQ)(p,o,s,c):(0,M.pt)(p,o,s)}t.stroke(p);for(let i=0;i<r.length;i++){const n=r[i];t.fillStyle="white";const[o,s,p,c]=n.transformPoints(e),a=new Path2D;t.globalAlpha=.5,(0,M.Ao)(a,o),(0,M.kZ)(a,s),n instanceof L?((0,M.Ao)(a,p),(0,M.kZ)(a,c),t.beginPath(),t.stroke(a)):((0,M.kZ)(a,p),t.beginPath(),t.stroke(a)),t.globalAlpha=1,t.lineWidth=2,(0,M.Ao)(t,o),t.beginPath(),(0,M.Nb)(t,o,4),t.closePath(),t.stroke(),t.fill(),i===r.length-1&&void 0!==c&&((0,M.Ao)(t,c),t.beginPath(),(0,M.Nb)(t,c,4),t.closePath(),t.stroke(),t.fill()),t.fillStyle="black";for(const e of[s,p])e.magnitude>0&&((0,M.Ao)(t,e),t.beginPath(),(0,M.Nb)(t,e,4),t.closePath(),t.fill(),t.stroke())}t.lineWidth=1,t.beginPath(),(0,M.wp)(t,s),t.stroke(),t.beginPath(),(0,M.pS)(t,o),t.closePath(),t.stroke()}isKnot(t){return t instanceof nt}}Nt([(0,h.nn)(.4),(0,h.td)()],St.prototype,"smoothness",void 0),Nt([(0,h.nn)(null),(0,h.td)()],St.prototype,"points",void 0),Nt([(0,N.F)()],St.prototype,"profile",null),Nt([(0,N.F)()],St.prototype,"knots",null),Nt([(0,N.F)()],St.prototype,"childrenBBox",null),Nt([(0,N.F)()],St.prototype,"getTightBBox",null);var zt=n(70419),Rt=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class Pt extends d.b{constructor(t){let{children:e,...n}=t;super(n),e&&this.text(e)}draw(t){this.requestFontUpdate(),this.applyStyle(t),this.applyText(t),t.font=this.styles.font,"letterSpacing"in t&&(t.letterSpacing=`${this.letterSpacing()}px`);const e=this.element.getBoundingClientRect(),{width:n,height:o}=this.size(),s=document.createRange();let r="";const p=new x.b;for(const i of this.element.childNodes){if(!i.textContent)continue;s.selectNodeContents(i);const c=s.getBoundingClientRect(),a=n/-2+c.left-e.left,l=o/-2+c.top-e.top;p.y===l?(p.width+=c.width,r+=i.textContent):(this.drawText(t,r,p),p.x=a,p.y=l,p.width=c.width,p.height=c.height,r=i.textContent)}this.drawText(t,r,p)}drawText(t,e,n){const o=n.y+n.height/2;t.save(),t.textBaseline="middle",this.lineWidth()<=0?t.fillText(e,n.x,o):this.strokeFirst()?(t.strokeText(e,n.x,o),t.fillText(e,n.x,o)):(t.fillText(e,n.x,o),t.strokeText(e,n.x,o)),t.restore()}formattedText(){return Pt.formatter.innerText=this.text(),Pt.formatter.innerText}updateLayout(){this.applyFont(),this.applyFlex(),this.justifyContent.isInitial()&&(this.element.style.justifyContent=this.styles.getPropertyValue("text-align"));if("nowrap"!==this.styles.whiteSpace&&"pre"!==this.styles.whiteSpace)if(this.element.innerText="",Pt.segmenter)for(const t of Pt.segmenter.segment(this.formattedText()))this.element.appendChild(document.createTextNode(t.segment));else for(const t of this.formattedText().split(""))this.element.appendChild(document.createTextNode(t));else if("pre"===this.styles.whiteSpace){this.element.innerText="";for(const t of this.text().split("\n"))this.element.appendChild(document.createTextNode(t+"\n"))}else this.element.innerText=this.formattedText()}}Rt([(0,h.nn)(""),(0,h.JI)(_.JC),(0,h.td)()],Pt.prototype,"text",void 0),Rt([(0,N.F)()],Pt.prototype,"formattedText",null),Rt([(0,v.V)((()=>{const t=document.createElement("div");return zt.h.shadowRoot.append(t),t}))],Pt,"formatter",void 0),Rt([(0,v.V)((()=>{try{return new Intl.Segmenter(void 0,{granularity:"grapheme"})}catch(t){return null}}))],Pt,"segmenter",void 0);var At=n(56632),It=n(88733),Wt=function(t,e,n,o){var s,r=arguments.length,p=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)p=Reflect.decorate(t,e,n,o);else for(var i=t.length-1;i>=0;i--)(s=t[i])&&(p=(r<3?s(p):r>3?s(e,n,p):s(e,n))||p);return r>3&&p&&Object.defineProperty(e,n,p),p};class Et extends F.U{constructor(t){let{play:e,...n}=t;super(n),this.lastTime=-1,e&&this.play()}isPlaying(){return this.playing()}getCurrentTime(){return this.clampTime(this.time())}getDuration(){return this.video().duration}desiredSize(){const t=super.desiredSize();if(null===t.x&&null===t.y){const t=this.video();return{x:t.videoWidth,y:t.videoHeight}}return t}completion(){return this.clampTime(this.time())/this.video().duration}video(){const t=this.src(),e=`${this.key}/${t}`;let n=Et.pool[e];return n||(n=document.createElement("video"),n.src=t,Et.pool[e]=n),n.readyState<2&&B.k.collectPromise(new Promise((t=>{const e=()=>{t(),n.removeEventListener("canplay",e)};n.addEventListener("canplay",e)}))),n}seekedVideo(){const t=this.video(),e=this.clampTime(this.time());return t.paused||t.pause(),this.lastTime===e||this.setCurrentTime(e),t}fastSeekedVideo(){const t=this.video(),e=this.clampTime(this.time());if(this.lastTime===e)return t;const n=this.playing()&&e<t.duration;return n?t.paused&&B.k.collectPromise(t.play()):t.paused||t.pause(),Math.abs(t.currentTime-e)>.2?this.setCurrentTime(e):n||(t.currentTime=e),t}draw(t){this.drawShape(t),this.clip()&&t.clip(this.getPath());const e=this.alpha();if(e>0){const n=this.view().playbackState(),o=n===It.q.Playing||n===It.q.Presenting?this.fastSeekedVideo():this.seekedVideo(),s=x.b.fromSizeCentered(this.computedSize());t.save(),e<1&&(t.globalAlpha*=e),t.imageSmoothingEnabled=this.smoothing(),(0,M.AE)(t,o,s),t.restore()}this.drawChildren(t)}applyFlex(){super.applyFlex();const t=this.video();this.element.style.aspectRatio=(this.ratio()??t.videoWidth/t.videoHeight).toString()}setCurrentTime(t){const e=this.video();e.readyState<2||(e.currentTime=t,this.lastTime=t,e.seeking&&B.k.collectPromise(new Promise((t=>{const n=()=>{t(),e.removeEventListener("seeked",n)};e.addEventListener("seeked",n)}))))}play(){const t=(0,At.nn)().time,e=t()-this.time();this.playing(!0),this.time((()=>this.clampTime(t()-e)))}pause(){this.playing(!1),this.time.save(),this.video().pause()}seek(t){const e=this.playing();this.time(this.clampTime(t)),e?this.play():this.pause()}clampTime(t){const e=this.video().duration;return this.loop()&&(t%=e),(0,_.uZ)(0,e,t)}collectAsyncResources(){super.collectAsyncResources(),this.seekedVideo()}}Et.pool={},Wt([(0,h.td)()],Et.prototype,"src",void 0),Wt([(0,h.nn)(1),(0,h.td)()],Et.prototype,"alpha",void 0),Wt([(0,h.nn)(!0),(0,h.td)()],Et.prototype,"smoothing",void 0),Wt([(0,h.nn)(!1),(0,h.td)()],Et.prototype,"loop",void 0),Wt([(0,h.nn)(0),(0,h.td)()],Et.prototype,"time",void 0),Wt([(0,h.nn)(!1),(0,h.td)()],Et.prototype,"playing",void 0),Wt([(0,N.F)()],Et.prototype,"completion",null),Wt([(0,N.F)()],Et.prototype,"video",null),Wt([(0,N.F)()],Et.prototype,"seekedVideo",null),Wt([(0,N.F)()],Et.prototype,"fastSeekedVideo",null);var Ft=n(5376),Bt=n(51284),Ot=n(42075),Gt=n(67292);function*jt(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];for(const o of e)yield o;yield*(0,Bt.v)(!1,...e)}(0,Ot.G)(jt,(0,Gt.C)());var Ut=n(80638);function*qt(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];for(const o of e)(0,Ut.R)(o)?yield*o:o()}(0,Ot.G)(qt,(0,Gt.C)());var Vt=n(84266);function*Ht(t,e){yield*(0,Vt.X)(t),(0,Ut.R)(e)?yield*e:e()}(0,Ot.G)(Ht,(0,Gt.C)());var $t=n(97715);function Qt(t,e){let n=!1;function*o(){const o=(0,$t.te)();let s=0,r=0;for(e(r),n=!0;;)s>=o.secondsToFrames(t)?(s=0,r++,e(r),n=!0):n=!1,s++,yield}return(0,Ot.G)(o,(0,Gt.C)("every")),{runner:o(),setInterval(e){t=e,n=!1},setCallback(t){e=t,n=!1},*sync(){for(;!n;)yield}}}function*Jt(t,e){for(let n=0;n<t;n++){const t=e(n);t?yield*t:yield}}function*Yt(t,e){const n=(0,At.nn)(),o=(0,$t.te)().framesToSeconds(1),s=n.time()+t;let r=0;for(;s-o>n.fixed;){const t=e(r);t?yield*t:yield,r+=1}n.time(s)}(0,Ot.G)(Jt,(0,Gt.C)()),(0,Ot.G)(Yt,(0,Gt.C)());var Kt=n(30092);function*te(t,e){yield*Yt((0,Kt.Y)(t),e)}function*ee(){}(0,Ot.G)(te,(0,Gt.C)()),(0,Ot.G)(ee,(0,Gt.C)());var ne=n(77396);function*oe(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),o=1;o<e;o++)n[o-1]=arguments[o];for(const s of n)yield s,yield*(0,Vt.X)(t);yield*(0,Bt.v)(...n)}function*se(t){const{slides:e}=(0,O.$r)(),n=(0,At.nn)();for(e.register(t,n.fixed),yield;e.shouldWait(t);)yield}(0,Ot.G)(oe,(0,Gt.C)());var re=n(15688);function pe(t){switch(typeof t){case"string":return t;case"undefined":return"undefined";default:return Number.isNaN(t)?"NaN":JSON.stringify(t)}}function ie(t){const e={message:pe(t)};t&&"object"==typeof t&&(e.object=t),(0,O.wL)().debug(e)}function ce(t,e,n){return function(){(0,O.wL)().warn({message:e,remarks:n,stack:(new Error).stack});for(var o=arguments.length,s=new Array(o),r=0;r<o;r++)s[r]=arguments[r];return t.apply(this,s)}}var ae=n(49111),le=n(90031),ue=n(1119),me=n(37762),de=n(15649),he=n(11726);function fe(t,e){return void 0===e&&(e=!0),"number"==typeof t?new he.k(e?t:t+(0,O.$r)().meta.seed.get()):(0,O.$r)().random}function ye(){let t;return e=>{if(void 0===e)return t;t=e}}function ke(t,e){return n=>{t[e]=n}}function we(){return{}}function Me(){return(0,At.nn)().time()}function De(t){return(0,O.$r)().lifecycleEvents.onBeginRender.subscribe(t)}function _e(t){return(0,O.$r)().lifecycleEvents.onFinishRender.subscribe(t)}var Xe=n(46096),ge=n(81865),xe=n(73662),Ce=n(97140);function Te(t,e){let n;void 0===e&&(e=null);const o=(0,Ce.g)(t);return(0,xe.D)((()=>{const t=o();var s;n&&n.promise===t||(n=ge.h.collectPromise(t,(null==(s=n)?void 0:s.value)??e));return n.value}))}var ve=n(16249),be=n(60771),Le=n(74741),Ze=n(57292);class Ne{static fromRotation(t){return Ne.identity.rotate(t)}static fromTranslation(t){return Ne.identity.translate(new w.F(t))}static fromScaling(t){return Ne.identity.scale(new w.F(t))}get x(){return new w.F(this.values[0],this.values[1])}get y(){return new w.F(this.values[2],this.values[3])}get scaleX(){return this.values[0]}set scaleX(t){this.values[0]=this.x.normalized.scale(t).x}set scaleY(t){this.values[3]=this.y.normalized.scale(t).y}get scaleY(){return this.values[3]}set translateX(t){this.values[4]=t}get translateX(){return this.values[4]}set translateY(t){this.values[5]=t}get translateY(){return this.values[5]}set rotation(t){const e=this.rotate(t-this.rotation);this.values[0]=e.values[0],this.values[1]=e.values[1],this.values[2]=e.values[2],this.values[3]=e.values[3]}get rotation(){return w.F.degrees(this.values[0],this.values[1])}set translation(t){const e=new w.F(t);this.values[4]=e.x,this.values[5]=e.y}get translation(){return new w.F(this.values[4],this.values[5])}set scaling(t){const e=new w.F(t),n=new w.F(this.values[0],this.values[1]).normalized,o=new w.F(this.values[2],this.values[3]).normalized;this.values[0]=n.x*e.x,this.values[1]=n.y*e.y,this.values[2]=o.x*e.x,this.values[3]=o.y*e.y}get scaling(){return new w.F(this.values[0],this.values[3])}get inverse(){const t=this.values[0],e=this.values[1],n=this.values[2],o=this.values[3],s=this.values[4],r=this.values[5];let p=t*o-e*n;return p?(p=1/p,new Ne(o*p,-e*p,-n*p,t*p,(n*r-o*s)*p,(e*s-t*r)*p)):null}get determinant(){return this.values[0]*this.values[3]-this.values[1]*this.values[2]}get domMatrix(){return new DOMMatrix([this.values[0],this.values[1],this.values[2],this.values[3],this.values[4],this.values[5]])}constructor(t,e,n,o,s,r){if(this.values=new Float32Array(6),0===arguments.length)return void(this.values=new Float32Array([1,0,0,1,0,0]));if(6===arguments.length)return this.values[0]=t,this.values[1]=e,this.values[2]=n,this.values[3]=o,this.values[4]=s,void(this.values[5]=r);if(t instanceof Ne)return void(this.values=t.values);if(Array.isArray(t)){if(2===t.length)return this.values[0]=t[0],this.values[1]=t[1],this.values[2]=e[0],this.values[3]=e[1],this.values[4]=n[0],void(this.values[5]=n[1]);if(3===t.length){const e=new w.F(t[0]),n=new w.F(t[1]),o=new w.F(t[2]);return this.values[0]=e.x,this.values[1]=e.y,this.values[2]=n.x,this.values[3]=n.y,this.values[4]=o.x,void(this.values[5]=o.y)}return this.values[0]=t[0],this.values[1]=t[1],this.values[2]=t[2],this.values[3]=t[3],this.values[4]=t[4],void(this.values[5]=t[5])}const p=new w.F(t),i=new w.F(e),c=new w.F(n);this.values[0]=p.x,this.values[1]=p.y,this.values[2]=i.x,this.values[3]=i.y,this.values[4]=c.x,this.values[5]=c.y}column(t){return new w.F(this.values[2*t],this.values[2*t+1])}row(t){return[this.values[t],this.values[t+2],this.values[t+4]]}mul(t){const e=this.values[0],n=this.values[1],o=this.values[2],s=this.values[3],r=this.values[4],p=this.values[5],i=t.values[0],c=t.values[1],a=t.values[2],l=t.values[3],u=t.values[4],m=t.values[5];return new Ne(e*i+o*c,n*i+s*c,e*a+o*l,n*a+s*l,e*u+o*m+r,n*u+s*m+p)}rotate(t,e){void 0===e&&(e=!0),e&&(t*=f.q);const n=this.values[0],o=this.values[1],s=this.values[2],r=this.values[3],p=this.values[4],i=this.values[5],c=Math.sin(t),a=Math.cos(t);return new Ne(n*a+s*c,o*a+r*c,n*-c+s*a,o*-c+r*a,p,i)}scale(t){const e=new w.F(t);return new Ne(this.values[0]*e.x,this.values[1]*e.x,this.values[2]*e.y,this.values[3]*e.y,this.values[4],this.values[5])}mulScalar(t){return new Ne(this.values[0]*t,this.values[1]*t,this.values[2]*t,this.values[3]*t,this.values[4]*t,this.values[5]*t)}translate(t){const e=new w.F(t);return new Ne(this.values[0],this.values[1],this.values[2],this.values[3],this.values[0]*e.x+this.values[2]*e.y+this.values[4],this.values[1]*e.x+this.values[3]*e.y+this.values[5])}add(t){return new Ne(this.values[0]+t.values[0],this.values[1]+t.values[1],this.values[2]+t.values[2],this.values[3]+t.values[3],this.values[4]+t.values[4],this.values[5]+t.values[5])}sub(t){return new Ne(this.values[0]-t.values[0],this.values[1]-t.values[1],this.values[2]-t.values[2],this.values[3]-t.values[3],this.values[4]-t.values[4],this.values[5]-t.values[5])}toSymbol(){return Ne.symbol}equals(t,e){return void 0===e&&(e=Ze.I),Math.abs(this.values[0]-t.values[0])<=e+Number.EPSILON&&Math.abs(this.values[1]-t.values[1])<=e+Number.EPSILON&&Math.abs(this.values[2]-t.values[2])<=e+Number.EPSILON&&Math.abs(this.values[3]-t.values[3])<=e+Number.EPSILON&&Math.abs(this.values[4]-t.values[4])<=e+Number.EPSILON&&Math.abs(this.values[5]-t.values[5])<=e+Number.EPSILON}exactlyEquals(t){return this.values[0]===t.values[0]&&this.values[1]===t.values[1]&&this.values[2]===t.values[2]&&this.values[3]===t.values[3]&&this.values[4]===t.values[4]&&this.values[5]===t.values[5]}}Ne.symbol=Symbol.for("@motion-canvas/core/types/Matrix2D"),Ne.identity=new Ne(1,0,0,1,0,0),Ne.zero=new Ne(0,0,0,0,0,0);var Se=n(98378),ze=n(43188),Re=n(97074),Pe=n(74534);function*Ae(t,e,n,o,s,r){const p="number"==typeof o?o:.001;r="number"==typeof o?r:s;const i=(t,e)=>{"function"==typeof o?o(t,e):"function"==typeof s&&s(t,e)};if((t=t??{mass:.05,stiffness:10,damping:.5}).mass<=0)return void(0,O.wL)().error(new Error("Spring mass must be greater than 0."));if(t.stiffness<0)return void(0,O.wL)().error(new Error("Spring stiffness must be greater or equal to 0."));if(t.damping<0)return void(0,O.wL)().error(new Error("Spring damping must be greater or equal to 0."));const c=(0,At.nn)();let a=e,l=t.initialVelocity??0;const u=e=>{if(null===t)return;const o=a-n,s=-t.stiffness*o-t.damping*l;l+=s/t.mass*e,a+=l*e},m=1/120;i(e,0);const d=c.time();let h=d,f=!1;for(;!f;){for(;h<c.fixed;){const t=c.fixed-h;if(m>t?(u(t),h=c.fixed):(u(m),h+=m),Math.abs(n-a)<p&&Math.abs(l)<p){c.time(h),f=!0;break}}f||(i(a,c.fixed-d),yield)}i(n,c.fixed-d),null==r||r(n,c.fixed-d)}function Ie(t,e,n,o){return{mass:t,stiffness:e,damping:n,initialVelocity:o}}(0,Ot.G)(Ae,(0,Gt.C)());const We=Ie(.13,5.7,1.2,10),Ee=Ie(.2,20,.68,0),Fe=Ie(.08,4.75,.05,0),Be=Ie(.39,19.85,2.82,0),Oe=Ie(.04,10,.7,8),Ge=Ie(.03,20,.9,4.8),je=Ie(.16,15.35,1.88,0);function Ue(){const t=(0,At.nn)();for(var e=arguments.length,n=new Array(e),o=0;o<e;o++)n[o]=arguments[o];for(const s of n){const e=t.children.find((t=>t.runner===s));e&&!e.canceled&&(e.cancel(),e.time(t.time()))}}var qe=n(75168),Ve=n(50580),He=n(5881);const $e={...o,...s,...r,...p,...i,...c,...a,_Fragment:u,_jsx:m,_jsxs:m,makeScene2D:l.r}},53487:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{v:()=>transform});var _babel_standalone__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(87243),_babel_standalone__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(_babel_standalone__WEBPACK_IMPORTED_MODULE_0__),_site_src_components_Fiddle_runtime__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(74391);function transform(code){try{const result=_babel_standalone__WEBPACK_IMPORTED_MODULE_0__.transform(code,{filename:"fiddle.tsx",presets:["typescript",["react",{runtime:"automatic",importSource:"@motion-canvas/2d/lib"}]],plugins:["mc"]});eval(result.code)}catch(e){return e}return null}_babel_standalone__WEBPACK_IMPORTED_MODULE_0__.registerPlugin("mc",(t=>{let{types:e}=t;return{visitor:{Program(t){t.node.body.unshift(e.variableDeclaration("const",[e.variableDeclarator(e.objectPattern(Object.keys(_site_src_components_Fiddle_runtime__WEBPACK_IMPORTED_MODULE_1__.Z).map((t=>e.objectProperty(e.identifier(t),e.identifier(t),!1,!0)))),e.memberExpression(e.identifier("window"),e.identifier("mc")))]))},ImportDeclaration(t){t.remove()},ExportDefaultDeclaration(t){t.replaceWith(t.node.declaration)}}}}))},70532:(t,e,n)=>{"use strict";n.d(e,{Z:()=>l});var o=n(2784),s=n(89741);const r="tooltip_lI6R",p="active_DOSD";var i=n(6277),c=n(88617),a=n(79322);function l(t){let{children:e}=t;const n=(0,s.Z)(),l=(0,c.rG)(),[u,m]=(0,o.useState)(!1),[d,h]=(0,o.useState)(null),f=(0,o.useRef)(),y=(0,o.useRef)(),k=(0,o.useRef)(),w=(0,o.useCallback)((()=>{if(!y.current||!k.current)return;const t=y.current.getBoundingClientRect();let e=window.innerWidth-t.left-496;e<0&&(e=0),k.current.style.right=`${e}px`,k.current.style.top=`${t.bottom}px`}),[]);return(0,o.useEffect)((()=>{if(!n)return;const t=t=>{var e,n,o;if(!t.target.href||null==(e=f.current)||!e.contains(t.target)||null!=(n=k.current)&&n.contains(t.target))return;const s=new URL(t.target.href,document.baseURI);if(s.pathname===window.location.pathname)return;const r=l(s.pathname+s.hash);null!=r&&null!=(o=r.comment)&&o.summary&&(y.current=t.target,m(!0),h(r.comment),w())},e=t=>{t.target===y.current&&m(!1)};return document.addEventListener("mouseenter",t,!0),document.addEventListener("focus",t,!0),document.addEventListener("mouseleave",e,!0),document.addEventListener("blur",e,!0),document.addEventListener("scroll",w),()=>{document.removeEventListener("mouseenter",t,!0),document.removeEventListener("focus",t,!0),document.removeEventListener("mouseleave",e,!0),document.removeEventListener("blur",e,!0),document.removeEventListener("scroll",w)}}),[n]),(0,o.useEffect)((()=>{w()})),o.createElement("div",{ref:f},e,o.createElement("div",{ref:k,className:(0,i.Z)(r,"padding--md margin-horiz--md",u&&p)},d&&o.createElement(a.Z,{comment:d,full:!1})))}},88617:(t,e,n)=>{"use strict";n.d(e,{Gr:()=>a,RU:()=>p,gs:()=>r,in:()=>i,rG:()=>c});var o=n(2784);const s=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:e,lookup:n,urlLookup:r}=t;return o.createElement(s.Provider,{value:{lookup:n,urlLookup:r}},e)}function p(t){const{lookup:e}=(0,o.useContext)(s);return e[t]}function i(){const{lookup:t}=(0,o.useContext)(s);return e=>{if("number"==typeof(null==e?void 0:e.project))return t[e.project][e.id]}}function c(){const{urlLookup:t,lookup:e}=(0,o.useContext)(s);return n=>{var o;const s=t[n];return s?(null==(o=e[s.projectId])?void 0:o[s.id])??null:null}}function a(t){if(t)return t.href}},80068:(t,e,n)=>{"use strict";n.d(e,{Ld:()=>i,Y0:()=>p,s2:()=>c});var o=n(2784),s=n(50822);const r=o.createContext(null);function p(t){let{children:e}=t;const n=(0,s.p)(),p=(0,o.useMemo)((()=>function(t,e){const{plain:n}=t,o=Object.create(null),s=t.styles.reduce(((t,n)=>{const{languages:o,style:s}=n;return o&&!o.includes(e)||n.types.forEach((e=>{t[e]={...t[e],...s}})),t}),o);return s.root=n,s.plain={...n,backgroundColor:null},s}(n,"typescript")),[n]);return o.createElement(r.Provider,{value:p},e)}function i(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return{className:`token ${t}`,style:e[t]??e.plain}}function c(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return e[t]??e.plain}},57708:(t,e,n)=>{"use strict";n.d(e,{It:()=>m,Wy:()=>l,mN:()=>u});var o=n(2784),s=n(31263),r=n(89741);const p="api-filters",i=s.Z.canUseDOM?localStorage.getItem(p):null,c=i?JSON.parse(i):{inherited:!0,private:!1},a=o.createContext([c,()=>{}]);function l(t){let{children:e}=t;const[n,s]=(0,o.useState)(c),i=(0,r.Z)();return o.createElement(a.Provider,{value:[n,t=>{i&&localStorage.setItem(p,JSON.stringify(t)),s(t)}]},e)}function u(){return(0,o.useContext)(a)}function m(t,e){var n,o;const s=(null==(n=e.flags)?void 0:n.isPrivate)||(null==(o=e.flags)?void 0:o.isProtected);if(!t.private&&s)return!1;const r=!!e.inheritedFrom;return!(!t.inherited&&r)}},26047:(t,e,n)=>{"use strict";n.d(e,{Z:()=>u});var o=n(7896),s=n(2784),r=n(59055);const p="icon_Fw4I";function i(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),s.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"}))}function c(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),s.createElement("path",{d:"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"}))}function a(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),s.createElement("path",{d:"M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"}))}function l(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),s.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"}))}function u(t){const e=(0,s.useMemo)((()=>{switch(t.type){case"tip":return l;case"caution":return c;case"danger":return a;default:return i}}),[t.type]);return s.createElement(s.Fragment,null,s.createElement(r.Z,(0,o.Z)({icon:s.createElement(e,{className:p})},t)))}},94141:(t,e,n)=>{"use strict";n.d(e,{Z:()=>i});var o=n(7896),s=n(2784),r=n(6277);const p="iconEdit_N_05";function i(t){let{className:e,...n}=t;return s.createElement("svg",(0,o.Z)({fill:"currentColor",width:"24px",height:"24px",viewBox:"0 0 24 24",className:(0,r.Z)(p,e),"aria-hidden":"true"},n),s.createElement("path",{d:"M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"}))}},44648:(t,e,n)=>{"use strict";n.d(e,{Z:()=>r});var o=n(7896),s=n(2784);function r(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",style:{width:16,height:16,marginTop:"0.1rem"}},t),s.createElement("path",{d:"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z",fill:"currentColor"}))}},29459:(t,e,n)=>{"use strict";n.d(e,{Z:()=>i});var o=n(2784),s=n(52203),r=n(26773),p=n(78128);const i={...s.Z,pre:function(t){var e,n;return(0,o.isValidElement)(t.children)&&null!=(e=t.children.props)&&e.editor?o.createElement(r.Z,t.children.props):o.createElement(p.Z,(0,o.isValidElement)(t.children)&&"code"===(null==(n=t.children.props)?void 0:n.originalType)?t.children.props:{...t})}}},47733:(t,e,n)=>{"use strict";n.d(e,{Z:()=>i});var o=n(7896),s=n(2784),r=n(77287);const p="root_ZAv1";function i(t){const e=s.Children.toArray(t.children),n=e.find((t=>{var e;return s.isValidElement(t)&&"summary"===(null==(e=t.props)?void 0:e.mdxType)})),i=s.createElement(s.Fragment,null,e.filter((t=>t!==n)));return s.createElement(s.Fragment,null,s.createElement(r.P,(0,o.Z)({},t,{summary:n,className:p}),i))}},46155:(t,e,n)=>{var o={"./locale":99394,"./locale.js":99394};function s(t){var e=r(t);return n(e)}function r(t){if(!n.o(o,t)){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}return o[t]}s.keys=function(){return Object.keys(o)},s.resolve=r,t.exports=s,s.id=46155}}]);
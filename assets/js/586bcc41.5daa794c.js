(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[3239],{61532:t=>{function e(t){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}e.keys=()=>[],e.resolve=e,e.id=61532,t.exports=e},70989:(t,e,n)=>{"use strict";n.d(e,{A:()=>w});var o=n(93091),s=n(88104),r=n(15688);function i(t,e){return void 0===e&&(e=t=>t),(n,o)=>{n[`getDefault${(0,r.k)(o)}`]=function(){this.requestLayoutUpdate();const n=this.element.style[t];this.element.style[t]="";const o=e.call(this,this.styles.getPropertyValue(t));return this.element.style[t]=n,o}}}var p=n(46350),a=n(29797),c=n(23357),l=n(98378),u=n(74534),m=n(67292),d=n(20092),h=n(11258),y=n(53693),f=n(97140),k=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class w extends d.N{get columnGap(){return this.gap.x}get rowGap(){return this.gap.y}getX(){return this.isLayoutRoot()?this.customX():this.computedPosition().x}setX(t){this.customX(t)}getY(){return this.isLayoutRoot()?this.customY():this.computedPosition().y}setY(t){this.customY(t)}get width(){return this.size.x}get height(){return this.size.y}getWidth(){return this.computedSize().width}setWidth(t){this.customWidth(t)}*tweenWidth(t,e,n,o){const s=this.desiredSize().x,r="number"!=typeof s||"number"!=typeof t;let i,p;i=r?this.size.x():s,r?(this.size.x(t),p=this.size.x()):p=t,this.size.x(i),r&&this.lockSize(),yield*(0,u.i)(e,(t=>this.size.x(o(i,p,n(t))))),this.size.x(t),r&&this.releaseSize()}getHeight(){return this.computedSize().height}setHeight(t){this.customHeight(t)}*tweenHeight(t,e,n,o){const s=this.desiredSize().y,r="number"!=typeof s||"number"!=typeof t;let i,p;i=r?this.size.y():s,r?(this.size.y(t),p=this.size.y()):p=t,this.size.y(i),r&&this.lockSize(),yield*(0,u.i)(e,(t=>this.size.y(o(i,p,n(t))))),this.size.y(t),r&&this.releaseSize()}desiredSize(){return{x:this.customWidth(),y:this.customHeight()}}*tweenSize(t,e,n,o){const s=this.desiredSize();let r,i;r="number"!=typeof s.x||"number"!=typeof s.y?this.size():new a.F(s),"object"==typeof t&&"number"==typeof t.x&&"number"==typeof t.y?i=new a.F(t):(this.size(t),i=this.size()),this.size(r),this.lockSize(),yield*(0,u.i)(e,(t=>this.size(o(r,i,n(t))))),this.releaseSize(),this.size(t)}constructor(t){let{tagName:e="div",...n}=t;super(n),this.sizeLockCounter=(0,f.g)(0),this.element=document.createElement(e),this.element.style.display="flex",this.element.style.boxSizing="border-box",this.styles=getComputedStyle(this.element)}lockSize(){this.sizeLockCounter(this.sizeLockCounter()+1)}releaseSize(){this.sizeLockCounter(this.sizeLockCounter()-1)}parentTransform(){let t=this.parent();for(;t;){if(t instanceof w)return t;t=t.parent()}return null}anchorPosition(){const t=this.computedSize(),e=this.offset();return t.scale(.5).mul(e)}layoutEnabled(){var t;return this.layout()??(null==(t=this.parentTransform())?void 0:t.layoutEnabled())??!1}isLayoutRoot(){var t;return!this.layoutEnabled()||!(null!=(t=this.parentTransform())&&t.layoutEnabled())}localToParent(){const t=new DOMMatrix,e=this.size().mul(this.offset()).scale(-.5);return t.translateSelf(this.position.x(),this.position.y()),t.rotateSelf(0,0,this.rotation()),t.scaleSelf(this.scale.x(),this.scale.y()),t.translateSelf(e.x,e.y),t}getComputedLayout(){return new c.b(this.element.getBoundingClientRect())}computedPosition(){this.requestLayoutUpdate();const t=this.getComputedLayout(),e=new a.F(t.x+t.width/2*this.offset.x(),t.y+t.height/2*this.offset.y()),n=this.parentTransform();if(n){const o=n.getComputedLayout();e.x-=o.x+(o.width-t.width)/2,e.y-=o.y+(o.height-t.height)/2}return e}computedSize(){return this.requestLayoutUpdate(),this.getComputedLayout().size}requestLayoutUpdate(){const t=this.parentTransform();this.appendedToView()?(null==t||t.requestFontUpdate(),this.updateLayout()):t.requestLayoutUpdate()}appendedToView(){const t=this.isLayoutRoot();return t&&this.view().element.append(this.element),t}updateLayout(){if(this.applyFont(),this.applyFlex(),this.layoutEnabled()){const t=this.layoutChildren();for(const e of t)e.updateLayout()}}layoutChildren(){const t=[...this.children()],e=[],n=[];for(;t.length;){const o=t.shift();o instanceof w?(e.push(o),n.push(o.element)):o&&t.unshift(...o.children())}return this.element.replaceChildren(...n),e}requestFontUpdate(){var t;null==(t=this.parentTransform())||t.requestFontUpdate(),this.applyFont()}getCacheBBox(){return c.b.fromSizeCentered(this.computedSize())}draw(t){if(this.clip()){const e=this.computedSize();if(0===e.width||0===e.height)return;t.beginPath(),t.rect(e.width/-2,e.height/-2,e.width,e.height),t.closePath(),t.clip()}this.drawChildren(t)}drawOverlay(t,e){const n=this.computedSize(),o=n.mul(this.offset()).scale(.5).transformAsPoint(e),s=c.b.fromSizeCentered(n),r=s.transformCorners(e),i=s.addSpacing(this.padding().scale(-1)).transformCorners(e),p=s.addSpacing(this.margin()).transformCorners(e);t.beginPath(),(0,h.pS)(t,p),(0,h.pS)(t,r),t.closePath(),t.fillStyle="rgba(255,193,125,0.6)",t.fill("evenodd"),t.beginPath(),(0,h.pS)(t,r),(0,h.pS)(t,i),t.closePath(),t.fillStyle="rgba(180,255,147,0.6)",t.fill("evenodd"),t.beginPath(),(0,h.pS)(t,r),t.closePath(),t.lineWidth=1,t.strokeStyle="white",t.stroke();t.beginPath(),(0,h.kZ)(t,o.addY(-8)),(0,h.kZ)(t,o.addY(8)),(0,h.kZ)(t,o),(0,h.kZ)(t,o.addX(-8)),t.arc(o.x,o.y,8,0,2*Math.PI),t.stroke()}getOriginDelta(t){const e=this.computedSize().scale(.5),n=this.offset().mul(e);if(t===l.aP.Middle)return n.flipped;return(0,l.WS)(t).mul(e).sub(n)}moveOffset(t){const e=this.computedSize().scale(.5),n=this.offset().mul(e),o=t.mul(e);this.offset(t),this.position(this.position().add(o).sub(n))}parsePixels(t){return null===t?"":`${t}px`}parseLength(t){return null===t?"":"string"==typeof t?t:`${t}px`}applyFlex(){this.element.style.position=this.isLayoutRoot()?"absolute":"relative";const t=this.desiredSize();this.element.style.width=this.parseLength(t.x),this.element.style.height=this.parseLength(t.y),this.element.style.maxWidth=this.parseLength(this.maxWidth()),this.element.style.minWidth=this.parseLength(this.minWidth()),this.element.style.maxHeight=this.parseLength(this.maxHeight()),this.element.style.minHeight=this.parseLength(this.minHeight()),this.element.style.aspectRatio=null===this.ratio()?"":this.ratio().toString(),this.element.style.marginTop=this.parsePixels(this.margin.top()),this.element.style.marginBottom=this.parsePixels(this.margin.bottom()),this.element.style.marginLeft=this.parsePixels(this.margin.left()),this.element.style.marginRight=this.parsePixels(this.margin.right()),this.element.style.paddingTop=this.parsePixels(this.padding.top()),this.element.style.paddingBottom=this.parsePixels(this.padding.bottom()),this.element.style.paddingLeft=this.parsePixels(this.padding.left()),this.element.style.paddingRight=this.parsePixels(this.padding.right()),this.element.style.flexDirection=this.direction(),this.element.style.flexBasis=this.parseLength(this.basis()),this.element.style.flexWrap=this.wrap(),this.element.style.justifyContent=this.justifyContent(),this.element.style.alignContent=this.alignContent(),this.element.style.alignItems=this.alignItems(),this.element.style.alignSelf=this.alignSelf(),this.element.style.columnGap=this.parseLength(this.gap.x()),this.element.style.rowGap=this.parseLength(this.gap.y()),this.sizeLockCounter()>0?(this.element.style.flexGrow="0",this.element.style.flexShrink="0"):(this.element.style.flexGrow=this.grow().toString(),this.element.style.flexShrink=this.shrink().toString())}applyFont(){if(this.element.style.fontFamily=this.fontFamily.isInitial()?"":this.fontFamily(),this.element.style.fontSize=this.fontSize.isInitial()?"":`${this.fontSize()}px`,this.element.style.fontStyle=this.fontStyle.isInitial()?"":this.fontStyle(),this.lineHeight.isInitial())this.element.style.lineHeight="";else{const t=this.lineHeight();this.element.style.lineHeight="string"==typeof t?(parseFloat(t)/100).toString():`${t}px`}if(this.element.style.fontWeight=this.fontWeight.isInitial()?"":this.fontWeight().toString(),this.element.style.letterSpacing=this.letterSpacing.isInitial()?"":`${this.letterSpacing()}px`,this.element.style.textAlign=this.textAlign.isInitial()?"":this.textAlign(),this.textWrap.isInitial())this.element.style.whiteSpace="";else{const t=this.textWrap();this.element.style.whiteSpace="boolean"==typeof t?t?"normal":"nowrap":t}}dispose(){var t;super.dispose(),null==(t=this.sizeLockCounter)||t.context.dispose(),this.element&&(this.element.remove(),this.element.innerHTML=""),this.element=null,this.styles=null}hit(t){const e=t.transformAsPoint(this.localToParent().inverse());return this.cacheBBox().includes(e)?super.hit(t)??this:null}}k([(0,o.nn)(null),(0,o.td)()],w.prototype,"layout",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"maxWidth",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"maxHeight",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"minWidth",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"minHeight",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"ratio",void 0),k([(0,y.g)("margin")],w.prototype,"margin",void 0),k([(0,y.g)("padding")],w.prototype,"padding",void 0),k([(0,o.nn)("row"),(0,o.td)()],w.prototype,"direction",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"basis",void 0),k([(0,o.nn)(0),(0,o.td)()],w.prototype,"grow",void 0),k([(0,o.nn)(1),(0,o.td)()],w.prototype,"shrink",void 0),k([(0,o.nn)("nowrap"),(0,o.td)()],w.prototype,"wrap",void 0),k([(0,o.nn)("start"),(0,o.td)()],w.prototype,"justifyContent",void 0),k([(0,o.nn)("normal"),(0,o.td)()],w.prototype,"alignContent",void 0),k([(0,o.nn)("stretch"),(0,o.td)()],w.prototype,"alignItems",void 0),k([(0,o.nn)("auto"),(0,o.td)()],w.prototype,"alignSelf",void 0),k([(0,o.nn)(0),(0,s.y)({x:"columnGap",y:"rowGap"})],w.prototype,"gap",void 0),k([i("font-family"),(0,o.td)()],w.prototype,"fontFamily",void 0),k([i("font-size",parseFloat),(0,o.td)()],w.prototype,"fontSize",void 0),k([i("font-style"),(0,o.td)()],w.prototype,"fontStyle",void 0),k([i("font-weight",parseInt),(0,o.td)()],w.prototype,"fontWeight",void 0),k([i("line-height",parseFloat),(0,o.td)()],w.prototype,"lineHeight",void 0),k([i("letter-spacing",(t=>"normal"===t?0:parseFloat(t))),(0,o.td)()],w.prototype,"letterSpacing",void 0),k([i("white-space",(t=>"pre"===t?"pre":"normal"===t)),(0,o.td)()],w.prototype,"textWrap",void 0),k([(0,o.nn)("inherit"),(0,o.td)()],w.prototype,"textDirection",void 0),k([i("text-align"),(0,o.td)()],w.prototype,"textAlign",void 0),k([(0,o.r_)(!1),(0,o.Oq)(!1),(0,o.td)()],w.prototype,"customX",void 0),k([(0,o.r_)(!1),(0,o.Oq)(!1),(0,o.td)()],w.prototype,"customY",void 0),k([(0,o.r_)(!1),(0,o.nn)({x:null,y:null}),(0,s.y)({x:"width",y:"height"})],w.prototype,"size",void 0),k([(0,o.Oq)(!1),(0,o.td)()],w.prototype,"customWidth",void 0),k([(0,m.C)()],w.prototype,"tweenWidth",null),k([(0,o.Oq)(!1),(0,o.td)()],w.prototype,"customHeight",void 0),k([(0,m.C)()],w.prototype,"tweenHeight",null),k([(0,p.F)()],w.prototype,"desiredSize",null),k([(0,m.C)()],w.prototype,"tweenSize",null),k([(0,s.y)("offset")],w.prototype,"offset",void 0),k([(0,o.nn)(!1),(0,o.td)()],w.prototype,"clip",void 0),k([(0,p.F)()],w.prototype,"parentTransform",null),k([(0,p.F)()],w.prototype,"anchorPosition",null),k([(0,p.F)()],w.prototype,"layoutEnabled",null),k([(0,p.F)()],w.prototype,"isLayoutRoot",null),k([(0,p.F)()],w.prototype,"computedPosition",null),k([(0,p.F)()],w.prototype,"computedSize",null),k([(0,p.F)()],w.prototype,"requestLayoutUpdate",null),k([(0,p.F)()],w.prototype,"appendedToView",null),k([(0,p.F)()],w.prototype,"updateLayout",null),k([(0,p.F)()],w.prototype,"layoutChildren",null),k([(0,p.F)()],w.prototype,"requestFontUpdate",null),k([(0,p.F)()],w.prototype,"applyFlex",null),k([(0,p.F)()],w.prototype,"applyFont",null)},20092:(t,e,n)=>{"use strict";n.d(e,{N:()=>T});var o=n(93091),s=n(88104),r=n(46350),i=n(43595),p=n(29797),a=n(74741),c=n(23357),l=n(49111),u=n(3163);var m=n(97074),d=n(74534),h=n(13170),y=n(67292),f=n(11258),k=n(97140);const w={invert:{name:"invert"},sepia:{name:"sepia"},grayscale:{name:"grayscale"},brightness:{name:"brightness",default:1},contrast:{name:"contrast",default:1},saturate:{name:"saturate",default:1},hue:{name:"hue-rotate",unit:"deg",scale:1},blur:{name:"blur",transform:!0,unit:"px",scale:1}};class g{get name(){return this.props.name}get default(){return this.props.default}constructor(t){this.props={name:"invert",default:0,unit:"%",scale:100,transform:!1,...t,value:t.value??t.default??0},this.value=(0,k.g)(this.props.value,h.UI,this)}isActive(){return this.value()!==this.props.default}serialize(t){let e=this.value();return this.props.transform&&(e=(0,a.X)(e,t)),`${this.props.name}(${e*this.props.scale}${this.props.unit})`}}var M=n(5376),D=n(5788),_=n(16249),X=n(93214);class x extends _.V{constructor(t,e){var n;super(t,h.o0,e),n=this;for(const o in w){const t=w[o];Object.defineProperty(this.invokable,o,{value:function(e,o,s){var r,i,p;if(void 0===s&&(s=m.qb),void 0===e)return(null==(i=n.get())||null==(p=i.find((e=>e.name===t.name)))?void 0:p.value())??t.default??0;let a=null==(r=n.get())?void 0:r.find((e=>e.name===t.name));return a||(a=new g(t),n.set([...n.get(),a])),void 0===o?(a.value(e),n.owner):a.value(e,o,s)}})}}*doTween(t,e,n){const o=this.get(),s=(0,X.P)(t)?t():t;if(function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n].name!==e[n].name)return!1;return!0}(o,s))return yield*(0,M.$)(...o.map(((t,o)=>t.value(s[o].value(),e,n)))),void this.set(s);for(const p of s)p.value(p.default);const r=s.map((t=>t.value.context.raw())),i=o.length>0&&s.length>0?e/2:e;o.length>0&&(yield*(0,M.$)(...o.map((t=>t.value(t.default,i,n))))),this.set(s),s.length>0&&(yield*(0,M.$)(...s.map(((t,e)=>t.value(r[e],i,n)))))}}var v=n(76062),C=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class T{getAbsolutePosition(){const t=this.localToWorld();return new p.F(t.m41,t.m42)}setAbsolutePosition(t){(0,X.P)(t)?this.position((()=>t().transformAsPoint(this.worldToParent()))):this.position(t.transformAsPoint(this.worldToParent()))}getAbsoluteRotation(){const t=this.localToWorld();return 180*Math.atan2(t.m12,t.m11)/Math.PI}setAbsoluteRotation(t){(0,X.P)(t)?this.rotation((()=>(0,a.$)(t(),this.worldToParent()))):this.rotation((0,a.$)(t,this.worldToParent()))}getAbsoluteScale(){const t=this.localToWorld();return new p.F(p.F.magnitude(t.m11,t.m12),p.F.magnitude(t.m21,t.m22))}setAbsoluteScale(t){(0,X.P)(t)?this.scale((()=>this.getRelativeScale(t()))):this.scale(this.getRelativeScale(t))}getRelativeScale(t){var e;const n=(null==(e=this.parent())?void 0:e.absoluteScale())??p.F.one;return t.div(n)}*tweenCompositeOperation(t,e,n){const o=(0,X.P)(t)?t():t;"source-over"===o?(yield*this.compositeOverride(1,e,n),this.compositeOverride(0),this.compositeOperation(o)):(this.compositeOperation(o),this.compositeOverride(1),yield*this.compositeOverride(0,e,n))}absoluteOpacity(){var t;return((null==(t=this.parent())?void 0:t.absoluteOpacity())??1)*this.opacity()}hasFilters(){return!!this.filters().find((t=>t.isActive()))}hasShadow(){return!!this.shadowColor()&&(this.shadowBlur()>0||0!==this.shadowOffset.x()||0!==this.shadowOffset.y())}filterString(){let t="";const e=this.compositeToWorld();for(const n of this.filters())n.isActive()&&(t+=" "+n.serialize(e));return t}setChildren(t){this.spawner(t)}getChildren(){return this.spawnChildren(),this.realChildren}spawnChildren(){const t=this.spawner();if((0,X.P)(this.spawner.context.raw())){const e=new Set;for(const n of t){const t=n.parent.context.raw();if(t&&t!==this)throw new l.t("The spawner returned a node that already has a parent","A spawner should either create entirely new nodes or reuse nodes from a pool.");n.parent(this),e.add(n.key)}for(const t of this.realChildren)e.has(t.key)||t.parent(null);this.realChildren=t}else this.realChildren=t}sortedChildren(){return[...this.children()].sort(((t,e)=>Math.sign(t.zIndex()-e.zIndex())))}constructor(t){let{children:e,spawner:n,key:s,...r}=t;this.compositeOverride=(0,k.g)(0),this.stateStack=[],this.realChildren=[],this.parent=(0,k.g)(null),this.properties=(0,o.RG)(this);const i=(0,u.$r)();this.key=i.registerNode(this,s),this.view2D=i.getView(),this.creationStack=(new Error).stack,(0,o.Xd)(this,r),this.add(e),n&&this.children(n)}localToWorld(){const t=this.parent();return t?t.localToWorld().multiply(this.localToParent()):this.localToParent()}worldToLocal(){return this.localToWorld().inverse()}worldToParent(){var t;return(null==(t=this.parent())?void 0:t.worldToLocal())??new DOMMatrix}localToParent(){const t=new DOMMatrix;return t.translateSelf(this.position.x(),this.position.y()),t.rotateSelf(0,0,this.rotation()),t.scaleSelf(this.scale.x(),this.scale.y()),t}compositeToWorld(){var t;return(null==(t=this.compositeRoot())?void 0:t.localToWorld())??new DOMMatrix}compositeRoot(){var t;return this.composite()?this:(null==(t=this.parent())?void 0:t.compositeRoot())??null}compositeToLocal(){const t=this.compositeRoot();if(t){const e=this.worldToLocal();return e.m44=1,t.localToWorld().multiply(e)}return new DOMMatrix}view(){return this.view2D}add(t){return this.insert(t,1/0)}insert(t,e){void 0===e&&(e=0);const n=Array.isArray(t)?t:[t];if(0===n.length)return this;const o=this.children(),s=o.slice(0,e);for(const r of n)r instanceof T&&(s.push(r),r.remove(),r.parent(this));return s.push(...o.slice(e)),this.children(s),this}remove(){const t=this.parent();return null===t||(t.children(t.children().filter((t=>t!==this))),this.parent(null)),this}move(t){void 0===t&&(t=1);const e=this.parent();if(0===t||!e)return this;const n=e.children(),o=[];if(t>0)for(let s=0;s<n.length;s++){const e=n[s];if(e===this){const e=s+t;for(;s<e&&s+1<n.length;s++)o[s]=n[s+1]}o[s]=e}else for(let s=n.length-1;s>=0;s--){const e=n[s];if(e===this){const e=s+t;for(;s>e&&s>0;s--)o[s]=n[s-1]}o[s]=e}return e.children(o),this}moveUp(){return this.move(1)}moveDown(){return this.move(-1)}moveToTop(){return this.move(1/0)}moveToBottom(){return this.move(-1/0)}moveTo(t){const e=this.parent();if(!e)return this;const n=t-e.children().indexOf(this);return this.move(n)}moveBelow(t,e){void 0===e&&(e=!1);const n=this.parent();if(!n)return this;if(t.parent()!==n)return(0,u.wL)().error("Cannot position nodes relative to each other if they don't belong to the same parent."),this;const o=n.children(),s=o.indexOf(this),r=o.indexOf(t);if(!e&&s<r)return this;const i=r-s-1;return this.move(i)}moveAbove(t,e){void 0===e&&(e=!1);const n=this.parent();if(!n)return this;if(t.parent()!==n)return(0,u.wL)().error("Cannot position nodes relative to each other if they don't belong to the same parent."),this;const o=n.children(),s=o.indexOf(this),r=o.indexOf(t);if(!e&&s>r)return this;const i=r-s+1;return this.move(i)}reparent(t){const e=this.absolutePosition(),n=this.absoluteRotation(),o=this.absoluteScale();t.add(this),this.absolutePosition(e),this.absoluteRotation(n),this.absoluteScale(o)}removeChildren(){for(const t of this.children())t.remove()}dispose(){this.stateStack=[];for(const{signal:t}of this)null==t||t.context.dispose()}clone(t){void 0===t&&(t={});const e={...t};(0,X.P)(this.spawner.context.raw())?e.spawner=this.spawner.context.raw():this.children().length>0&&(e.children??(e.children=this.children().map((t=>t.clone()))));for(const{key:n,meta:o,signal:s}of this)if(o.cloneable&&!(n in e))if(o.compound)for(const[t,r]of o.compoundEntries)r in e||(e[r]=s[t].context.raw());else e[n]=s.context.raw();return this.instantiate(e)}snapshotClone(t){void 0===t&&(t={});const e={...this.getState(),...t};return this.children().length>0&&(e.children??(e.children=this.children().map((t=>t.snapshotClone())))),this.instantiate(e)}reactiveClone(t){void 0===t&&(t={});const e={...t};this.children().length>0&&(e.children??(e.children=this.children().map((t=>t.reactiveClone()))));for(const{key:n,meta:o,signal:s}of this)o.cloneable&&!(n in e)&&(e[n]=()=>s());return this.instantiate(e)}instantiate(t){return void 0===t&&(t={}),new this.constructor(t)}requiresCache(){return this.cache()||this.opacity()<1||"source-over"!==this.compositeOperation()||this.hasFilters()||this.hasShadow()}cacheCanvas(){const t=document.createElement("canvas").getContext("2d");if(!t)throw new Error("Could not create a cache canvas");return t}cachedCanvas(){const t=this.cacheCanvas(),e=this.worldSpaceCacheBBox(),n=this.localToWorld();return t.canvas.width=e.width,t.canvas.height=e.height,t.setTransform(n.a,n.b,n.c,n.d,n.e-e.x,n.f-e.y),this.draw(t),t}getCacheBBox(){return new c.b}cacheBBox(){const t=this.getCacheBBox(),e=this.children();if(0===e.length)return t;const n=t.corners;for(const o of e){const t=o.fullCacheBBox(),e=o.localToParent();n.push(...t.corners.map((t=>t.transformAsPoint(e))))}return c.b.fromPoints(...n)}fullCacheBBox(){const t=this.compositeToLocal(),e=this.shadowOffset().transform(t),n=(0,a.X)(this.shadowBlur(),t),o=this.cacheBBox().expand(2*this.filters.blur()+n);return e.x<0?(o.x+=e.x,o.width-=e.x):o.width+=e.x,e.y<0?(o.y+=e.y,o.height-=e.y):o.height+=e.y,o}worldSpaceCacheBBox(){const t=c.b.fromSizeCentered(this.view().size()),e=c.b.fromPoints(...t.transformCorners(this.view().localToWorld())),n=c.b.fromPoints(...this.cacheBBox().transformCorners(this.localToWorld()));return e.intersection(n).pixelPerfect}setupDrawFromCache(t){if(t.globalCompositeOperation=this.compositeOperation(),t.globalAlpha*=this.opacity(),this.hasFilters()&&(t.filter=this.filterString()),this.hasShadow()){const e=this.compositeToWorld(),n=this.shadowOffset().transform(e),o=(0,a.X)(this.shadowBlur(),e);t.shadowColor=this.shadowColor().serialize(),t.shadowBlur=o,t.shadowOffsetX=n.x,t.shadowOffsetY=n.y}}render(t){if(!(this.absoluteOpacity()<=0)){if(t.save(),this.transformContext(t),this.requiresCache()){const e=this.worldSpaceCacheBBox();if(0!==e.width&&0!==e.height){this.setupDrawFromCache(t);const n=this.cachedCanvas(),o=this.compositeOverride(),s=this.worldToLocal();t.transform(s.a,s.b,s.c,s.d,s.e,s.f),t.drawImage(n.canvas,e.position.x,e.position.y),o>0&&(t.save(),t.globalAlpha*=o,t.globalCompositeOperation="source-over",t.drawImage(n.canvas,e.position.x,e.position.y),t.restore())}}else this.draw(t);t.restore()}}draw(t){this.drawChildren(t)}drawChildren(t){for(const e of this.sortedChildren())e.render(t)}drawOverlay(t,e){const n=this.cacheBBox().transformCorners(e),o=this.getCacheBBox().transformCorners(e);t.strokeStyle="white",t.lineWidth=1,t.beginPath(),(0,f.pS)(t,n),t.closePath(),t.stroke(),t.strokeStyle="blue",t.beginPath(),(0,f.pS)(t,o),t.closePath(),t.stroke()}transformContext(t){const e=this.localToParent();t.transform(e.a,e.b,e.c,e.d,e.e,e.f)}hit(t){let e=null;const n=t.transformAsPoint(this.localToParent().inverse());for(const o of this.children().reverse())if(e=o.hit(n),e)break;return e}collectAsyncResources(){for(const t of this.children())t.collectAsyncResources()}async toPromise(){let t=v.k.consumePromises();do{await Promise.all(t.map((t=>t.promise))),this.collectAsyncResources(),t=v.k.consumePromises()}while(t.length>0);return this}getState(){const t={};for(const{key:e,meta:n,signal:o}of this)n.cloneable&&!(e in t)&&(t[e]=o());return t}applyState(t){for(const e in t){const n=this.signalByKey(e);n&&n(t[e])}}save(){this.stateStack.push(this.getState())}restore(t,e){void 0===e&&(e=m.qb);const n=this.stateStack.pop();if(void 0===n)return;const o=this.getState();for(const s in n)o[s]===n[s]&&delete n[s];return(0,d.i)(t,(t=>{const s=e(t),r=Object.keys(n).reduce(((t,e)=>(t[e]=(0,h.o0)(o[e],n[e],s),t)),{});this.applyState(r)}))}*[Symbol.iterator](){for(const t in this.properties){const e=this.properties[t],n=this.signalByKey(t);yield{meta:e,signal:n,key:t}}}signalByKey(t){return this[t]}}C([(0,s.y)()],T.prototype,"position",void 0),C([(0,o.YS)(p.F),(0,o.r_)(!1),(0,o.td)()],T.prototype,"absolutePosition",void 0),C([(0,o.nn)(0),(0,o.td)()],T.prototype,"rotation",void 0),C([(0,o.r_)(!1),(0,o.td)()],T.prototype,"absoluteRotation",void 0),C([(0,o.nn)(p.F.one),(0,s.y)("scale")],T.prototype,"scale",void 0),C([(0,o.YS)(p.F),(0,o.r_)(!1),(0,o.td)()],T.prototype,"absoluteScale",void 0),C([(0,o.nn)(0),(0,o.td)()],T.prototype,"zIndex",void 0),C([(0,o.nn)(!1),(0,o.td)()],T.prototype,"cache",void 0),C([(0,o.nn)(!1),(0,o.td)()],T.prototype,"composite",void 0),C([(0,o.nn)("source-over"),(0,o.td)()],T.prototype,"compositeOperation",void 0),C([(0,y.C)()],T.prototype,"tweenCompositeOperation",null),C([(0,o.nn)(1),(0,o.td)()],T.prototype,"opacity",void 0),C([(0,r.F)()],T.prototype,"absoluteOpacity",null),C([(t,e)=>{const n=(0,o.J)(t,e);(0,D.f)(t,(t=>{t[e]=new x(n.default??[],t).toSignal()}))}],T.prototype,"filters",void 0),C([(0,o.nn)("#0000"),(0,i.j)()],T.prototype,"shadowColor",void 0),C([(0,o.nn)(0),(0,o.td)()],T.prototype,"shadowBlur",void 0),C([(0,s.y)("shadowOffset")],T.prototype,"shadowOffset",void 0),C([(0,r.F)()],T.prototype,"hasFilters",null),C([(0,r.F)()],T.prototype,"hasShadow",null),C([(0,r.F)()],T.prototype,"filterString",null),C([(0,o.Oq)(!1),(0,o.r_)(!1),(0,o.nn)([]),(0,o.td)()],T.prototype,"spawner",void 0),C([(0,o.Oq)(!1),(0,o.r_)(!1),(0,o.td)()],T.prototype,"children",void 0),C([(0,r.F)()],T.prototype,"spawnChildren",null),C([(0,r.F)()],T.prototype,"sortedChildren",null),C([(0,r.F)()],T.prototype,"localToWorld",null),C([(0,r.F)()],T.prototype,"worldToLocal",null),C([(0,r.F)()],T.prototype,"worldToParent",null),C([(0,r.F)()],T.prototype,"localToParent",null),C([(0,r.F)()],T.prototype,"compositeToWorld",null),C([(0,r.F)()],T.prototype,"compositeRoot",null),C([(0,r.F)()],T.prototype,"compositeToLocal",null),C([(0,r.F)()],T.prototype,"cacheCanvas",null),C([(0,r.F)()],T.prototype,"cachedCanvas",null),C([(0,r.F)()],T.prototype,"cacheBBox",null),C([(0,r.F)()],T.prototype,"fullCacheBBox",null),C([(0,r.F)()],T.prototype,"worldSpaceCacheBBox",null),T.prototype.isClass=!0},15498:(t,e,n)=>{"use strict";n.d(e,{U:()=>c});var o=n(23357),s=n(13730),r=n(11258),i=n(93091),p=n(53693),a=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class c extends s.b{constructor(t){super(t)}getPath(){const t=new Path2D,e=this.radius(),n=this.smoothCorners(),s=this.cornerSharpness(),i=o.b.fromSizeCentered(this.size());return(0,r.Zy)(t,i,e,n,s),t}getCacheBBox(){return super.getCacheBBox().expand(this.rippleSize())}getRipplePath(){const t=new Path2D,e=this.rippleSize(),n=this.radius().addScalar(e),s=this.smoothCorners(),i=this.cornerSharpness(),p=o.b.fromSizeCentered(this.size()).expand(e);return(0,r.Zy)(t,p,n,s,i),t}}a([(0,p.g)("radius")],c.prototype,"radius",void 0),a([(0,i.nn)(!1),(0,i.td)()],c.prototype,"smoothCorners",void 0),a([(0,i.nn)(.6),(0,i.td)()],c.prototype,"cornerSharpness",void 0)},13730:(t,e,n)=>{"use strict";n.d(e,{b:()=>h});var o=n(93091),s=n(46350),r=n(70989),i=n(67292),p=n(97074),a=n(13170),c=n(11258),l=n(30204);function u(){return(t,e)=>{(0,o.td)()(t,e),(0,o.E2)(c.av)(t,e),(0,o.JI)(l.I.lerp)(t,e),(0,o.nn)(null)(t,e)}}var m=n(97140),d=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class h extends r.A{rippleSize(){return(0,p.ad)(this.rippleStrength(),0,50)}constructor(t){super(t),this.rippleStrength=(0,m.g)(0)}applyText(t){t.direction=this.textDirection(),this.element.dir=this.textDirection()}applyStyle(t){t.fillStyle=(0,c.ho)(this.fill(),t),t.strokeStyle=(0,c.ho)(this.stroke(),t),t.lineWidth=this.lineWidth(),t.lineJoin=this.lineJoin(),t.lineCap=this.lineCap(),t.setLineDash(this.lineDash()),t.lineDashOffset=this.lineDashOffset(),this.antialiased()||(t.filter="url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxmaWx0ZXIgaWQ9ImZpbHRlciIgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj48ZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVGdW5jUiB0eXBlPSJpZGVudGl0eSIvPjxmZUZ1bmNHIHR5cGU9ImlkZW50aXR5Ii8+PGZlRnVuY0IgdHlwZT0iaWRlbnRpdHkiLz48ZmVGdW5jQSB0eXBlPSJkaXNjcmV0ZSIgdGFibGVWYWx1ZXM9IjAgMSIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj48L2ZpbHRlcj48L3N2Zz4=#filter)")}draw(t){this.drawShape(t),this.clip()&&t.clip(this.getPath()),this.drawChildren(t)}drawShape(t){const e=this.getPath(),n=this.lineWidth()>0&&null!==this.stroke(),o=null!==this.fill();t.save(),this.applyStyle(t),this.drawRipple(t),this.strokeFirst()?(n&&t.stroke(e),o&&t.fill(e)):(o&&t.fill(e),n&&t.stroke(e)),t.restore()}getCacheBBox(){return super.getCacheBBox().expand(this.lineWidth()/2)}getPath(){return new Path2D}getRipplePath(){return new Path2D}drawRipple(t){const e=this.rippleStrength();if(e>0){const n=this.getRipplePath();t.save(),t.globalAlpha*=(0,a.UI)(.54,0,e),t.fill(n),t.restore()}}*ripple(t){void 0===t&&(t=1),this.rippleStrength(0),yield*this.rippleStrength(1,t,p.GE),this.rippleStrength(0)}}d([u()],h.prototype,"fill",void 0),d([u()],h.prototype,"stroke",void 0),d([(0,o.nn)(!1),(0,o.td)()],h.prototype,"strokeFirst",void 0),d([(0,o.nn)(0),(0,o.td)()],h.prototype,"lineWidth",void 0),d([(0,o.nn)("miter"),(0,o.td)()],h.prototype,"lineJoin",void 0),d([(0,o.nn)("butt"),(0,o.td)()],h.prototype,"lineCap",void 0),d([(0,o.nn)([]),(0,o.td)()],h.prototype,"lineDash",void 0),d([(0,o.nn)(0),(0,o.td)()],h.prototype,"lineDashOffset",void 0),d([(0,o.nn)(!0),(0,o.td)()],h.prototype,"antialiased",void 0),d([(0,s.F)()],h.prototype,"rippleSize",null),d([(0,s.F)()],h.prototype,"getPath",null),d([(0,i.C)()],h.prototype,"ripple",null)},70419:(t,e,n)=>{"use strict";n.d(e,{h:()=>a});var o=n(15498),s=n(93091),r=n(88733),i=n(79116),p=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class a extends o.U{constructor(t){super({composite:!0,fontFamily:"Roboto",fontSize:48,lineHeight:"120%",textWrap:!1,fontStyle:"normal",...t}),this.view2D=this,a.shadowRoot.append(this.element),this.applyFlex()}transformContext(){}dispose(){this.removeChildren(),super.dispose()}render(t){this.computedSize(),this.computedPosition(),super.render(t)}requestLayoutUpdate(){this.updateLayout()}view(){return this}}p([(0,s.nn)(r.q.Paused),(0,s.td)()],a.prototype,"playbackState",void 0),p([(0,i.V)((()=>{const t="motion-canvas-2d-frame";let e=document.querySelector(`#${t}`);return e||(e=document.createElement("div"),e.id=t,e.style.position="absolute",e.style.pointerEvents="none",e.style.top="0",e.style.left="0",e.style.opacity="0",e.style.overflow="hidden",document.body.prepend(e)),e.shadowRoot??e.attachShadow({mode:"open"})}))],a,"shadowRoot",void 0)},43595:(t,e,n)=>{"use strict";n.d(e,{j:()=>r});var o=n(30204),s=n(93091);function r(){return(t,e)=>{(0,s.td)()(t,e),(0,s.YS)(o.I)(t,e)}}},37060:(t,e,n)=>{"use strict";n.d(e,{I:()=>c});var o=n(3163),s=n(93091),r=n(5788),i=n(13170),p=n(46096),a=n(14455);function c(t){return(e,n)=>{const c=(0,s.J)(e,n);c.compound=!0,c.compoundEntries=Object.entries(t),(0,r.f)(e,(e=>{if(!c.parser)return void(0,o.wL)().error(`Missing parser decorator for "${n.toString()}"`);const s=new p.N(Object.keys(t),c.parser,c.default,c.interpolationFunction??i.o0,e);(0,a.I)(s,c.parser,e,n);const r=s.toSignal();for(const[t,n]of c.compoundEntries)(0,a.I)(r[t].context,void 0,e,n);e[n]=r}))}}},46350:(t,e,n)=>{"use strict";n.d(e,{F:()=>r});var o=n(5788),s=n(73662);function r(){return(t,e)=>{(0,o.f)(t,(t=>{const n=Object.getPrototypeOf(t)[e];t[e]=(0,s.D)(n.bind(t),t)}))}}},5788:(t,e,n)=>{"use strict";n.d(e,{f:()=>s,j:()=>r});const o=Symbol.for("@motion-canvas/2d/decorators/initializers");function s(t,e){if(t[o]){if(t[o]&&!Object.prototype.hasOwnProperty.call(t,o)){const e=Object.getPrototypeOf(t);t[o]=[...e[o]]}}else t[o]=[];t[o].push(e)}function r(t,e){if(t[o])try{t[o].forEach((n=>n(t,e)))}catch(n){throw n.inspect??(n.inspect=t.key),n}}},93091:(t,e,n)=>{"use strict";n.d(e,{E2:()=>k,J:()=>u,JI:()=>f,Oq:()=>M,RG:()=>m,Xd:()=>d,YS:()=>w,nn:()=>y,r_:()=>g,td:()=>h});var o=n(13170),s=n(5788),r=n(15688),i=n(3163),p=n(14455),a=n(16249);const c=Symbol.for("@motion-canvas/2d/decorators/properties");function l(t,e){var n;return(null==(n=t[c])?void 0:n[e])??null}function u(t,e){let n;return t[c]?t[c]&&!Object.prototype.hasOwnProperty.call(t,c)?t[c]=n=Object.fromEntries(Object.entries(t[c]).map((t=>{let[e,n]=t;return[e,{...n}]}))):n=t[c]:t[c]=n={},n[e]??(n[e]={cloneable:!0,inspectable:!0,compoundEntries:[]}),n[e]}function m(t){return t&&"object"==typeof t?t[c]??{}:{}}function d(t,e){(0,s.j)(t);for(const[n,o]of Object.entries(m(t))){const s=t[n];if(s.reset(),void 0!==e[n]&&s(e[n]),void 0!==o.compoundEntries)for(const[t,n]of o.compoundEntries)n in e&&s[t](e[n])}}function h(){return(t,e)=>{const n=u(t,e);(0,s.f)(t,(t=>{var s;const i=null==(s=t[`getDefault${(0,r.k)(e)}`])?void 0:s.bind(t),c=new a.V(i??n.default,n.interpolationFunction??o.o0,t);(0,p.I)(c,n.parser,t,e),t[e]=c.toSignal()}))}}function y(t){return(e,n)=>{const o=l(e,n);o?o.default=t:(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function f(t){return(e,n)=>{const o=l(e,n);o?o.interpolationFunction=t:(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function k(t){return(e,n)=>{const o=l(e,n);o?o.parser=t:(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function w(t){return(e,n)=>{const o=l(e,n);o?(o.parser=e=>new t(e),"lerp"in t&&(o.interpolationFunction??(o.interpolationFunction=t.lerp))):(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function g(t){return void 0===t&&(t=!0),(e,n)=>{const o=l(e,n);o?o.cloneable=t:(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function M(t){return void 0===t&&(t=!0),(e,n)=>{const o=l(e,n);o?o.inspectable=t:(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}},53693:(t,e,n)=>{"use strict";n.d(e,{g:()=>i});var o=n(43188),s=n(37060),r=n(93091);function i(t){return(e,n)=>{(0,s.I)({top:t?`${t}Top`:"top",right:t?`${t}Right`:"right",bottom:t?`${t}Bottom`:"bottom",left:t?`${t}Left`:"left"})(e,n),(0,r.YS)(o.K)(e,n)}}},88104:(t,e,n)=>{"use strict";n.d(e,{y:()=>i});var o=n(29797),s=n(37060),r=n(93091);function i(t){return(e,n)=>{(0,s.I)("object"==typeof t?t:{x:t?`${t}X`:"x",y:t?`${t}Y`:"y"})(e,n),(0,r.YS)(o.F)(e,n)}}},15914:(t,e,n)=>{"use strict";n.d(e,{r:()=>T});var o=n(92673),s=n(82344),r=n(11726);var i=n(80638),p=n(5881),a=n(97140);class c{constructor(t){this.scene=t,this.signals={},this.variables={},this.handleReset=()=>{this.signals={}},t.onReset.subscribe(this.handleReset)}get(t,e){var n;return(n=this.signals)[t]??(n[t]=(0,a.g)(this.variables[t]??e)),()=>this.signals[t]()}updateSignals(t){this.variables=t,Object.keys(t).map((e=>{e in this.signals&&this.signals[e](t[e])}))}}var l,u=n(1323),m=n(96881),d=n(42075),h=n(67292),y=n(3163),f=n(97715);!function(t){t[t.BeforeRender=0]="BeforeRender",t[t.BeginRender=1]="BeginRender",t[t.FinishRender=2]="FinishRender",t[t.AfterRender=3]="AfterRender"}(l||(l={}));class k{get onBeforeRender(){return this.beforeRender.subscribable}get onBeginRender(){return this.beginRender.subscribable}get onFinishRender(){return this.finishRender.subscribable}get onAfterRender(){return this.afterRender.subscribable}constructor(t){this.scene=t,this.beforeRender=new m.p,this.beginRender=new m.p,this.finishRender=new m.p,this.afterRender=new m.p,this.scene.onRenderLifecycle.subscribe((t=>{let[e,n]=t;switch(e){case l.BeforeRender:return this.beforeRender.dispatch(n);case l.BeginRender:return this.beginRender.dispatch(n);case l.FinishRender:return this.finishRender.dispatch(n);case l.AfterRender:return this.afterRender.dispatch(n)}})),this.scene.onReset.subscribe((()=>{this.beforeRender.clear(),this.beginRender.clear(),this.finishRender.clear(),this.afterRender.clear()}))}}var w,g=n(23357);!function(t){t[t.Initial=0]="Initial",t[t.AfterTransitionIn=1]="AfterTransitionIn",t[t.CanTransitionOut=2]="CanTransitionOut",t[t.Finished=3]="Finished"}(w||(w={}));var M=n(76062),D=n(88733);class _{get onChanged(){return this.slides.subscribable}constructor(t){this.scene=t,this.slides=new u.G([]),this.lookup=new Map,this.collisionLookup=new Set,this.current=null,this.canResume=!1,this.waitsForId=null,this.targetId=null,this.handleReload=()=>{this.lookup.clear(),this.collisionLookup.clear(),this.current=null,this.waitsForId=null,this.targetId=null},this.handleReset=()=>{this.collisionLookup.clear(),this.current=null,this.waitsForId=null},this.handleRecalculated=()=>{this.slides.current=[...this.lookup.values()]},this.scene.onReloaded.subscribe(this.handleReload),this.scene.onReset.subscribe(this.handleReset),this.scene.onRecalculated.subscribe(this.handleRecalculated)}setTarget(t){this.targetId=t}resume(){this.canResume=!0}isWaitingFor(t){return this.waitsForId===t}isWaiting(){return null!==this.waitsForId}didHappen(t){if(null===this.current)return!1;for(const n of this.lookup.keys()){var e;if(n===t)return!0;if(n===(null==(e=this.current)?void 0:e.id))return!1}return!1}getCurrent(){return this.current}register(t,e){if(null!==this.waitsForId)throw new Error(`The animation already waits for a slide: ${this.waitsForId}.`);const n=this.toId(t);this.scene.playback.state!==D.q.Presenting&&(this.lookup.has(n)||this.lookup.set(n,{id:n,name:t,time:e,scene:this.scene,stack:(new Error).stack}),this.collisionLookup.has(t)?this.scene.logger.warn({message:`A slide named "${t}" already exists.`,stack:(new Error).stack}):this.collisionLookup.add(t)),this.waitsForId=n,this.current=this.lookup.get(n)??null,this.canResume=!1}shouldWait(t){const e=this.toId(t);if(this.waitsForId!==e)throw new Error(`The animation waits for a different slide: ${this.waitsForId}.`);if(!this.lookup.get(e))throw new Error(`Could not find the "${t}" slide.`);let n=this.canResume;return this.scene.playback.state!==D.q.Presenting&&(n=e!==this.targetId),n&&(this.waitsForId=null),!n}toId(t){return`${this.scene.name}:${t}`}}class X{get firstFrame(){return this.cache.current.firstFrame}get lastFrame(){return this.firstFrame+this.cache.current.duration}get onCacheChanged(){return this.cache.subscribable}get onReloaded(){return this.reloaded.subscribable}get onRecalculated(){return this.recalculated.subscribable}get onThreadChanged(){return this.thread.subscribable}get onRenderLifecycle(){return this.renderLifecycle.subscribable}get onReset(){return this.afterReset.subscribable}get LifecycleEvents(){return this.logger.warn("LifecycleEvents is deprecated. Use lifecycleEvents instead."),this.lifecycleEvents}get previous(){return this.previousScene}constructor(t){this.cache=new u.G({firstFrame:0,transitionDuration:0,duration:0,lastFrame:0}),this.reloaded=new m.p,this.recalculated=new m.p,this.thread=new u.G(null),this.renderLifecycle=new m.p,this.afterReset=new m.p,this.lifecycleEvents=new k(this),this.previousScene=null,this.runner=null,this.state=w.Initial,this.cached=!1,this.counters={},this.name=t.name,this.size=t.size,this.resolutionScale=t.resolutionScale,this.logger=t.logger,this.playback=t.playback,this.meta=t.meta,this.runnerFactory=t.config,this.creationStack=t.stack,(0,d.G)(this.runnerFactory,(0,h.C)(this.name)),this.timeEvents=new t.timeEventsClass(this),this.variables=new c(this),this.slides=new _(this),this.random=new r.k(this.meta.seed.get())}update(){}async render(t){let e=M.k.consumePromises(),n=0;do{n++,await Promise.all(e.map((t=>t.promise))),t.save();const o=g.b.fromSizeCentered(this.getSize());t.clearRect(o.x,o.y,o.width,o.height),this.execute((()=>this.draw(t))),t.restore(),e=M.k.consumePromises()}while(e.length>0&&n<10);n>1&&this.logger.debug(`render iterations: ${n}`)}reload(t){let{config:e,size:n,stack:o,resolutionScale:s}=void 0===t?{}:t;e&&(this.runnerFactory=e),n&&(this.size=n),s&&(this.resolutionScale=s),o&&(this.creationStack=o),this.cached=!1,this.reloaded.dispatch()}async recalculate(t){const e=this.cache.current;if(e.firstFrame=this.playback.frame,e.lastFrame=e.firstFrame+e.duration,this.isCached())return t(e.lastFrame),void(this.cache.current={...e});for(e.transitionDuration=-1,await this.reset();!this.canTransitionOut();)e.transitionDuration<0&&this.state===w.AfterTransitionIn&&(e.transitionDuration=this.playback.frame-e.firstFrame),t(this.playback.frame+1),await this.next();-1===e.transitionDuration&&(e.transitionDuration=0),e.lastFrame=this.playback.frame,e.duration=e.lastFrame-e.firstFrame,await new Promise((t=>setTimeout(t,0))),this.cached=!0,this.cache.current={...e},this.recalculated.dispatch()}async next(){if(!this.runner)return;let t=this.execute((()=>this.runner.next()));for(this.update();t.value;){if((0,i.x)(t.value)){const e=await t.value.toPromise();t=this.execute((()=>this.runner.next(e)))}else if((0,p.t)(t.value)){const e=await t.value;t=this.execute((()=>this.runner.next(e)))}else this.logger.warn({message:"Invalid value yielded by the scene.",object:t.value}),t=this.execute((()=>this.runner.next(t.value)));this.update()}const e=M.k.consumePromises();var n;e.length>0&&(await Promise.all(e.map((t=>t.promise))),this.logger.error({message:"Tried to access an asynchronous property before the node was ready. Make sure to yield the node before accessing the property.",stack:e[0].stack,inspect:(null==(n=e[0].owner)?void 0:n.key)??void 0}));t.done&&(this.state=w.Finished)}async reset(t){void 0===t&&(t=null),this.counters={},this.previousScene=t,this.random=new r.k(this.meta.seed.get()),this.runner=(0,p.C)((()=>this.runnerFactory(this.getView())),(t=>{this.thread.current=t})),this.state=w.AfterTransitionIn,this.afterReset.dispatch(),await this.next()}getSize(){return this.size}isAfterTransitionIn(){return this.state===w.AfterTransitionIn}canTransitionOut(){return this.state===w.CanTransitionOut||this.state===w.Finished}isFinished(){return this.state===w.Finished}enterInitial(){this.state===w.AfterTransitionIn?this.state=w.Initial:this.logger.warn(`Scene ${this.name} entered initial in an unexpected state: ${this.state}`)}enterAfterTransitionIn(){this.state===w.Initial?this.state=w.AfterTransitionIn:this.logger.warn(`Scene ${this.name} transitioned in an unexpected state: ${this.state}`)}enterCanTransitionOut(){this.state===w.AfterTransitionIn||this.state===w.Initial?this.state=w.CanTransitionOut:this.logger.warn(`Scene ${this.name} was marked as finished in an unexpected state: ${this.state}`)}isCached(){return this.cached}execute(t){let e;(0,y.DO)(this),(0,f.wA)(this.playback);try{e=t()}finally{(0,f.Mh)(this.playback),(0,y.ug)(this)}return e}}var x=n(29797),v=n(70419);class C extends X{constructor(t){super(t),this.view=null,this.registeredNodes={},this.nodeCounters={},this.recreateView()}getView(){return this.view}next(){var t;return null==(t=this.getView())||t.playbackState(this.playback.state),super.next()}draw(t){t.save(),this.renderLifecycle.dispatch([l.BeforeRender,t]),t.save(),this.renderLifecycle.dispatch([l.BeginRender,t]),this.getView().playbackState(this.playback.state),this.getView().render(t),this.renderLifecycle.dispatch([l.FinishRender,t]),t.restore(),this.renderLifecycle.dispatch([l.AfterRender,t]),t.restore()}reset(t){for(const n in this.registeredNodes)try{this.registeredNodes[n].dispose()}catch(e){this.logger.error(e)}return this.registeredNodes={},this.nodeCounters={},this.recreateView(),super.reset(t)}inspectPosition(t,e){return this.execute((()=>{var n;return(null==(n=this.getView().hit(new x.F(t,e).scale(this.resolutionScale)))?void 0:n.key)??null}))}validateInspection(t){var e;return(null==(e=this.getNode(t))?void 0:e.key)??null}inspectAttributes(t){const e=this.getNode(t);if(!e)return null;const n={stack:e.creationStack,key:e.key};for(const{key:o,meta:s,signal:r}of e)s.inspectable&&(n[o]=r());return n}drawOverlay(t,e,n){const o=this.getNode(t);o&&this.execute((()=>{o.drawOverlay(n,e.scale(1/this.resolutionScale,1/this.resolutionScale).multiplySelf(o.localToWorld()))}))}registerNode(t,e){var n,o;const s=(null==(n=t.constructor)?void 0:n.name)??"unknown";(o=this.nodeCounters)[s]??(o[s]=0);const r=this.nodeCounters[s]++;return e??(e=`${this.name}/${s}[${r}]`),this.registeredNodes[e]=t,e}getNode(t){return"string"!=typeof t?null:this.registeredNodes[t]??null}recreateView(){this.execute((()=>{const t=this.getSize();this.view=new v.h({position:t.scale(this.resolutionScale/2),scale:this.resolutionScale,size:t})}))}}function T(t){return{klass:C,config:t,stack:(new Error).stack,meta:new o.v("scene",{version:new s.C("version",1),timeEvents:new s.C("time events",[]),seed:new s.C("seed",r.k.createSeed())})}}},11258:(t,e,n)=>{"use strict";n.d(e,{Nb:()=>_,JQ:()=>X,av:()=>d,AE:()=>w,pS:()=>D,is:()=>k,Zy:()=>y,kZ:()=>M,Ao:()=>g,pt:()=>x,ho:()=>h});var o=n(93091),s=n(88104),r=n(46350),i=n(30204),p=n(93214),a=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class c{constructor(t){(0,o.Xd)(this,t)}canvasGradient(t){let e;switch(this.type()){case"linear":e=t.createLinearGradient(this.from.x(),this.from.y(),this.to.x(),this.to.y());break;case"conic":e=t.createConicGradient(this.angle(),this.from.x(),this.from.y());break;case"radial":e=t.createRadialGradient(this.from.x(),this.from.y(),this.fromRadius(),this.to.x(),this.to.y(),this.toRadius())}for(const{offset:n,color:o}of this.stops())e.addColorStop((0,p.P)(n)?n():n,new i.I((0,p.P)(o)?o():o).serialize());return e}}a([(0,o.nn)("linear"),(0,o.td)()],c.prototype,"type",void 0),a([(0,s.y)("from")],c.prototype,"from",void 0),a([(0,s.y)("to")],c.prototype,"to",void 0),a([(0,o.nn)(0),(0,o.td)()],c.prototype,"angle",void 0),a([(0,o.nn)(0),(0,o.td)()],c.prototype,"fromRadius",void 0),a([(0,o.nn)(0),(0,o.td)()],c.prototype,"toRadius",void 0),a([(0,o.nn)([]),(0,o.td)()],c.prototype,"stops",void 0),a([(0,r.F)()],c.prototype,"canvasGradient",null);var l=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class u{constructor(t){(0,o.Xd)(this,t)}canvasPattern(t){return t.createPattern(this.image(),this.repetition())}}l([(0,o.td)()],u.prototype,"image",void 0),l([(0,o.nn)(null),(0,o.td)()],u.prototype,"repetition",void 0),l([(0,r.F)()],u.prototype,"canvasPattern",null);var m=n(29797);function d(t){return null===t?null:t instanceof c||t instanceof u?t:new i.I(t)}function h(t,e){return null===t?"":t instanceof i.I?t.serialize():t instanceof c?t.canvasGradient(e):t instanceof u?t.canvasPattern(e)??"":""}function y(t,e,n,o,s){if(0===n.top&&0===n.right&&0===n.bottom&&0===n.left)return void function(t,e){t.rect(e.x,e.y,e.width,e.height)}(t,e);const r=f(n.top,n.right,n.left,e),i=f(n.right,n.top,n.bottom,e),p=f(n.bottom,n.left,n.right,e),a=f(n.left,n.bottom,n.top,e);if(o){const n=t=>t-t*s;return t.moveTo(e.left+r,e.top),t.lineTo(e.right-i,e.top),t.bezierCurveTo(e.right-n(i),e.top,e.right,e.top+n(i),e.right,e.top+i),t.lineTo(e.right,e.bottom-p),t.bezierCurveTo(e.right,e.bottom-n(p),e.right-n(p),e.bottom,e.right-p,e.bottom),t.lineTo(e.left+a,e.bottom),t.bezierCurveTo(e.left+n(a),e.bottom,e.left,e.bottom-n(a),e.left,e.bottom-a),t.lineTo(e.left,e.top+r),void t.bezierCurveTo(e.left,e.top+n(r),e.left+n(r),e.top,e.left+r,e.top)}t.moveTo(e.left+r,e.top),t.arcTo(e.right,e.top,e.right,e.bottom,i),t.arcTo(e.right,e.bottom,e.left,e.bottom,p),t.arcTo(e.left,e.bottom,e.left,e.top,a),t.arcTo(e.left,e.top,e.right,e.top,r)}function f(t,e,n,o){const s=t+e>o.width?o.width*(t/(t+e)):t,r=t+n>o.height?o.height*(t/(t+n)):t;return Math.min(s,r)}function k(t,e,n){const o=e.size.scale(.5);for(let s=0;s<=n;s++){const e=2*s*Math.PI/n,r=m.F.fromRadians(e).perpendicular.mul(o);0==s?g(t,r):M(t,r)}t.closePath()}function w(t,e,n,o){o?t.drawImage(e,n.x,n.y,n.width,n.height,o.x,o.y,o.width,o.height):t.drawImage(e,n.x,n.y,n.width,n.height)}function g(t,e){t.moveTo(e.x,e.y)}function M(t,e){t.lineTo(e.x,e.y)}function D(t,e){if(!(e.length<2)){g(t,e[0]);for(const n of e.slice(1))M(t,n)}}function _(t,e,n,o,s,r){void 0===o&&(o=0),void 0===s&&(s=2*Math.PI),void 0===r&&(r=!1),t.arc(e.x,e.y,n,o,s,r)}function X(t,e,n,o){t.bezierCurveTo(e.x,e.y,n.x,n.y,o.x,o.y)}function x(t,e,n){t.quadraticCurveTo(e.x,e.y,n.x,n.y)}},14455:(t,e,n)=>{"use strict";n.d(e,{I:()=>s});var o=n(15688);function s(t,e,n,s){if(e&&t.setParser(e.bind(n)),s&&n){const e=null==n?void 0:n[`set${(0,o.k)(s)}`];e&&(t.set=function(){for(var t=arguments.length,o=new Array(t),s=0;s<t;s++)o[s]=arguments[s];return e.apply(n,o),n});const r=null==n?void 0:n[`get${(0,o.k)(s)}`];r&&(t.get=r.bind(n));const i=null==n?void 0:n[`tween${(0,o.k)(s)}`];i&&(t.doTween=i.bind(n))}}},88733:(t,e,n)=>{"use strict";n.d(e,{q:()=>o,r:()=>r});var o,s=n(1323);!function(t){t[t.Playing=0]="Playing",t[t.Rendering=1]="Rendering",t[t.Paused=2]="Paused",t[t.Presenting=3]="Presenting"}(o||(o={}));class r{constructor(){this.frame=0,this.speed=1,this.fps=30,this.duration=0,this.finished=!1,this.slides=[],this.previousScene=null,this.state=o.Paused,this.currentSceneReference=null,this.scenes=new s.G([])}get onSceneChanged(){if(null===this.currentSceneReference)throw new Error("PlaybackManager has not been properly initialized");return this.currentSceneReference.subscribable}get onScenesRecalculated(){return this.scenes.subscribable}get currentScene(){if(null===this.currentSceneReference)throw new Error("PlaybackManager has not been properly initialized");return this.currentSceneReference.current}set currentScene(t){if(!t)throw new Error("Invalid scene.");this.currentSceneReference??(this.currentSceneReference=new s.G(t)),this.currentSceneReference.current=t}setup(t){this.scenes.current=t,this.currentScene=t[0]}async progress(){return this.finished=await this.next(),this.finished}async seek(t){if(t<=this.frame||this.currentScene.isCached()&&this.currentScene.lastFrame<t){const e=this.findBestScene(t);e!==this.currentScene?(this.previousScene=null,this.currentScene=e,this.frame=this.currentScene.firstFrame,await this.currentScene.reset()):this.frame>=t&&(this.previousScene=null,this.frame=this.currentScene.firstFrame,await this.currentScene.reset())}for(this.finished=!1;this.frame<t&&!this.finished;)this.finished=await this.next();return this.finished}async goBack(){let t=this.currentScene.slides.getCurrent();if(t&&this.currentScene.slides.isWaiting()){const e=this.slides.indexOf(t);t=this.slides[e-1]}await this.seekSlide(t)}async goForward(){const t=this.currentScene.slides.getCurrent(),e=this.slides.indexOf(t);await this.seekSlide(this.slides[e+1])}async goTo(t){await this.seekSlide(this.slides.find((e=>e.id===t)))}async seekSlide(t){if(void 0===t&&(t=null),!t)return;const{id:e,scene:n}=t;for((this.currentScene!==n||this.currentScene.slides.didHappen(e))&&(this.previousScene=null,this.currentScene=n,this.frame=this.currentScene.firstFrame,this.currentScene.slides.setTarget(e),await this.currentScene.reset()),this.finished=!1,this.currentScene.slides.setTarget(e);!this.currentScene.slides.isWaitingFor(e)&&!this.finished;)this.finished=await this.next();return this.currentScene.slides.setTarget(null),this.finished}async reset(){this.previousScene=null,this.currentScene=this.scenes.current[0],this.frame=0,await this.currentScene.reset()}reload(t){this.scenes.current.forEach((e=>e.reload(t)))}async recalculate(){this.previousScene=null,this.slides=[];const t=this.speed;this.frame=0,this.speed=1;const e=[];try{for(const t of this.scenes.current)await t.recalculate((t=>{this.frame=t})),this.slides.push(...t.slides.onChanged.current),e.push(t)}finally{this.speed=t}this.scenes.current=e,this.duration=this.frame}async next(){if(this.previousScene&&(await this.previousScene.next(),this.currentScene.isFinished()&&(this.previousScene=null)),this.frame+=this.speed,this.currentScene.isFinished())return!0;if(await this.currentScene.next(),this.previousScene&&this.currentScene.isAfterTransitionIn()&&(this.previousScene=null),this.currentScene.canTransitionOut()){this.previousScene=this.currentScene;const t=this.getNextScene(this.previousScene);t&&(this.currentScene=t,await this.currentScene.reset(this.previousScene)),t&&!this.currentScene.isAfterTransitionIn()||(this.previousScene=null)}return this.currentScene.isFinished()}findBestScene(t){let e=this.scenes.current[0];for(const n of this.scenes.current){if(!n.isCached()||n.lastFrame>t)return n;e=n}return e}getNextScene(t){const e=this.scenes.current;if(!t)return e[0];const n=e.findIndex((e=>e===t));return n<0?null:e[n+1]??null}}},2672:(t,e,n)=>{"use strict";n.d(e,{J:()=>y});var o=n(88733),s=n(1323),r=n(3163);class i{get onDataChanged(){return this.data.subscribable}constructor(t){this.logger=t,this.data=new s.G(null),this.context=new AudioContext,this.audioElement=new Audio,this.source=null,this.error=!1,this.abortController=null,this.offset=0}getTime(){return this.toAbsoluteTime(this.audioElement.currentTime)}setTime(t){this.audioElement.currentTime=this.toRelativeTime(t)}setOffset(t){this.offset=t}setMuted(t){this.audioElement.muted=t}setSource(t){var e;this.source=t,this.audioElement.src=t,null==(e=this.abortController)||e.abort(),this.abortController=new AbortController,this.loadData(this.abortController.signal).catch((t=>{"AbortError"!==t.name&&this.logger.error(t)}))}isInRange(t){return t>=this.offset&&t<this.audioElement.duration}toRelativeTime(t){return Math.max(0,t-this.offset)}toAbsoluteTime(t){return t+this.offset}isReady(){return this.source&&!this.error}async setPaused(t){if(this.source&&this.audioElement.paused!==t)if(t)this.audioElement.pause();else try{return await this.audioElement.play(),this.error=!1,!0}catch(e){this.error||(0,r.wL)().error(e),this.error=!0}return!1}async loadData(t){if(this.data.current=null,!this.source)return;const e=await fetch(this.source,{signal:t}),n=await e.arrayBuffer();if(t.aborted)return;const o=await this.decodeAudioData(n);if(t.aborted)return;const s=256,r=~~(o.length/s),i=[];let p=0;for(let a=0;a<o.numberOfChannels;a++){const t=o.getChannelData(a);for(let e=0;e<r;e++){const n=~~(e*s),o=~~(n+s);let r=t[n],c=r;for(let e=n;e<o;e++){const n=t[e];n>c&&(c=n),n<r&&(r=n)}(0===a||c>i[2*e])&&(i[2*e]=c),(0===a||r<i[2*e+1])&&(i[2*e+1]=r),c>p&&(p=c),Math.abs(r)>p&&(p=Math.abs(r))}}this.data.current={peaks:i,absoluteMax:p,length:r,sampleRate:o.sampleRate/s*2}}decodeAudioData(t){return new Promise(((e,n)=>this.context.decodeAudioData(t,e,n)))}}var p=n(13170),a=n(11395);class c extends a.p{async dispatch(t){await Promise.all(this.notifySubscribers(t))}}var l=n(96881),u=n(29797);class m{constructor(t){this.playback=t}secondsToFrames(t){return Math.ceil(t*this.playback.fps)}framesToSeconds(t){return t/this.playback.fps}get time(){return this.framesToSeconds(this.playback.frame)}get frame(){return this.playback.frame}get speed(){return this.playback.speed}get fps(){return this.playback.fps}get state(){return this.playback.state}}var d=n(15649);class h{get onChanged(){return this.events.subscribable}constructor(t){this.scene=t,this.events=new s.G([]),this.registeredEvents={},this.lookup={},this.collisionLookup=new Set,this.previousReference=[],this.didEventsChange=!1,this.preserveTiming=!0,this.handleReload=()=>{this.registeredEvents={},this.collisionLookup.clear()},this.handleRecalculated=()=>{var t;this.preserveTiming=!0,this.events.current=Object.values(this.registeredEvents),(this.didEventsChange||((null==(t=this.previousReference)?void 0:t.length)??0)!==this.events.current.length)&&(this.didEventsChange=!1,this.previousReference=Object.values(this.registeredEvents).map((t=>({name:t.name,targetTime:t.targetTime}))),this.scene.meta.timeEvents.set(this.previousReference))},this.handleReset=()=>{this.collisionLookup.clear()},this.handleMetaChanged=t=>{t!==this.previousReference&&(this.previousReference=t,this.load(t),this.scene.reload())},this.previousReference=t.meta.timeEvents.get(),this.load(this.previousReference),t.onReloaded.subscribe(this.handleReload),t.onRecalculated.subscribe(this.handleRecalculated),t.onReset.subscribe(this.handleReset),t.meta.timeEvents.onChanged.subscribe(this.handleMetaChanged,!1)}set(t,e,n){void 0===n&&(n=!0),this.lookup[t]&&this.lookup[t].offset!==e&&(this.preserveTiming=n,this.lookup[t]={...this.lookup[t],targetTime:this.lookup[t].initialTime+e,offset:e},this.registeredEvents[t]=this.lookup[t],this.events.current=Object.values(this.registeredEvents),this.didEventsChange=!0,this.scene.reload())}register(t,e){if(this.collisionLookup.has(t))return this.scene.logger.error({message:`name "${t}" has already been used for another event name.`,stack:(new Error).stack}),0;if(this.collisionLookup.add(t),this.lookup[t]){let n=!1;const o={...this.lookup[t]},s=(new Error).stack;o.stack!==s&&(o.stack=s,n=!0),o.initialTime!==e&&(o.initialTime=e,n=!0);const r=Math.max(0,o.targetTime-o.initialTime);this.preserveTiming&&o.offset!==r&&(o.offset=r,n=!0);const i=o.initialTime+o.offset;this.preserveTiming||o.targetTime===i||(this.didEventsChange=!0,o.targetTime=i,n=!0),n&&(this.lookup[t]=o)}else this.didEventsChange=!0,this.lookup[t]={name:t,initialTime:e,targetTime:e,offset:0,stack:(new Error).stack};return this.registeredEvents[t]=this.lookup[t],this.lookup[t].offset}load(t){for(const e of t){const t=this.lookup[e.name]??{name:e.name,initialTime:0,offset:0};this.lookup[e.name]={...t,targetTime:e.targetTime}}}}class y{get onRender(){return this.render.subscribable}get onStateChanged(){return this.playerState.subscribable}get onFrameChanged(){return this.frame.subscribable}get onDurationChanged(){return this.duration.subscribable}get onRecalculated(){return this.recalculated.subscribable}get startFrame(){return Math.min(this.playback.duration,this.status.secondsToFrames(this.startTime))}get endFrame(){return Math.min(this.playback.duration,this.status.secondsToFrames(this.endTime))}get finished(){return this.playback.finished||this.playback.frame>=this.endFrame}constructor(t,e,n,r){var p,a;void 0===e&&(e={}),void 0===n&&(n={}),void 0===r&&(r=-1),this.project=t,this.settings=e,this.initialState=n,this.initialFrame=r,this.render=new c,this.frame=new s.G(0),this.duration=new s.G(0),this.recalculated=new l.p,this.lock=new d.L,this.startTime=0,this.endTime=1/0,this.requestId=null,this.renderTime=0,this.requestedSeek=-1,this.requestedRecalculation=!0,this.active=!1,this.playerState=new s.G({loop:!0,muted:!0,speed:1,...n,paused:!0}),this.requestedSeek=r,this.logger=this.project.logger,this.playback=new o.r,this.status=new m(this.playback),this.audio=new i(this.logger),this.size=e.size??new u.F(1920,1080),this.resolutionScale=e.resolutionScale??1,this.startTime=(null==(p=e.range)?void 0:p[0])??0,this.endTime=(null==(a=e.range)?void 0:a[1])??1/0,this.playback.fps=e.fps??60,this.audio.setOffset(e.audioOffset??0),t.audio&&this.audio.setSource(t.audio);const y=[];for(const o of t.scenes){var f;const e=new o.klass({...o,playback:this.status,logger:this.project.logger,size:this.size,resolutionScale:this.resolutionScale,timeEventsClass:h});null==(f=o.onReplaced)||f.subscribe((t=>{e.reload(t)}),!1),e.onReloaded.subscribe((()=>this.requestRecalculation())),e.variables.updateSignals(t.variables??{}),y.push(e)}this.playback.setup(y),this.activate()}async configure(t){await this.lock.acquire();let e=this.playback.frame,n=!1;if(this.startTime=t.range[0],this.endTime=t.range[1],this.playback.fps!==t.fps){const o=t.fps/this.playback.fps;this.playback.fps=t.fps,e=Math.floor(e*o),n=!0}t.size.exactlyEquals(this.size)&&t.resolutionScale===this.resolutionScale||(this.size=t.size,this.resolutionScale=t.resolutionScale,this.playback.reload({size:this.size,resolutionScale:this.resolutionScale})),void 0!==t.audioOffset&&this.audio.setOffset(t.audioOffset),this.lock.release(),n&&(this.playback.reload(),this.frame.current=e,this.requestRecalculation(),this.requestedSeek=e)}requestSeek(t){this.requestedSeek=this.clampRange(t)}requestPreviousFrame(){this.requestedSeek=this.frame.current-this.playback.speed}requestNextFrame(){this.requestedSeek=this.frame.current+this.playback.speed}requestReset(){this.requestedSeek=0}toggleLoop(t){void 0===t&&(t=!this.playerState.current.loop),t!==this.playerState.current.loop&&(this.playerState.current={...this.playerState.current,loop:t})}togglePlayback(t){void 0===t&&(t=this.playerState.current.paused),t===this.playerState.current.paused&&(this.playerState.current={...this.playerState.current,paused:!t},t&&!this.playerState.current.loop&&this.playback.frame===this.playback.duration&&this.requestReset())}toggleAudio(t){void 0===t&&(t=this.playerState.current.muted),t===this.playerState.current.muted&&(this.playerState.current={...this.playerState.current,muted:!t})}setSpeed(t){t!==this.playerState.current.speed&&(this.playback.speed=t,this.playback.reload(),this.playerState.current={...this.playerState.current,speed:t},this.requestRecalculation())}setVariables(t){for(const e of this.playback.onScenesRecalculated.current)e.variables.updateSignals(t)}activate(){this.active=!0,this.request()}deactivate(){this.active=!1,null!==this.requestId&&(cancelAnimationFrame(this.requestId),this.requestId=null)}requestRecalculation(){this.requestedRecalculation=!0,this.request()}async prepare(){const t={...this.playerState.current,seek:this.requestedSeek};if(this.requestedSeek=-1,this.requestedRecalculation){t.seek<0&&(t.seek=this.playback.frame);try{await this.playback.recalculate(),this.duration.current=this.playback.frame,this.recalculated.dispatch()}catch(n){throw this.requestSeek(t.seek),n}finally{this.requestedRecalculation=!1}}(!t.loop&&this.finished&&!t.paused&&t.seek<0||this.endFrame===this.startFrame)&&(this.togglePlayback(!1),t.paused=!0),t.loop&&(t.seek>this.endFrame||this.finished&&!t.paused)&&this.startFrame!==this.endTime&&(t.seek=this.startFrame);const e=t.paused||this.finished||!this.audio.isInRange(this.status.time);return await this.audio.setPaused(e)&&this.syncAudio(-3),this.audio.setMuted(t.muted),t}async run(){const t=await this.prepare(),e=this.playback.state;if(this.playback.state=t.paused?o.q.Paused:o.q.Playing,t.seek>=0||!this.isInRange(this.status.frame)){const e=t.seek<0?this.status.frame:t.seek,n=this.clampRange(e);this.logger.profile("seek time"),await this.playback.seek(n),this.logger.profile("seek time"),this.syncAudio(-3)}else{if(t.paused||1===t.speed&&this.audio.isReady()&&this.audio.isInRange(this.status.time)&&this.audio.getTime()<this.status.time)return t.paused&&e!==o.q.Paused&&await this.render.dispatch(),!t.paused&&this.status.time>this.audio.getTime()+.02&&this.syncAudio(),void this.request();if(this.audio.isReady()&&1===t.speed&&this.audio.isInRange(this.status.time)&&this.status.framesToSeconds(this.playback.frame+1)<this.audio.getTime()-.02){const t=this.status.secondsToFrames(this.audio.getTime());await this.playback.seek(t)}else this.status.frame<this.endFrame&&(await this.playback.progress(),1!==t.speed&&this.syncAudio())}!t.paused&&this.playback.currentScene.slides.isWaiting()&&(this.togglePlayback(!1),t.paused=!0),await this.render.dispatch(),this.frame.current=this.playback.frame,this.request()}request(){this.active&&(this.requestId??(this.requestId=requestAnimationFrame((async t=>{if(this.requestId=null,t-this.renderTime>=1e3/(this.status.fps+5)){this.renderTime=t,await this.lock.acquire();try{await this.run()}catch(e){this.logger.error(e)}this.lock.release()}else this.request()}))))}clampRange(t){return(0,p.uZ)(this.startFrame,this.endFrame,t)}isInRange(t){return t>=this.startFrame&&t<=this.endFrame}syncAudio(t){void 0===t&&(t=0),this.audio.setTime(this.status.framesToSeconds(this.playback.frame+t))}}},9989:(t,e,n)=>{"use strict";n.d(e,{H:()=>r});var o=n(1119),s=n(29797);class r{get canvasSize(){return this.size.scale(this.resolutionScale)}constructor(){this.background=null,this.resolutionScale=1,this.colorSpace="srgb",this.size=s.F.zero,this.finalBuffer=document.createElement("canvas"),this.currentBuffer=document.createElement("canvas"),this.previousBuffer=document.createElement("canvas");const t=this.colorSpace;this.context=(0,o.f)({colorSpace:t},this.finalBuffer),this.currentContext=(0,o.f)({colorSpace:t},this.currentBuffer),this.previousContext=(0,o.f)({colorSpace:t},this.previousBuffer)}configure(t){let{colorSpace:e=this.colorSpace,size:n=this.size,resolutionScale:s=this.resolutionScale,background:r=this.background}=t;e!==this.colorSpace&&(this.colorSpace=e,this.context=(0,o.f)({colorSpace:e},this.finalBuffer),this.currentContext=(0,o.f)({colorSpace:e},this.currentBuffer),this.previousContext=(0,o.f)({colorSpace:e},this.previousBuffer)),n.exactlyEquals(this.size)&&s===this.resolutionScale||(this.resolutionScale=s,this.size=n,this.resizeCanvas(this.context),this.resizeCanvas(this.currentContext),this.resizeCanvas(this.previousContext)),this.background="string"==typeof r?r:(null==r?void 0:r.serialize())??null}async render(t,e){e&&(this.transformCanvas(this.previousContext),await e.render(this.previousContext)),this.transformCanvas(this.currentContext),await t.render(this.currentContext);const n=this.canvasSize;this.context.clearRect(0,0,n.width,n.height),this.background&&(this.context.save(),this.context.fillStyle=this.background,this.context.fillRect(0,0,n.width,n.height),this.context.restore()),e&&this.context.drawImage(this.previousBuffer,0,0),this.context.drawImage(this.currentBuffer,0,0)}transformCanvas(t){const e=this.canvasSize.scale(.5);t.setTransform(this.resolutionScale,0,0,this.resolutionScale,e.x,e.y)}resizeCanvas(t){const e=this.canvasSize;t.canvas.width=e.width,t.canvas.height=e.height}}},42075:(t,e,n)=>{"use strict";function o(t){const e={[t.name]:t},n=Object.getOwnPropertyDescriptor(e,t.name);if(n){for(var o=arguments.length,s=new Array(o>1?o-1:0),r=1;r<o;r++)s[r-1]=arguments[r];for(let o=s.length-1;o>=0;o--)s[o](e,t.name,n)}}n.d(e,{G:()=>o})},79116:(t,e,n)=>{"use strict";n.d(e,{V:()=>s});const o=Symbol.for("@motion-canvas/core/decorators/UNINITIALIZED");function s(t){return(e,n)=>{let s=o;Object.defineProperty(e,n,{get(){return s===o&&(s=t.call(this)),s}})}}},67292:(t,e,n)=>{"use strict";function o(t){return function(e,n,o){o.value.prototype.name=t??n,o.value.prototype.threadable=!0}}n.d(e,{C:()=>o})},96881:(t,e,n)=>{"use strict";n.d(e,{p:()=>s});var o=n(11395);class s extends o.p{dispatch(t){this.notifySubscribers(t)}}},11395:(t,e,n)=>{"use strict";n.d(e,{l:()=>s,p:()=>o});class o{constructor(){this.subscribable=new s(this),this.subscribers=new Set}subscribe(t){return this.subscribers.add(t),()=>this.unsubscribe(t)}unsubscribe(t){this.subscribers.delete(t)}clear(){this.subscribers.clear()}notifySubscribers(t){return[...this.subscribers].map((e=>e(t)))}}class s{constructor(t){this.dispatcher=t}subscribe(t){return this.dispatcher.subscribe(t)}unsubscribe(t){this.dispatcher.unsubscribe(t)}}},1323:(t,e,n)=>{"use strict";n.d(e,{G:()=>s});var o=n(11395);class s extends o.p{set current(t){this.value=t,this.notifySubscribers(t)}get current(){return this.value}constructor(t){super(),this.value=t,this.subscribable=new r(this)}subscribe(t,e){void 0===e&&(e=!0);const n=super.subscribe(t);return e&&t(this.value),n}}class r extends o.l{get current(){return this.dispatcher.current}subscribe(t,e){return void 0===e&&(e=!0),this.dispatcher.subscribe(t,e)}}},5376:(t,e,n)=>{"use strict";n.d(e,{$:()=>i});var o=n(51284),s=n(42075),r=n(67292);function*i(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];for(const o of e)yield o;yield*(0,o.v)(...e)}(0,s.G)(i,(0,r.C)())},77396:(t,e,n)=>{"use strict";n.d(e,{K:()=>s});var o=n(75168);function s(t,e){let n;return"string"==typeof t?(n=e(),(0,o.i)(n,t)):(n=t(),(0,o.i)(n,n)),n}},82344:(t,e,n)=>{"use strict";n.d(e,{C:()=>s});var o=n(1323);class s{get onChanged(){return this.value.subscribable}get onDisabled(){return this.disabled.subscribable}constructor(t,e){this.name=t,this.type=void 0,this.spacing=!1,this.disabled=new o.G(!1),this.value=new o.G(e)}get(){return this.value.current}set(t){this.value.current=this.parse(t)}parse(t){return t}serialize(){return this.value.current}clone(){return new this.constructor(this.name,this.get())}disable(t){return void 0===t&&(t=!0),this.disabled.current=t,this}space(t){return void 0===t&&(t=!0),this.spacing=t,this}}},92673:(t,e,n)=>{"use strict";n.d(e,{v:()=>i});var o=n(82344),s=n(1323);class r extends o.C{get onFieldsChanged(){return this.event.subscribable}constructor(t,e){const n=new Map(Object.entries(e));super(t,Object.fromEntries(Array.from(n,(t=>{let[e,n]=t;return[e,n.get()]})))),this.type=Object,this.ignoreChange=!1,this.customFields={},this.handleChange=()=>{this.ignoreChange||(this.value.current=this.transform("get"))},this.event=new s.G([...n.values()]),this.fields=n;for(const[o,s]of this.fields)Object.defineProperty(this,o,{value:s}),s.onChanged.subscribe(this.handleChange)}set(t){this.ignoreChange=!0;for(const[e,n]of Object.entries(t)){const t=this.fields.get(e);t?t.set(n):this.customFields[e]=n}this.ignoreChange=!1,this.handleChange()}serialize(){return this.transform("serialize")}clone(){return new this.constructor(this.name,this.transform("clone"))}transform(t){return{...Object.fromEntries(Array.from(this.fields,(e=>{let[n,o]=e;return[n,o[t]()]}))),...this.customFields}}}const i=r},11726:(t,e,n)=>{"use strict";n.d(e,{k:()=>r});var o=n(13170),s=n(37762);class r{constructor(t){this.state=t}static createSeed(){return Math.floor(4294967296*Math.random())}nextFloat(t,e){return void 0===t&&(t=0),void 0===e&&(e=1),(0,o.UI)(t,e,this.next())}nextInt(t,e){void 0===t&&(t=0),void 0===e&&(e=4294967296);let n=Math.floor((0,o.UI)(t,e,this.next()));return n===e&&(n=t),n}floatArray(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,s.w)(t).map((()=>this.nextFloat(e,n)))}intArray(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=4294967296),(0,s.w)(t).map((()=>this.nextInt(e,n)))}spawn(){return new r(this.nextInt())}next(){this.state|=0,this.state=this.state+1831565813|0;let t=Math.imul(this.state^this.state>>>15,1|this.state);return t=t+Math.imul(t^t>>>7,61|t)^t,((t^t>>>14)>>>0)/4294967296}}},46096:(t,e,n)=>{"use strict";n.d(e,{N:()=>i});var o=n(13170),s=n(16249),r=n(93214);class i extends s.V{constructor(t,e,n,i,p){void 0===p&&(p=void 0),super(void 0,i,p),this.entries=t,this.signals=[],this.parser=e;for(const a of t){const t=new s.V((0,r.P)(n)?()=>e(n())[a]:e(n)[a],o.UI,p??this.invokable).toSignal();this.signals.push([a,t]),Object.defineProperty(this.invokable,a,{value:t})}}toSignal(){return this.invokable}parse(t){return this.parser(t)}get(){return this.parse(Object.fromEntries(this.signals.map((t=>{let[e,n]=t;return[e,n()]}))))}set(t){if((0,r.P)(t))for(const[e,n]of this.signals)n((()=>this.parser(t())[e]));else{const e=this.parse(t);for(const[t,n]of this.signals)n(e[t])}return this.owner}reset(){for(const[,t]of this.signals)t.reset();return this.owner}save(){for(const[,t]of this.signals)t.save();return this.owner}}},81865:(t,e,n)=>{"use strict";n.d(e,{h:()=>i});var o=n(3163),s=n(90031),r=n(76062);class i extends r.k{constructor(t,e){super(e),this.factory=t,this.markDirty()}toSignal(){return this.invokable}dispose(){super.dispose(),this.last=void 0}invoke(){if(this.event.isRaised()){this.clearDependencies(),this.startCollecting();try{this.last=this.factory(...arguments)}catch(e){var t;(0,o.wL)().error({...(0,s.d)(e),inspect:null==(t=this.owner)?void 0:t.key})}this.finishCollecting()}return this.event.reset(),this.collect(),this.last}}},76062:(t,e,n)=>{"use strict";n.d(e,{k:()=>i});var o=n(11395);class s extends o.p{constructor(){super(...arguments),this.value=!1}raise(){this.value||(this.value=!0,this.notifySubscribers())}reset(){this.value=!1}isRaised(){return this.value}subscribe(t){const e=super.subscribe(t);return this.value&&t(),e}}var r=n(49111);class i{static collectPromise(t,e){void 0===e&&(e=null);const n={promise:t,value:e,stack:(new Error).stack},o=this.collectionStack.at(-1);return o&&(n.owner=o.owner),t.then((t=>{n.value=t,null==o||o.markDirty()})),this.promises.push(n),n}static consumePromises(){const t=this.promises;return this.promises=[],t}constructor(t){this.owner=t,this.dependencies=new Set,this.event=new s,this.markDirty=()=>this.event.raise(),this.invokable=this.invoke.bind(this),Object.defineProperty(this.invokable,"context",{value:this}),Object.defineProperty(this.invokable,"toPromise",{value:this.toPromise.bind(this)})}invoke(){}startCollecting(){if(i.collectionSet.has(this))throw new r.t("A circular dependency occurred between signals.","This can happen when signals reference each other in a loop.\n        Try using the attached stack trace to locate said loop.");i.collectionSet.add(this),i.collectionStack.push(this)}finishCollecting(){if(i.collectionSet.delete(this),i.collectionStack.pop()!==this)throw new Error("collectStart/collectEnd was called out of order.")}clearDependencies(){this.dependencies.forEach((t=>t.unsubscribe(this.markDirty))),this.dependencies.clear()}collect(){const t=i.collectionStack.at(-1);t&&(t.dependencies.add(this.event.subscribable),this.event.subscribe(t.markDirty))}dispose(){this.clearDependencies(),this.event.clear(),this.owner=null}async toPromise(){let t=i.consumePromises();do{await Promise.all(t.map((t=>t.promise))),this.invokable(),t=i.consumePromises()}while(t.length>0);return this.invokable}}i.collectionSet=new Set,i.collectionStack=[],i.promises=[]},16249:(t,e,n)=>{"use strict";n.d(e,{V:()=>u});var o=n(97074),s=n(74534),r=n(3163),i=n(90031),p=n(77396),a=n(76062),c=n(93214),l=n(60771);class u extends a.k{constructor(t,e,n){void 0===n&&(n=void 0),super(n),this.initial=t,this.interpolation=e,this.parser=t=>t,Object.defineProperty(this.invokable,"reset",{value:this.reset.bind(this)}),Object.defineProperty(this.invokable,"save",{value:this.save.bind(this)}),Object.defineProperty(this.invokable,"isInitial",{value:this.isInitial.bind(this)}),void 0!==this.initial&&(this.current=this.initial,this.markDirty(),(0,c.P)(this.initial)||(this.last=this.parse(this.initial)))}toSignal(){return this.invokable}parse(t){return this.parser(t)}wrap(t){return(0,c.P)(t)?()=>this.parse(t()):this.parse(t)}setInitial(t){this.initial=t}setParser(t){this.parser=t,void 0===this.current||(0,c.P)(this.current)||(this.last=this.parse(this.current)),this.markDirty()}set(t){return t===l.T&&(t=this.initial),this.current===t||(this.current=t,this.markDirty(),this.clearDependencies(),(0,c.P)(t)||(this.last=this.parse(t))),this.owner}get(){if(this.event.isRaised()&&(0,c.P)(this.current)){this.clearDependencies(),this.startCollecting();try{this.last=this.parse(this.current())}catch(e){var t;(0,r.wL)().error({...(0,i.d)(e),inspect:null==(t=this.owner)?void 0:t.key})}this.finishCollecting()}return this.event.reset(),this.collect(),this.last}invoke(t,e,n,s){return void 0===n&&(n=o.qb),void 0===s&&(s=this.interpolation),void 0===t?this.get():void 0===e?this.set(t):this.makeAnimate(n,s)(t,e)}makeAnimate(t,e,n){var o=this;return function(s,r,i,a){void 0===i&&(i=t),void 0===a&&(a=e);const c=o.tween(s,r,i,a);let l=c;return n&&(l=(0,p.K)((function*(){yield*n,yield*c}))),l.to=o.makeAnimate(i,a,l),l}}*tween(t,e,n,o){t===l.T&&(t=this.initial),yield*this.doTween(this.parse((0,c.P)(t)?t():t),e,n,o),this.set(t)}*doTween(t,e,n,o){const r=this.get();yield*(0,s.i)(e,(e=>{this.set(o(r,t,n(e)))}))}dispose(){super.dispose(),this.initial=void 0,this.current=void 0,this.last=void 0}reset(){return void 0!==this.initial&&this.set(this.initial),this.owner}save(){return this.set(this.get())}isInitial(){return this.collect(),this.current===this.initial}raw(){return this.current}}},73662:(t,e,n)=>{"use strict";n.d(e,{D:()=>s});var o=n(81865);function s(t,e){return new o.h(t,e).toSignal()}},97140:(t,e,n)=>{"use strict";n.d(e,{g:()=>r});var o=n(13170),s=n(16249);function r(t,e,n){return void 0===e&&(e=o.o0),new s.V(t,e,n).toSignal()}},93214:(t,e,n)=>{"use strict";function o(t){return"function"==typeof t}n.d(e,{P:()=>o})},60771:(t,e,n)=>{"use strict";n.d(e,{T:()=>o});const o=Symbol.for("@motion-canvas/core/signals/default")},50580:(t,e,n)=>{"use strict";n.d(e,{j:()=>i});var o=n(56632),s=n(97140),r=n(75168);class i{get fixed(){return this.fixedTime}get canceled(){var t;return this.isCanceled||((null==(t=this.parent)?void 0:t.canceled)??!1)}constructor(t){this.runner=t,this.children=[],this.time=(0,s.g)(0),this.parent=null,this.isCanceled=!1,this.fixedTime=0}next(){(0,o.h$)(this);const t=this.runner.next(this.value);return(0,o.kw)(this),this.value=null,t}update(t){this.time(this.time()+t),this.fixedTime+=t,this.children=this.children.filter((t=>!t.canceled))}add(t){t.cancel(),t.parent=this,t.isCanceled=!1,t.time(this.time()),t.fixedTime=this.fixedTime,this.children.push(t),(0,r.i)(t.runner,`unknown ${this.children.length}`)}cancel(){this.isCanceled=!0,this.parent=null}}},80638:(t,e,n)=>{"use strict";function o(t){return t&&("object"==typeof t||"function"==typeof t)&&"toPromise"in t}function s(t){return null!==t&&"object"==typeof t&&Symbol.iterator in t&&"next"in t}n.d(e,{R:()=>s,x:()=>o})},51284:(t,e,n)=>{"use strict";n.d(e,{v:()=>i});var o=n(42075),s=n(67292),r=n(56632);function*i(t){let e=!0;for(var n=arguments.length,o=new Array(n>1?n-1:0),s=1;s<n;s++)o[s-1]=arguments[s];"boolean"==typeof t?e=t:o.push(t);const i=(0,r.nn)(),p=o.map((t=>i.children.find((e=>e.runner===t)))).filter((t=>t)),a=i.time();let c;if(e){for(;p.find((t=>!t.canceled));)yield;c=Math.max(...p.map((t=>t.time())))}else{for(;!p.find((t=>t.canceled));)yield;const t=p.filter((t=>t.canceled));c=Math.min(...t.map((t=>t.time())))}i.time(Math.max(a,c))}(0,o.G)(i,(0,s.C)())},75168:(t,e,n)=>{"use strict";function o(t,e){const n=Object.getPrototypeOf(t);n.threadable||(n.threadable=!0,n.name="string"==typeof e?e:s(e))}function s(t){return Object.getPrototypeOf(t).name??null}n.d(e,{i:()=>o,z:()=>s})},5881:(t,e,n)=>{"use strict";n.d(e,{C:()=>l,t:()=>c});var o=n(42075),s=n(67292),r=n(50580),i=n(80638),p=n(75168),a=n(97715);function c(t){return"function"==typeof(null==t?void 0:t.then)}function*l(t,e){const n=(0,a.te)(),o=t();(0,p.i)(o,"root");const s=new r.j(o);null==e||e(s);let c=[s];for(;c.length>0;){const t=[],e=[...c],o=n.framesToSeconds(1)*n.speed;for(;e.length>0;){const n=e.pop();if(!n||n.canceled)continue;const s=n.next();if(s.done)n.cancel();else if((0,i.R)(s.value)){const t=new r.j(s.value);n.value=s.value,n.add(t),e.push(n),e.push(t)}else s.value?(n.value=yield s.value,e.push(n)):(n.update(o),t.unshift(n))}c=t.filter((t=>!t.canceled)),c.length>0&&(yield)}}(0,o.G)(l,(0,s.C)())},13170:(t,e,n)=>{"use strict";n.d(e,{JC:()=>r,UI:()=>p,Vz:()=>u,a2:()=>a,o0:()=>i,uZ:()=>c,vl:()=>l});var o=n(3163),s=n(29797);function r(t,e,n){if(e.length>=t.length){const o=Math.floor(e.length*n),s=Math.floor(p(t.length-1,e.length,n));let r="";for(let n=0;n<e.length;n++)n<o?r+=e[n]:(t[n]||n<=s)&&(r+=t[n]??e[n]);return r}{const o=Math.round(t.length*(1-n)),s=Math.floor(p(t.length+1,e.length,n)),r=[];for(let n=t.length-1;n>=0;n--)n<o?r.unshift(t[n]):(e[n]||n<s)&&r.unshift(e[n]??t[n]);return r.join("")}}function i(t,e,n,s){if(void 0===s&&(s=!1),0===n)return t;if(1===n)return e;if(null!=t&&null!=e){if("number"==typeof t&&"number"==typeof e)return p(t,e,n);if("string"==typeof t&&"string"==typeof e)return r(t,e,n);if("boolean"==typeof t&&"boolean"==typeof e)return n<.5?t:e;if("lerp"in t)return t.lerp(e,n);if(t&&e&&"object"==typeof t&&"object"==typeof e)if(Array.isArray(t)&&Array.isArray(e)){if(t.length===e.length)return t.map(((t,o)=>i(t,e[o],n)))}else{let o=!1;if(t instanceof Map||e instanceof Map||(o=!0,t=new Map(Object.entries(t)),e=new Map(Object.entries(e))),t instanceof Map&&e instanceof Map){const s=new Map;for(const o of new Set([...t.keys(),...e.keys()])){const r=i(t.get(o),e.get(o),n,!0);void 0!==r&&s.set(o,r)}return o?Object.fromEntries(s):s}}return e}s||(0,o.wL)().warn(`Attempting to lerp ${t} -> ${e} may result in unexpected behavior.`)}function p(t,e,n){return t+(e-t)*n}function a(t,e,n,o,s){return n+(s-t)*(o-n)/(e-t)}function c(t,e,n){return n<t?t:n>e?e:n}function l(t,e,n,o,s){const r=a(t,e,n,o,s);return n>o&&([n,o]=[o,n]),c(n,o,r)}function u(t,e,n){let o=e;n>1?n=1/n:o=!o;const r=p(o?Math.acos(c(-1,1,1-t)):Math.asin(t),p(0,Math.PI/2,t),n);let i=Math.sin(r),a=1-Math.cos(r);return e&&([i,a]=[a,i]),new s.F(i,a)}},97074:(t,e,n)=>{"use strict";n.d(e,{BH:()=>F,Bl:()=>b,C6:()=>B,FG:()=>a,Fs:()=>p,GE:()=>A,Ge:()=>v,Ij:()=>E,J7:()=>f,Kx:()=>Z,Mg:()=>X,N1:()=>r,O$:()=>s,Q9:()=>u,SJ:()=>W,UE:()=>I,Y3:()=>y,Yw:()=>P,ad:()=>D,cv:()=>q,du:()=>N,eE:()=>O,e_:()=>M,ei:()=>x,en:()=>G,g4:()=>h,hN:()=>_,hl:()=>c,j$:()=>C,jv:()=>S,lj:()=>T,mC:()=>z,n5:()=>k,pl:()=>w,qS:()=>L,qb:()=>d,rz:()=>g,sK:()=>j,to:()=>l,vh:()=>i,w2:()=>m,zk:()=>R});var o=n(13170);function s(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,o.a2)(-1,1,e,n,Math.sin(t))}function r(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.cos(t*Math.PI/2),(0,o.UI)(e,n,t)}function i(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=Math.sin(t*Math.PI/2),(0,o.UI)(e,n,t)}function p(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=-(Math.cos(Math.PI*t)-1)/2,(0,o.UI)(e,n,t)}function a(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t,(0,o.UI)(e,n,t)}function c(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,2),(0,o.UI)(e,n,t)}function l(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2,(0,o.UI)(e,n,t)}function u(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t*t,(0,o.UI)(e,n,t)}function m(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,3),(0,o.UI)(e,n,t)}function d(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,(0,o.UI)(e,n,t)}function h(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t*t*t,(0,o.UI)(e,n,t)}function y(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,4),(0,o.UI)(e,n,t)}function f(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?8*t*t*t*t:1-Math.pow(-2*t+2,4)/2,(0,o.UI)(e,n,t)}function k(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t*t*t*t,(0,o.UI)(e,n,t)}function w(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,5),(0,o.UI)(e,n,t)}function g(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?16*t*t*t*t*t:1-Math.pow(-2*t+2,5)/2,(0,o.UI)(e,n,t)}function M(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=0===t?0:Math.pow(2,10*t-10),(0,o.UI)(e,n,t)}function D(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1===t?1:1-Math.pow(2,-10*t),(0,o.UI)(e,n,t)}function _(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=0===t?0:1===t?1:t<.5?Math.pow(2,20*t-10)/2:(2-Math.pow(2,-20*t+10))/2,(0,o.UI)(e,n,t)}function X(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.sqrt(1-Math.pow(t,2)),(0,o.UI)(e,n,t)}function x(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=Math.sqrt(1-Math.pow(t-1,2)),(0,o.UI)(e,n,t)}function v(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?(1-Math.sqrt(1-Math.pow(2*t,2)))/2:(Math.sqrt(1-Math.pow(-2*t+2,2))+1)/2,(0,o.UI)(e,n,t)}function C(t){return void 0===t&&(t=1.70158),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=(t+1)*e*e*e-t*e*e,(0,o.UI)(n,s,e)}}function T(t){return void 0===t&&(t=1.70158),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=1+(t+1)*Math.pow(e-1,3)+t*Math.pow(e-1,2),(0,o.UI)(n,s,e)}}function b(t,e){return void 0===t&&(t=1.70158),void 0===e&&(e=1.525),function(n,s,r){return void 0===s&&(s=0),void 0===r&&(r=1),n=n<.5?Math.pow(2*n,2)*(2*(t*e+1)*n-t*e)/2:(Math.pow(2*n-2,2)*((t*e+1)*(2*n-2)+t*e)+2)/2,(0,o.UI)(s,r,n)}}function L(t){return void 0===t&&(t=2.094395),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=0===e?0:1===e?1:-Math.pow(2,10*e-10)*Math.sin((10*e-10.75)*t),(0,o.UI)(n,s,e)}}function Z(t){return void 0===t&&(t=2.094395),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=0===e?0:1===e?1:Math.pow(2,-10*e)*Math.sin((10*e-.75)*t)+1,(0,o.UI)(n,s,e)}}function N(t){return void 0===t&&(t=1.39626),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=0===e?0:1===e?1:e<.5?-Math.pow(2,20*e-10)*Math.sin((20*e-11.125)*t)/2:Math.pow(2,-20*e+10)*Math.sin((20*e-11.125)*t)/2+1,(0,o.UI)(n,s,e)}}function S(t,e){void 0===t&&(t=7.5625),void 0===e&&(e=2.75);const n=R(t,e);return function(t,e,o){return void 0===e&&(e=0),void 0===o&&(o=1),1-n(1-t,e,o)}}function R(t,e){return void 0===t&&(t=7.5625),void 0===e&&(e=2.75),function(n,s,r){return void 0===s&&(s=0),void 0===r&&(r=1),n<1/e?n*=t*n:n=n<2/e?t*(n-=1.505/e)*n+.75:n<2.5/e?t*(n-=2.25/e)*n+.9375:t*(n-=2.625/e)*n+.984375,(0,o.UI)(s,r,n)}}function E(t,e){void 0===t&&(t=7.5625),void 0===e&&(e=2.75);const n=R(t,e);return function(t,e,o){return void 0===e&&(e=0),void 0===o&&(o=1),t<.5?(1-n(1-2*t,e,o))/2:(1+n(2*t-1,e,o))/2}}function A(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,o.UI)(e,n,t)}function z(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,o.a2)(-1,1,e,n,Math.cos(t))}const P=C(),I=T(),F=b(),W=S(),B=R(),G=E(),O=L(),j=Z(),q=N()},74534:(t,e,n)=>{"use strict";n.d(e,{i:()=>i});var o=n(42075),s=n(67292),r=n(56632);function*i(t,e,n){const o=(0,r.nn)(),s=o.time(),i=o.time()+t;for(e(0,0);i>o.fixed;){const n=o.fixed-s;n>0&&e(n/t,n),yield}o.time(i),e(1,t),null==n||n(1,t)}(0,o.G)(i,(0,s.C)())},23357:(t,e,n)=>{"use strict";n.d(e,{b:()=>i});var o=n(29797),s=n(13170),r=n(46096);class i{static createSignal(t,e){return void 0===e&&(e=i.lerp),new r.N(["x","y","width","height"],(t=>new i(t)),t,e).toSignal()}static lerp(t,e,n){let r,p,a,c;return"number"==typeof n?r=p=a=c=n:n instanceof o.F?(r=a=n.x,p=c=n.y):(r=n.x,p=n.y,a=n.width,c=n.height),new i((0,s.UI)(t.x,e.x,r),(0,s.UI)(t.y,e.y,p),(0,s.UI)(t.width,e.width,a),(0,s.UI)(t.height,e.height,c))}static arcLerp(t,e,n,o,r){return void 0===o&&(o=!1),r??(r=(t.position.sub(e.position).ctg+t.size.sub(e.size).ctg)/2),i.lerp(t,e,(0,s.Vz)(n,o,r))}static fromSizeCentered(t){return new i(-t.width/2,-t.height/2,t.width,t.height)}static fromPoints(){let t=1/0,e=1/0,n=-1/0,o=-1/0;for(var s=arguments.length,r=new Array(s),p=0;p<s;p++)r[p]=arguments[p];for(const i of r)i.x>n&&(n=i.x),i.x<t&&(t=i.x),i.y>o&&(o=i.y),i.y<e&&(e=i.y);return new i(t,e,n-t,o-e)}static fromBBoxes(){let t=1/0,e=1/0,n=-1/0,o=-1/0;for(var s=arguments.length,r=new Array(s),p=0;p<s;p++)r[p]=arguments[p];for(const i of r){const s=i.x+i.width;s>n&&(n=s),i.x<t&&(t=i.x);const r=i.y+i.height;r>o&&(o=r),i.y<e&&(e=i.y)}return new i(t,e,n-t,o-e)}lerp(t,e){return i.lerp(this,t,e)}get position(){return new o.F(this.x,this.y)}set position(t){this.x=t.x,this.y=t.y}get size(){return new o.F(this.width,this.height)}get center(){return new o.F(this.x+this.width/2,this.y+this.height/2)}get left(){return this.x}set left(t){this.width+=this.x-t,this.x=t}get right(){return this.x+this.width}set right(t){this.width=t-this.x}get top(){return this.y}set top(t){this.height+=this.y-t,this.y=t}get bottom(){return this.y+this.height}set bottom(t){this.height=t-this.y}get topLeft(){return this.position}get topRight(){return new o.F(this.x+this.width,this.y)}get bottomLeft(){return new o.F(this.x,this.y+this.height)}get bottomRight(){return new o.F(this.x+this.width,this.y+this.height)}get corners(){return[this.topLeft,this.topRight,this.bottomRight,this.bottomLeft]}get pixelPerfect(){return new i(Math.floor(this.x),Math.floor(this.y),Math.ceil(this.width+1),Math.ceil(this.height+1))}constructor(t,e,n,s){if(void 0===e&&(e=0),void 0===n&&(n=0),void 0===s&&(s=0),this.x=0,this.y=0,this.width=0,this.height=0,null!=t){if("number"==typeof t)return this.x=t,this.y=e,this.width=n,void(this.height=s);if(t instanceof o.F)return this.x=t.x,this.y=t.y,void(e instanceof o.F&&(this.width=e.x,this.height=e.y));if(Array.isArray(t))return this.x=t[0],this.y=t[1],this.width=t[2],void(this.height=t[3]);this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height}}transform(t){return new i(this.position.transformAsPoint(t),this.size.transform(t))}transformCorners(t){return this.corners.map((e=>e.transformAsPoint(t)))}expand(t){return new i(this.x-t,this.y-t,this.width+2*t,this.height+2*t)}addSpacing(t){const e=new i(this);return e.left-=t.left,e.top-=t.top,e.right+=t.right,e.bottom+=t.bottom,e}includes(t){return t.x>=this.x&&t.x<=this.x+this.width&&t.y>=this.y&&t.y<=this.y+this.height}intersects(t){return this.left<t.right&&this.right>t.left&&this.top<t.bottom&&this.bottom>t.top}intersection(t){const e=new i;return this.intersects(t)&&(e.left=Math.max(this.left,t.left),e.top=Math.max(this.top,t.top),e.right=Math.min(this.right,t.right),e.bottom=Math.min(this.bottom,t.bottom)),e}toSymbol(){return i.symbol}serialize(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}i.symbol=Symbol.for("@motion-canvas/core/types/Rect")},30204:(t,e,n)=>{"use strict";n.d(e,{I:()=>o.Color});var o=n(5392),s=n(16249);o.Color.symbol=o.Color.prototype.symbol=Symbol.for("@motion-canvas/core/types/Color"),o.Color.lerp=o.Color.prototype.lerp=function(t,e,n,s){void 0===s&&(s="lch"),"string"==typeof t&&(t=new o.Color(t)),"string"==typeof e&&(e=new o.Color(e));const r=t instanceof o.Color,i=e instanceof o.Color;return r||(t=i?e.alpha(0):new o.Color("rgba(0, 0, 0, 0)")),i||(e=r?t.alpha(0):new o.Color("rgba(0, 0, 0, 0)")),(0,o.mix)(t,e,n,s)},o.Color.createLerp=o.Color.prototype.createLerp=t=>(e,n,s)=>o.Color.lerp(e,n,s,t),o.Color.createSignal=function(t,e){void 0===e&&(e=o.Color.lerp);const n=new s.V(t,e);return n.setParser((t=>new o.Color(t))),n.toSignal()},o.Color.prototype.toSymbol=()=>o.Color.symbol,o.Color.prototype.serialize=function(){return this.css()},o.Color.prototype.lerp=function(t,e,n){return o.Color.lerp(this,t,e,n)}},74741:(t,e,n)=>{"use strict";n.d(e,{$:()=>s,X:()=>r});var o=n(29797);function s(t,e){const n=t/180*Math.PI;return 180*o.F.fromRadians(n).transform(e).radians/Math.PI}function r(t,e){return Math.sqrt(e.m11*e.m11+e.m12*e.m12)*t}},98378:(t,e,n)=>{"use strict";n.d(e,{M5:()=>o,Nm:()=>s,WS:()=>a,aP:()=>r,lk:()=>p});var o,s,r,i=n(29797);function p(t,e){return void 0===e&&(e=o.Horizontal|o.Vertical),e&o.Vertical&&(t&s.Top?t=t&~s.Top|s.Bottom:t&s.Bottom&&(t=t&~s.Bottom|s.Top)),e&o.Horizontal&&(t&s.Left?t=t&~s.Left|s.Right:t&s.Right&&(t=t&~s.Right|s.Left)),t}function a(t){if(t===r.Middle)return i.F.zero;let e=0;t&s.Left?e=-1:t&s.Right&&(e=1);let n=0;return t&s.Top?n=-1:t&s.Bottom&&(n=1),new i.F(e,n)}!function(t){t[t.Vertical=1]="Vertical",t[t.Horizontal=2]="Horizontal"}(o||(o={})),function(t){t[t.Top=4]="Top",t[t.Bottom=8]="Bottom",t[t.Left=16]="Left",t[t.Right=32]="Right"}(s||(s={})),function(t){t[t.Middle=3]="Middle",t[t.Top=5]="Top",t[t.Bottom=9]="Bottom",t[t.Left=18]="Left",t[t.Right=34]="Right",t[t.TopLeft=20]="TopLeft",t[t.TopRight=36]="TopRight",t[t.BottomLeft=24]="BottomLeft",t[t.BottomRight=40]="BottomRight"}(r||(r={}))},43188:(t,e,n)=>{"use strict";n.d(e,{K:()=>r});var o=n(13170),s=n(46096);class r{static createSignal(t,e){return void 0===e&&(e=r.lerp),new s.N(["top","right","bottom","left"],(t=>new r(t)),t,e).toSignal()}static lerp(t,e,n){return new r((0,o.UI)(t.top,e.top,n),(0,o.UI)(t.right,e.right,n),(0,o.UI)(t.bottom,e.bottom,n),(0,o.UI)(t.left,e.left,n))}get x(){return this.left+this.right}get y(){return this.top+this.bottom}constructor(t,e,n,o){if(void 0===t&&(t=0),this.top=0,this.right=0,this.bottom=0,this.left=0,null!=t){if(Array.isArray(t)&&(o=t[3],n=t[2],e=t[1],t=t[0]),"number"==typeof t)return this.top=t,this.right=void 0!==e?e:t,this.bottom=void 0!==n?n:t,void(this.left=void 0!==o?o:void 0!==e?e:t);this.top=t.top,this.right=t.right,this.bottom=t.bottom,this.left=t.left}}lerp(t,e){return r.lerp(this,t,e)}scale(t){return new r(this.top*t,this.right*t,this.bottom*t,this.left*t)}addScalar(t){return new r(this.top+t,this.right+t,this.bottom+t,this.left+t)}toSymbol(){return r.symbol}serialize(){return{top:this.top,right:this.right,bottom:this.bottom,left:this.left}}}r.symbol=Symbol.for("@motion-canvas/core/types/Spacing")},57292:(t,e,n)=>{"use strict";n.d(e,{I:()=>o,P:()=>s});const o=1e-6;function s(t){return t&&"object"==typeof t&&"toSymbol"in t}},29797:(t,e,n)=>{"use strict";n.d(e,{F:()=>p});var o=n(13170),s=n(98378),r=n(57292),i=n(46096);class p{static createSignal(t,e,n){return void 0===e&&(e=p.lerp),new i.N(["x","y"],(t=>new p(t)),t,e,n).toSignal()}static lerp(t,e,n){let s,r;return"number"==typeof n?s=r=n:(s=n.x,r=n.y),new p((0,o.UI)(t.x,e.x,s),(0,o.UI)(t.y,e.y,r))}static arcLerp(t,e,n,s,r){return void 0===s&&(s=!1),r??(r=t.sub(e).ctg),p.lerp(t,e,(0,o.Vz)(n,s,r))}static fromOrigin(t){const e=new p;return t===s.aP.Middle||(t&s.Nm.Left?e.x=-1:t&s.Nm.Right&&(e.x=1),t&s.Nm.Top?e.y=-1:t&s.Nm.Bottom&&(e.y=1)),e}static fromScalar(t){return new p(t,t)}static fromRadians(t){return new p(Math.cos(t),Math.sin(t))}static radians(t,e){return Math.atan2(e,t)}static degrees(t,e){return 180*p.radians(t,e)/Math.PI}static magnitude(t,e){return Math.sqrt(t*t+e*e)}static squaredMagnitude(t,e){return t*t+e*e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}get magnitude(){return p.magnitude(this.x,this.y)}get squaredMagnitude(){return p.squaredMagnitude(this.x,this.y)}get normalized(){return this.scale(1/p.magnitude(this.x,this.y))}get safe(){return new p(isNaN(this.x)?0:this.x,isNaN(this.y)?0:this.y)}get flipped(){return new p(-this.x,-this.y)}get floored(){return new p(Math.floor(this.x),Math.floor(this.y))}get perpendicular(){return new p(this.y,-this.x)}get radians(){return p.radians(this.x,this.y)}get degrees(){return p.degrees(this.x,this.y)}get ctg(){return this.x/this.y}constructor(t,e){if(this.x=0,this.y=0,null!=t){if("object"!=typeof t)return this.x=t,void(this.y=e??t);if(Array.isArray(t))return this.x=t[0],void(this.y=t[1]);if("width"in t)return this.x=t.width,void(this.y=t.height);this.x=t.x,this.y=t.y}}lerp(t,e){return p.lerp(this,t,e)}getOriginOffset(t){const e=p.fromOrigin(t);return e.x*=this.x/2,e.y*=this.y/2,e}scale(t){return new p(this.x*t,this.y*t)}transformAsPoint(t){return new p(this.x*t.m11+this.y*t.m21+t.m41,this.x*t.m12+this.y*t.m22+t.m42)}transform(t){return new p(this.x*t.m11+this.y*t.m21,this.x*t.m12+this.y*t.m22)}mul(t){const e=new p(t);return new p(this.x*e.x,this.y*e.y)}div(t){const e=new p(t);return new p(this.x/e.x,this.y/e.y)}add(t){const e=new p(t);return new p(this.x+e.x,this.y+e.y)}sub(t){const e=new p(t);return new p(this.x-e.x,this.y-e.y)}dot(t){const e=new p(t);return this.x*e.x+this.y*e.y}addX(t){return new p(this.x+t,this.y)}addY(t){return new p(this.x,this.y+t)}toSymbol(){return p.symbol}serialize(){return{x:this.x,y:this.y}}exactlyEquals(t){return this.x===t.x&&this.y===t.y}equals(t,e){return void 0===e&&(e=r.I),Math.abs(this.x-t.x)<=e+Number.EPSILON&&Math.abs(this.y-t.y)<=e+Number.EPSILON}}p.symbol=Symbol.for("@motion-canvas/core/types/Vector2"),p.zero=new p,p.one=new p(1,1),p.right=new p(1,0),p.left=new p(-1,0),p.up=new p(0,1),p.down=new p(0,-1)},49111:(t,e,n)=>{"use strict";n.d(e,{t:()=>o});class o extends Error{constructor(t,e){super(t),this.remarks=e}}},15649:(t,e,n)=>{"use strict";n.d(e,{L:()=>o});class o{constructor(){this.resolveCurrent=null,this.current=null}async acquire(){for(;this.current;)await this.current;this.current=new Promise((t=>{this.resolveCurrent=t}))}release(){var t;this.current=null,null==(t=this.resolveCurrent)||t.call(this),this.resolveCurrent=null}}},15688:(t,e,n)=>{"use strict";function o(t){return t[0].toUpperCase()+t.slice(1)}n.d(e,{k:()=>o})},90031:(t,e,n)=>{"use strict";function o(t){return{message:t.message,stack:t.stack,remarks:t.remarks}}n.d(e,{d:()=>o})},1119:(t,e,n)=>{"use strict";function o(t,e){void 0===e&&(e=document.createElement("canvas"));const n=e.getContext("2d",t);if(!n)throw new Error("Could not create a 2D context.");return n}n.d(e,{f:()=>o})},37762:(t,e,n)=>{"use strict";function o(t,e,n){let o=0,s=t;void 0!==e&&(o=t,s=e),n=void 0===n?o<s?1:-1:n;const r=[];let i=Math.max(Math.ceil((s-o)/n),0),p=0;for(;i--;)r[p++]=o,o+=n;return r}n.d(e,{w:()=>o})},97715:(t,e,n)=>{"use strict";n.d(e,{Mh:()=>i,te:()=>s,wA:()=>r});const o=[];function s(){const t=o.at(-1);if(!t)throw new Error("The playback is not available in the current context.");return t}function r(t){o.push(t)}function i(t){if(o.pop()!==t)throw new Error("startPlayback/endPlayback were called out of order.")}},3163:(t,e,n)=>{"use strict";n.d(e,{$r:()=>s,DO:()=>r,ug:()=>i,vl:()=>a,wL:()=>p});const o=[];function s(){const t=o.at(-1);if(!t)throw new Error("The scene is not available in the current context.");return t}function r(t){o.push(t)}function i(t){if(o.pop()!==t)throw new Error("startScene/endScene were called out of order.")}function p(){var t;return(null==(t=o.at(-1))?void 0:t.logger)??console}function a(){s().enterCanTransitionOut()}},56632:(t,e,n)=>{"use strict";n.d(e,{h$:()=>i,kw:()=>p,nn:()=>r});var o=n(49111);const s=[];function r(){const t=s.at(-1);if(!t)throw new o.t("The thread is not available in the current context.","<p><code>useThread()</code> can only be called from within generator functions.\n      It&#39;s not available during rendering.</p>\n");return t}function i(t){s.push(t)}function p(t){if(s.pop()!==t)throw new Error("startThread/endThread was called out of order.")}},64415:(t,e,n)=>{"use strict";n.r(e),n.d(e,{default:()=>h});var o=n(2784),s=n(42104),r=n(49072),i=n(76183),p=n(31930),a=n(88617),c=n(80068),l=n(57708),u=n(70532),m=n(37390),d=n(89741);function h(t){var e,n,h;let{route:y}=t;const f=(0,a.RU)(y.projectId),k=f[y.reflectionId],[w]=(0,l.mN)(),g=(0,d.Z)(),M=(0,o.useMemo)((()=>{const t=[];if(!k.groups||k.kind===m.W.Project)return t;for(const e of k.groups)if(t.push({value:e.title,id:e.title,level:2}),e.children)for(const n of e.children){const e=f[n];!e||e.hasOwnPage||g&&!(0,l.It)(w,e)||t.push({value:`<code>${e.name}</code>`,id:e.anchor,level:3})}return t}),[w,k,g]);return o.createElement(i.b,{content:{frontMatter:{},metadata:{id:k.docId,unversionedId:k.docId,version:"current",title:k.name,description:null==(e=k.comment)?void 0:e.summaryText,slug:k.url,permalink:k.url,editUrl:(null==(n=k.sources)||null==(h=n[0])?void 0:h.url)??void 0,draft:!1,tags:[],frontMatter:{},next:k.next,previous:k.previous},toc:M,assets:{}}},o.createElement(c.Y0,null,o.createElement(s.Z,null),o.createElement(u.Z,null,o.createElement(r.Z,null,o.createElement(p.Z,{reflection:k})))))}},93342:(t,e,n)=>{"use strict";n.d(e,{Z:()=>QRt});var o={};n.r(o),n.d(o,{content_0_0:()=>a,content_0_10:()=>w,content_0_100:()=>te,content_0_1000:()=>Fk,content_0_1002:()=>Bk,content_0_1004:()=>Ok,content_0_1006:()=>qk,content_0_1008:()=>Vk,content_0_1010:()=>$k,content_0_1012:()=>Yk,content_0_1014:()=>Qk,content_0_1016:()=>ew,content_0_1018:()=>ow,content_0_102:()=>ne,content_0_1020:()=>rw,content_0_1022:()=>pw,content_0_1024:()=>cw,content_0_1026:()=>uw,content_0_1028:()=>dw,content_0_1030:()=>yw,content_0_1032:()=>kw,content_0_1034:()=>gw,content_0_1036:()=>Dw,content_0_1038:()=>Xw,content_0_104:()=>se,content_0_1040:()=>vw,content_0_1042:()=>Tw,content_0_1044:()=>Lw,content_0_1046:()=>Nw,content_0_1048:()=>Rw,content_0_1050:()=>Aw,content_0_1052:()=>Pw,content_0_1054:()=>Fw,content_0_1056:()=>Bw,content_0_1058:()=>Ow,content_0_106:()=>ie,content_0_1060:()=>qw,content_0_1062:()=>Vw,content_0_1064:()=>$w,content_0_108:()=>ae,content_0_110:()=>le,content_0_112:()=>me,content_0_114:()=>he,content_0_116:()=>fe,content_0_118:()=>we,content_0_12:()=>M,content_0_120:()=>Me,content_0_122:()=>_e,content_0_124:()=>xe,content_0_126:()=>Ce,content_0_128:()=>be,content_0_130:()=>Ze,content_0_132:()=>Se,content_0_134:()=>Ee,content_0_136:()=>ze,content_0_138:()=>Ie,content_0_14:()=>_,content_0_140:()=>We,content_0_142:()=>Ge,content_0_144:()=>je,content_0_146:()=>Ue,content_0_148:()=>He,content_0_150:()=>Je,content_0_152:()=>Ke,content_0_154:()=>tn,content_0_156:()=>nn,content_0_158:()=>sn,content_0_16:()=>x,content_0_160:()=>pn,content_0_162:()=>cn,content_0_164:()=>un,content_0_166:()=>dn,content_0_168:()=>yn,content_0_170:()=>kn,content_0_172:()=>gn,content_0_174:()=>Dn,content_0_176:()=>Xn,content_0_178:()=>vn,content_0_18:()=>C,content_0_180:()=>Tn,content_0_182:()=>Ln,content_0_184:()=>Nn,content_0_186:()=>Rn,content_0_188:()=>An,content_0_190:()=>Pn,content_0_192:()=>Fn,content_0_194:()=>Bn,content_0_196:()=>On,content_0_198:()=>qn,content_0_2:()=>l,content_0_20:()=>b,content_0_200:()=>Vn,content_0_202:()=>$n,content_0_204:()=>Yn,content_0_206:()=>Qn,content_0_208:()=>eo,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>po,content_0_216:()=>co,content_0_218:()=>uo,content_0_22:()=>Z,content_0_220:()=>ho,content_0_222:()=>fo,content_0_224:()=>wo,content_0_226:()=>Mo,content_0_228:()=>_o,content_0_230:()=>xo,content_0_232:()=>Co,content_0_234:()=>bo,content_0_236:()=>Zo,content_0_238:()=>So,content_0_24:()=>S,content_0_240:()=>Eo,content_0_242:()=>zo,content_0_244:()=>Io,content_0_246:()=>Wo,content_0_248:()=>Go,content_0_250:()=>jo,content_0_252:()=>Uo,content_0_254:()=>Ho,content_0_256:()=>Jo,content_0_258:()=>Ko,content_0_26:()=>E,content_0_260:()=>ts,content_0_262:()=>ns,content_0_264:()=>ss,content_0_266:()=>is,content_0_268:()=>as,content_0_270:()=>ls,content_0_272:()=>ms,content_0_274:()=>hs,content_0_276:()=>fs,content_0_278:()=>ws,content_0_28:()=>z,content_0_280:()=>Ms,content_0_282:()=>_s,content_0_284:()=>xs,content_0_286:()=>Cs,content_0_288:()=>bs,content_0_290:()=>Zs,content_0_292:()=>Ss,content_0_294:()=>Es,content_0_296:()=>zs,content_0_298:()=>Is,content_0_30:()=>I,content_0_300:()=>Ws,content_0_302:()=>Gs,content_0_304:()=>js,content_0_306:()=>Us,content_0_308:()=>Hs,content_0_310:()=>Js,content_0_312:()=>Ks,content_0_314:()=>tr,content_0_316:()=>nr,content_0_318:()=>sr,content_0_32:()=>W,content_0_320:()=>ir,content_0_322:()=>ar,content_0_324:()=>lr,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>fr,content_0_332:()=>wr,content_0_334:()=>Mr,content_0_336:()=>_r,content_0_338:()=>xr,content_0_34:()=>G,content_0_340:()=>Cr,content_0_342:()=>br,content_0_344:()=>Zr,content_0_346:()=>Sr,content_0_348:()=>Er,content_0_350:()=>zr,content_0_352:()=>Ir,content_0_354:()=>Wr,content_0_356:()=>Gr,content_0_358:()=>jr,content_0_36:()=>j,content_0_360:()=>Ur,content_0_362:()=>Hr,content_0_364:()=>Jr,content_0_366:()=>Kr,content_0_368:()=>ti,content_0_370:()=>ni,content_0_372:()=>si,content_0_374:()=>ii,content_0_376:()=>ai,content_0_378:()=>li,content_0_38:()=>U,content_0_380:()=>mi,content_0_382:()=>hi,content_0_384:()=>fi,content_0_386:()=>wi,content_0_388:()=>Mi,content_0_390:()=>_i,content_0_392:()=>xi,content_0_394:()=>Ci,content_0_396:()=>bi,content_0_398:()=>Zi,content_0_4:()=>m,content_0_40:()=>H,content_0_400:()=>Si,content_0_402:()=>Ei,content_0_404:()=>zi,content_0_406:()=>Ii,content_0_408:()=>Wi,content_0_410:()=>Gi,content_0_412:()=>ji,content_0_414:()=>Ui,content_0_416:()=>Hi,content_0_418:()=>Ji,content_0_42:()=>J,content_0_420:()=>Ki,content_0_422:()=>tp,content_0_424:()=>np,content_0_426:()=>sp,content_0_428:()=>ip,content_0_430:()=>ap,content_0_432:()=>lp,content_0_434:()=>mp,content_0_436:()=>hp,content_0_438:()=>fp,content_0_44:()=>K,content_0_440:()=>wp,content_0_442:()=>Mp,content_0_444:()=>_p,content_0_446:()=>xp,content_0_448:()=>Cp,content_0_450:()=>bp,content_0_452:()=>Zp,content_0_454:()=>Sp,content_0_456:()=>Ep,content_0_458:()=>zp,content_0_46:()=>tt,content_0_460:()=>Ip,content_0_462:()=>Wp,content_0_464:()=>Gp,content_0_466:()=>jp,content_0_468:()=>Up,content_0_470:()=>Hp,content_0_472:()=>Jp,content_0_474:()=>Kp,content_0_476:()=>ta,content_0_478:()=>na,content_0_48:()=>nt,content_0_480:()=>sa,content_0_482:()=>ia,content_0_484:()=>aa,content_0_486:()=>la,content_0_488:()=>ma,content_0_490:()=>ha,content_0_492:()=>fa,content_0_494:()=>wa,content_0_496:()=>Ma,content_0_498:()=>_a,content_0_50:()=>st,content_0_500:()=>xa,content_0_502:()=>Ca,content_0_504:()=>ba,content_0_506:()=>Za,content_0_508:()=>Sa,content_0_510:()=>Ea,content_0_512:()=>za,content_0_514:()=>Ia,content_0_516:()=>Wa,content_0_518:()=>Ga,content_0_52:()=>it,content_0_520:()=>ja,content_0_522:()=>Ua,content_0_524:()=>Ha,content_0_526:()=>Ja,content_0_528:()=>Ka,content_0_530:()=>tc,content_0_532:()=>nc,content_0_534:()=>sc,content_0_536:()=>ic,content_0_538:()=>ac,content_0_54:()=>at,content_0_540:()=>lc,content_0_542:()=>mc,content_0_544:()=>hc,content_0_546:()=>fc,content_0_548:()=>wc,content_0_550:()=>Mc,content_0_552:()=>_c,content_0_554:()=>xc,content_0_556:()=>Cc,content_0_558:()=>bc,content_0_56:()=>lt,content_0_560:()=>Zc,content_0_562:()=>Sc,content_0_564:()=>Ec,content_0_566:()=>zc,content_0_568:()=>Ic,content_0_570:()=>Wc,content_0_572:()=>Gc,content_0_574:()=>jc,content_0_576:()=>Uc,content_0_578:()=>Hc,content_0_58:()=>mt,content_0_580:()=>Jc,content_0_582:()=>Kc,content_0_584:()=>tl,content_0_586:()=>nl,content_0_588:()=>sl,content_0_590:()=>il,content_0_592:()=>al,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>fl,content_0_602:()=>wl,content_0_604:()=>Ml,content_0_606:()=>_l,content_0_608:()=>xl,content_0_610:()=>Cl,content_0_612:()=>bl,content_0_614:()=>Zl,content_0_616:()=>Sl,content_0_618:()=>El,content_0_62:()=>ft,content_0_620:()=>zl,content_0_622:()=>Il,content_0_624:()=>Wl,content_0_626:()=>Gl,content_0_628:()=>jl,content_0_630:()=>Ul,content_0_632:()=>Hl,content_0_634:()=>Jl,content_0_636:()=>Kl,content_0_638:()=>tu,content_0_64:()=>wt,content_0_640:()=>nu,content_0_642:()=>su,content_0_644:()=>iu,content_0_646:()=>au,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>fu,content_0_656:()=>wu,content_0_658:()=>Mu,content_0_66:()=>Mt,content_0_660:()=>_u,content_0_662:()=>xu,content_0_664:()=>Cu,content_0_666:()=>bu,content_0_668:()=>Zu,content_0_670:()=>Su,content_0_672:()=>Eu,content_0_674:()=>zu,content_0_676:()=>Iu,content_0_678:()=>Wu,content_0_68:()=>_t,content_0_680:()=>Gu,content_0_682:()=>ju,content_0_684:()=>Uu,content_0_686:()=>Hu,content_0_688:()=>Ju,content_0_690:()=>Ku,content_0_692:()=>tm,content_0_694:()=>nm,content_0_696:()=>sm,content_0_698:()=>im,content_0_70:()=>xt,content_0_700:()=>am,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>fm,content_0_710:()=>wm,content_0_712:()=>Mm,content_0_714:()=>_m,content_0_716:()=>xm,content_0_718:()=>Cm,content_0_72:()=>Ct,content_0_720:()=>bm,content_0_722:()=>Zm,content_0_724:()=>Sm,content_0_726:()=>Em,content_0_728:()=>zm,content_0_730:()=>Im,content_0_732:()=>Wm,content_0_734:()=>Gm,content_0_736:()=>jm,content_0_738:()=>Um,content_0_74:()=>bt,content_0_740:()=>Hm,content_0_742:()=>Jm,content_0_744:()=>Km,content_0_746:()=>td,content_0_748:()=>nd,content_0_750:()=>sd,content_0_752:()=>id,content_0_754:()=>ad,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>Zt,content_0_760:()=>hd,content_0_762:()=>fd,content_0_764:()=>wd,content_0_766:()=>Md,content_0_768:()=>_d,content_0_770:()=>xd,content_0_772:()=>Cd,content_0_774:()=>bd,content_0_776:()=>Zd,content_0_778:()=>Sd,content_0_78:()=>St,content_0_780:()=>Ed,content_0_782:()=>zd,content_0_784:()=>Id,content_0_786:()=>Wd,content_0_788:()=>Gd,content_0_790:()=>jd,content_0_792:()=>Ud,content_0_794:()=>Hd,content_0_796:()=>Jd,content_0_798:()=>Kd,content_0_8:()=>f,content_0_80:()=>Et,content_0_800:()=>th,content_0_802:()=>nh,content_0_804:()=>sh,content_0_806:()=>ih,content_0_808:()=>ah,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>fh,content_0_818:()=>wh,content_0_82:()=>zt,content_0_820:()=>Mh,content_0_822:()=>_h,content_0_824:()=>xh,content_0_826:()=>Ch,content_0_828:()=>bh,content_0_830:()=>Zh,content_0_832:()=>Sh,content_0_834:()=>Eh,content_0_836:()=>zh,content_0_838:()=>Ih,content_0_84:()=>It,content_0_840:()=>Wh,content_0_842:()=>Gh,content_0_844:()=>jh,content_0_846:()=>Uh,content_0_848:()=>Hh,content_0_850:()=>Jh,content_0_852:()=>Kh,content_0_854:()=>ty,content_0_856:()=>ny,content_0_858:()=>sy,content_0_86:()=>Wt,content_0_860:()=>iy,content_0_862:()=>ay,content_0_864:()=>ly,content_0_866:()=>my,content_0_868:()=>hy,content_0_870:()=>fy,content_0_872:()=>wy,content_0_874:()=>My,content_0_876:()=>_y,content_0_878:()=>xy,content_0_88:()=>Gt,content_0_880:()=>Cy,content_0_882:()=>by,content_0_884:()=>Zy,content_0_886:()=>Sy,content_0_888:()=>Ey,content_0_890:()=>zy,content_0_892:()=>Iy,content_0_894:()=>Wy,content_0_896:()=>Gy,content_0_898:()=>jy,content_0_90:()=>jt,content_0_900:()=>Uy,content_0_902:()=>Hy,content_0_904:()=>Jy,content_0_906:()=>Ky,content_0_908:()=>tf,content_0_910:()=>nf,content_0_912:()=>sf,content_0_914:()=>pf,content_0_916:()=>cf,content_0_918:()=>uf,content_0_92:()=>Ut,content_0_920:()=>df,content_0_922:()=>yf,content_0_924:()=>kf,content_0_926:()=>gf,content_0_928:()=>Df,content_0_930:()=>Xf,content_0_932:()=>vf,content_0_934:()=>Tf,content_0_936:()=>Lf,content_0_938:()=>Nf,content_0_94:()=>Ht,content_0_940:()=>Rf,content_0_942:()=>Af,content_0_944:()=>Pf,content_0_946:()=>Ff,content_0_948:()=>Bf,content_0_950:()=>Of,content_0_952:()=>qf,content_0_954:()=>Vf,content_0_956:()=>$f,content_0_958:()=>Yf,content_0_96:()=>Jt,content_0_960:()=>Qf,content_0_962:()=>ek,content_0_964:()=>ok,content_0_966:()=>rk,content_0_968:()=>pk,content_0_970:()=>ck,content_0_972:()=>uk,content_0_974:()=>dk,content_0_976:()=>yk,content_0_978:()=>kk,content_0_98:()=>Kt,content_0_980:()=>gk,content_0_982:()=>Dk,content_0_984:()=>Xk,content_0_986:()=>vk,content_0_988:()=>Tk,content_0_990:()=>Lk,content_0_992:()=>Nk,content_0_994:()=>Rk,content_0_996:()=>Ak,content_0_998:()=>Pk,content_2251_0:()=>Yw,content_2251_10:()=>pg,content_2251_100:()=>OM,content_2251_1000:()=>vP,content_2251_1002:()=>TP,content_2251_1004:()=>LP,content_2251_1006:()=>NP,content_2251_1008:()=>RP,content_2251_1010:()=>AP,content_2251_1012:()=>PP,content_2251_1014:()=>FP,content_2251_1016:()=>BP,content_2251_1018:()=>OP,content_2251_102:()=>qM,content_2251_1020:()=>qP,content_2251_1022:()=>VP,content_2251_1024:()=>$P,content_2251_1026:()=>YP,content_2251_1028:()=>QP,content_2251_1030:()=>eI,content_2251_1032:()=>oI,content_2251_1034:()=>rI,content_2251_1036:()=>pI,content_2251_1038:()=>cI,content_2251_104:()=>VM,content_2251_1040:()=>uI,content_2251_1042:()=>dI,content_2251_1044:()=>yI,content_2251_1046:()=>kI,content_2251_1048:()=>gI,content_2251_1050:()=>DI,content_2251_1052:()=>XI,content_2251_1054:()=>vI,content_2251_1056:()=>TI,content_2251_1058:()=>LI,content_2251_106:()=>$M,content_2251_1060:()=>NI,content_2251_1062:()=>RI,content_2251_1064:()=>AI,content_2251_1066:()=>PI,content_2251_1068:()=>FI,content_2251_1070:()=>BI,content_2251_1072:()=>OI,content_2251_1074:()=>qI,content_2251_1076:()=>VI,content_2251_1078:()=>$I,content_2251_108:()=>YM,content_2251_1080:()=>YI,content_2251_1082:()=>QI,content_2251_1084:()=>eF,content_2251_1086:()=>oF,content_2251_1088:()=>rF,content_2251_1090:()=>pF,content_2251_1092:()=>cF,content_2251_1094:()=>uF,content_2251_1096:()=>dF,content_2251_1098:()=>yF,content_2251_110:()=>QM,content_2251_1100:()=>kF,content_2251_1102:()=>gF,content_2251_1104:()=>DF,content_2251_1106:()=>XF,content_2251_1108:()=>vF,content_2251_1110:()=>TF,content_2251_1112:()=>LF,content_2251_1114:()=>NF,content_2251_1116:()=>RF,content_2251_1118:()=>AF,content_2251_112:()=>eD,content_2251_1120:()=>PF,content_2251_1122:()=>FF,content_2251_1124:()=>BF,content_2251_1126:()=>OF,content_2251_1128:()=>qF,content_2251_1130:()=>VF,content_2251_1132:()=>$F,content_2251_1134:()=>YF,content_2251_1136:()=>QF,content_2251_1138:()=>eW,content_2251_114:()=>oD,content_2251_1140:()=>oW,content_2251_1142:()=>rW,content_2251_1144:()=>pW,content_2251_1146:()=>cW,content_2251_1148:()=>uW,content_2251_1150:()=>dW,content_2251_1152:()=>yW,content_2251_1154:()=>kW,content_2251_1156:()=>gW,content_2251_1158:()=>DW,content_2251_116:()=>rD,content_2251_1160:()=>XW,content_2251_1162:()=>vW,content_2251_1164:()=>TW,content_2251_1166:()=>LW,content_2251_1168:()=>NW,content_2251_1170:()=>RW,content_2251_1172:()=>AW,content_2251_1174:()=>PW,content_2251_1176:()=>FW,content_2251_1178:()=>BW,content_2251_118:()=>pD,content_2251_1180:()=>OW,content_2251_1182:()=>qW,content_2251_1184:()=>VW,content_2251_1186:()=>$W,content_2251_1188:()=>YW,content_2251_1190:()=>QW,content_2251_1192:()=>eB,content_2251_1194:()=>oB,content_2251_1196:()=>rB,content_2251_1198:()=>pB,content_2251_12:()=>cg,content_2251_120:()=>cD,content_2251_1200:()=>cB,content_2251_1202:()=>uB,content_2251_1204:()=>dB,content_2251_1206:()=>yB,content_2251_1208:()=>kB,content_2251_1210:()=>gB,content_2251_1212:()=>DB,content_2251_1214:()=>XB,content_2251_1216:()=>vB,content_2251_1218:()=>TB,content_2251_122:()=>uD,content_2251_1220:()=>LB,content_2251_1222:()=>NB,content_2251_1224:()=>RB,content_2251_1226:()=>AB,content_2251_1228:()=>PB,content_2251_1230:()=>FB,content_2251_1232:()=>BB,content_2251_1234:()=>OB,content_2251_1236:()=>qB,content_2251_1238:()=>VB,content_2251_124:()=>dD,content_2251_1240:()=>$B,content_2251_1242:()=>YB,content_2251_1244:()=>QB,content_2251_1246:()=>eG,content_2251_1248:()=>oG,content_2251_1250:()=>rG,content_2251_1252:()=>pG,content_2251_1254:()=>cG,content_2251_1256:()=>uG,content_2251_1258:()=>dG,content_2251_126:()=>yD,content_2251_1260:()=>yG,content_2251_1262:()=>kG,content_2251_1264:()=>gG,content_2251_1266:()=>DG,content_2251_1268:()=>XG,content_2251_1270:()=>vG,content_2251_1272:()=>TG,content_2251_1274:()=>LG,content_2251_1276:()=>NG,content_2251_1278:()=>RG,content_2251_128:()=>kD,content_2251_1280:()=>AG,content_2251_1282:()=>PG,content_2251_1284:()=>FG,content_2251_1286:()=>BG,content_2251_1288:()=>OG,content_2251_1290:()=>qG,content_2251_1292:()=>VG,content_2251_1294:()=>$G,content_2251_1296:()=>YG,content_2251_1298:()=>QG,content_2251_130:()=>gD,content_2251_1300:()=>eO,content_2251_1302:()=>oO,content_2251_1304:()=>rO,content_2251_1306:()=>pO,content_2251_1308:()=>cO,content_2251_1310:()=>uO,content_2251_1312:()=>dO,content_2251_1314:()=>yO,content_2251_1316:()=>kO,content_2251_1318:()=>gO,content_2251_132:()=>DD,content_2251_1320:()=>DO,content_2251_1322:()=>XO,content_2251_1324:()=>vO,content_2251_1326:()=>TO,content_2251_1328:()=>LO,content_2251_1330:()=>NO,content_2251_1332:()=>RO,content_2251_1334:()=>AO,content_2251_1336:()=>PO,content_2251_1338:()=>FO,content_2251_134:()=>XD,content_2251_1340:()=>BO,content_2251_1342:()=>OO,content_2251_1344:()=>qO,content_2251_1346:()=>VO,content_2251_1348:()=>$O,content_2251_1350:()=>YO,content_2251_1352:()=>QO,content_2251_1354:()=>ej,content_2251_1356:()=>oj,content_2251_1358:()=>rj,content_2251_136:()=>vD,content_2251_1360:()=>pj,content_2251_1362:()=>cj,content_2251_1364:()=>uj,content_2251_1366:()=>dj,content_2251_1368:()=>yj,content_2251_1370:()=>kj,content_2251_1372:()=>gj,content_2251_1374:()=>Dj,content_2251_1376:()=>Xj,content_2251_1378:()=>vj,content_2251_138:()=>TD,content_2251_1380:()=>Tj,content_2251_1382:()=>Lj,content_2251_1384:()=>Nj,content_2251_1386:()=>Rj,content_2251_1388:()=>Aj,content_2251_1390:()=>Pj,content_2251_1392:()=>Fj,content_2251_1394:()=>Bj,content_2251_1396:()=>Oj,content_2251_1398:()=>qj,content_2251_14:()=>ug,content_2251_140:()=>LD,content_2251_1400:()=>Vj,content_2251_1402:()=>$j,content_2251_1404:()=>Yj,content_2251_1406:()=>Qj,content_2251_1408:()=>eq,content_2251_1410:()=>oq,content_2251_1412:()=>rq,content_2251_1414:()=>pq,content_2251_1416:()=>cq,content_2251_1418:()=>uq,content_2251_142:()=>ND,content_2251_1420:()=>dq,content_2251_1422:()=>yq,content_2251_1424:()=>kq,content_2251_1426:()=>gq,content_2251_1428:()=>Dq,content_2251_1430:()=>Xq,content_2251_1432:()=>vq,content_2251_1434:()=>Tq,content_2251_1436:()=>Lq,content_2251_1438:()=>Nq,content_2251_144:()=>RD,content_2251_1440:()=>Rq,content_2251_1442:()=>Aq,content_2251_1444:()=>Pq,content_2251_1446:()=>Fq,content_2251_1448:()=>Bq,content_2251_1450:()=>Oq,content_2251_1452:()=>qq,content_2251_1454:()=>Vq,content_2251_1456:()=>$q,content_2251_1458:()=>Yq,content_2251_146:()=>AD,content_2251_1460:()=>Qq,content_2251_1462:()=>eU,content_2251_1464:()=>oU,content_2251_1466:()=>rU,content_2251_1468:()=>pU,content_2251_1470:()=>cU,content_2251_1472:()=>uU,content_2251_1474:()=>dU,content_2251_1476:()=>yU,content_2251_1478:()=>kU,content_2251_148:()=>PD,content_2251_1480:()=>gU,content_2251_1482:()=>DU,content_2251_1484:()=>XU,content_2251_1486:()=>vU,content_2251_1488:()=>TU,content_2251_1490:()=>LU,content_2251_1492:()=>NU,content_2251_1494:()=>RU,content_2251_1496:()=>AU,content_2251_1498:()=>PU,content_2251_150:()=>FD,content_2251_1500:()=>FU,content_2251_1502:()=>BU,content_2251_1504:()=>OU,content_2251_1506:()=>qU,content_2251_1508:()=>VU,content_2251_1510:()=>$U,content_2251_1512:()=>YU,content_2251_1514:()=>QU,content_2251_1516:()=>eV,content_2251_1518:()=>oV,content_2251_152:()=>BD,content_2251_1520:()=>rV,content_2251_1522:()=>pV,content_2251_1524:()=>cV,content_2251_1526:()=>uV,content_2251_1528:()=>dV,content_2251_1530:()=>yV,content_2251_1532:()=>kV,content_2251_1534:()=>gV,content_2251_1536:()=>DV,content_2251_1538:()=>XV,content_2251_154:()=>OD,content_2251_1540:()=>vV,content_2251_1542:()=>TV,content_2251_1544:()=>LV,content_2251_1546:()=>NV,content_2251_1548:()=>RV,content_2251_1550:()=>AV,content_2251_1552:()=>PV,content_2251_1554:()=>FV,content_2251_1556:()=>BV,content_2251_1558:()=>OV,content_2251_156:()=>qD,content_2251_1560:()=>qV,content_2251_1562:()=>VV,content_2251_1564:()=>$V,content_2251_1566:()=>YV,content_2251_1568:()=>QV,content_2251_1570:()=>eH,content_2251_1572:()=>oH,content_2251_1574:()=>rH,content_2251_1576:()=>pH,content_2251_1578:()=>cH,content_2251_158:()=>VD,content_2251_1580:()=>uH,content_2251_1582:()=>dH,content_2251_1584:()=>yH,content_2251_1586:()=>kH,content_2251_1588:()=>gH,content_2251_1590:()=>DH,content_2251_1592:()=>XH,content_2251_1594:()=>vH,content_2251_1596:()=>TH,content_2251_1598:()=>LH,content_2251_16:()=>dg,content_2251_160:()=>$D,content_2251_1600:()=>NH,content_2251_1602:()=>RH,content_2251_1604:()=>AH,content_2251_1606:()=>PH,content_2251_1608:()=>FH,content_2251_1610:()=>BH,content_2251_1612:()=>OH,content_2251_1614:()=>qH,content_2251_1616:()=>VH,content_2251_1618:()=>$H,content_2251_162:()=>YD,content_2251_1620:()=>YH,content_2251_1622:()=>QH,content_2251_1624:()=>e$,content_2251_1626:()=>o$,content_2251_1628:()=>r$,content_2251_1630:()=>p$,content_2251_1632:()=>c$,content_2251_1634:()=>u$,content_2251_1636:()=>d$,content_2251_1638:()=>y$,content_2251_164:()=>QD,content_2251_1640:()=>k$,content_2251_1642:()=>g$,content_2251_1644:()=>D$,content_2251_1646:()=>X$,content_2251_1648:()=>v$,content_2251_1650:()=>T$,content_2251_1652:()=>L$,content_2251_1654:()=>N$,content_2251_1656:()=>R$,content_2251_1658:()=>A$,content_2251_166:()=>e_,content_2251_1660:()=>P$,content_2251_1662:()=>F$,content_2251_1664:()=>B$,content_2251_1666:()=>O$,content_2251_1668:()=>q$,content_2251_1670:()=>V$,content_2251_1672:()=>$$,content_2251_1674:()=>Y$,content_2251_1676:()=>Q$,content_2251_1678:()=>eJ,content_2251_168:()=>o_,content_2251_1680:()=>oJ,content_2251_1682:()=>rJ,content_2251_1684:()=>pJ,content_2251_1686:()=>cJ,content_2251_1688:()=>uJ,content_2251_1690:()=>dJ,content_2251_1692:()=>yJ,content_2251_1694:()=>kJ,content_2251_1696:()=>gJ,content_2251_1698:()=>DJ,content_2251_170:()=>r_,content_2251_1700:()=>XJ,content_2251_1702:()=>vJ,content_2251_1704:()=>TJ,content_2251_1706:()=>LJ,content_2251_1708:()=>NJ,content_2251_1710:()=>RJ,content_2251_1712:()=>AJ,content_2251_1714:()=>PJ,content_2251_1716:()=>FJ,content_2251_1718:()=>BJ,content_2251_172:()=>p_,content_2251_1720:()=>OJ,content_2251_1722:()=>qJ,content_2251_1724:()=>VJ,content_2251_1726:()=>$J,content_2251_1728:()=>YJ,content_2251_1730:()=>QJ,content_2251_1732:()=>eY,content_2251_1734:()=>oY,content_2251_1736:()=>rY,content_2251_1738:()=>pY,content_2251_174:()=>c_,content_2251_1740:()=>cY,content_2251_1742:()=>uY,content_2251_1744:()=>dY,content_2251_1746:()=>yY,content_2251_1748:()=>kY,content_2251_1750:()=>gY,content_2251_1752:()=>DY,content_2251_1754:()=>XY,content_2251_1756:()=>vY,content_2251_1758:()=>TY,content_2251_176:()=>u_,content_2251_1760:()=>LY,content_2251_1762:()=>NY,content_2251_1764:()=>RY,content_2251_1766:()=>AY,content_2251_1768:()=>PY,content_2251_1770:()=>FY,content_2251_1772:()=>BY,content_2251_1774:()=>OY,content_2251_1776:()=>qY,content_2251_1778:()=>VY,content_2251_178:()=>d_,content_2251_1780:()=>$Y,content_2251_1782:()=>YY,content_2251_1784:()=>QY,content_2251_1786:()=>eK,content_2251_1788:()=>oK,content_2251_1790:()=>rK,content_2251_1792:()=>pK,content_2251_1794:()=>cK,content_2251_1796:()=>uK,content_2251_1798:()=>dK,content_2251_18:()=>yg,content_2251_180:()=>y_,content_2251_1800:()=>yK,content_2251_1802:()=>kK,content_2251_1804:()=>gK,content_2251_1806:()=>DK,content_2251_1808:()=>XK,content_2251_1810:()=>vK,content_2251_1812:()=>TK,content_2251_1814:()=>LK,content_2251_1816:()=>NK,content_2251_1818:()=>RK,content_2251_182:()=>k_,content_2251_1820:()=>AK,content_2251_1822:()=>PK,content_2251_1824:()=>FK,content_2251_1826:()=>BK,content_2251_1828:()=>OK,content_2251_1830:()=>qK,content_2251_1832:()=>VK,content_2251_1834:()=>$K,content_2251_1836:()=>YK,content_2251_1838:()=>QK,content_2251_184:()=>g_,content_2251_1840:()=>eQ,content_2251_1842:()=>oQ,content_2251_1844:()=>rQ,content_2251_1846:()=>pQ,content_2251_1848:()=>cQ,content_2251_1850:()=>uQ,content_2251_1852:()=>dQ,content_2251_1854:()=>yQ,content_2251_1856:()=>kQ,content_2251_1858:()=>gQ,content_2251_186:()=>D_,content_2251_1860:()=>DQ,content_2251_1862:()=>XQ,content_2251_1864:()=>vQ,content_2251_1866:()=>TQ,content_2251_1868:()=>LQ,content_2251_1870:()=>NQ,content_2251_1872:()=>RQ,content_2251_1874:()=>AQ,content_2251_1876:()=>PQ,content_2251_1878:()=>FQ,content_2251_188:()=>X_,content_2251_1880:()=>BQ,content_2251_1882:()=>OQ,content_2251_1884:()=>qQ,content_2251_1886:()=>VQ,content_2251_1888:()=>$Q,content_2251_1890:()=>YQ,content_2251_1892:()=>QQ,content_2251_1894:()=>e0,content_2251_1896:()=>o0,content_2251_1898:()=>r0,content_2251_190:()=>v_,content_2251_1900:()=>p0,content_2251_1902:()=>c0,content_2251_1904:()=>u0,content_2251_1906:()=>d0,content_2251_1908:()=>y0,content_2251_1910:()=>k0,content_2251_1912:()=>g0,content_2251_1914:()=>D0,content_2251_1916:()=>X0,content_2251_1918:()=>v0,content_2251_192:()=>T_,content_2251_1920:()=>T0,content_2251_1922:()=>L0,content_2251_1924:()=>N0,content_2251_1926:()=>R0,content_2251_1928:()=>A0,content_2251_1930:()=>P0,content_2251_1932:()=>F0,content_2251_1934:()=>B0,content_2251_1936:()=>O0,content_2251_1938:()=>q0,content_2251_194:()=>L_,content_2251_1940:()=>V0,content_2251_1942:()=>$0,content_2251_1944:()=>Y0,content_2251_1946:()=>Q0,content_2251_1948:()=>e2,content_2251_1950:()=>o2,content_2251_1952:()=>r2,content_2251_1954:()=>p2,content_2251_1956:()=>c2,content_2251_1958:()=>u2,content_2251_196:()=>N_,content_2251_1960:()=>d2,content_2251_1962:()=>y2,content_2251_1964:()=>k2,content_2251_1966:()=>g2,content_2251_1968:()=>D2,content_2251_1970:()=>X2,content_2251_1972:()=>v2,content_2251_1974:()=>T2,content_2251_1976:()=>L2,content_2251_1978:()=>N2,content_2251_198:()=>R_,content_2251_1980:()=>R2,content_2251_1982:()=>A2,content_2251_1984:()=>P2,content_2251_1986:()=>F2,content_2251_1988:()=>B2,content_2251_1990:()=>O2,content_2251_1992:()=>q2,content_2251_1994:()=>V2,content_2251_1996:()=>$2,content_2251_1998:()=>Y2,content_2251_2:()=>Qw,content_2251_20:()=>kg,content_2251_200:()=>A_,content_2251_2000:()=>Q2,content_2251_2002:()=>e1,content_2251_2004:()=>o1,content_2251_2006:()=>r1,content_2251_2008:()=>p1,content_2251_2010:()=>c1,content_2251_2012:()=>u1,content_2251_2014:()=>d1,content_2251_2016:()=>y1,content_2251_2018:()=>k1,content_2251_202:()=>P_,content_2251_2020:()=>g1,content_2251_2022:()=>D1,content_2251_2024:()=>X1,content_2251_2026:()=>v1,content_2251_2028:()=>T1,content_2251_2030:()=>L1,content_2251_2032:()=>N1,content_2251_2034:()=>R1,content_2251_2036:()=>A1,content_2251_2038:()=>P1,content_2251_204:()=>F_,content_2251_2040:()=>F1,content_2251_2042:()=>B1,content_2251_2044:()=>O1,content_2251_2046:()=>q1,content_2251_2048:()=>V1,content_2251_2050:()=>$1,content_2251_2052:()=>Y1,content_2251_2054:()=>Q1,content_2251_2056:()=>e5,content_2251_2058:()=>o5,content_2251_206:()=>B_,content_2251_2060:()=>r5,content_2251_2062:()=>p5,content_2251_2064:()=>c5,content_2251_2066:()=>u5,content_2251_2068:()=>d5,content_2251_2070:()=>y5,content_2251_2072:()=>k5,content_2251_2074:()=>g5,content_2251_2076:()=>D5,content_2251_2078:()=>X5,content_2251_208:()=>O_,content_2251_2080:()=>v5,content_2251_2082:()=>T5,content_2251_2084:()=>L5,content_2251_2086:()=>N5,content_2251_2088:()=>R5,content_2251_2090:()=>A5,content_2251_2092:()=>P5,content_2251_2094:()=>F5,content_2251_2096:()=>B5,content_2251_2098:()=>O5,content_2251_210:()=>q_,content_2251_2100:()=>q5,content_2251_2102:()=>V5,content_2251_2104:()=>$5,content_2251_2106:()=>Y5,content_2251_2108:()=>Q5,content_2251_2110:()=>e3,content_2251_2112:()=>o3,content_2251_2114:()=>r3,content_2251_2116:()=>p3,content_2251_2118:()=>c3,content_2251_212:()=>V_,content_2251_2120:()=>u3,content_2251_2122:()=>d3,content_2251_2124:()=>y3,content_2251_2126:()=>k3,content_2251_2128:()=>g3,content_2251_2130:()=>D3,content_2251_2132:()=>X3,content_2251_2134:()=>v3,content_2251_2136:()=>T3,content_2251_2138:()=>L3,content_2251_214:()=>$_,content_2251_2140:()=>N3,content_2251_2142:()=>R3,content_2251_2144:()=>A3,content_2251_2146:()=>P3,content_2251_2148:()=>F3,content_2251_2150:()=>B3,content_2251_2152:()=>O3,content_2251_2154:()=>q3,content_2251_2156:()=>V3,content_2251_2158:()=>$3,content_2251_216:()=>Y_,content_2251_2160:()=>Y3,content_2251_2162:()=>Q3,content_2251_2164:()=>e4,content_2251_2166:()=>o4,content_2251_2168:()=>r4,content_2251_2170:()=>p4,content_2251_2172:()=>c4,content_2251_2174:()=>u4,content_2251_2176:()=>d4,content_2251_2178:()=>y4,content_2251_218:()=>Q_,content_2251_2180:()=>k4,content_2251_2182:()=>g4,content_2251_2184:()=>D4,content_2251_2186:()=>X4,content_2251_2188:()=>v4,content_2251_2190:()=>T4,content_2251_2192:()=>L4,content_2251_2194:()=>N4,content_2251_2196:()=>R4,content_2251_2198:()=>A4,content_2251_22:()=>gg,content_2251_220:()=>eX,content_2251_2200:()=>P4,content_2251_2202:()=>F4,content_2251_2204:()=>B4,content_2251_2206:()=>O4,content_2251_2208:()=>q4,content_2251_2210:()=>V4,content_2251_2212:()=>$4,content_2251_2214:()=>Y4,content_2251_2216:()=>Q4,content_2251_2218:()=>e8,content_2251_222:()=>oX,content_2251_2220:()=>o8,content_2251_2222:()=>r8,content_2251_2224:()=>p8,content_2251_2226:()=>c8,content_2251_2228:()=>u8,content_2251_2230:()=>d8,content_2251_2232:()=>y8,content_2251_2234:()=>k8,content_2251_2236:()=>g8,content_2251_2238:()=>D8,content_2251_224:()=>rX,content_2251_2240:()=>X8,content_2251_2242:()=>v8,content_2251_2244:()=>T8,content_2251_2246:()=>L8,content_2251_2248:()=>N8,content_2251_2250:()=>R8,content_2251_2252:()=>A8,content_2251_2254:()=>P8,content_2251_2256:()=>F8,content_2251_2258:()=>B8,content_2251_226:()=>pX,content_2251_2260:()=>O8,content_2251_2262:()=>q8,content_2251_2264:()=>V8,content_2251_2266:()=>$8,content_2251_2268:()=>Y8,content_2251_2270:()=>Q8,content_2251_2272:()=>e6,content_2251_2274:()=>o6,content_2251_2276:()=>r6,content_2251_2278:()=>p6,content_2251_228:()=>cX,content_2251_2280:()=>c6,content_2251_2282:()=>u6,content_2251_2284:()=>d6,content_2251_2286:()=>y6,content_2251_2288:()=>k6,content_2251_2290:()=>g6,content_2251_2292:()=>D6,content_2251_2294:()=>X6,content_2251_2296:()=>v6,content_2251_2298:()=>T6,content_2251_230:()=>uX,content_2251_2300:()=>L6,content_2251_2302:()=>N6,content_2251_2304:()=>R6,content_2251_2306:()=>A6,content_2251_2308:()=>P6,content_2251_2310:()=>F6,content_2251_2312:()=>B6,content_2251_2314:()=>O6,content_2251_2316:()=>q6,content_2251_2318:()=>V6,content_2251_232:()=>dX,content_2251_2320:()=>$6,content_2251_2322:()=>Y6,content_2251_2324:()=>Q6,content_2251_2326:()=>e7,content_2251_2328:()=>o7,content_2251_2330:()=>r7,content_2251_2332:()=>p7,content_2251_2334:()=>c7,content_2251_2336:()=>u7,content_2251_2338:()=>d7,content_2251_234:()=>yX,content_2251_2340:()=>y7,content_2251_2342:()=>k7,content_2251_2344:()=>g7,content_2251_2346:()=>D7,content_2251_2348:()=>X7,content_2251_2350:()=>v7,content_2251_2352:()=>T7,content_2251_2354:()=>L7,content_2251_2356:()=>N7,content_2251_2358:()=>R7,content_2251_236:()=>kX,content_2251_2360:()=>A7,content_2251_2362:()=>P7,content_2251_2364:()=>F7,content_2251_2366:()=>B7,content_2251_2368:()=>O7,content_2251_2370:()=>q7,content_2251_2372:()=>V7,content_2251_2374:()=>$7,content_2251_2376:()=>Y7,content_2251_2378:()=>Q7,content_2251_238:()=>gX,content_2251_2380:()=>e9,content_2251_2382:()=>o9,content_2251_2384:()=>r9,content_2251_2386:()=>p9,content_2251_2388:()=>c9,content_2251_2390:()=>u9,content_2251_2392:()=>d9,content_2251_2394:()=>y9,content_2251_2396:()=>k9,content_2251_2398:()=>g9,content_2251_24:()=>Dg,content_2251_240:()=>DX,content_2251_2400:()=>D9,content_2251_2402:()=>X9,content_2251_2404:()=>v9,content_2251_2406:()=>T9,content_2251_2408:()=>L9,content_2251_2410:()=>N9,content_2251_2412:()=>R9,content_2251_2414:()=>A9,content_2251_2416:()=>P9,content_2251_2418:()=>F9,content_2251_242:()=>XX,content_2251_2420:()=>B9,content_2251_2422:()=>O9,content_2251_2424:()=>q9,content_2251_2426:()=>V9,content_2251_2428:()=>$9,content_2251_2430:()=>Y9,content_2251_2432:()=>Q9,content_2251_2434:()=>ett,content_2251_2436:()=>ott,content_2251_2438:()=>rtt,content_2251_244:()=>vX,content_2251_2440:()=>ptt,content_2251_2442:()=>ctt,content_2251_2444:()=>utt,content_2251_2446:()=>dtt,content_2251_2448:()=>ytt,content_2251_2450:()=>ktt,content_2251_2452:()=>gtt,content_2251_2454:()=>Dtt,content_2251_2456:()=>Xtt,content_2251_2458:()=>vtt,content_2251_246:()=>TX,content_2251_2460:()=>Ttt,content_2251_2462:()=>Ltt,content_2251_2464:()=>Ntt,content_2251_2466:()=>Rtt,content_2251_2468:()=>Att,content_2251_2470:()=>Ptt,content_2251_2472:()=>Ftt,content_2251_2474:()=>Btt,content_2251_2476:()=>Ott,content_2251_2478:()=>qtt,content_2251_248:()=>LX,content_2251_2480:()=>Vtt,content_2251_2482:()=>$tt,content_2251_2484:()=>Ytt,content_2251_2486:()=>Qtt,content_2251_2488:()=>eet,content_2251_2490:()=>oet,content_2251_2492:()=>ret,content_2251_2494:()=>pet,content_2251_2496:()=>cet,content_2251_2498:()=>met,content_2251_250:()=>NX,content_2251_2500:()=>het,content_2251_2502:()=>fet,content_2251_2504:()=>wet,content_2251_2506:()=>Met,content_2251_2508:()=>_et,content_2251_2510:()=>xet,content_2251_2512:()=>Cet,content_2251_2514:()=>bet,content_2251_2516:()=>Zet,content_2251_2518:()=>Set,content_2251_252:()=>RX,content_2251_2520:()=>Eet,content_2251_2522:()=>zet,content_2251_2524:()=>Iet,content_2251_2526:()=>Wet,content_2251_2528:()=>Get,content_2251_2530:()=>jet,content_2251_2532:()=>Uet,content_2251_2534:()=>Het,content_2251_2536:()=>Jet,content_2251_2538:()=>Ket,content_2251_254:()=>AX,content_2251_2540:()=>tnt,content_2251_2542:()=>nnt,content_2251_2544:()=>snt,content_2251_2546:()=>int,content_2251_2548:()=>ant,content_2251_2550:()=>lnt,content_2251_2552:()=>mnt,content_2251_2554:()=>hnt,content_2251_2556:()=>fnt,content_2251_2558:()=>wnt,content_2251_256:()=>PX,content_2251_2560:()=>Mnt,content_2251_2562:()=>_nt,content_2251_2564:()=>xnt,content_2251_2566:()=>Cnt,content_2251_2568:()=>bnt,content_2251_2570:()=>Znt,content_2251_2572:()=>Snt,content_2251_2574:()=>Ent,content_2251_2576:()=>znt,content_2251_2578:()=>Int,content_2251_258:()=>FX,content_2251_2580:()=>Wnt,content_2251_2582:()=>Gnt,content_2251_2584:()=>jnt,content_2251_2586:()=>Unt,content_2251_2588:()=>Hnt,content_2251_2590:()=>Jnt,content_2251_2592:()=>Knt,content_2251_2594:()=>tot,content_2251_2596:()=>not,content_2251_2598:()=>sot,content_2251_26:()=>Xg,content_2251_260:()=>BX,content_2251_2600:()=>iot,content_2251_2602:()=>aot,content_2251_2604:()=>lot,content_2251_2606:()=>mot,content_2251_2608:()=>hot,content_2251_2610:()=>fot,content_2251_2612:()=>wot,content_2251_2614:()=>Mot,content_2251_2616:()=>_ot,content_2251_2618:()=>xot,content_2251_262:()=>OX,content_2251_2620:()=>Cot,content_2251_2622:()=>bot,content_2251_2624:()=>Zot,content_2251_2626:()=>Sot,content_2251_2628:()=>Eot,content_2251_2630:()=>zot,content_2251_2632:()=>Iot,content_2251_2634:()=>Wot,content_2251_2636:()=>Got,content_2251_2638:()=>jot,content_2251_264:()=>qX,content_2251_2640:()=>Uot,content_2251_2642:()=>Hot,content_2251_2644:()=>Jot,content_2251_2646:()=>Kot,content_2251_2648:()=>tst,content_2251_2650:()=>nst,content_2251_2652:()=>sst,content_2251_2654:()=>ist,content_2251_2656:()=>ast,content_2251_2658:()=>lst,content_2251_266:()=>VX,content_2251_2660:()=>mst,content_2251_2662:()=>hst,content_2251_2664:()=>fst,content_2251_2666:()=>wst,content_2251_2668:()=>Mst,content_2251_2670:()=>_st,content_2251_2672:()=>xst,content_2251_2674:()=>Cst,content_2251_2676:()=>bst,content_2251_2678:()=>Zst,content_2251_268:()=>$X,content_2251_2680:()=>Sst,content_2251_2682:()=>Est,content_2251_2684:()=>zst,content_2251_2686:()=>Ist,content_2251_2688:()=>Wst,content_2251_2690:()=>Gst,content_2251_2692:()=>jst,content_2251_2694:()=>Ust,content_2251_2696:()=>Hst,content_2251_2698:()=>Jst,content_2251_270:()=>YX,content_2251_2700:()=>Kst,content_2251_2702:()=>trt,content_2251_2704:()=>nrt,content_2251_2706:()=>srt,content_2251_2708:()=>irt,content_2251_2710:()=>art,content_2251_2712:()=>lrt,content_2251_2714:()=>mrt,content_2251_2716:()=>hrt,content_2251_2718:()=>frt,content_2251_272:()=>QX,content_2251_2720:()=>wrt,content_2251_2722:()=>Mrt,content_2251_2724:()=>_rt,content_2251_2726:()=>xrt,content_2251_2728:()=>Crt,content_2251_2730:()=>brt,content_2251_2732:()=>Zrt,content_2251_2734:()=>Srt,content_2251_2736:()=>Ert,content_2251_2738:()=>zrt,content_2251_274:()=>ex,content_2251_2740:()=>Irt,content_2251_2742:()=>Wrt,content_2251_2744:()=>Grt,content_2251_2746:()=>jrt,content_2251_2748:()=>Urt,content_2251_2750:()=>Hrt,content_2251_2752:()=>Jrt,content_2251_2754:()=>Krt,content_2251_2756:()=>tit,content_2251_2758:()=>nit,content_2251_276:()=>ox,content_2251_2760:()=>sit,content_2251_2762:()=>iit,content_2251_2764:()=>ait,content_2251_2766:()=>lit,content_2251_2768:()=>mit,content_2251_2770:()=>hit,content_2251_2772:()=>fit,content_2251_2774:()=>wit,content_2251_2776:()=>Mit,content_2251_2778:()=>_it,content_2251_278:()=>rx,content_2251_2780:()=>xit,content_2251_2782:()=>Cit,content_2251_2784:()=>bit,content_2251_2786:()=>Zit,content_2251_2788:()=>Sit,content_2251_2790:()=>Eit,content_2251_2792:()=>zit,content_2251_2794:()=>Iit,content_2251_2796:()=>Wit,content_2251_2798:()=>Git,content_2251_28:()=>vg,content_2251_280:()=>px,content_2251_2800:()=>jit,content_2251_2802:()=>Uit,content_2251_2804:()=>Hit,content_2251_2806:()=>Jit,content_2251_2808:()=>Kit,content_2251_2810:()=>tpt,content_2251_2812:()=>npt,content_2251_2814:()=>spt,content_2251_2816:()=>ipt,content_2251_2818:()=>apt,content_2251_282:()=>cx,content_2251_2820:()=>lpt,content_2251_2822:()=>mpt,content_2251_2824:()=>hpt,content_2251_2826:()=>fpt,content_2251_2828:()=>wpt,content_2251_2830:()=>Mpt,content_2251_2832:()=>_pt,content_2251_2834:()=>xpt,content_2251_2836:()=>Cpt,content_2251_2838:()=>bpt,content_2251_284:()=>ux,content_2251_2840:()=>Zpt,content_2251_2842:()=>Spt,content_2251_2844:()=>Ept,content_2251_2846:()=>zpt,content_2251_2848:()=>Ipt,content_2251_2850:()=>Wpt,content_2251_2852:()=>Gpt,content_2251_2854:()=>jpt,content_2251_2856:()=>Upt,content_2251_2858:()=>Hpt,content_2251_286:()=>dx,content_2251_2860:()=>Jpt,content_2251_2862:()=>Kpt,content_2251_2864:()=>tat,content_2251_2866:()=>nat,content_2251_2868:()=>sat,content_2251_2870:()=>iat,content_2251_2872:()=>aat,content_2251_2874:()=>lat,content_2251_2876:()=>mat,content_2251_2878:()=>hat,content_2251_288:()=>yx,content_2251_2880:()=>fat,content_2251_2882:()=>wat,content_2251_2884:()=>Mat,content_2251_2886:()=>_at,content_2251_2888:()=>xat,content_2251_2890:()=>Cat,content_2251_2892:()=>bat,content_2251_2894:()=>Zat,content_2251_2896:()=>Sat,content_2251_2898:()=>Eat,content_2251_290:()=>kx,content_2251_2900:()=>zat,content_2251_2902:()=>Iat,content_2251_2904:()=>Wat,content_2251_2906:()=>Gat,content_2251_2908:()=>jat,content_2251_2910:()=>Uat,content_2251_2912:()=>Hat,content_2251_2914:()=>Jat,content_2251_2916:()=>Kat,content_2251_2918:()=>tct,content_2251_292:()=>gx,content_2251_2920:()=>nct,content_2251_2922:()=>sct,content_2251_2924:()=>ict,content_2251_2926:()=>act,content_2251_2928:()=>lct,content_2251_2930:()=>mct,content_2251_2932:()=>hct,content_2251_2934:()=>fct,content_2251_2936:()=>wct,content_2251_2938:()=>Mct,content_2251_294:()=>Dx,content_2251_2940:()=>_ct,content_2251_2942:()=>xct,content_2251_2944:()=>Cct,content_2251_2946:()=>bct,content_2251_2948:()=>Zct,content_2251_2950:()=>Sct,content_2251_2952:()=>Ect,content_2251_2954:()=>zct,content_2251_2956:()=>Ict,content_2251_2958:()=>Wct,content_2251_296:()=>Xx,content_2251_2960:()=>Gct,content_2251_2962:()=>jct,content_2251_2964:()=>Uct,content_2251_2966:()=>Hct,content_2251_2968:()=>Jct,content_2251_2970:()=>Kct,content_2251_2972:()=>tlt,content_2251_2974:()=>nlt,content_2251_2976:()=>slt,content_2251_2978:()=>ilt,content_2251_298:()=>vx,content_2251_2980:()=>alt,content_2251_2982:()=>llt,content_2251_2984:()=>mlt,content_2251_2986:()=>hlt,content_2251_2988:()=>flt,content_2251_2990:()=>wlt,content_2251_2992:()=>Mlt,content_2251_2994:()=>_lt,content_2251_2996:()=>xlt,content_2251_2998:()=>Clt,content_2251_30:()=>Tg,content_2251_300:()=>Tx,content_2251_3000:()=>blt,content_2251_3002:()=>Zlt,content_2251_3004:()=>Slt,content_2251_3006:()=>Elt,content_2251_3008:()=>zlt,content_2251_3010:()=>Ilt,content_2251_3012:()=>Wlt,content_2251_3014:()=>Glt,content_2251_3016:()=>jlt,content_2251_3018:()=>Ult,content_2251_302:()=>Lx,content_2251_3020:()=>Hlt,content_2251_3022:()=>Jlt,content_2251_3024:()=>Klt,content_2251_3026:()=>tut,content_2251_3028:()=>nut,content_2251_3030:()=>sut,content_2251_3032:()=>iut,content_2251_3034:()=>aut,content_2251_3036:()=>lut,content_2251_3038:()=>mut,content_2251_304:()=>Nx,content_2251_3040:()=>hut,content_2251_3042:()=>fut,content_2251_3044:()=>wut,content_2251_3046:()=>Mut,content_2251_3048:()=>_ut,content_2251_3050:()=>xut,content_2251_3052:()=>Cut,content_2251_3054:()=>but,content_2251_3056:()=>Zut,content_2251_3058:()=>Sut,content_2251_306:()=>Rx,content_2251_3060:()=>Eut,content_2251_3062:()=>zut,content_2251_3064:()=>Iut,content_2251_3066:()=>Wut,content_2251_3068:()=>Gut,content_2251_3070:()=>jut,content_2251_3072:()=>Uut,content_2251_3074:()=>Hut,content_2251_3076:()=>Jut,content_2251_3078:()=>Kut,content_2251_308:()=>Ax,content_2251_3080:()=>tmt,content_2251_3082:()=>nmt,content_2251_3084:()=>smt,content_2251_3086:()=>imt,content_2251_3088:()=>amt,content_2251_3090:()=>lmt,content_2251_3092:()=>mmt,content_2251_3094:()=>hmt,content_2251_3096:()=>fmt,content_2251_3098:()=>wmt,content_2251_310:()=>Px,content_2251_3100:()=>Mmt,content_2251_3102:()=>_mt,content_2251_3104:()=>xmt,content_2251_3106:()=>Cmt,content_2251_3108:()=>bmt,content_2251_3110:()=>Zmt,content_2251_3112:()=>Smt,content_2251_3114:()=>Emt,content_2251_3116:()=>zmt,content_2251_3118:()=>Imt,content_2251_312:()=>Fx,content_2251_3120:()=>Wmt,content_2251_3122:()=>Gmt,content_2251_3124:()=>jmt,content_2251_3126:()=>Umt,content_2251_3128:()=>Hmt,content_2251_3130:()=>Jmt,content_2251_3132:()=>Kmt,content_2251_3134:()=>tdt,content_2251_3136:()=>ndt,content_2251_3138:()=>sdt,content_2251_314:()=>Bx,content_2251_3140:()=>idt,content_2251_3142:()=>adt,content_2251_3144:()=>ldt,content_2251_3146:()=>mdt,content_2251_3148:()=>hdt,content_2251_3150:()=>fdt,content_2251_3152:()=>wdt,content_2251_3154:()=>Mdt,content_2251_3156:()=>_dt,content_2251_3158:()=>xdt,content_2251_316:()=>Ox,content_2251_3160:()=>Cdt,content_2251_3162:()=>bdt,content_2251_3164:()=>Zdt,content_2251_3166:()=>Sdt,content_2251_3168:()=>Edt,content_2251_3170:()=>zdt,content_2251_3172:()=>Idt,content_2251_3174:()=>Wdt,content_2251_3176:()=>Gdt,content_2251_3178:()=>jdt,content_2251_318:()=>qx,content_2251_3180:()=>Udt,content_2251_3182:()=>Hdt,content_2251_3184:()=>Jdt,content_2251_3186:()=>Kdt,content_2251_3188:()=>tht,content_2251_3190:()=>nht,content_2251_3192:()=>sht,content_2251_3194:()=>iht,content_2251_3196:()=>aht,content_2251_3198:()=>lht,content_2251_32:()=>Lg,content_2251_320:()=>Vx,content_2251_3200:()=>mht,content_2251_3202:()=>hht,content_2251_3204:()=>fht,content_2251_3206:()=>wht,content_2251_3208:()=>Mht,content_2251_3210:()=>_ht,content_2251_3212:()=>xht,content_2251_3214:()=>Cht,content_2251_3216:()=>bht,content_2251_3218:()=>Zht,content_2251_322:()=>$x,content_2251_3220:()=>Sht,content_2251_3222:()=>Eht,content_2251_3224:()=>zht,content_2251_3226:()=>Iht,content_2251_3228:()=>Wht,content_2251_3230:()=>Ght,content_2251_3232:()=>jht,content_2251_3234:()=>Uht,content_2251_3236:()=>Hht,content_2251_3238:()=>Jht,content_2251_324:()=>Yx,content_2251_3240:()=>Kht,content_2251_3242:()=>tyt,content_2251_3244:()=>nyt,content_2251_3246:()=>syt,content_2251_3248:()=>iyt,content_2251_3250:()=>ayt,content_2251_3252:()=>lyt,content_2251_3254:()=>myt,content_2251_3256:()=>hyt,content_2251_3258:()=>fyt,content_2251_326:()=>Qx,content_2251_3260:()=>wyt,content_2251_3262:()=>Myt,content_2251_3264:()=>_yt,content_2251_3266:()=>xyt,content_2251_3268:()=>Cyt,content_2251_3270:()=>byt,content_2251_3272:()=>Zyt,content_2251_3274:()=>Syt,content_2251_3276:()=>Eyt,content_2251_3278:()=>zyt,content_2251_328:()=>ev,content_2251_3280:()=>Iyt,content_2251_3282:()=>Wyt,content_2251_3284:()=>Gyt,content_2251_3286:()=>jyt,content_2251_3288:()=>Uyt,content_2251_3290:()=>Hyt,content_2251_3292:()=>Jyt,content_2251_3294:()=>Kyt,content_2251_3296:()=>tft,content_2251_3298:()=>nft,content_2251_330:()=>ov,content_2251_3300:()=>sft,content_2251_3302:()=>ift,content_2251_3304:()=>aft,content_2251_3306:()=>lft,content_2251_3308:()=>mft,content_2251_3310:()=>hft,content_2251_3312:()=>fft,content_2251_3314:()=>wft,content_2251_3316:()=>Mft,content_2251_3318:()=>_ft,content_2251_332:()=>rv,content_2251_3320:()=>xft,content_2251_3322:()=>Cft,content_2251_3324:()=>bft,content_2251_3326:()=>Zft,content_2251_3328:()=>Sft,content_2251_3330:()=>Eft,content_2251_3332:()=>zft,content_2251_3334:()=>Ift,content_2251_3336:()=>Wft,content_2251_3338:()=>Gft,content_2251_334:()=>pv,content_2251_3340:()=>jft,content_2251_3342:()=>Uft,content_2251_3344:()=>Hft,content_2251_3346:()=>Jft,content_2251_3348:()=>Kft,content_2251_3350:()=>tkt,content_2251_3352:()=>nkt,content_2251_3354:()=>skt,content_2251_3356:()=>ikt,content_2251_3358:()=>akt,content_2251_336:()=>cv,content_2251_3360:()=>lkt,content_2251_3362:()=>mkt,content_2251_3364:()=>hkt,content_2251_3366:()=>fkt,content_2251_3368:()=>wkt,content_2251_3370:()=>Mkt,content_2251_3372:()=>_kt,content_2251_3374:()=>xkt,content_2251_3376:()=>Ckt,content_2251_3378:()=>bkt,content_2251_338:()=>uv,content_2251_3380:()=>Zkt,content_2251_3382:()=>Skt,content_2251_3384:()=>Ekt,content_2251_3386:()=>zkt,content_2251_3388:()=>Ikt,content_2251_3390:()=>Wkt,content_2251_3392:()=>Gkt,content_2251_3394:()=>jkt,content_2251_3396:()=>Ukt,content_2251_3398:()=>Hkt,content_2251_34:()=>Ng,content_2251_340:()=>dv,content_2251_3400:()=>Jkt,content_2251_3402:()=>Kkt,content_2251_3404:()=>twt,content_2251_3406:()=>nwt,content_2251_3408:()=>swt,content_2251_3410:()=>iwt,content_2251_3412:()=>awt,content_2251_3414:()=>lwt,content_2251_3416:()=>mwt,content_2251_3418:()=>hwt,content_2251_342:()=>yv,content_2251_3420:()=>fwt,content_2251_3422:()=>wwt,content_2251_3424:()=>Mwt,content_2251_3426:()=>_wt,content_2251_3428:()=>xwt,content_2251_3430:()=>Cwt,content_2251_3432:()=>bwt,content_2251_3434:()=>Zwt,content_2251_3436:()=>Swt,content_2251_3438:()=>Ewt,content_2251_344:()=>kv,content_2251_3440:()=>zwt,content_2251_3442:()=>Iwt,content_2251_3444:()=>Wwt,content_2251_3446:()=>Gwt,content_2251_3448:()=>jwt,content_2251_3450:()=>Uwt,content_2251_3452:()=>Hwt,content_2251_3454:()=>Jwt,content_2251_3456:()=>Kwt,content_2251_3458:()=>tgt,content_2251_346:()=>gv,content_2251_3460:()=>ngt,content_2251_3462:()=>sgt,content_2251_3464:()=>igt,content_2251_3466:()=>agt,content_2251_3468:()=>lgt,content_2251_3470:()=>mgt,content_2251_3472:()=>hgt,content_2251_3474:()=>fgt,content_2251_3476:()=>wgt,content_2251_3478:()=>Mgt,content_2251_348:()=>Dv,content_2251_3480:()=>_gt,content_2251_3482:()=>xgt,content_2251_3484:()=>Cgt,content_2251_3486:()=>bgt,content_2251_3488:()=>Zgt,content_2251_3490:()=>Sgt,content_2251_3492:()=>Egt,content_2251_3494:()=>zgt,content_2251_3496:()=>Igt,content_2251_3498:()=>Wgt,content_2251_350:()=>Xv,content_2251_3500:()=>Ggt,content_2251_3502:()=>jgt,content_2251_3504:()=>Ugt,content_2251_3506:()=>Hgt,content_2251_3508:()=>Jgt,content_2251_3510:()=>Kgt,content_2251_3512:()=>tMt,content_2251_3514:()=>nMt,content_2251_3516:()=>sMt,content_2251_3518:()=>iMt,content_2251_352:()=>vv,content_2251_3520:()=>aMt,content_2251_3522:()=>lMt,content_2251_3524:()=>mMt,content_2251_3526:()=>hMt,content_2251_3528:()=>fMt,content_2251_3530:()=>wMt,content_2251_3532:()=>MMt,content_2251_3534:()=>_Mt,content_2251_3536:()=>xMt,content_2251_3538:()=>CMt,content_2251_354:()=>Tv,content_2251_3540:()=>bMt,content_2251_3542:()=>ZMt,content_2251_3544:()=>SMt,content_2251_3546:()=>EMt,content_2251_3548:()=>zMt,content_2251_3550:()=>IMt,content_2251_3552:()=>WMt,content_2251_3554:()=>GMt,content_2251_3556:()=>jMt,content_2251_3558:()=>UMt,content_2251_356:()=>Lv,content_2251_3560:()=>HMt,content_2251_3562:()=>JMt,content_2251_3564:()=>KMt,content_2251_3566:()=>tDt,content_2251_3568:()=>nDt,content_2251_3570:()=>sDt,content_2251_3572:()=>iDt,content_2251_3574:()=>aDt,content_2251_3576:()=>lDt,content_2251_3578:()=>mDt,content_2251_358:()=>Nv,content_2251_3580:()=>hDt,content_2251_3582:()=>fDt,content_2251_3584:()=>wDt,content_2251_3586:()=>MDt,content_2251_3588:()=>_Dt,content_2251_3590:()=>xDt,content_2251_3592:()=>CDt,content_2251_3594:()=>bDt,content_2251_3596:()=>ZDt,content_2251_3598:()=>SDt,content_2251_36:()=>Rg,content_2251_360:()=>Rv,content_2251_3600:()=>EDt,content_2251_3602:()=>zDt,content_2251_3604:()=>IDt,content_2251_3606:()=>WDt,content_2251_3608:()=>GDt,content_2251_3610:()=>jDt,content_2251_3612:()=>UDt,content_2251_3614:()=>HDt,content_2251_3616:()=>JDt,content_2251_3618:()=>KDt,content_2251_362:()=>Av,content_2251_3620:()=>t_t,content_2251_3622:()=>n_t,content_2251_3624:()=>s_t,content_2251_3626:()=>i_t,content_2251_3628:()=>a_t,content_2251_3630:()=>l_t,content_2251_3632:()=>m_t,content_2251_3634:()=>h_t,content_2251_3636:()=>f_t,content_2251_3638:()=>w_t,content_2251_364:()=>Pv,content_2251_3640:()=>M_t,content_2251_3642:()=>__t,content_2251_3644:()=>x_t,content_2251_3646:()=>C_t,content_2251_3648:()=>b_t,content_2251_3650:()=>Z_t,content_2251_3652:()=>S_t,content_2251_3654:()=>E_t,content_2251_3656:()=>z_t,content_2251_3658:()=>I_t,content_2251_366:()=>Fv,content_2251_3660:()=>W_t,content_2251_3662:()=>G_t,content_2251_3664:()=>j_t,content_2251_3666:()=>U_t,content_2251_3668:()=>H_t,content_2251_3670:()=>J_t,content_2251_3672:()=>K_t,content_2251_3674:()=>tXt,content_2251_3676:()=>nXt,content_2251_3678:()=>sXt,content_2251_368:()=>Bv,content_2251_3680:()=>iXt,content_2251_3682:()=>aXt,content_2251_3684:()=>lXt,content_2251_3686:()=>mXt,content_2251_3688:()=>hXt,content_2251_3690:()=>fXt,content_2251_3692:()=>wXt,content_2251_3694:()=>MXt,content_2251_3696:()=>_Xt,content_2251_3698:()=>xXt,content_2251_370:()=>Ov,content_2251_3700:()=>CXt,content_2251_3702:()=>bXt,content_2251_3704:()=>ZXt,content_2251_3706:()=>SXt,content_2251_3708:()=>EXt,content_2251_3710:()=>zXt,content_2251_3712:()=>IXt,content_2251_3714:()=>WXt,content_2251_3716:()=>GXt,content_2251_3718:()=>jXt,content_2251_372:()=>qv,content_2251_3720:()=>UXt,content_2251_3722:()=>HXt,content_2251_3724:()=>JXt,content_2251_3726:()=>KXt,content_2251_3728:()=>txt,content_2251_3730:()=>nxt,content_2251_3732:()=>sxt,content_2251_3734:()=>ixt,content_2251_3736:()=>axt,content_2251_3738:()=>lxt,content_2251_374:()=>Vv,content_2251_3740:()=>mxt,content_2251_3742:()=>hxt,content_2251_3744:()=>fxt,content_2251_3746:()=>wxt,content_2251_3748:()=>Mxt,content_2251_3750:()=>_xt,content_2251_3752:()=>xxt,content_2251_3754:()=>Cxt,content_2251_3756:()=>bxt,content_2251_3758:()=>Zxt,content_2251_376:()=>$v,content_2251_3760:()=>Sxt,content_2251_3762:()=>Ext,content_2251_3764:()=>zxt,content_2251_3766:()=>Ixt,content_2251_3768:()=>Wxt,content_2251_3770:()=>Gxt,content_2251_3772:()=>jxt,content_2251_3774:()=>Uxt,content_2251_3776:()=>Hxt,content_2251_3778:()=>Jxt,content_2251_378:()=>Yv,content_2251_3780:()=>Kxt,content_2251_3782:()=>tvt,content_2251_3784:()=>nvt,content_2251_3786:()=>svt,content_2251_3788:()=>ivt,content_2251_3790:()=>avt,content_2251_3792:()=>lvt,content_2251_3794:()=>mvt,content_2251_3796:()=>hvt,content_2251_3798:()=>fvt,content_2251_38:()=>Ag,content_2251_380:()=>Qv,content_2251_3800:()=>wvt,content_2251_3802:()=>Mvt,content_2251_3804:()=>_vt,content_2251_3806:()=>xvt,content_2251_3808:()=>Cvt,content_2251_3810:()=>bvt,content_2251_3812:()=>Zvt,content_2251_3814:()=>Svt,content_2251_3816:()=>Evt,content_2251_3818:()=>zvt,content_2251_382:()=>eC,content_2251_3820:()=>Ivt,content_2251_3822:()=>Wvt,content_2251_3824:()=>Gvt,content_2251_3826:()=>jvt,content_2251_3828:()=>Uvt,content_2251_3830:()=>Hvt,content_2251_3832:()=>Jvt,content_2251_3834:()=>Kvt,content_2251_3836:()=>tCt,content_2251_3838:()=>nCt,content_2251_384:()=>oC,content_2251_3840:()=>sCt,content_2251_3842:()=>iCt,content_2251_3844:()=>aCt,content_2251_3846:()=>lCt,content_2251_3848:()=>mCt,content_2251_3850:()=>hCt,content_2251_3852:()=>fCt,content_2251_3854:()=>wCt,content_2251_3856:()=>MCt,content_2251_3858:()=>_Ct,content_2251_386:()=>rC,content_2251_3860:()=>xCt,content_2251_3862:()=>CCt,content_2251_3864:()=>bCt,content_2251_3866:()=>ZCt,content_2251_3868:()=>SCt,content_2251_3870:()=>ECt,content_2251_3872:()=>zCt,content_2251_3874:()=>ICt,content_2251_3876:()=>WCt,content_2251_3878:()=>GCt,content_2251_388:()=>pC,content_2251_3880:()=>jCt,content_2251_3882:()=>UCt,content_2251_3884:()=>HCt,content_2251_3886:()=>JCt,content_2251_3888:()=>KCt,content_2251_3890:()=>tTt,content_2251_3892:()=>nTt,content_2251_3894:()=>sTt,content_2251_3896:()=>iTt,content_2251_3898:()=>aTt,content_2251_390:()=>cC,content_2251_3900:()=>lTt,content_2251_3902:()=>mTt,content_2251_3904:()=>hTt,content_2251_3906:()=>fTt,content_2251_3908:()=>wTt,content_2251_3910:()=>MTt,content_2251_3912:()=>_Tt,content_2251_3914:()=>xTt,content_2251_3916:()=>CTt,content_2251_3918:()=>bTt,content_2251_392:()=>uC,content_2251_3920:()=>ZTt,content_2251_3922:()=>STt,content_2251_3924:()=>ETt,content_2251_3926:()=>zTt,content_2251_3928:()=>ITt,content_2251_3930:()=>WTt,content_2251_3932:()=>GTt,content_2251_3934:()=>jTt,content_2251_3936:()=>UTt,content_2251_3938:()=>HTt,content_2251_394:()=>dC,content_2251_3940:()=>JTt,content_2251_3942:()=>KTt,content_2251_3944:()=>tbt,content_2251_3946:()=>nbt,content_2251_3948:()=>sbt,content_2251_3950:()=>ibt,content_2251_3952:()=>abt,content_2251_3954:()=>lbt,content_2251_3956:()=>mbt,content_2251_3958:()=>hbt,content_2251_396:()=>yC,content_2251_3960:()=>fbt,content_2251_3962:()=>wbt,content_2251_3964:()=>Mbt,content_2251_3966:()=>_bt,content_2251_3968:()=>xbt,content_2251_3970:()=>Cbt,content_2251_3972:()=>bbt,content_2251_3974:()=>Zbt,content_2251_3976:()=>Sbt,content_2251_3978:()=>Ebt,content_2251_398:()=>kC,content_2251_3980:()=>zbt,content_2251_3982:()=>Ibt,content_2251_3984:()=>Wbt,content_2251_3986:()=>Gbt,content_2251_3988:()=>jbt,content_2251_3990:()=>Ubt,content_2251_3992:()=>Hbt,content_2251_3994:()=>Jbt,content_2251_3996:()=>Kbt,content_2251_3998:()=>tLt,content_2251_4:()=>eg,content_2251_40:()=>Pg,content_2251_400:()=>gC,content_2251_4000:()=>nLt,content_2251_4002:()=>sLt,content_2251_4004:()=>iLt,content_2251_4006:()=>aLt,content_2251_4008:()=>lLt,content_2251_4010:()=>mLt,content_2251_4012:()=>hLt,content_2251_4014:()=>fLt,content_2251_4016:()=>wLt,content_2251_4018:()=>MLt,content_2251_402:()=>DC,content_2251_4020:()=>_Lt,content_2251_4022:()=>xLt,content_2251_4024:()=>CLt,content_2251_4026:()=>bLt,content_2251_4028:()=>ZLt,content_2251_4030:()=>SLt,content_2251_4032:()=>ELt,content_2251_4034:()=>zLt,content_2251_4036:()=>ILt,content_2251_4038:()=>WLt,content_2251_404:()=>XC,content_2251_4040:()=>GLt,content_2251_4042:()=>jLt,content_2251_4044:()=>ULt,content_2251_4046:()=>HLt,content_2251_4048:()=>JLt,content_2251_4050:()=>KLt,content_2251_4052:()=>tZt,content_2251_4054:()=>nZt,content_2251_4056:()=>sZt,content_2251_4058:()=>iZt,content_2251_406:()=>vC,content_2251_4060:()=>aZt,content_2251_4062:()=>lZt,content_2251_4064:()=>mZt,content_2251_4066:()=>hZt,content_2251_4068:()=>fZt,content_2251_4070:()=>wZt,content_2251_4072:()=>MZt,content_2251_4074:()=>_Zt,content_2251_4076:()=>xZt,content_2251_4078:()=>CZt,content_2251_408:()=>TC,content_2251_4080:()=>bZt,content_2251_4082:()=>ZZt,content_2251_4084:()=>SZt,content_2251_4086:()=>EZt,content_2251_4088:()=>zZt,content_2251_4090:()=>IZt,content_2251_4092:()=>WZt,content_2251_4094:()=>GZt,content_2251_4096:()=>jZt,content_2251_4098:()=>UZt,content_2251_410:()=>LC,content_2251_4100:()=>HZt,content_2251_4102:()=>JZt,content_2251_4104:()=>KZt,content_2251_4106:()=>tNt,content_2251_4108:()=>nNt,content_2251_4110:()=>sNt,content_2251_4112:()=>iNt,content_2251_4114:()=>aNt,content_2251_4116:()=>lNt,content_2251_4118:()=>mNt,content_2251_412:()=>NC,content_2251_4120:()=>hNt,content_2251_4122:()=>fNt,content_2251_4124:()=>wNt,content_2251_4126:()=>MNt,content_2251_4128:()=>_Nt,content_2251_4130:()=>xNt,content_2251_4132:()=>CNt,content_2251_4134:()=>bNt,content_2251_4136:()=>ZNt,content_2251_4138:()=>SNt,content_2251_414:()=>RC,content_2251_4140:()=>ENt,content_2251_4142:()=>zNt,content_2251_4144:()=>INt,content_2251_4146:()=>WNt,content_2251_4148:()=>GNt,content_2251_4150:()=>jNt,content_2251_4152:()=>UNt,content_2251_4154:()=>HNt,content_2251_4156:()=>JNt,content_2251_4158:()=>KNt,content_2251_416:()=>AC,content_2251_4160:()=>tSt,content_2251_4162:()=>nSt,content_2251_4164:()=>sSt,content_2251_4166:()=>iSt,content_2251_4168:()=>aSt,content_2251_4170:()=>lSt,content_2251_4172:()=>mSt,content_2251_4174:()=>hSt,content_2251_4176:()=>fSt,content_2251_4178:()=>wSt,content_2251_418:()=>PC,content_2251_4180:()=>MSt,content_2251_4182:()=>_St,content_2251_4184:()=>xSt,content_2251_4186:()=>CSt,content_2251_4188:()=>bSt,content_2251_4190:()=>ZSt,content_2251_4192:()=>SSt,content_2251_4194:()=>ESt,content_2251_4196:()=>zSt,content_2251_4198:()=>ISt,content_2251_42:()=>Fg,content_2251_420:()=>FC,content_2251_4200:()=>WSt,content_2251_4202:()=>GSt,content_2251_4204:()=>jSt,content_2251_4206:()=>USt,content_2251_4208:()=>HSt,content_2251_4210:()=>JSt,content_2251_4212:()=>KSt,content_2251_4214:()=>tRt,content_2251_4216:()=>nRt,content_2251_4218:()=>sRt,content_2251_422:()=>BC,content_2251_4220:()=>iRt,content_2251_4222:()=>aRt,content_2251_4224:()=>lRt,content_2251_4226:()=>mRt,content_2251_4228:()=>hRt,content_2251_4230:()=>fRt,content_2251_4232:()=>wRt,content_2251_4234:()=>MRt,content_2251_4236:()=>_Rt,content_2251_4238:()=>xRt,content_2251_424:()=>OC,content_2251_4240:()=>CRt,content_2251_4242:()=>bRt,content_2251_4244:()=>ZRt,content_2251_4246:()=>SRt,content_2251_4248:()=>ERt,content_2251_4250:()=>zRt,content_2251_4252:()=>IRt,content_2251_4254:()=>WRt,content_2251_4256:()=>GRt,content_2251_4258:()=>jRt,content_2251_426:()=>qC,content_2251_4260:()=>URt,content_2251_4262:()=>HRt,content_2251_4264:()=>JRt,content_2251_4266:()=>KRt,content_2251_428:()=>VC,content_2251_430:()=>$C,content_2251_432:()=>YC,content_2251_434:()=>QC,content_2251_436:()=>eT,content_2251_438:()=>oT,content_2251_44:()=>Bg,content_2251_440:()=>rT,content_2251_442:()=>pT,content_2251_444:()=>cT,content_2251_446:()=>uT,content_2251_448:()=>dT,content_2251_450:()=>yT,content_2251_452:()=>kT,content_2251_454:()=>gT,content_2251_456:()=>DT,content_2251_458:()=>XT,content_2251_46:()=>Og,content_2251_460:()=>vT,content_2251_462:()=>TT,content_2251_464:()=>LT,content_2251_466:()=>NT,content_2251_468:()=>RT,content_2251_470:()=>AT,content_2251_472:()=>PT,content_2251_474:()=>FT,content_2251_476:()=>BT,content_2251_478:()=>OT,content_2251_48:()=>qg,content_2251_480:()=>qT,content_2251_482:()=>VT,content_2251_484:()=>$T,content_2251_486:()=>YT,content_2251_488:()=>QT,content_2251_490:()=>eb,content_2251_492:()=>ob,content_2251_494:()=>rb,content_2251_496:()=>pb,content_2251_498:()=>cb,content_2251_50:()=>Vg,content_2251_500:()=>ub,content_2251_502:()=>db,content_2251_504:()=>yb,content_2251_506:()=>kb,content_2251_508:()=>gb,content_2251_510:()=>Db,content_2251_512:()=>Xb,content_2251_514:()=>vb,content_2251_516:()=>Tb,content_2251_518:()=>Lb,content_2251_52:()=>$g,content_2251_520:()=>Nb,content_2251_522:()=>Rb,content_2251_524:()=>Ab,content_2251_526:()=>Pb,content_2251_528:()=>Fb,content_2251_530:()=>Bb,content_2251_532:()=>Ob,content_2251_534:()=>qb,content_2251_536:()=>Vb,content_2251_538:()=>$b,content_2251_54:()=>Yg,content_2251_540:()=>Yb,content_2251_542:()=>Qb,content_2251_544:()=>eL,content_2251_546:()=>oL,content_2251_548:()=>rL,content_2251_550:()=>pL,content_2251_552:()=>cL,content_2251_554:()=>uL,content_2251_556:()=>dL,content_2251_558:()=>yL,content_2251_56:()=>Qg,content_2251_560:()=>kL,content_2251_562:()=>gL,content_2251_564:()=>DL,content_2251_566:()=>XL,content_2251_568:()=>vL,content_2251_570:()=>TL,content_2251_572:()=>LL,content_2251_574:()=>NL,content_2251_576:()=>RL,content_2251_578:()=>AL,content_2251_58:()=>eM,content_2251_580:()=>PL,content_2251_582:()=>FL,content_2251_584:()=>BL,content_2251_586:()=>OL,content_2251_588:()=>qL,content_2251_590:()=>VL,content_2251_592:()=>$L,content_2251_594:()=>YL,content_2251_596:()=>QL,content_2251_598:()=>eZ,content_2251_6:()=>og,content_2251_60:()=>oM,content_2251_600:()=>oZ,content_2251_602:()=>rZ,content_2251_604:()=>pZ,content_2251_606:()=>cZ,content_2251_608:()=>uZ,content_2251_610:()=>dZ,content_2251_612:()=>yZ,content_2251_614:()=>kZ,content_2251_616:()=>gZ,content_2251_618:()=>DZ,content_2251_62:()=>rM,content_2251_620:()=>XZ,content_2251_622:()=>vZ,content_2251_624:()=>TZ,content_2251_626:()=>LZ,content_2251_628:()=>NZ,content_2251_630:()=>RZ,content_2251_632:()=>AZ,content_2251_634:()=>PZ,content_2251_636:()=>FZ,content_2251_638:()=>BZ,content_2251_64:()=>pM,content_2251_640:()=>OZ,content_2251_642:()=>qZ,content_2251_644:()=>VZ,content_2251_646:()=>$Z,content_2251_648:()=>YZ,content_2251_650:()=>QZ,content_2251_652:()=>eN,content_2251_654:()=>oN,content_2251_656:()=>rN,content_2251_658:()=>pN,content_2251_66:()=>cM,content_2251_660:()=>cN,content_2251_662:()=>uN,content_2251_664:()=>dN,content_2251_666:()=>yN,content_2251_668:()=>kN,content_2251_670:()=>gN,content_2251_672:()=>DN,content_2251_674:()=>XN,content_2251_676:()=>vN,content_2251_678:()=>TN,content_2251_68:()=>uM,content_2251_680:()=>LN,content_2251_682:()=>NN,content_2251_684:()=>RN,content_2251_686:()=>AN,content_2251_688:()=>PN,content_2251_690:()=>FN,content_2251_692:()=>BN,content_2251_694:()=>ON,content_2251_696:()=>qN,content_2251_698:()=>VN,content_2251_70:()=>dM,content_2251_700:()=>$N,content_2251_702:()=>YN,content_2251_704:()=>QN,content_2251_706:()=>eS,content_2251_708:()=>oS,content_2251_710:()=>rS,content_2251_712:()=>pS,content_2251_714:()=>cS,content_2251_716:()=>uS,content_2251_718:()=>dS,content_2251_72:()=>yM,content_2251_720:()=>yS,content_2251_722:()=>kS,content_2251_724:()=>gS,content_2251_726:()=>DS,content_2251_728:()=>XS,content_2251_730:()=>vS,content_2251_732:()=>TS,content_2251_734:()=>LS,content_2251_736:()=>NS,content_2251_738:()=>RS,content_2251_74:()=>kM,content_2251_740:()=>AS,content_2251_742:()=>PS,content_2251_744:()=>FS,content_2251_746:()=>BS,content_2251_748:()=>OS,content_2251_750:()=>qS,content_2251_752:()=>VS,content_2251_754:()=>$S,content_2251_756:()=>YS,content_2251_758:()=>QS,content_2251_76:()=>gM,content_2251_760:()=>eR,content_2251_762:()=>oR,content_2251_764:()=>rR,content_2251_766:()=>pR,content_2251_768:()=>cR,content_2251_770:()=>uR,content_2251_772:()=>dR,content_2251_774:()=>yR,content_2251_776:()=>kR,content_2251_778:()=>gR,content_2251_78:()=>DM,content_2251_780:()=>DR,content_2251_782:()=>XR,content_2251_784:()=>vR,content_2251_786:()=>TR,content_2251_788:()=>LR,content_2251_790:()=>NR,content_2251_792:()=>RR,content_2251_794:()=>AR,content_2251_796:()=>PR,content_2251_798:()=>FR,content_2251_8:()=>rg,content_2251_80:()=>XM,content_2251_800:()=>BR,content_2251_802:()=>OR,content_2251_804:()=>qR,content_2251_806:()=>VR,content_2251_808:()=>$R,content_2251_810:()=>YR,content_2251_812:()=>QR,content_2251_814:()=>eE,content_2251_816:()=>oE,content_2251_818:()=>rE,content_2251_82:()=>vM,content_2251_820:()=>pE,content_2251_822:()=>cE,content_2251_824:()=>uE,content_2251_826:()=>dE,content_2251_828:()=>yE,content_2251_830:()=>kE,content_2251_832:()=>gE,content_2251_834:()=>DE,content_2251_836:()=>XE,content_2251_838:()=>vE,content_2251_84:()=>TM,content_2251_840:()=>TE,content_2251_842:()=>LE,content_2251_844:()=>NE,content_2251_846:()=>RE,content_2251_848:()=>AE,content_2251_850:()=>PE,content_2251_852:()=>FE,content_2251_854:()=>BE,content_2251_856:()=>OE,content_2251_858:()=>qE,content_2251_86:()=>LM,content_2251_860:()=>VE,content_2251_862:()=>$E,content_2251_864:()=>YE,content_2251_866:()=>QE,content_2251_868:()=>eA,content_2251_870:()=>oA,content_2251_872:()=>rA,content_2251_874:()=>pA,content_2251_876:()=>cA,content_2251_878:()=>uA,content_2251_88:()=>NM,content_2251_880:()=>dA,content_2251_882:()=>yA,content_2251_884:()=>kA,content_2251_886:()=>gA,content_2251_888:()=>DA,content_2251_890:()=>XA,content_2251_892:()=>vA,content_2251_894:()=>TA,content_2251_896:()=>LA,content_2251_898:()=>NA,content_2251_90:()=>RM,content_2251_900:()=>RA,content_2251_902:()=>AA,content_2251_904:()=>PA,content_2251_906:()=>FA,content_2251_908:()=>BA,content_2251_910:()=>OA,content_2251_912:()=>qA,content_2251_914:()=>VA,content_2251_916:()=>$A,content_2251_918:()=>YA,content_2251_92:()=>AM,content_2251_920:()=>QA,content_2251_922:()=>ez,content_2251_924:()=>oz,content_2251_926:()=>rz,content_2251_928:()=>pz,content_2251_930:()=>cz,content_2251_932:()=>uz,content_2251_934:()=>dz,content_2251_936:()=>yz,content_2251_938:()=>kz,content_2251_94:()=>PM,content_2251_940:()=>gz,content_2251_942:()=>Dz,content_2251_944:()=>Xz,content_2251_946:()=>vz,content_2251_948:()=>Tz,content_2251_950:()=>Lz,content_2251_952:()=>Nz,content_2251_954:()=>Rz,content_2251_956:()=>Az,content_2251_958:()=>Pz,content_2251_96:()=>FM,content_2251_960:()=>Fz,content_2251_962:()=>Bz,content_2251_964:()=>Oz,content_2251_966:()=>qz,content_2251_968:()=>Vz,content_2251_970:()=>$z,content_2251_972:()=>Yz,content_2251_974:()=>Qz,content_2251_976:()=>eP,content_2251_978:()=>oP,content_2251_98:()=>BM,content_2251_980:()=>rP,content_2251_982:()=>pP,content_2251_984:()=>cP,content_2251_986:()=>uP,content_2251_988:()=>dP,content_2251_990:()=>yP,content_2251_992:()=>kP,content_2251_994:()=>gP,content_2251_996:()=>DP,content_2251_998:()=>XP});var s=n(2784),r=n(7896),i=n(30876);const p={toc:[]};function a(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Property decorators."))}a.isMDXComponent=!0;const c={toc:[]};function l(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,i.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a lazy decorator."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A function that returns the value of this property."))}h.isMDXComponent=!0;const y={toc:[]};function f(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},y,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscriptions and triggering of events."))}f.isMDXComponent=!0;const k={toc:[]};function w(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},k,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,i.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}w.isMDXComponent=!0;const g={toc:[]};function M(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}M.isMDXComponent=!0;const D={toc:[]};function _(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},D,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Dispatches an asynchronous ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,i.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}_.isMDXComponent=!0;const X={toc:[]};function x(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},X,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe all subscribers from the event."))}x.isMDXComponent=!0;const v={toc:[]};function C(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},v,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A callback function that cancels the subscription."))}C.isMDXComponent=!0;const T={toc:[]};function b(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},T,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."))}b.isMDXComponent=!0;const L={toc:[]};function Z(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},L,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}Z.isMDXComponent=!0;const N={toc:[]};function S(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},N,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}S.isMDXComponent=!0;const R={toc:[]};function E(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},R,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}E.isMDXComponent=!0;const A={toc:[]};function z(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},A,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the argument passed to subscribers."))}z.isMDXComponent=!0;const P={toc:[]};function I(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},P,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}I.isMDXComponent=!0;const F={toc:[]};function W(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},F,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Dispatches a ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,i.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}W.isMDXComponent=!0;const B={toc:[]};function G(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},B,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe all subscribers from the event."))}G.isMDXComponent=!0;const O={toc:[]};function j(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},O,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A callback function that cancels the subscription."))}j.isMDXComponent=!0;const q={toc:[]};function U(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."))}U.isMDXComponent=!0;const V={toc:[]};function H(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},V,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}H.isMDXComponent=!0;const $={toc:[]};function J(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}J.isMDXComponent=!0;const Y={toc:[]};function K(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Y,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}K.isMDXComponent=!0;const Q={toc:[]};function tt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Q,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the value argument to subscribers."))}tt.isMDXComponent=!0;const et={toc:[]};function nt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},et,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A base for dispatching ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,i.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}nt.isMDXComponent=!0;const ot={toc:[]};function st(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe all subscribers from the event."))}st.isMDXComponent=!0;const rt={toc:[]};function it(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A callback function that cancels the subscription."))}it.isMDXComponent=!0;const pt={toc:[]};function at(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."))}at.isMDXComponent=!0;const ct={toc:[]};function lt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}ht.isMDXComponent=!0;const yt={toc:[]};function ft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the argument passed to subscribers."))}ft.isMDXComponent=!0;const kt={toc:[]};function wt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the callback function."))}wt.isMDXComponent=!0;const gt={toc:[]};function Mt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,i.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,i.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}Mt.isMDXComponent=!0;const Dt={toc:[]};function _t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}_t.isMDXComponent=!0;const Xt={toc:[]};function xt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Dispatches a ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,i.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}xt.isMDXComponent=!0;const vt={toc:[]};function Ct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe all subscribers from the event."))}Ct.isMDXComponent=!0;const Tt={toc:[]};function bt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Are subscribers being notified?"))}bt.isMDXComponent=!0;const Lt={toc:[]};function Zt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Notify all current and future subscribers."))}Zt.isMDXComponent=!0;const Nt={toc:[]};function St(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Stop notifying future subscribers."))}St.isMDXComponent=!0;const Rt={toc:[]};function Et(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A callback function that cancels the subscription."))}Et.isMDXComponent=!0;const At={toc:[]};function zt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},At,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."))}zt.isMDXComponent=!0;const Pt={toc:[]};function It(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}It.isMDXComponent=!0;const Ft={toc:[]};function Wt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}Wt.isMDXComponent=!0;const Bt={toc:[]};function Gt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}Gt.isMDXComponent=!0;const Ot={toc:[]};function jt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}jt.isMDXComponent=!0;const qt={toc:[]};function Ut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provides safe access to the public interface of ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,i.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Ut.isMDXComponent=!0;const Vt={toc:[]};function Ht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A callback function that cancels the subscription."))}Ht.isMDXComponent=!0;const $t={toc:[]};function Jt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."))}Jt.isMDXComponent=!0;const Yt={toc:[]};function Kt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}Kt.isMDXComponent=!0;const Qt={toc:[]};function te(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}te.isMDXComponent=!0;const ee={toc:[]};function ne(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ee,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}ne.isMDXComponent=!0;const oe={toc:[]};function se(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the argument passed to subscribers."))}se.isMDXComponent=!0;const re={toc:[]};function ie(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},re,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the callback function."))}ie.isMDXComponent=!0;const pe={toc:[]};function ae(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ae.isMDXComponent=!0;const ce={toc:[]};function le(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ce,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provides safe access to the public interface of ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,i.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}le.isMDXComponent=!0;const ue={toc:[]};function me(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ue,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the most recent value of this dispatcher."))}me.isMDXComponent=!0;const de={toc:[]};function he(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},de,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Callback function that cancels the subscription."))}he.isMDXComponent=!0;const ye={toc:[]};function fe(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ye,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."),(0,i.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}fe.isMDXComponent=!0;const ke={toc:[]};function we(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ke,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}we.isMDXComponent=!0;const ge={toc:[]};function Me(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ge,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Me.isMDXComponent=!0;const De={toc:[]};function _e(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},De,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Callback function that cancels the subscription."))}_e.isMDXComponent=!0;const Xe={toc:[]};function xe(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."),(0,i.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}xe.isMDXComponent=!0;const ve={toc:[]};function Ce(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ve,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}Ce.isMDXComponent=!0;const Te={toc:[]};function be(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Te,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}be.isMDXComponent=!0;const Le={toc:[]};function Ze(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Le,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the value passed to subscribers."))}Ze.isMDXComponent=!0;const Ne={toc:[]};function Se(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ne,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}Se.isMDXComponent=!0;const Re={toc:[]};function Ee(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Re,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Ee.isMDXComponent=!0;const Ae={toc:[]};function ze(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ae,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Dispatches a ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,i.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}ze.isMDXComponent=!0;const Pe={toc:[]};function Ie(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The initial value."))}Ie.isMDXComponent=!0;const Fe={toc:[]};function We(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the most recent value of this dispatcher."))}We.isMDXComponent=!0;const Be={toc:[]};function Ge(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Be,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Setting the value will immediately notify all subscribers."))}Ge.isMDXComponent=!0;const Oe={toc:[]};function je(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Set the current value of this dispatcher."))}je.isMDXComponent=!0;const qe={toc:[]};function Ue(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new value."))}Ue.isMDXComponent=!0;const Ve={toc:[]};function He(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ve,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe all subscribers from the event."))}He.isMDXComponent=!0;const $e={toc:[]};function Je(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$e,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Callback function that cancels the subscription."))}Je.isMDXComponent=!0;const Ye={toc:[]};function Ke(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ye,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."),(0,i.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ke.isMDXComponent=!0;const Qe={toc:[]};function tn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}tn.isMDXComponent=!0;const en={toc:[]};function nn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},en,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}nn.isMDXComponent=!0;const on={toc:[]};function sn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},on,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}sn.isMDXComponent=!0;const rn={toc:[]};function pn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}pn.isMDXComponent=!0;const an={toc:[]};function cn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},an,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the value passed to subscribers."))}cn.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ln,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provides safe access to the public interface of ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,i.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}dn.isMDXComponent=!0;const hn={toc:[]};function yn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the argument passed to subscribers."))}yn.isMDXComponent=!0;const fn={toc:[]};function kn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}kn.isMDXComponent=!0;const wn={toc:[]};function gn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provides safe access to the public interface of ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,i.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}gn.isMDXComponent=!0;const Mn={toc:[]};function Dn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the argument passed to subscribers."))}Dn.isMDXComponent=!0;const _n={toc:[]};function Xn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_n,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Xn.isMDXComponent=!0;const xn={toc:[]};function vn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provides safe access to the public interface of ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,i.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}vn.isMDXComponent=!0;const Cn={toc:[]};function Tn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}Tn.isMDXComponent=!0;const bn={toc:[]};function Ln(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The amount of times the timer has ticked."))}Ln.isMDXComponent=!0;const Zn={toc:[]};function Nn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The generator responsible for running this timer."))}Nn.isMDXComponent=!0;const Sn={toc:[]};function Rn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait until the timer ticks."))}Rn.isMDXComponent=!0;const En={toc:[]};function An(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},En,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The current iteration index."))}An.isMDXComponent=!0;const zn={toc:[]};function Pn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Pn.isMDXComponent=!0;const In={toc:[]};function Fn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},In,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Fn.isMDXComponent=!0;const Wn={toc:[]};function Bn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to run."))}Bn.isMDXComponent=!0;const Gn={toc:[]};function On(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}On.isMDXComponent=!0;const jn={toc:[]};function qn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}qn.isMDXComponent=!0;const Un={toc:[]};function Vn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Un,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to run."))}Vn.isMDXComponent=!0;const Hn={toc:[]};function $n(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,i.kt)("p",null,"Note that the same animation can be written as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,i.kt)("p",null,"The reason ",(0,i.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}$n.isMDXComponent=!0;const Jn={toc:[]};function Yn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Run tasks one after another."))}Yn.isMDXComponent=!0;const Kn={toc:[]};function Qn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to run."))}Qn.isMDXComponent=!0;const to={toc:[]};function eo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},to,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,i.kt)("p",null,"Note that the same animation can be written as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,i.kt)("p",null,"The reason ",(0,i.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}eo.isMDXComponent=!0;const no={toc:[]};function oo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},no,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}oo.isMDXComponent=!0;const so={toc:[]};function ro(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},so,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The delay in seconds"))}ro.isMDXComponent=!0;const io={toc:[]};function po(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},io,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The task or callback to run after the delay."))}po.isMDXComponent=!0;const ao={toc:[]};function co(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ao,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}co.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Call the given callback every N seconds."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The interval between subsequent calls."))}ho.isMDXComponent=!0;const yo={toc:[]};function fo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The callback to be called."))}fo.isMDXComponent=!0;const ko={toc:[]};function wo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ko,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Each time iteration waits until the previous one is completed."))}wo.isMDXComponent=!0;const go={toc:[]};function Mo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},go,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n});\n")))}Mo.isMDXComponent=!0;const Do={toc:[]};function _o(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Do,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Run the given generator N times."))}_o.isMDXComponent=!0;const Xo={toc:[]};function xo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The number of iterations."))}xo.isMDXComponent=!0;const vo={toc:[]};function Co(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each iteration."))}Co.isMDXComponent=!0;const To={toc:[]};function bo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},To,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Do nothing."))}bo.isMDXComponent=!0;const Lo={toc:[]};function Zo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Zo.isMDXComponent=!0;const No={toc:[]};function So(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},No,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Turn the given generator function into a threadable generator."))}So.isMDXComponent=!0;const Ro={toc:[]};function Eo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ro,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A generator function or a factory that creates the generator."))}Eo.isMDXComponent=!0;const Ao={toc:[]};function zo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ao,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}zo.isMDXComponent=!0;const Po={toc:[]};function Io(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Po,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Turn the given generator function into a threadable generator."))}Io.isMDXComponent=!0;const Fo={toc:[]};function Wo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An optional name used when displaying this generator in the UI."))}Wo.isMDXComponent=!0;const Bo={toc:[]};function Go(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A generator function or a factory that creates the generator."))}Go.isMDXComponent=!0;const Oo={toc:[]};function jo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}jo.isMDXComponent=!0;const qo={toc:[]};function Uo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Uo.isMDXComponent=!0;const Vo={toc:[]};function Ho(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Start all tasks one after another with a constant delay between."))}Ho.isMDXComponent=!0;const $o={toc:[]};function Jo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$o,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The delay between each of the tasks."))}Jo.isMDXComponent=!0;const Yo={toc:[]};function Ko(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to be run in a sequence."))}Ko.isMDXComponent=!0;const Qo={toc:[]};function ts(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}ts.isMDXComponent=!0;const es={toc:[]};function ns(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},es,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for the given amount of time."))}ns.isMDXComponent=!0;const os={toc:[]};function ss(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},os,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The relative time in seconds."))}ss.isMDXComponent=!0;const rs={toc:[]};function is(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An optional task to be run after the function completes."))}is.isMDXComponent=!0;const ps={toc:[]};function as(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ps,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}as.isMDXComponent=!0;const cs={toc:[]};function ls(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},us,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait until the given time event."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ds,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The name of the time event."))}hs.isMDXComponent=!0;const ys={toc:[]};function fs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ys,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An optional task to be run after the function completes."))}fs.isMDXComponent=!0;const ks={toc:[]};function ws(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ks,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Multi-media management."))}ws.isMDXComponent=!0;const gs={toc:[]};function Ms(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Ms.isMDXComponent=!0;const Ds={toc:[]};function _s(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ds,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Pause/resume the audio."))}_s.isMDXComponent=!0;const Xs={toc:[]};function xs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the audio should be paused or resumed."))}xs.isMDXComponent=!0;const vs={toc:[]};function Cs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The absolute biggest value from the peaks array."))}Cs.isMDXComponent=!0;const Ts={toc:[]};function bs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ts,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The amount of samples taken."))}bs.isMDXComponent=!0;const Ls={toc:[]};function Zs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ls,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Zs.isMDXComponent=!0;const Ns={toc:[]};function Ss(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ns,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Samples per seconds."))}Ss.isMDXComponent=!0;const Rs={toc:[]};function Es(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Abstract scene representations and related utilities."))}Es.isMDXComponent=!0;const As={toc:[]};function zs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},As,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Signifies the various stages of a ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,i.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}zs.isMDXComponent=!0;const Ps={toc:[]};function Is(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ps,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Occurs after a render ends."))}Is.isMDXComponent=!0;const Fs={toc:[]};function Ws(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}Ws.isMDXComponent=!0;const Bs={toc:[]};function Gs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,i.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}Gs.isMDXComponent=!0;const Os={toc:[]};function js(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Os,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,i.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}js.isMDXComponent=!0;const qs={toc:[]};function Us(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Describes the state of a scene."))}Us.isMDXComponent=!0;const Vs={toc:[]};function Hs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}Hs.isMDXComponent=!0;const $s={toc:[]};function Js(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$s,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene has finished transitioning in."))}Js.isMDXComponent=!0;const Ys={toc:[]};function Ks(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ys,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,i.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,i.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}Ks.isMDXComponent=!0;const Qs={toc:[]};function tr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene is ready to transition out."))}tr.isMDXComponent=!0;const er={toc:[]};function nr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},er,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Invoking ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,i.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}nr.isMDXComponent=!0;const or={toc:[]};function sr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},or,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene has finished."))}sr.isMDXComponent=!0;const rr={toc:[]};function ir(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene has just been created/reset."))}ir.isMDXComponent=!0;const pr={toc:[]};function ar(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The default implementation of the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,i.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,i.kt)("p",null,"Uses generators to control the animation."))}ar.isMDXComponent=!0;const cr={toc:[]};function lr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will be passed as the second argument to the constructor."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ur,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Name of the scene."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reference to the project."))}hr.isMDXComponent=!0;const yr={toc:[]};function fr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,i.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}fr.isMDXComponent=!0;const kr={toc:[]};function wr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,i.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}wr.isMDXComponent=!0;const gr={toc:[]};function Mr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The frame at which this scene starts."))}Mr.isMDXComponent=!0;const Dr={toc:[]};function _r(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The frame at which this scene ends."))}_r.isMDXComponent=!0;const Xr={toc:[]};function xr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the cached data changes."))}xr.isMDXComponent=!0;const vr={toc:[]};function Cr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered after scene is recalculated."))}Cr.isMDXComponent=!0;const Tr={toc:[]};function br(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the scene is reloaded."))}br.isMDXComponent=!0;const Lr={toc:[]};function Zr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Zr.isMDXComponent=!0;const Nr={toc:[]};function Sr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the scene is reset."))}Sr.isMDXComponent=!0;const Rr={toc:[]};function Er(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the main thread changes."))}Er.isMDXComponent=!0;const Ar={toc:[]};function zr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ar,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}zr.isMDXComponent=!0;const Pr={toc:[]};function Ir(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,i.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Ir.isMDXComponent=!0;const Fr={toc:[]};function Wr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,i.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Wr.isMDXComponent=!0;const Br={toc:[]};function Gr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Br,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,i.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}Gr.isMDXComponent=!0;const Or={toc:[]};function jr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Or,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,i.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}jr.isMDXComponent=!0;const qr={toc:[]};function Ur(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}Ur.isMDXComponent=!0;const Vr={toc:[]};function Hr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Invoke the given callback in the context of this scene."))}Hr.isMDXComponent=!0;const $r={toc:[]};function Jr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$r,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The callback to invoke."))}Jr.isMDXComponent=!0;const Yr={toc:[]};function Kr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the size of this scene."),(0,i.kt)("p",null,"Usually return ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}Kr.isMDXComponent=!0;const Qr={toc:[]};function ti(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,i.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}ti.isMDXComponent=!0;const ei={toc:[]};function ni(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ei,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene cached?"),(0,i.kt)("p",null,"Used only by ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,i.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,i.kt)("p",null,"Should always return ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}ni.isMDXComponent=!0;const oi={toc:[]};function si(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,i.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}si.isMDXComponent=!0;const ri={toc:[]};function ii(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ri,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Progress this scene one frame forward."))}ii.isMDXComponent=!0;const pi={toc:[]};function ai(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,i.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,i.kt)("p",null,"At the end of execution, this method should set ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,i.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,i.kt)("p",null,"Should trigger ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,i.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}ai.isMDXComponent=!0;const ci={toc:[]};function li(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ci,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Recalculate the scene."))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ui,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,i.kt)("p",null,"Should trigger ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,i.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},di,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reload the scene."))}hi.isMDXComponent=!0;const yi={toc:[]};function fi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If present, an updated version of the description."))}fi.isMDXComponent=!0;const ki={toc:[]};function wi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ki,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render the scene onto a canvas."))}wi.isMDXComponent=!0;const gi={toc:[]};function Mi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to used when rendering."))}Mi.isMDXComponent=!0;const Di={toc:[]};function _i(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Di,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset this scene to its initial state."))}_i.isMDXComponent=!0;const Xi={toc:[]};function xi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If present, the previous scene."))}xi.isMDXComponent=!0;const vi={toc:[]};function Ci(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the view."),(0,i.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,i.kt)("p",null,"Can modify the state of the view."))}Ci.isMDXComponent=!0;const Ti={toc:[]};function bi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ti,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Lifecycle events for ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,i.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}bi.isMDXComponent=!0;const Li={toc:[]};function Zi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Li,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A random number generator based on\n",(0,i.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,i.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Zi.isMDXComponent=!0;const Ni={toc:[]};function Si(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ni,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get an array filled with random floats in the given range."))}Si.isMDXComponent=!0;const Ri={toc:[]};function Ei(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ri,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The size of the array."))}Ei.isMDXComponent=!0;const Ai={toc:[]};function zi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ai,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."))}zi.isMDXComponent=!0;const Pi={toc:[]};function Ii(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range."))}Ii.isMDXComponent=!0;const Fi={toc:[]};function Wi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get an array filled with random integers in the given range."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"}),(0,i.kt)("li",{parentName:"ul"})))}Wi.isMDXComponent=!0;const Bi={toc:[]};function Gi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The size of the array."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"})))}Gi.isMDXComponent=!0;const Oi={toc:[]};function ji(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"})))}ji.isMDXComponent=!0;const qi={toc:[]};function Ui(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range. Exclusive."))}Ui.isMDXComponent=!0;const Vi={toc:[]};function Hi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the next random float in the given range."))}Hi.isMDXComponent=!0;const $i={toc:[]};function Ji(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$i,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."))}Ji.isMDXComponent=!0;const Yi={toc:[]};function Ki(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range."))}Ki.isMDXComponent=!0;const Qi={toc:[]};function tp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the next random integer in the given range."))}tp.isMDXComponent=!0;const ep={toc:[]};function np(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ep,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."))}np.isMDXComponent=!0;const op={toc:[]};function sp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},op,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range. Exclusive."))}sp.isMDXComponent=!0;const rp={toc:[]};function ip(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a new independent generator."))}ip.isMDXComponent=!0;const pp={toc:[]};function ap(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get variable signal if exists or create signal if not"))}ap.isMDXComponent=!0;const cp={toc:[]};function lp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The name of the variable."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},up,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get variable signal if exists or create signal if not"))}hp.isMDXComponent=!0;const yp={toc:[]};function fp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset all stored signals."))}fp.isMDXComponent=!0;const kp={toc:[]};function wp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update all signals with new project variable values."))}wp.isMDXComponent=!0;const gp={toc:[]};function Mp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Describes cached information about the timing of a scene."))}Mp.isMDXComponent=!0;const Dp={toc:[]};function _p(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Describes a complete scene together with the meta file."))}_p.isMDXComponent=!0;const Xp={toc:[]};function xp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Configuration object."))}xp.isMDXComponent=!0;const vp={toc:[]};function Cp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The class used to instantiate the scene."))}Cp.isMDXComponent=!0;const Tp={toc:[]};function bp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The stack trace at the moment of creation."))}bp.isMDXComponent=!0;const Lp={toc:[]};function Zp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the configuration object."))}Zp.isMDXComponent=!0;const Np={toc:[]};function Sp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Np,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Sp.isMDXComponent=!0;const Rp={toc:[]};function Ep(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}Ep.isMDXComponent=!0;const Ap={toc:[]};function zp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ap,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for the inspected element."))}zp.isMDXComponent=!0;const Pp={toc:[]};function Ip(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The element for which to draw an overlay."))}Ip.isMDXComponent=!0;const Fp={toc:[]};function Wp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}Wp.isMDXComponent=!0;const Bp={toc:[]};function Gp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Gp.isMDXComponent=!0;const Op={toc:[]};function jp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Op,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}jp.isMDXComponent=!0;const qp={toc:[]};function Up(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the attributes of the inspected element."))}Up.isMDXComponent=!0;const Vp={toc:[]};function Hp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The element to inspect."))}Hp.isMDXComponent=!0;const $p={toc:[]};function Jp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$p,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a possible element to inspect at a given position."))}Jp.isMDXComponent=!0;const Yp={toc:[]};function Kp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The x coordinate."))}Kp.isMDXComponent=!0;const Qp={toc:[]};function ta(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The y coordinate."))}ta.isMDXComponent=!0;const ea={toc:[]};function na(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ea,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}na.isMDXComponent=!0;const oa={toc:[]};function sa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the inspected element is still valid."))}sa.isMDXComponent=!0;const ra={toc:[]};function ia(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ra,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The element to validate."))}ia.isMDXComponent=!0;const pa={toc:[]};function aa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,i.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}aa.isMDXComponent=!0;const ca={toc:[]};function la(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ca,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The main interface for scenes."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ua,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will be passed as the second argument to the constructor."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},da,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Name of the scene."))}ha.isMDXComponent=!0;const ya={toc:[]};function fa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ya,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reference to the project."))}fa.isMDXComponent=!0;const ka={toc:[]};function wa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ka,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,i.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}wa.isMDXComponent=!0;const ga={toc:[]};function Ma(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ga,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,i.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Ma.isMDXComponent=!0;const Da={toc:[]};function _a(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Da,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The frame at which this scene starts."))}_a.isMDXComponent=!0;const Xa={toc:[]};function xa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The frame at which this scene ends."))}xa.isMDXComponent=!0;const va={toc:[]};function Ca(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},va,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,i.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Ca.isMDXComponent=!0;const Ta={toc:[]};function ba(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ta,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the cached data changes."))}ba.isMDXComponent=!0;const La={toc:[]};function Za(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},La,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered after scene is recalculated."))}Za.isMDXComponent=!0;const Na={toc:[]};function Sa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Na,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the scene is reloaded."))}Sa.isMDXComponent=!0;const Ra={toc:[]};function Ea(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ra,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Ea.isMDXComponent=!0;const Aa={toc:[]};function za(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Aa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the scene is reset."))}za.isMDXComponent=!0;const Pa={toc:[]};function Ia(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Ia.isMDXComponent=!0;const Fa={toc:[]};function Wa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,i.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Wa.isMDXComponent=!0;const Ba={toc:[]};function Ga(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ba,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,i.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Ga.isMDXComponent=!0;const Oa={toc:[]};function ja(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,i.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}ja.isMDXComponent=!0;const qa={toc:[]};function Ua(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,i.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}Ua.isMDXComponent=!0;const Va={toc:[]};function Ha(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Va,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the size of this scene."),(0,i.kt)("p",null,"Usually return ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}Ha.isMDXComponent=!0;const $a={toc:[]};function Ja(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$a,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,i.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}Ja.isMDXComponent=!0;const Ya={toc:[]};function Ka(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ya,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene cached?"),(0,i.kt)("p",null,"Used only by ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,i.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,i.kt)("p",null,"Should always return ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}Ka.isMDXComponent=!0;const Qa={toc:[]};function tc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,i.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}tc.isMDXComponent=!0;const ec={toc:[]};function nc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ec,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Progress this scene one frame forward."))}nc.isMDXComponent=!0;const oc={toc:[]};function sc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,i.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,i.kt)("p",null,"At the end of execution, this method should set ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,i.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,i.kt)("p",null,"Should trigger ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,i.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}sc.isMDXComponent=!0;const rc={toc:[]};function ic(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Recalculate the scene."))}ic.isMDXComponent=!0;const pc={toc:[]};function ac(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,i.kt)("p",null,"Should trigger ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,i.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}ac.isMDXComponent=!0;const cc={toc:[]};function lc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reload the scene."))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If present, an updated version of the description."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render the scene onto a canvas."))}hc.isMDXComponent=!0;const yc={toc:[]};function fc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to used when rendering."))}fc.isMDXComponent=!0;const kc={toc:[]};function wc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset this scene to its initial state."))}wc.isMDXComponent=!0;const gc={toc:[]};function Mc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If present, the previous scene."))}Mc.isMDXComponent=!0;const Dc={toc:[]};function _c(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the configuration object."))}_c.isMDXComponent=!0;const Xc={toc:[]};function xc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Each class implementing the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,i.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}xc.isMDXComponent=!0;const vc={toc:[]};function Cc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constructor used when creating new scenes."))}Cc.isMDXComponent=!0;const Tc={toc:[]};function bc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,i.kt)("inlineCode",{parentName:"a"},"config")),"."))}bc.isMDXComponent=!0;const Lc={toc:[]};function Zc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Describes a scene exposed by scene files."))}Zc.isMDXComponent=!0;const Nc={toc:[]};function Sc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Configuration object."))}Sc.isMDXComponent=!0;const Rc={toc:[]};function Ec(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The class used to instantiate the scene."))}Ec.isMDXComponent=!0;const Ac={toc:[]};function zc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ac,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The stack trace at the moment of creation."))}zc.isMDXComponent=!0;const Pc={toc:[]};function Ic(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the configuration object."))}Ic.isMDXComponent=!0;const Fc={toc:[]};function Wc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A part of the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,i.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}Wc.isMDXComponent=!0;const Bc={toc:[]};function Gc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the configuration object."))}Gc.isMDXComponent=!0;const Oc={toc:[]};function jc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}jc.isMDXComponent=!0;const qc={toc:[]};function Uc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}Uc.isMDXComponent=!0;const Vc={toc:[]};function Hc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the main thread changes."))}Hc.isMDXComponent=!0;const $c={toc:[]};function Jc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$c,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents attributes of an inspected element."))}Jc.isMDXComponent=!0;const Yc={toc:[]};function Kc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}Kc.isMDXComponent=!0;const Qc={toc:[]};function tl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents an element to inspect."))}tl.isMDXComponent=!0;const el={toc:[]};function nl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},el,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A runtime representation of the scene metadata."))}nl.isMDXComponent=!0;const ol={toc:[]};function sl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ol,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a runtime representation of the scene metadata."))}sl.isMDXComponent=!0;const rl={toc:[]};function il(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}il.isMDXComponent=!0;const pl={toc:[]};function al(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}al.isMDXComponent=!0;const cl={toc:[]};function ll(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the signal is currently using its initial value."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ul,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,i.kt)("p",null,"This method can be used to create copies of signals."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}hl.isMDXComponent=!0;const yl={toc:[]};function fl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the raw value of this signal."))}fl.isMDXComponent=!0;const kl={toc:[]};function wl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}wl.isMDXComponent=!0;const gl={toc:[]};function Ml(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Ml.isMDXComponent=!0;const Dl={toc:[]};function _l(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}_l.isMDXComponent=!0;const Xl={toc:[]};function xl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}xl.isMDXComponent=!0;const vl={toc:[]};function Cl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Cl.isMDXComponent=!0;const Tl={toc:[]};function bl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}bl.isMDXComponent=!0;const Ll={toc:[]};function Zl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ll,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the signal is currently using its initial value."))}Zl.isMDXComponent=!0;const Nl={toc:[]};function Sl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,i.kt)("p",null,"This method can be used to create copies of signals."))}Sl.isMDXComponent=!0;const Rl={toc:[]};function El(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}El.isMDXComponent=!0;const Al={toc:[]};function zl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Al,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the raw value of this signal."))}zl.isMDXComponent=!0;const Pl={toc:[]};function Il(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Il.isMDXComponent=!0;const Fl={toc:[]};function Wl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Wl.isMDXComponent=!0;const Bl={toc:[]};function Gl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Gl.isMDXComponent=!0;const Ol={toc:[]};function jl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ol,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}jl.isMDXComponent=!0;const ql={toc:[]};function Ul(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ql,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Ul.isMDXComponent=!0;const Vl={toc:[]};function Hl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the signal is currently using its initial value."))}Hl.isMDXComponent=!0;const $l={toc:[]};function Jl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$l,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Jl.isMDXComponent=!0;const Yl={toc:[]};function Kl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Kl.isMDXComponent=!0;const Ql={toc:[]};function tu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ql,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Compute the current value of the signal and immediately set it."))}tu.isMDXComponent=!0;const eu={toc:[]};function nu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Thread management."))}nu.isMDXComponent=!0;const ou={toc:[]};function su(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ou,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,i.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}su.isMDXComponent=!0;const ru={toc:[]};function iu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ru,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A class representing an individual thread."))}iu.isMDXComponent=!0;const pu={toc:[]};function au(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The generator wrapped by this thread."))}au.isMDXComponent=!0;const cu={toc:[]};function lu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The generator wrapped by this thread."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Used by ",(0,i.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,i.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},du,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The current time of this thread."))}hu.isMDXComponent=!0;const yu={toc:[]};function fu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The next value to be passed to the wrapped generator."))}fu.isMDXComponent=!0;const ku={toc:[]};function wu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ku,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}wu.isMDXComponent=!0;const gu={toc:[]};function Mu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,i.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,i.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}Mu.isMDXComponent=!0;const Du={toc:[]};function _u(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Du,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The fixed time of this thread."))}_u.isMDXComponent=!0;const Xu={toc:[]};function xu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Progress the wrapped generator once."))}xu.isMDXComponent=!0;const vu={toc:[]};function Cu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the thread for the next update cycle."))}Cu.isMDXComponent=!0;const Tu={toc:[]};function bu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The delta time of the next cycle."))}bu.isMDXComponent=!0;const Lu={toc:[]};function Zu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A generator function or a normal function that returns a generator."))}Zu.isMDXComponent=!0;const Nu={toc:[]};function Su(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,i.kt)("p",null,"Progress to the next frame:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,i.kt)("p",null,"Run another generator synchronously:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,i.kt)("p",null,"Run another generator concurrently:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,i.kt)("p",null,"Await a Promise:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}Su.isMDXComponent=!0;const Ru={toc:[]};function Eu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ru,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}Eu.isMDXComponent=!0;const Au={toc:[]};function zu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Au,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Cancel all listed tasks."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}zu.isMDXComponent=!0;const Pu={toc:[]};function Iu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to cancel."))}Iu.isMDXComponent=!0;const Fu={toc:[]};function Wu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}Wu.isMDXComponent=!0;const Bu={toc:[]};function Gu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A possible ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}Gu.isMDXComponent=!0;const Ou={toc:[]};function ju(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ou,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the given value is a ",(0,i.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,i.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}ju.isMDXComponent=!0;const qu={toc:[]};function Uu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A possible thread ",(0,i.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,i.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Uu.isMDXComponent=!0;const Vu={toc:[]};function Hu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}Hu.isMDXComponent=!0;const $u={toc:[]};function Ju(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$u,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}Ju.isMDXComponent=!0;const Yu={toc:[]};function Ku(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to join."))}Ku.isMDXComponent=!0;const Qu={toc:[]};function tm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}tm.isMDXComponent=!0;const em={toc:[]};function nm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},em,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Pause the current generator until listed tasks are finished."))}nm.isMDXComponent=!0;const om={toc:[]};function sm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},om,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}sm.isMDXComponent=!0;const rm={toc:[]};function im(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to join."))}im.isMDXComponent=!0;const pm={toc:[]};function am(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"From the perspective of the external generator, ",(0,i.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,i.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}am.isMDXComponent=!0;const cm={toc:[]};function lm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},um,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a context in which generators can be run concurrently."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A function that returns the generator to run."))}hm.isMDXComponent=!0;const ym={toc:[]};function fm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ym,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}fm.isMDXComponent=!0;const km={toc:[]};function wm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},km,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Transitions between scenes."))}wm.isMDXComponent=!0;const gm={toc:[]};function Mm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Perform a transition that fades between the scenes."))}Mm.isMDXComponent=!0;const Dm={toc:[]};function _m(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition."))}_m.isMDXComponent=!0;const Xm={toc:[]};function xm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}xm.isMDXComponent=!0;const vm={toc:[]};function Cm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The direction in which to slide."))}Cm.isMDXComponent=!0;const Tm={toc:[]};function bm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition."))}bm.isMDXComponent=!0;const Lm={toc:[]};function Zm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}Zm.isMDXComponent=!0;const Nm={toc:[]};function Sm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The callback to use before the current scene is rendered."))}Sm.isMDXComponent=!0;const Rm={toc:[]};function Em(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The callback to use before the previous scene is rendered."))}Em.isMDXComponent=!0;const Am={toc:[]};function zm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Am,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}zm.isMDXComponent=!0;const Pm={toc:[]};function Im(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The area on which to zoom in."))}Im.isMDXComponent=!0;const Fm={toc:[]};function Wm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition."))}Wm.isMDXComponent=!0;const Bm={toc:[]};function Gm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}Gm.isMDXComponent=!0;const Om={toc:[]};function jm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Om,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The area from which to zoom out."))}jm.isMDXComponent=!0;const qm={toc:[]};function Um(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition."))}Um.isMDXComponent=!0;const Vm={toc:[]};function Hm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Interpolation and timing of tweens."))}Hm.isMDXComponent=!0;const $m={toc:[]};function Jm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$m,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Any old key that is missing in ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"})))}Jm.isMDXComponent=!0;const Ym={toc:[]};function Km(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ym,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A value matching the structure of from and to."))}Km.isMDXComponent=!0;const Qm={toc:[]};function td(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}td.isMDXComponent=!0;const ed={toc:[]};function nd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ed,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The input to favor when value is 0."))}nd.isMDXComponent=!0;const od={toc:[]};function sd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},od,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The input to favor when value is 1."))}sd.isMDXComponent=!0;const rd={toc:[]};function id(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}id.isMDXComponent=!0;const pd={toc:[]};function ad(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A value matching the structure of from and to."))}ad.isMDXComponent=!0;const cd={toc:[]};function ld(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ud,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The input to favor when value is 0."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The input to favor when value is 1."))}hd.isMDXComponent=!0;const yd={toc:[]};function fd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}fd.isMDXComponent=!0;const kd={toc:[]};function wd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Complex types used in animations."))}wd.isMDXComponent=!0;const gd={toc:[]};function Md(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,i.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,i.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,i.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,i.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,i.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,i.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}Md.isMDXComponent=!0;const Dd={toc:[]};function _d(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the determinant of the matrix."))}_d.isMDXComponent=!0;const Xd={toc:[]};function xd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}xd.isMDXComponent=!0;const vd={toc:[]};function Cd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}Cd.isMDXComponent=!0;const Td={toc:[]};function bd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Td,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the inverse of the matrix."))}bd.isMDXComponent=!0;const Ld={toc:[]};function Zd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ld,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Zd.isMDXComponent=!0;const Nd={toc:[]};function Sd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}Sd.isMDXComponent=!0;const Rd={toc:[]};function Ed(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the provided matrix to this matrix."))}Ed.isMDXComponent=!0;const Ad={toc:[]};function zd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ad,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The matrix to add"))}zd.isMDXComponent=!0;const Pd={toc:[]};function Id(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}Id.isMDXComponent=!0;const Fd={toc:[]};function Wd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}Wd.isMDXComponent=!0;const Bd={toc:[]};function Gd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index of the component vector to retrieve."))}Gd.isMDXComponent=!0;const Od={toc:[]};function jd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Od,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}jd.isMDXComponent=!0;const qd={toc:[]};function Ud(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}Ud.isMDXComponent=!0;const Vd={toc:[]};function Hd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}Hd.isMDXComponent=!0;const $d={toc:[]};function Jd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$d,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The matrix to multiply with"))}Jd.isMDXComponent=!0;const Yd={toc:[]};function Kd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}Kd.isMDXComponent=!0;const Qd={toc:[]};function th(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"})))}th.isMDXComponent=!0;const eh={toc:[]};function nh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value by which to scale each term"))}nh.isMDXComponent=!0;const oh={toc:[]};function sh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}sh.isMDXComponent=!0;const rh={toc:[]};function ih(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}ih.isMDXComponent=!0;const ph={toc:[]};function ah(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ph,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}ah.isMDXComponent=!0;const ch={toc:[]};function lh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ch,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The angle by which to rotate the matrix"))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}hh.isMDXComponent=!0;const yh={toc:[]};function fh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index of the row to retrieve."))}fh.isMDXComponent=!0;const kh={toc:[]};function wh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}wh.isMDXComponent=!0;const gh={toc:[]};function Mh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}Mh.isMDXComponent=!0;const Dh={toc:[]};function _h(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Scale the x and y component vectors of the matrix."))}_h.isMDXComponent=!0;const Xh={toc:[]};function xh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The factor by which to scale the matrix"))}xh.isMDXComponent=!0;const vh={toc:[]};function Ch(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Ch.isMDXComponent=!0;const Th={toc:[]};function bh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Th,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}bh.isMDXComponent=!0;const Lh={toc:[]};function Zh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subtract the provided matrix from this matrix."))}Zh.isMDXComponent=!0;const Nh={toc:[]};function Sh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The matrix to subract"))}Sh.isMDXComponent=!0;const Rh={toc:[]};function Eh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Eh.isMDXComponent=!0;const Ah={toc:[]};function zh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ah,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}zh.isMDXComponent=!0;const Ph={toc:[]};function Ih(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ph,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}Ih.isMDXComponent=!0;const Fh={toc:[]};function Wh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The vector by which to translate the matrix"))}Wh.isMDXComponent=!0;const Bh={toc:[]};function Gh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents a two-dimensional vector."))}Gh.isMDXComponent=!0;const Oh={toc:[]};function jh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}jh.isMDXComponent=!0;const qh={toc:[]};function Uh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}Uh.isMDXComponent=!0;const Vh={toc:[]};function Hh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}Hh.isMDXComponent=!0;const $h={toc:[]};function Jh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$h,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,i.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}Jh.isMDXComponent=!0;const Yh={toc:[]};function Kh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if two vectors are equal to each other."))}Kh.isMDXComponent=!0;const Qh={toc:[]};function ty(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The vector to compare."))}ty.isMDXComponent=!0;const ey={toc:[]};function ny(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ey,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The allowed error threshold when comparing the vectors."))}ny.isMDXComponent=!0;const oy={toc:[]};function sy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,i.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}sy.isMDXComponent=!0;const ry={toc:[]};function iy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ry,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if two vectors are exactly equal to each other."))}iy.isMDXComponent=!0;const py={toc:[]};function ay(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},py,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The vector to compare."))}ay.isMDXComponent=!0;const cy={toc:[]};function ly(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}ly.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The x component of the vector."))}hy.isMDXComponent=!0;const yy={toc:[]};function fy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The y component of the vector."))}fy.isMDXComponent=!0;const ky={toc:[]};function wy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ky,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}wy.isMDXComponent=!0;const gy={toc:[]};function My(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The x component of the vector."))}My.isMDXComponent=!0;const Dy={toc:[]};function _y(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The y component of the vector."))}_y.isMDXComponent=!0;const Xy={toc:[]};function xy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}xy.isMDXComponent=!0;const vy={toc:[]};function Cy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The unclipped RGB components."))}Cy.isMDXComponent=!0;const Ty={toc:[]};function by(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ty,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}by.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ly,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}Zy.isMDXComponent=!0;const Ny={toc:[]};function Sy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ny,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Sy.isMDXComponent=!0;const Ry={toc:[]};function Ey(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ry,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}Ey.isMDXComponent=!0;const Ay={toc:[]};function zy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ay,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}zy.isMDXComponent=!0;const Py={toc:[]};function Iy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Py,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}Iy.isMDXComponent=!0;const Fy={toc:[]};function Wy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}Wy.isMDXComponent=!0;const By={toc:[]};function Gy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},By,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Alias of ",(0,i.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}Gy.isMDXComponent=!0;const Oy={toc:[]};function jy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}jy.isMDXComponent=!0;const qy={toc:[]};function Uy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the ",(0,i.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}Uy.isMDXComponent=!0;const Vy={toc:[]};function Hy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}Hy.isMDXComponent=!0;const $y={toc:[]};function Jy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$y,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the ",(0,i.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,i.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,i.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}Jy.isMDXComponent=!0;const Yy={toc:[]};function Ky(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}Ky.isMDXComponent=!0;const Qy={toc:[]};function tf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the ",(0,i.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,i.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,i.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}tf.isMDXComponent=!0;const ef={toc:[]};function nf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ef,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}nf.isMDXComponent=!0;const of={toc:[]};function sf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},of,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the ",(0,i.kt)("strong",{parentName:"p"},"L"),", ",(0,i.kt)("strong",{parentName:"p"},"a"),", and ",(0,i.kt)("strong",{parentName:"p"},"b")," components."))}sf.isMDXComponent=!0;const rf={toc:[]};function pf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}pf.isMDXComponent=!0;const af={toc:[]};function cf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},af,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the ",(0,i.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,i.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,i.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}cf.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}df.isMDXComponent=!0;const hf={toc:[]};function yf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}yf.isMDXComponent=!0;const ff={toc:[]};function kf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ff,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}kf.isMDXComponent=!0;const wf={toc:[]};function gf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get and set the color opacity."))}gf.isMDXComponent=!0;const Mf={toc:[]};function Df(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,i.kt)("code",null,"'rgb'")))}Df.isMDXComponent=!0;const _f={toc:[]};function Xf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_f,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Similar to saturate, but the opposite direction."))}Xf.isMDXComponent=!0;const xf={toc:[]};function vf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"set"))}vf.isMDXComponent=!0;const Cf={toc:[]};function Tf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns a single channel value.\nAlso"))}Tf.isMDXComponent=!0;const bf={toc:[]};function Lf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}Lf.isMDXComponent=!0;const Zf={toc:[]};function Nf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color as hexadecimal string."))}Nf.isMDXComponent=!0;const Sf={toc:[]};function Rf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,i.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,i.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}Rf.isMDXComponent=!0;const Ef={toc:[]};function Af(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ef,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,i.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}Af.isMDXComponent=!0;const zf={toc:[]};function Pf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}Pf.isMDXComponent=!0;const If={toc:[]};function Ff(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},If,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}Ff.isMDXComponent=!0;const Wf={toc:[]};function Bf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}Bf.isMDXComponent=!0;const Gf={toc:[]};function Of(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}Of.isMDXComponent=!0;const jf={toc:[]};function qf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}qf.isMDXComponent=!0;const Uf={toc:[]};function Vf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}Vf.isMDXComponent=!0;const Hf={toc:[]};function $f(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}$f.isMDXComponent=!0;const Jf={toc:[]};function Yf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}Yf.isMDXComponent=!0;const Kf={toc:[]};function Qf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}Qf.isMDXComponent=!0;const tk={toc:[]};function ek(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}ek.isMDXComponent=!0;const nk={toc:[]};function ok(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Convert the given origin to a vector representing its offset."))}ok.isMDXComponent=!0;const sk={toc:[]};function rk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The origin to convert."))}rk.isMDXComponent=!0;const ik={toc:[]};function pk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ik,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"General utilities and helper functions."))}pk.isMDXComponent=!0;const ak={toc:[]};function ck(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ak,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}ck.isMDXComponent=!0;const lk={toc:[]};function uk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Optional override for formatting stack traces"))}uk.isMDXComponent=!0;const mk={toc:[]};function dk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create .stack property on a target object"))}dk.isMDXComponent=!0;const hk={toc:[]};function yk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is a shortcut for calling ",(0,i.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}yk.isMDXComponent=!0;const fk={toc:[]};function kk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}kk.isMDXComponent=!0;const wk={toc:[]};function gk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Logs a debug message with an arbitrary payload."))}gk.isMDXComponent=!0;const Mk={toc:[]};function Dk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The payload to log"))}Dk.isMDXComponent=!0;const _k={toc:[]};function Xk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_k,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Mark the given function as deprecated."))}Xk.isMDXComponent=!0;const xk={toc:[]};function vk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The function to deprecate."))}vk.isMDXComponent=!0;const Ck={toc:[]};function Tk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ck,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The log message."))}Tk.isMDXComponent=!0;const bk={toc:[]};function Lk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The optional log remarks."))}Lk.isMDXComponent=!0;const Zk={toc:[]};function Nk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}Nk.isMDXComponent=!0;const Sk={toc:[]};function Rk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Mark the current scene as ready to transition out."))}Rk.isMDXComponent=!0;const Ek={toc:[]};function Ak(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ek,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}Ak.isMDXComponent=!0;const zk={toc:[]};function Pk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,i.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}Pk.isMDXComponent=!0;const Ik={toc:[]};function Fk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ik,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}Fk.isMDXComponent=!0;const Wk={toc:[]};function Bk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an array containing a range of numbers."))}Bk.isMDXComponent=!0;const Gk={toc:[]};function Ok(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The length of the array."))}Ok.isMDXComponent=!0;const jk={toc:[]};function qk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}qk.isMDXComponent=!0;const Uk={toc:[]};function Vk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an array containing a range of numbers."))}Vk.isMDXComponent=!0;const Hk={toc:[]};function $k(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."))}$k.isMDXComponent=!0;const Jk={toc:[]};function Yk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range. ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}Yk.isMDXComponent=!0;const Kk={toc:[]};function Qk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}Qk.isMDXComponent=!0;const tw={toc:[]};function ew(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an array containing a range of numbers."))}ew.isMDXComponent=!0;const nw={toc:[]};function ow(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."))}ow.isMDXComponent=!0;const sw={toc:[]};function rw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range. ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}rw.isMDXComponent=!0;const iw={toc:[]};function pw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value by which to increment or decrement."))}pw.isMDXComponent=!0;const aw={toc:[]};function cw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}cw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The function that will be provided the context before render."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}dw.isMDXComponent=!0;const hw={toc:[]};function yw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The function that will be provided the context after render."))}yw.isMDXComponent=!0;const fw={toc:[]};function kw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}kw.isMDXComponent=!0;const ww={toc:[]};function gw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ww,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}gw.isMDXComponent=!0;const Mw={toc:[]};function Dw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the event in seconds."))}Dw.isMDXComponent=!0;const _w={toc:[]};function Xw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_w,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Register a time event and get its duration in seconds."))}Xw.isMDXComponent=!0;const xw={toc:[]};function vw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The name of the event."))}vw.isMDXComponent=!0;const Cw={toc:[]};function Tw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a reference to the playback status."))}Tw.isMDXComponent=!0;const bw={toc:[]};function Lw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the random number generator for the current scene."))}Lw.isMDXComponent=!0;const Zw={toc:[]};function Nw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the random number generator for the given seed."))}Nw.isMDXComponent=!0;const Sw={toc:[]};function Rw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The seed for the generator."))}Rw.isMDXComponent=!0;const Ew={toc:[]};function Aw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ew,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}Aw.isMDXComponent=!0;const zw={toc:[]};function Pw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a reference to the current scene."))}Pw.isMDXComponent=!0;const Iw={toc:[]};function Fw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a reference to the current thread."))}Fw.isMDXComponent=!0;const Ww={toc:[]};function Bw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ww,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,i.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}Bw.isMDXComponent=!0;const Gw={toc:[]};function Ow(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}Ow.isMDXComponent=!0;const jw={toc:[]};function qw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the real time since the start of the animation."))}qw.isMDXComponent=!0;const Uw={toc:[]};function Vw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This rewrites a remote url like ",(0,i.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,i.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}Vw.isMDXComponent=!0;const Hw={toc:[]};function $w(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Route the given url through a local proxy."))}$w.isMDXComponent=!0;const Jw={toc:[]};function Yw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}Yw.isMDXComponent=!0;const Kw={toc:[]};function Qw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A simple circle:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n/>\n")),(0,i.kt)("p",null,"An ellipse:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  width={300}\n  height={100}\n  fill={'lightseagreen'}\n/>\n")),(0,i.kt)("p",null,"A sector (pie chart):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  startAngle={30}\n  endAngle={270}\n  closed={true}\n/>\n")),(0,i.kt)("p",null,"An arc:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  startAngle={-90}\n  endAngle={90}\n/>\n")))}Qw.isMDXComponent=!0;const tg={toc:[]};function eg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node for drawing circular shapes."))}eg.isMDXComponent=!0;const ng={toc:[]};function og(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ng,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}og.isMDXComponent=!0;const sg={toc:[]};function rg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}rg.isMDXComponent=!0;const ig={toc:[]};function pg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ig,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}pg.isMDXComponent=!0;const ag={toc:[]};function cg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ag,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}cg.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}dg.isMDXComponent=!0;const hg={toc:[]};function yg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}yg.isMDXComponent=!0;const fg={toc:[]};function kg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A closed circle will look like a pie chart:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,i.kt)("p",null,"An open one will look like an arc:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}kg.isMDXComponent=!0;const wg={toc:[]};function gg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"false"))}gg.isMDXComponent=!0;const Mg={toc:[]};function Dg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the path of this circle should be closed."))}Dg.isMDXComponent=!0;const _g={toc:[]};function Xg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_g,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property can be used together with ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,i.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Xg.isMDXComponent=!0;const xg={toc:[]};function vg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"360"))}vg.isMDXComponent=!0;const Cg={toc:[]};function Tg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ending angle in degrees for the circle sector."))}Tg.isMDXComponent=!0;const bg={toc:[]};function Lg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Lg.isMDXComponent=!0;const Zg={toc:[]};function Ng(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}Ng.isMDXComponent=!0;const Sg={toc:[]};function Rg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Rg.isMDXComponent=!0;const Eg={toc:[]};function Ag(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Eg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}Ag.isMDXComponent=!0;const zg={toc:[]};function Pg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Pg.isMDXComponent=!0;const Ig={toc:[]};function Fg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ig,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Fg.isMDXComponent=!0;const Wg={toc:[]};function Bg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Bg.isMDXComponent=!0;const Gg={toc:[]};function Og(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Og.isMDXComponent=!0;const jg={toc:[]};function qg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}qg.isMDXComponent=!0;const Ug={toc:[]};function Vg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ug,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}Vg.isMDXComponent=!0;const Hg={toc:[]};function $g(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property can be used together with ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,i.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}$g.isMDXComponent=!0;const Jg={toc:[]};function Yg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"0"))}Yg.isMDXComponent=!0;const Kg={toc:[]};function Qg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The starting angle in degrees for the circle sector."))}Qg.isMDXComponent=!0;const tM={toc:[]};function eM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}eM.isMDXComponent=!0;const nM={toc:[]};function oM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}oM.isMDXComponent=!0;const sM={toc:[]};function rM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}rM.isMDXComponent=!0;const iM={toc:[]};function pM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}pM.isMDXComponent=!0;const aM={toc:[]};function cM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}cM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}dM.isMDXComponent=!0;const hM={toc:[]};function yM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}yM.isMDXComponent=!0;const fM={toc:[]};function kM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}kM.isMDXComponent=!0;const wM={toc:[]};function gM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}gM.isMDXComponent=!0;const MM={toc:[]};function DM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}DM.isMDXComponent=!0;const _M={toc:[]};function XM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_M,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}XM.isMDXComponent=!0;const xM={toc:[]};function vM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}vM.isMDXComponent=!0;const CM={toc:[]};function TM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}TM.isMDXComponent=!0;const bM={toc:[]};function LM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}LM.isMDXComponent=!0;const ZM={toc:[]};function NM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}NM.isMDXComponent=!0;const SM={toc:[]};function RM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}RM.isMDXComponent=!0;const EM={toc:[]};function AM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}AM.isMDXComponent=!0;const zM={toc:[]};function PM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}PM.isMDXComponent=!0;const IM={toc:[]};function FM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}FM.isMDXComponent=!0;const WM={toc:[]};function BM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}BM.isMDXComponent=!0;const GM={toc:[]};function OM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}OM.isMDXComponent=!0;const jM={toc:[]};function qM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}qM.isMDXComponent=!0;const UM={toc:[]};function VM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}VM.isMDXComponent=!0;const HM={toc:[]};function $M(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}$M.isMDXComponent=!0;const JM={toc:[]};function YM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}YM.isMDXComponent=!0;const KM={toc:[]};function QM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}QM.isMDXComponent=!0;const tD={toc:[]};function eD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}eD.isMDXComponent=!0;const nD={toc:[]};function oD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}oD.isMDXComponent=!0;const sD={toc:[]};function rD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}rD.isMDXComponent=!0;const iD={toc:[]};function pD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}pD.isMDXComponent=!0;const aD={toc:[]};function cD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}cD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}dD.isMDXComponent=!0;const hD={toc:[]};function yD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}yD.isMDXComponent=!0;const fD={toc:[]};function kD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}kD.isMDXComponent=!0;const wD={toc:[]};function gD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}gD.isMDXComponent=!0;const MD={toc:[]};function DD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}DD.isMDXComponent=!0;const _D={toc:[]};function XD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_D,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}XD.isMDXComponent=!0;const xD={toc:[]};function vD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}vD.isMDXComponent=!0;const CD={toc:[]};function TD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}TD.isMDXComponent=!0;const bD={toc:[]};function LD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}LD.isMDXComponent=!0;const ZD={toc:[]};function ND(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}ND.isMDXComponent=!0;const SD={toc:[]};function RD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}RD.isMDXComponent=!0;const ED={toc:[]};function AD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ED,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}AD.isMDXComponent=!0;const zD={toc:[]};function PD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}PD.isMDXComponent=!0;const ID={toc:[]};function FD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ID,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}FD.isMDXComponent=!0;const WD={toc:[]};function BD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}BD.isMDXComponent=!0;const GD={toc:[]};function OD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}OD.isMDXComponent=!0;const jD={toc:[]};function qD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}qD.isMDXComponent=!0;const UD={toc:[]};function VD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}VD.isMDXComponent=!0;const HD={toc:[]};function $D(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}$D.isMDXComponent=!0;const JD={toc:[]};function YD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}YD.isMDXComponent=!0;const KD={toc:[]};function QD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}QD.isMDXComponent=!0;const t_={toc:[]};function e_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}e_.isMDXComponent=!0;const n_={toc:[]};function o_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}o_.isMDXComponent=!0;const s_={toc:[]};function r_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}r_.isMDXComponent=!0;const i_={toc:[]};function p_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}p_.isMDXComponent=!0;const a_={toc:[]};function c_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}c_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}d_.isMDXComponent=!0;const h_={toc:[]};function y_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}y_.isMDXComponent=!0;const f_={toc:[]};function k_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}k_.isMDXComponent=!0;const w_={toc:[]};function g_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}g_.isMDXComponent=!0;const M_={toc:[]};function D_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}D_.isMDXComponent=!0;const __={toc:[]};function X_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},__,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}X_.isMDXComponent=!0;const x_={toc:[]};function v_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}v_.isMDXComponent=!0;const C_={toc:[]};function T_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}T_.isMDXComponent=!0;const b_={toc:[]};function L_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}L_.isMDXComponent=!0;const Z_={toc:[]};function N_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}N_.isMDXComponent=!0;const S_={toc:[]};function R_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}R_.isMDXComponent=!0;const E_={toc:[]};function A_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}A_.isMDXComponent=!0;const z_={toc:[]};function P_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}P_.isMDXComponent=!0;const I_={toc:[]};function F_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}F_.isMDXComponent=!0;const W_={toc:[]};function B_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}B_.isMDXComponent=!0;const G_={toc:[]};function O_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}O_.isMDXComponent=!0;const j_={toc:[]};function q_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}q_.isMDXComponent=!0;const U_={toc:[]};function V_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},U_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}V_.isMDXComponent=!0;const H_={toc:[]};function $_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}$_.isMDXComponent=!0;const J_={toc:[]};function Y_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Y_.isMDXComponent=!0;const K_={toc:[]};function Q_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Q_.isMDXComponent=!0;const tX={toc:[]};function eX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}eX.isMDXComponent=!0;const nX={toc:[]};function oX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}oX.isMDXComponent=!0;const sX={toc:[]};function rX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}rX.isMDXComponent=!0;const iX={toc:[]};function pX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}pX.isMDXComponent=!0;const aX={toc:[]};function cX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}cX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}dX.isMDXComponent=!0;const hX={toc:[]};function yX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}yX.isMDXComponent=!0;const fX={toc:[]};function kX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}kX.isMDXComponent=!0;const wX={toc:[]};function gX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}gX.isMDXComponent=!0;const MX={toc:[]};function DX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}DX.isMDXComponent=!0;const _X={toc:[]};function XX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_X,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}XX.isMDXComponent=!0;const xX={toc:[]};function vX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}vX.isMDXComponent=!0;const CX={toc:[]};function TX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}TX.isMDXComponent=!0;const bX={toc:[]};function LX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}LX.isMDXComponent=!0;const ZX={toc:[]};function NX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}NX.isMDXComponent=!0;const SX={toc:[]};function RX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}RX.isMDXComponent=!0;const EX={toc:[]};function AX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}AX.isMDXComponent=!0;const zX={toc:[]};function PX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}PX.isMDXComponent=!0;const IX={toc:[]};function FX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}FX.isMDXComponent=!0;const WX={toc:[]};function BX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}BX.isMDXComponent=!0;const GX={toc:[]};function OX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}OX.isMDXComponent=!0;const jX={toc:[]};function qX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}qX.isMDXComponent=!0;const UX={toc:[]};function VX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}VX.isMDXComponent=!0;const HX={toc:[]};function $X(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}$X.isMDXComponent=!0;const JX={toc:[]};function YX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}YX.isMDXComponent=!0;const KX={toc:[]};function QX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}QX.isMDXComponent=!0;const tx={toc:[]};function ex(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}ex.isMDXComponent=!0;const nx={toc:[]};function ox(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}ox.isMDXComponent=!0;const sx={toc:[]};function rx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}rx.isMDXComponent=!0;const ix={toc:[]};function px(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ix,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}px.isMDXComponent=!0;const ax={toc:[]};function cx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ax,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}cx.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}dx.isMDXComponent=!0;const hx={toc:[]};function yx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}yx.isMDXComponent=!0;const fx={toc:[]};function kx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}kx.isMDXComponent=!0;const wx={toc:[]};function gx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}gx.isMDXComponent=!0;const Mx={toc:[]};function Dx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Dx.isMDXComponent=!0;const _x={toc:[]};function Xx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_x,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Xx.isMDXComponent=!0;const xx={toc:[]};function vx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}vx.isMDXComponent=!0;const Cx={toc:[]};function Tx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}Tx.isMDXComponent=!0;const bx={toc:[]};function Lx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Lx.isMDXComponent=!0;const Zx={toc:[]};function Nx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}Nx.isMDXComponent=!0;const Sx={toc:[]};function Rx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}Rx.isMDXComponent=!0;const Ex={toc:[]};function Ax(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ex,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Ax.isMDXComponent=!0;const zx={toc:[]};function Px(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}Px.isMDXComponent=!0;const Ix={toc:[]};function Fx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ix,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Fx.isMDXComponent=!0;const Wx={toc:[]};function Bx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Bx.isMDXComponent=!0;const Gx={toc:[]};function Ox(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}Ox.isMDXComponent=!0;const jx={toc:[]};function qx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}qx.isMDXComponent=!0;const Ux={toc:[]};function Vx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ux,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}Vx.isMDXComponent=!0;const Hx={toc:[]};function $x(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}$x.isMDXComponent=!0;const Jx={toc:[]};function Yx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}Yx.isMDXComponent=!0;const Kx={toc:[]};function Qx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Qx.isMDXComponent=!0;const tv={toc:[]};function ev(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}ev.isMDXComponent=!0;const nv={toc:[]};function ov(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}ov.isMDXComponent=!0;const sv={toc:[]};function rv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}rv.isMDXComponent=!0;const iv={toc:[]};function pv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pv.isMDXComponent=!0;const av={toc:[]};function cv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},av,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}cv.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dv.isMDXComponent=!0;const hv={toc:[]};function yv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}yv.isMDXComponent=!0;const fv={toc:[]};function kv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}kv.isMDXComponent=!0;const wv={toc:[]};function gv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}gv.isMDXComponent=!0;const Mv={toc:[]};function Dv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Dv.isMDXComponent=!0;const _v={toc:[]};function Xv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_v,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Xv.isMDXComponent=!0;const xv={toc:[]};function vv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}vv.isMDXComponent=!0;const Cv={toc:[]};function Tv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Tv.isMDXComponent=!0;const bv={toc:[]};function Lv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Lv.isMDXComponent=!0;const Zv={toc:[]};function Nv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}Nv.isMDXComponent=!0;const Sv={toc:[]};function Rv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}Rv.isMDXComponent=!0;const Ev={toc:[]};function Av(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ev,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}Av.isMDXComponent=!0;const zv={toc:[]};function Pv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Pv.isMDXComponent=!0;const Iv={toc:[]};function Fv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Fv.isMDXComponent=!0;const Wv={toc:[]};function Bv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}Bv.isMDXComponent=!0;const Gv={toc:[]};function Ov(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}Ov.isMDXComponent=!0;const jv={toc:[]};function qv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}qv.isMDXComponent=!0;const Uv={toc:[]};function Vv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}Vv.isMDXComponent=!0;const Hv={toc:[]};function $v(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}$v.isMDXComponent=!0;const Jv={toc:[]};function Yv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}Yv.isMDXComponent=!0;const Kv={toc:[]};function Qv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Qv.isMDXComponent=!0;const tC={toc:[]};function eC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}eC.isMDXComponent=!0;const nC={toc:[]};function oC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}oC.isMDXComponent=!0;const sC={toc:[]};function rC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}rC.isMDXComponent=!0;const iC={toc:[]};function pC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}pC.isMDXComponent=!0;const aC={toc:[]};function cC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}cC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}dC.isMDXComponent=!0;const hC={toc:[]};function yC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}yC.isMDXComponent=!0;const fC={toc:[]};function kC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}kC.isMDXComponent=!0;const wC={toc:[]};function gC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}gC.isMDXComponent=!0;const MC={toc:[]};function DC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}DC.isMDXComponent=!0;const _C={toc:[]};function XC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_C,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}XC.isMDXComponent=!0;const xC={toc:[]};function vC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}vC.isMDXComponent=!0;const CC={toc:[]};function TC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}TC.isMDXComponent=!0;const bC={toc:[]};function LC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}LC.isMDXComponent=!0;const ZC={toc:[]};function NC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}NC.isMDXComponent=!0;const SC={toc:[]};function RC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}RC.isMDXComponent=!0;const EC={toc:[]};function AC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}AC.isMDXComponent=!0;const zC={toc:[]};function PC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}PC.isMDXComponent=!0;const IC={toc:[]};function FC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}FC.isMDXComponent=!0;const WC={toc:[]};function BC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}BC.isMDXComponent=!0;const GC={toc:[]};function OC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}OC.isMDXComponent=!0;const jC={toc:[]};function qC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}qC.isMDXComponent=!0;const UC={toc:[]};function VC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}VC.isMDXComponent=!0;const HC={toc:[]};function $C(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}$C.isMDXComponent=!0;const JC={toc:[]};function YC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}YC.isMDXComponent=!0;const KC={toc:[]};function QC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}QC.isMDXComponent=!0;const tT={toc:[]};function eT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}eT.isMDXComponent=!0;const nT={toc:[]};function oT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}oT.isMDXComponent=!0;const sT={toc:[]};function rT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}rT.isMDXComponent=!0;const iT={toc:[]};function pT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}pT.isMDXComponent=!0;const aT={toc:[]};function cT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}cT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}dT.isMDXComponent=!0;const hT={toc:[]};function yT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}yT.isMDXComponent=!0;const fT={toc:[]};function kT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}kT.isMDXComponent=!0;const wT={toc:[]};function gT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}gT.isMDXComponent=!0;const MT={toc:[]};function DT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}DT.isMDXComponent=!0;const _T={toc:[]};function XT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_T,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}XT.isMDXComponent=!0;const xT={toc:[]};function vT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}vT.isMDXComponent=!0;const CT={toc:[]};function TT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}TT.isMDXComponent=!0;const bT={toc:[]};function LT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}LT.isMDXComponent=!0;const ZT={toc:[]};function NT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}NT.isMDXComponent=!0;const ST={toc:[]};function RT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ST,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}RT.isMDXComponent=!0;const ET={toc:[]};function AT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ET,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}AT.isMDXComponent=!0;const zT={toc:[]};function PT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}PT.isMDXComponent=!0;const IT={toc:[]};function FT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}FT.isMDXComponent=!0;const WT={toc:[]};function BT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}BT.isMDXComponent=!0;const GT={toc:[]};function OT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}OT.isMDXComponent=!0;const jT={toc:[]};function qT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}qT.isMDXComponent=!0;const UT={toc:[]};function VT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}VT.isMDXComponent=!0;const HT={toc:[]};function $T(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}$T.isMDXComponent=!0;const JT={toc:[]};function YT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}YT.isMDXComponent=!0;const KT={toc:[]};function QT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}QT.isMDXComponent=!0;const tb={toc:[]};function eb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}eb.isMDXComponent=!0;const nb={toc:[]};function ob(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}ob.isMDXComponent=!0;const sb={toc:[]};function rb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}rb.isMDXComponent=!0;const ib={toc:[]};function pb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ib,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}pb.isMDXComponent=!0;const ab={toc:[]};function cb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ab,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}cb.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}db.isMDXComponent=!0;const hb={toc:[]};function yb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}yb.isMDXComponent=!0;const fb={toc:[]};function kb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kb.isMDXComponent=!0;const wb={toc:[]};function gb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}gb.isMDXComponent=!0;const Mb={toc:[]};function Db(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An Icon Component that provides an easy access to over 150k icons.\nSee ",(0,i.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}Db.isMDXComponent=!0;const _b={toc:[]};function Xb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_b,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}Xb.isMDXComponent=!0;const xb={toc:[]};function vb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}vb.isMDXComponent=!0;const Cb={toc:[]};function Tb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Tb.isMDXComponent=!0;const bb={toc:[]};function Lb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Lb.isMDXComponent=!0;const Zb={toc:[]};function Nb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}Nb.isMDXComponent=!0;const Sb={toc:[]};function Rb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}Rb.isMDXComponent=!0;const Eb={toc:[]};function Ab(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Eb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provide the color in one of the following formats:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"named color like ",(0,i.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,i.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}Ab.isMDXComponent=!0;const zb={toc:[]};function Pb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"'white'"))}Pb.isMDXComponent=!0;const Ib={toc:[]};function Fb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ib,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The color of the icon"))}Fb.isMDXComponent=!0;const Wb={toc:[]};function Bb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Bb.isMDXComponent=!0;const Gb={toc:[]};function Ob(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Ob.isMDXComponent=!0;const jb={toc:[]};function qb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}qb.isMDXComponent=!0;const Ub={toc:[]};function Vb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ub,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"You can find identifiers on ",(0,i.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}Vb.isMDXComponent=!0;const Hb={toc:[]};function $b(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The identifier of the icon."))}$b.isMDXComponent=!0;const Jb={toc:[]};function Yb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Yb.isMDXComponent=!0;const Kb={toc:[]};function Qb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}Qb.isMDXComponent=!0;const tL={toc:[]};function eL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}eL.isMDXComponent=!0;const nL={toc:[]};function oL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}oL.isMDXComponent=!0;const sL={toc:[]};function rL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}rL.isMDXComponent=!0;const iL={toc:[]};function pL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}pL.isMDXComponent=!0;const aL={toc:[]};function cL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}cL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}dL.isMDXComponent=!0;const hL={toc:[]};function yL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}yL.isMDXComponent=!0;const fL={toc:[]};function kL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}kL.isMDXComponent=!0;const wL={toc:[]};function gL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}gL.isMDXComponent=!0;const ML={toc:[]};function DL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ML,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}DL.isMDXComponent=!0;const _L={toc:[]};function XL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_L,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}XL.isMDXComponent=!0;const xL={toc:[]};function vL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}vL.isMDXComponent=!0;const CL={toc:[]};function TL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}TL.isMDXComponent=!0;const bL={toc:[]};function LL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}LL.isMDXComponent=!0;const ZL={toc:[]};function NL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}NL.isMDXComponent=!0;const SL={toc:[]};function RL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}RL.isMDXComponent=!0;const EL={toc:[]};function AL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}AL.isMDXComponent=!0;const zL={toc:[]};function PL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}PL.isMDXComponent=!0;const IL={toc:[]};function FL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}FL.isMDXComponent=!0;const WL={toc:[]};function BL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}BL.isMDXComponent=!0;const GL={toc:[]};function OL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}OL.isMDXComponent=!0;const jL={toc:[]};function qL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}qL.isMDXComponent=!0;const UL={toc:[]};function VL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}VL.isMDXComponent=!0;const HL={toc:[]};function $L(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}$L.isMDXComponent=!0;const JL={toc:[]};function YL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}YL.isMDXComponent=!0;const KL={toc:[]};function QL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}QL.isMDXComponent=!0;const tZ={toc:[]};function eZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}eZ.isMDXComponent=!0;const nZ={toc:[]};function oZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}oZ.isMDXComponent=!0;const sZ={toc:[]};function rZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}rZ.isMDXComponent=!0;const iZ={toc:[]};function pZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}pZ.isMDXComponent=!0;const aZ={toc:[]};function cZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}cZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function yZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}yZ.isMDXComponent=!0;const fZ={toc:[]};function kZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}kZ.isMDXComponent=!0;const wZ={toc:[]};function gZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}gZ.isMDXComponent=!0;const MZ={toc:[]};function DZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}DZ.isMDXComponent=!0;const _Z={toc:[]};function XZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_Z,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}XZ.isMDXComponent=!0;const xZ={toc:[]};function vZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given position."))}vZ.isMDXComponent=!0;const CZ={toc:[]};function TZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The position in local space at which to sample the color."))}TZ.isMDXComponent=!0;const bZ={toc:[]};function LZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given pixel."))}LZ.isMDXComponent=!0;const ZZ={toc:[]};function NZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The pixel's position."))}NZ.isMDXComponent=!0;const SZ={toc:[]};function RZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"overrides ",(0,i.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}RZ.isMDXComponent=!0;const EZ={toc:[]};function AZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}AZ.isMDXComponent=!0;const zZ={toc:[]};function PZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}PZ.isMDXComponent=!0;const IZ={toc:[]};function FZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}FZ.isMDXComponent=!0;const WZ={toc:[]};function BZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}BZ.isMDXComponent=!0;const GZ={toc:[]};function OZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}OZ.isMDXComponent=!0;const jZ={toc:[]};function qZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}qZ.isMDXComponent=!0;const UZ={toc:[]};function VZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}VZ.isMDXComponent=!0;const HZ={toc:[]};function $Z(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}$Z.isMDXComponent=!0;const JZ={toc:[]};function YZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}YZ.isMDXComponent=!0;const KZ={toc:[]};function QZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}QZ.isMDXComponent=!0;const tN={toc:[]};function eN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}eN.isMDXComponent=!0;const nN={toc:[]};function oN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}oN.isMDXComponent=!0;const sN={toc:[]};function rN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}rN.isMDXComponent=!0;const iN={toc:[]};function pN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}pN.isMDXComponent=!0;const aN={toc:[]};function cN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}cN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}dN.isMDXComponent=!0;const hN={toc:[]};function yN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}yN.isMDXComponent=!0;const fN={toc:[]};function kN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}kN.isMDXComponent=!0;const wN={toc:[]};function gN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}gN.isMDXComponent=!0;const MN={toc:[]};function DN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}DN.isMDXComponent=!0;const _N={toc:[]};function XN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_N,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}XN.isMDXComponent=!0;const xN={toc:[]};function vN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}vN.isMDXComponent=!0;const CN={toc:[]};function TN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}TN.isMDXComponent=!0;const bN={toc:[]};function LN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}LN.isMDXComponent=!0;const ZN={toc:[]};function NN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}NN.isMDXComponent=!0;const SN={toc:[]};function RN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}RN.isMDXComponent=!0;const EN={toc:[]};function AN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}AN.isMDXComponent=!0;const zN={toc:[]};function PN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}PN.isMDXComponent=!0;const IN={toc:[]};function FN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}FN.isMDXComponent=!0;const WN={toc:[]};function BN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}BN.isMDXComponent=!0;const GN={toc:[]};function ON(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}ON.isMDXComponent=!0;const jN={toc:[]};function qN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}qN.isMDXComponent=!0;const UN={toc:[]};function VN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}VN.isMDXComponent=!0;const HN={toc:[]};function $N(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}$N.isMDXComponent=!0;const JN={toc:[]};function YN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}YN.isMDXComponent=!0;const KN={toc:[]};function QN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}QN.isMDXComponent=!0;const tS={toc:[]};function eS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}eS.isMDXComponent=!0;const nS={toc:[]};function oS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}oS.isMDXComponent=!0;const sS={toc:[]};function rS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}rS.isMDXComponent=!0;const iS={toc:[]};function pS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}pS.isMDXComponent=!0;const aS={toc:[]};function cS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}cS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}dS.isMDXComponent=!0;const hS={toc:[]};function yS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}yS.isMDXComponent=!0;const fS={toc:[]};function kS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}kS.isMDXComponent=!0;const wS={toc:[]};function gS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}gS.isMDXComponent=!0;const MS={toc:[]};function DS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}DS.isMDXComponent=!0;const _S={toc:[]};function XS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_S,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}XS.isMDXComponent=!0;const xS={toc:[]};function vS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}vS.isMDXComponent=!0;const CS={toc:[]};function TS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}TS.isMDXComponent=!0;const bS={toc:[]};function LS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}LS.isMDXComponent=!0;const ZS={toc:[]};function NS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}NS.isMDXComponent=!0;const SS={toc:[]};function RS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}RS.isMDXComponent=!0;const ES={toc:[]};function AS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ES,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}AS.isMDXComponent=!0;const zS={toc:[]};function PS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}PS.isMDXComponent=!0;const IS={toc:[]};function FS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}FS.isMDXComponent=!0;const WS={toc:[]};function BS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}BS.isMDXComponent=!0;const GS={toc:[]};function OS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}OS.isMDXComponent=!0;const jS={toc:[]};function qS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}qS.isMDXComponent=!0;const US={toc:[]};function VS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},US,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}VS.isMDXComponent=!0;const HS={toc:[]};function $S(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"overrides ",(0,i.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}$S.isMDXComponent=!0;const JS={toc:[]};function YS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}YS.isMDXComponent=!0;const KS={toc:[]};function QS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}QS.isMDXComponent=!0;const tR={toc:[]};function eR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}eR.isMDXComponent=!0;const nR={toc:[]};function oR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}oR.isMDXComponent=!0;const sR={toc:[]};function rR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}rR.isMDXComponent=!0;const iR={toc:[]};function pR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}pR.isMDXComponent=!0;const aR={toc:[]};function cR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Address to Iconify API for the requested Icon."))}cR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create the URL that will be used as the Image source"))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}dR.isMDXComponent=!0;const hR={toc:[]};function yR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}yR.isMDXComponent=!0;const fR={toc:[]};function kR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}kR.isMDXComponent=!0;const wR={toc:[]};function gR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}gR.isMDXComponent=!0;const MR={toc:[]};function DR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}DR.isMDXComponent=!0;const _R={toc:[]};function XR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_R,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}XR.isMDXComponent=!0;const xR={toc:[]};function vR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}vR.isMDXComponent=!0;const CR={toc:[]};function TR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}TR.isMDXComponent=!0;const bR={toc:[]};function LR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}LR.isMDXComponent=!0;const ZR={toc:[]};function NR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}NR.isMDXComponent=!0;const SR={toc:[]};function RR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}RR.isMDXComponent=!0;const ER={toc:[]};function AR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ER,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}AR.isMDXComponent=!0;const zR={toc:[]};function PR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}PR.isMDXComponent=!0;const IR={toc:[]};function FR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}FR.isMDXComponent=!0;const WR={toc:[]};function BR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}BR.isMDXComponent=!0;const GR={toc:[]};function OR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}OR.isMDXComponent=!0;const jR={toc:[]};function qR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}qR.isMDXComponent=!0;const UR={toc:[]};function VR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}VR.isMDXComponent=!0;const HR={toc:[]};function $R(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}$R.isMDXComponent=!0;const JR={toc:[]};function YR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}YR.isMDXComponent=!0;const KR={toc:[]};function QR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}QR.isMDXComponent=!0;const tE={toc:[]};function eE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}eE.isMDXComponent=!0;const nE={toc:[]};function oE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}oE.isMDXComponent=!0;const sE={toc:[]};function rE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}rE.isMDXComponent=!0;const iE={toc:[]};function pE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}pE.isMDXComponent=!0;const aE={toc:[]};function cE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}cE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}dE.isMDXComponent=!0;const hE={toc:[]};function yE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}yE.isMDXComponent=!0;const fE={toc:[]};function kE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}kE.isMDXComponent=!0;const wE={toc:[]};function gE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}gE.isMDXComponent=!0;const ME={toc:[]};function DE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ME,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}DE.isMDXComponent=!0;const _E={toc:[]};function XE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_E,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}XE.isMDXComponent=!0;const xE={toc:[]};function vE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}vE.isMDXComponent=!0;const CE={toc:[]};function TE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}TE.isMDXComponent=!0;const bE={toc:[]};function LE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}LE.isMDXComponent=!0;const ZE={toc:[]};function NE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}NE.isMDXComponent=!0;const SE={toc:[]};function RE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}RE.isMDXComponent=!0;const EE={toc:[]};function AE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}AE.isMDXComponent=!0;const zE={toc:[]};function PE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}PE.isMDXComponent=!0;const IE={toc:[]};function FE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}FE.isMDXComponent=!0;const WE={toc:[]};function BE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}BE.isMDXComponent=!0;const GE={toc:[]};function OE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}OE.isMDXComponent=!0;const jE={toc:[]};function qE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}qE.isMDXComponent=!0;const UE={toc:[]};function VE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}VE.isMDXComponent=!0;const HE={toc:[]};function $E(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}$E.isMDXComponent=!0;const JE={toc:[]};function YE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}YE.isMDXComponent=!0;const KE={toc:[]};function QE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}QE.isMDXComponent=!0;const tA={toc:[]};function eA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}eA.isMDXComponent=!0;const nA={toc:[]};function oA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}oA.isMDXComponent=!0;const sA={toc:[]};function rA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}rA.isMDXComponent=!0;const iA={toc:[]};function pA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}pA.isMDXComponent=!0;const aA={toc:[]};function cA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}cA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}dA.isMDXComponent=!0;const hA={toc:[]};function yA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}yA.isMDXComponent=!0;const fA={toc:[]};function kA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}kA.isMDXComponent=!0;const wA={toc:[]};function gA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}gA.isMDXComponent=!0;const MA={toc:[]};function DA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}DA.isMDXComponent=!0;const _A={toc:[]};function XA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_A,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}XA.isMDXComponent=!0;const xA={toc:[]};function vA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given position."))}vA.isMDXComponent=!0;const CA={toc:[]};function TA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The position in local space at which to sample the color."))}TA.isMDXComponent=!0;const bA={toc:[]};function LA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given pixel."))}LA.isMDXComponent=!0;const ZA={toc:[]};function NA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The pixel's position."))}NA.isMDXComponent=!0;const SA={toc:[]};function RA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}RA.isMDXComponent=!0;const EA={toc:[]};function AA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}AA.isMDXComponent=!0;const zA={toc:[]};function PA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}PA.isMDXComponent=!0;const IA={toc:[]};function FA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}FA.isMDXComponent=!0;const WA={toc:[]};function BA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}BA.isMDXComponent=!0;const GA={toc:[]};function OA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}OA.isMDXComponent=!0;const jA={toc:[]};function qA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}qA.isMDXComponent=!0;const UA={toc:[]};function VA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}VA.isMDXComponent=!0;const HA={toc:[]};function $A(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}$A.isMDXComponent=!0;const JA={toc:[]};function YA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}YA.isMDXComponent=!0;const KA={toc:[]};function QA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}QA.isMDXComponent=!0;const tz={toc:[]};function ez(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}ez.isMDXComponent=!0;const nz={toc:[]};function oz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}oz.isMDXComponent=!0;const sz={toc:[]};function rz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}rz.isMDXComponent=!0;const iz={toc:[]};function pz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}pz.isMDXComponent=!0;const az={toc:[]};function cz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},az,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}cz.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dz.isMDXComponent=!0;const hz={toc:[]};function yz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}yz.isMDXComponent=!0;const fz={toc:[]};function kz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}kz.isMDXComponent=!0;const wz={toc:[]};function gz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}gz.isMDXComponent=!0;const Mz={toc:[]};function Dz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Dz.isMDXComponent=!0;const _z={toc:[]};function Xz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_z,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Xz.isMDXComponent=!0;const xz={toc:[]};function vz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}vz.isMDXComponent=!0;const Cz={toc:[]};function Tz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Tz.isMDXComponent=!0;const bz={toc:[]};function Lz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Lz.isMDXComponent=!0;const Zz={toc:[]};function Nz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Nz.isMDXComponent=!0;const Sz={toc:[]};function Rz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Rz.isMDXComponent=!0;const Ez={toc:[]};function Az(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ez,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Az.isMDXComponent=!0;const zz={toc:[]};function Pz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}Pz.isMDXComponent=!0;const Iz={toc:[]};function Fz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Fz.isMDXComponent=!0;const Wz={toc:[]};function Bz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}Bz.isMDXComponent=!0;const Gz={toc:[]};function Oz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Oz.isMDXComponent=!0;const jz={toc:[]};function qz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}qz.isMDXComponent=!0;const Uz={toc:[]};function Vz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}Vz.isMDXComponent=!0;const Hz={toc:[]};function $z(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}$z.isMDXComponent=!0;const Jz={toc:[]};function Yz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Yz.isMDXComponent=!0;const Kz={toc:[]};function Qz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Qz.isMDXComponent=!0;const tP={toc:[]};function eP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}eP.isMDXComponent=!0;const nP={toc:[]};function oP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}oP.isMDXComponent=!0;const sP={toc:[]};function rP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}rP.isMDXComponent=!0;const iP={toc:[]};function pP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}pP.isMDXComponent=!0;const aP={toc:[]};function cP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}cP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}dP.isMDXComponent=!0;const hP={toc:[]};function yP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}yP.isMDXComponent=!0;const fP={toc:[]};function kP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}kP.isMDXComponent=!0;const wP={toc:[]};function gP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}gP.isMDXComponent=!0;const MP={toc:[]};function DP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}DP.isMDXComponent=!0;const _P={toc:[]};function XP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_P,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}XP.isMDXComponent=!0;const xP={toc:[]};function vP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}vP.isMDXComponent=!0;const CP={toc:[]};function TP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}TP.isMDXComponent=!0;const bP={toc:[]};function LP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}LP.isMDXComponent=!0;const ZP={toc:[]};function NP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}NP.isMDXComponent=!0;const SP={toc:[]};function RP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}RP.isMDXComponent=!0;const EP={toc:[]};function AP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}AP.isMDXComponent=!0;const zP={toc:[]};function PP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}PP.isMDXComponent=!0;const IP={toc:[]};function FP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}FP.isMDXComponent=!0;const WP={toc:[]};function BP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}BP.isMDXComponent=!0;const GP={toc:[]};function OP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}OP.isMDXComponent=!0;const jP={toc:[]};function qP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}qP.isMDXComponent=!0;const UP={toc:[]};function VP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}VP.isMDXComponent=!0;const HP={toc:[]};function $P(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}$P.isMDXComponent=!0;const JP={toc:[]};function YP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}YP.isMDXComponent=!0;const KP={toc:[]};function QP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}QP.isMDXComponent=!0;const tI={toc:[]};function eI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}eI.isMDXComponent=!0;const nI={toc:[]};function oI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}oI.isMDXComponent=!0;const sI={toc:[]};function rI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}rI.isMDXComponent=!0;const iI={toc:[]};function pI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}pI.isMDXComponent=!0;const aI={toc:[]};function cI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}cI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}dI.isMDXComponent=!0;const hI={toc:[]};function yI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}yI.isMDXComponent=!0;const fI={toc:[]};function kI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}kI.isMDXComponent=!0;const wI={toc:[]};function gI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}gI.isMDXComponent=!0;const MI={toc:[]};function DI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}DI.isMDXComponent=!0;const _I={toc:[]};function XI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_I,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}XI.isMDXComponent=!0;const xI={toc:[]};function vI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node representing a knot of a ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,i.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}vI.isMDXComponent=!0;const CI={toc:[]};function TI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}TI.isMDXComponent=!0;const bI={toc:[]};function LI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}LI.isMDXComponent=!0;const ZI={toc:[]};function NI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}NI.isMDXComponent=!0;const SI={toc:[]};function RI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}RI.isMDXComponent=!0;const EI={toc:[]};function AI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}AI.isMDXComponent=!0;const zI={toc:[]};function PI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}PI.isMDXComponent=!0;const II={toc:[]};function FI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},II,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}FI.isMDXComponent=!0;const WI={toc:[]};function BI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"0"))}BI.isMDXComponent=!0;const GI={toc:[]};function OI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}OI.isMDXComponent=!0;const jI={toc:[]};function qI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,i.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,i.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,i.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,i.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}qI.isMDXComponent=!0;const UI={toc:[]};function VI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Mirrored position of the startHandle."))}VI.isMDXComponent=!0;const HI={toc:[]};function $I(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}$I.isMDXComponent=!0;const JI={toc:[]};function YI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}YI.isMDXComponent=!0;const KI={toc:[]};function QI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}QI.isMDXComponent=!0;const tF={toc:[]};function eF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}eF.isMDXComponent=!0;const nF={toc:[]};function oF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}oF.isMDXComponent=!0;const sF={toc:[]};function rF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}rF.isMDXComponent=!0;const iF={toc:[]};function pF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,i.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,i.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,i.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,i.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}pF.isMDXComponent=!0;const aF={toc:[]};function cF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Mirrored position of the endHandle."))}cF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}dF.isMDXComponent=!0;const hF={toc:[]};function yF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}yF.isMDXComponent=!0;const fF={toc:[]};function kF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}kF.isMDXComponent=!0;const wF={toc:[]};function gF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}gF.isMDXComponent=!0;const MF={toc:[]};function DF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}DF.isMDXComponent=!0;const _F={toc:[]};function XF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_F,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}XF.isMDXComponent=!0;const xF={toc:[]};function vF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}vF.isMDXComponent=!0;const CF={toc:[]};function TF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}TF.isMDXComponent=!0;const bF={toc:[]};function LF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}LF.isMDXComponent=!0;const ZF={toc:[]};function NF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}NF.isMDXComponent=!0;const SF={toc:[]};function RF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}RF.isMDXComponent=!0;const EF={toc:[]};function AF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}AF.isMDXComponent=!0;const zF={toc:[]};function PF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}PF.isMDXComponent=!0;const IF={toc:[]};function FF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}FF.isMDXComponent=!0;const WF={toc:[]};function BF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}BF.isMDXComponent=!0;const GF={toc:[]};function OF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}OF.isMDXComponent=!0;const jF={toc:[]};function qF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}qF.isMDXComponent=!0;const UF={toc:[]};function VF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}VF.isMDXComponent=!0;const HF={toc:[]};function $F(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}$F.isMDXComponent=!0;const JF={toc:[]};function YF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}YF.isMDXComponent=!0;const KF={toc:[]};function QF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}QF.isMDXComponent=!0;const tW={toc:[]};function eW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}eW.isMDXComponent=!0;const nW={toc:[]};function oW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}oW.isMDXComponent=!0;const sW={toc:[]};function rW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}rW.isMDXComponent=!0;const iW={toc:[]};function pW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}pW.isMDXComponent=!0;const aW={toc:[]};function cW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}cW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}dW.isMDXComponent=!0;const hW={toc:[]};function yW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}yW.isMDXComponent=!0;const fW={toc:[]};function kW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}kW.isMDXComponent=!0;const wW={toc:[]};function gW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}gW.isMDXComponent=!0;const MW={toc:[]};function DW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}DW.isMDXComponent=!0;const _W={toc:[]};function XW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_W,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}XW.isMDXComponent=!0;const xW={toc:[]};function vW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}vW.isMDXComponent=!0;const CW={toc:[]};function TW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}TW.isMDXComponent=!0;const bW={toc:[]};function LW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}LW.isMDXComponent=!0;const ZW={toc:[]};function NW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}NW.isMDXComponent=!0;const SW={toc:[]};function RW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}RW.isMDXComponent=!0;const EW={toc:[]};function AW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}AW.isMDXComponent=!0;const zW={toc:[]};function PW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}PW.isMDXComponent=!0;const IW={toc:[]};function FW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}FW.isMDXComponent=!0;const WW={toc:[]};function BW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}BW.isMDXComponent=!0;const GW={toc:[]};function OW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}OW.isMDXComponent=!0;const jW={toc:[]};function qW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}qW.isMDXComponent=!0;const UW={toc:[]};function VW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}VW.isMDXComponent=!0;const HW={toc:[]};function $W(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}$W.isMDXComponent=!0;const JW={toc:[]};function YW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}YW.isMDXComponent=!0;const KW={toc:[]};function QW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}QW.isMDXComponent=!0;const tB={toc:[]};function eB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}eB.isMDXComponent=!0;const nB={toc:[]};function oB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}oB.isMDXComponent=!0;const sB={toc:[]};function rB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}rB.isMDXComponent=!0;const iB={toc:[]};function pB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}pB.isMDXComponent=!0;const aB={toc:[]};function cB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}cB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}dB.isMDXComponent=!0;const hB={toc:[]};function yB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}yB.isMDXComponent=!0;const fB={toc:[]};function kB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}kB.isMDXComponent=!0;const wB={toc:[]};function gB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}gB.isMDXComponent=!0;const MB={toc:[]};function DB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}DB.isMDXComponent=!0;const _B={toc:[]};function XB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_B,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}XB.isMDXComponent=!0;const xB={toc:[]};function vB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}vB.isMDXComponent=!0;const CB={toc:[]};function TB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}TB.isMDXComponent=!0;const bB={toc:[]};function LB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}LB.isMDXComponent=!0;const ZB={toc:[]};function NB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}NB.isMDXComponent=!0;const SB={toc:[]};function RB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}RB.isMDXComponent=!0;const EB={toc:[]};function AB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}AB.isMDXComponent=!0;const zB={toc:[]};function PB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}PB.isMDXComponent=!0;const IB={toc:[]};function FB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}FB.isMDXComponent=!0;const WB={toc:[]};function BB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}BB.isMDXComponent=!0;const GB={toc:[]};function OB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}OB.isMDXComponent=!0;const jB={toc:[]};function qB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}qB.isMDXComponent=!0;const UB={toc:[]};function VB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}VB.isMDXComponent=!0;const HB={toc:[]};function $B(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}$B.isMDXComponent=!0;const JB={toc:[]};function YB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}YB.isMDXComponent=!0;const KB={toc:[]};function QB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}QB.isMDXComponent=!0;const tG={toc:[]};function eG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}eG.isMDXComponent=!0;const nG={toc:[]};function oG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}oG.isMDXComponent=!0;const sG={toc:[]};function rG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}rG.isMDXComponent=!0;const iG={toc:[]};function pG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}pG.isMDXComponent=!0;const aG={toc:[]};function cG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}cG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}dG.isMDXComponent=!0;const hG={toc:[]};function yG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}yG.isMDXComponent=!0;const fG={toc:[]};function kG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}kG.isMDXComponent=!0;const wG={toc:[]};function gG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}gG.isMDXComponent=!0;const MG={toc:[]};function DG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}DG.isMDXComponent=!0;const _G={toc:[]};function XG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_G,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}XG.isMDXComponent=!0;const xG={toc:[]};function vG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}vG.isMDXComponent=!0;const CG={toc:[]};function TG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}TG.isMDXComponent=!0;const bG={toc:[]};function LG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}LG.isMDXComponent=!0;const ZG={toc:[]};function NG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}NG.isMDXComponent=!0;const SG={toc:[]};function RG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}RG.isMDXComponent=!0;const EG={toc:[]};function AG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}AG.isMDXComponent=!0;const zG={toc:[]};function PG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}PG.isMDXComponent=!0;const IG={toc:[]};function FG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}FG.isMDXComponent=!0;const WG={toc:[]};function BG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}BG.isMDXComponent=!0;const GG={toc:[]};function OG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}OG.isMDXComponent=!0;const jG={toc:[]};function qG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}qG.isMDXComponent=!0;const UG={toc:[]};function VG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}VG.isMDXComponent=!0;const HG={toc:[]};function $G(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}$G.isMDXComponent=!0;const JG={toc:[]};function YG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}YG.isMDXComponent=!0;const KG={toc:[]};function QG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}QG.isMDXComponent=!0;const tO={toc:[]};function eO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}eO.isMDXComponent=!0;const nO={toc:[]};function oO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}oO.isMDXComponent=!0;const sO={toc:[]};function rO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}rO.isMDXComponent=!0;const iO={toc:[]};function pO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}pO.isMDXComponent=!0;const aO={toc:[]};function cO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}cO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}dO.isMDXComponent=!0;const hO={toc:[]};function yO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}yO.isMDXComponent=!0;const fO={toc:[]};function kO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}kO.isMDXComponent=!0;const wO={toc:[]};function gO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}gO.isMDXComponent=!0;const MO={toc:[]};function DO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}DO.isMDXComponent=!0;const _O={toc:[]};function XO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_O,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}XO.isMDXComponent=!0;const xO={toc:[]};function vO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}vO.isMDXComponent=!0;const CO={toc:[]};function TO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}TO.isMDXComponent=!0;const bO={toc:[]};function LO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}LO.isMDXComponent=!0;const ZO={toc:[]};function NO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}NO.isMDXComponent=!0;const SO={toc:[]};function RO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}RO.isMDXComponent=!0;const EO={toc:[]};function AO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}AO.isMDXComponent=!0;const zO={toc:[]};function PO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}PO.isMDXComponent=!0;const IO={toc:[]};function FO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}FO.isMDXComponent=!0;const WO={toc:[]};function BO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}BO.isMDXComponent=!0;const GO={toc:[]};function OO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}OO.isMDXComponent=!0;const jO={toc:[]};function qO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}qO.isMDXComponent=!0;const UO={toc:[]};function VO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}VO.isMDXComponent=!0;const HO={toc:[]};function $O(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}$O.isMDXComponent=!0;const JO={toc:[]};function YO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}YO.isMDXComponent=!0;const KO={toc:[]};function QO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}QO.isMDXComponent=!0;const tj={toc:[]};function ej(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}ej.isMDXComponent=!0;const nj={toc:[]};function oj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}oj.isMDXComponent=!0;const sj={toc:[]};function rj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}rj.isMDXComponent=!0;const ij={toc:[]};function pj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ij,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}pj.isMDXComponent=!0;const aj={toc:[]};function cj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}cj.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}dj.isMDXComponent=!0;const hj={toc:[]};function yj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}yj.isMDXComponent=!0;const fj={toc:[]};function kj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}kj.isMDXComponent=!0;const wj={toc:[]};function gj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}gj.isMDXComponent=!0;const Mj={toc:[]};function Dj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}Dj.isMDXComponent=!0;const _j={toc:[]};function Xj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_j,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Xj.isMDXComponent=!0;const xj={toc:[]};function vj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}vj.isMDXComponent=!0;const Cj={toc:[]};function Tj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Tj.isMDXComponent=!0;const bj={toc:[]};function Lj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Lj.isMDXComponent=!0;const Zj={toc:[]};function Nj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Nj.isMDXComponent=!0;const Sj={toc:[]};function Rj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Rj.isMDXComponent=!0;const Ej={toc:[]};function Aj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ej,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given position."))}Aj.isMDXComponent=!0;const zj={toc:[]};function Pj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The position in local space at which to sample the color."))}Pj.isMDXComponent=!0;const Ij={toc:[]};function Fj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ij,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given pixel."))}Fj.isMDXComponent=!0;const Wj={toc:[]};function Bj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The pixel's position."))}Bj.isMDXComponent=!0;const Gj={toc:[]};function Oj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Oj.isMDXComponent=!0;const jj={toc:[]};function qj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}qj.isMDXComponent=!0;const Uj={toc:[]};function Vj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}Vj.isMDXComponent=!0;const Hj={toc:[]};function $j(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}$j.isMDXComponent=!0;const Jj={toc:[]};function Yj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Yj.isMDXComponent=!0;const Kj={toc:[]};function Qj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Qj.isMDXComponent=!0;const tq={toc:[]};function eq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}eq.isMDXComponent=!0;const nq={toc:[]};function oq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}oq.isMDXComponent=!0;const sq={toc:[]};function rq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}rq.isMDXComponent=!0;const iq={toc:[]};function pq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}pq.isMDXComponent=!0;const aq={toc:[]};function cq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}cq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}dq.isMDXComponent=!0;const hq={toc:[]};function yq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}yq.isMDXComponent=!0;const fq={toc:[]};function kq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}kq.isMDXComponent=!0;const wq={toc:[]};function gq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}gq.isMDXComponent=!0;const Mq={toc:[]};function Dq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}Dq.isMDXComponent=!0;const _q={toc:[]};function Xq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_q,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Xq.isMDXComponent=!0;const xq={toc:[]};function vq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}vq.isMDXComponent=!0;const Cq={toc:[]};function Tq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}Tq.isMDXComponent=!0;const bq={toc:[]};function Lq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Lq.isMDXComponent=!0;const Zq={toc:[]};function Nq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Nq.isMDXComponent=!0;const Sq={toc:[]};function Rq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Rq.isMDXComponent=!0;const Eq={toc:[]};function Aq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Eq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Aq.isMDXComponent=!0;const zq={toc:[]};function Pq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Pq.isMDXComponent=!0;const Iq={toc:[]};function Fq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Fq.isMDXComponent=!0;const Wq={toc:[]};function Bq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Bq.isMDXComponent=!0;const Gq={toc:[]};function Oq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Oq.isMDXComponent=!0;const jq={toc:[]};function qq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qq.isMDXComponent=!0;const Uq={toc:[]};function Vq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}Vq.isMDXComponent=!0;const Hq={toc:[]};function $q(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}$q.isMDXComponent=!0;const Jq={toc:[]};function Yq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}Yq.isMDXComponent=!0;const Kq={toc:[]};function Qq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Qq.isMDXComponent=!0;const tU={toc:[]};function eU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}eU.isMDXComponent=!0;const nU={toc:[]};function oU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}oU.isMDXComponent=!0;const sU={toc:[]};function rU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}rU.isMDXComponent=!0;const iU={toc:[]};function pU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}pU.isMDXComponent=!0;const aU={toc:[]};function cU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}cU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}dU.isMDXComponent=!0;const hU={toc:[]};function yU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}yU.isMDXComponent=!0;const fU={toc:[]};function kU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}kU.isMDXComponent=!0;const wU={toc:[]};function gU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}gU.isMDXComponent=!0;const MU={toc:[]};function DU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}DU.isMDXComponent=!0;const _U={toc:[]};function XU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_U,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}XU.isMDXComponent=!0;const xU={toc:[]};function vU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}vU.isMDXComponent=!0;const CU={toc:[]};function TU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}TU.isMDXComponent=!0;const bU={toc:[]};function LU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}LU.isMDXComponent=!0;const ZU={toc:[]};function NU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}NU.isMDXComponent=!0;const SU={toc:[]};function RU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}RU.isMDXComponent=!0;const EU={toc:[]};function AU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}AU.isMDXComponent=!0;const zU={toc:[]};function PU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}PU.isMDXComponent=!0;const IU={toc:[]};function FU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}FU.isMDXComponent=!0;const WU={toc:[]};function BU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}BU.isMDXComponent=!0;const GU={toc:[]};function OU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}OU.isMDXComponent=!0;const jU={toc:[]};function qU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qU.isMDXComponent=!0;const UU={toc:[]};function VU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}VU.isMDXComponent=!0;const HU={toc:[]};function $U(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}$U.isMDXComponent=!0;const JU={toc:[]};function YU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}YU.isMDXComponent=!0;const KU={toc:[]};function QU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}QU.isMDXComponent=!0;const tV={toc:[]};function eV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}eV.isMDXComponent=!0;const nV={toc:[]};function oV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}oV.isMDXComponent=!0;const sV={toc:[]};function rV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}rV.isMDXComponent=!0;const iV={toc:[]};function pV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}pV.isMDXComponent=!0;const aV={toc:[]};function cV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}cV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}dV.isMDXComponent=!0;const hV={toc:[]};function yV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}yV.isMDXComponent=!0;const fV={toc:[]};function kV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}kV.isMDXComponent=!0;const wV={toc:[]};function gV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}gV.isMDXComponent=!0;const MV={toc:[]};function DV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}DV.isMDXComponent=!0;const _V={toc:[]};function XV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_V,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}XV.isMDXComponent=!0;const xV={toc:[]};function vV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}vV.isMDXComponent=!0;const CV={toc:[]};function TV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}TV.isMDXComponent=!0;const bV={toc:[]};function LV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}LV.isMDXComponent=!0;const ZV={toc:[]};function NV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}NV.isMDXComponent=!0;const SV={toc:[]};function RV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}RV.isMDXComponent=!0;const EV={toc:[]};function AV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}AV.isMDXComponent=!0;const zV={toc:[]};function PV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}PV.isMDXComponent=!0;const IV={toc:[]};function FV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}FV.isMDXComponent=!0;const WV={toc:[]};function BV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}BV.isMDXComponent=!0;const GV={toc:[]};function OV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}OV.isMDXComponent=!0;const jV={toc:[]};function qV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}qV.isMDXComponent=!0;const UV={toc:[]};function VV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}VV.isMDXComponent=!0;const HV={toc:[]};function $V(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}$V.isMDXComponent=!0;const JV={toc:[]};function YV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}YV.isMDXComponent=!0;const KV={toc:[]};function QV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}QV.isMDXComponent=!0;const tH={toc:[]};function eH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}eH.isMDXComponent=!0;const nH={toc:[]};function oH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}oH.isMDXComponent=!0;const sH={toc:[]};function rH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}rH.isMDXComponent=!0;const iH={toc:[]};function pH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}pH.isMDXComponent=!0;const aH={toc:[]};function cH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}cH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}dH.isMDXComponent=!0;const hH={toc:[]};function yH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}yH.isMDXComponent=!0;const fH={toc:[]};function kH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}kH.isMDXComponent=!0;const wH={toc:[]};function gH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}gH.isMDXComponent=!0;const MH={toc:[]};function DH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}DH.isMDXComponent=!0;const _H={toc:[]};function XH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_H,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}XH.isMDXComponent=!0;const xH={toc:[]};function vH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}vH.isMDXComponent=!0;const CH={toc:[]};function TH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}TH.isMDXComponent=!0;const bH={toc:[]};function LH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}LH.isMDXComponent=!0;const ZH={toc:[]};function NH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}NH.isMDXComponent=!0;const SH={toc:[]};function RH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}RH.isMDXComponent=!0;const EH={toc:[]};function AH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}AH.isMDXComponent=!0;const zH={toc:[]};function PH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}PH.isMDXComponent=!0;const IH={toc:[]};function FH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}FH.isMDXComponent=!0;const WH={toc:[]};function BH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}BH.isMDXComponent=!0;const GH={toc:[]};function OH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}OH.isMDXComponent=!0;const jH={toc:[]};function qH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}qH.isMDXComponent=!0;const UH={toc:[]};function VH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}VH.isMDXComponent=!0;const HH={toc:[]};function $H(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}$H.isMDXComponent=!0;const JH={toc:[]};function YH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}YH.isMDXComponent=!0;const KH={toc:[]};function QH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}QH.isMDXComponent=!0;const t$={toc:[]};function e$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}e$.isMDXComponent=!0;const n$={toc:[]};function o$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}o$.isMDXComponent=!0;const s$={toc:[]};function r$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}r$.isMDXComponent=!0;const i$={toc:[]};function p$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}p$.isMDXComponent=!0;const a$={toc:[]};function c$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}c$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}d$.isMDXComponent=!0;const h$={toc:[]};function y$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}y$.isMDXComponent=!0;const f$={toc:[]};function k$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}k$.isMDXComponent=!0;const w$={toc:[]};function g$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}g$.isMDXComponent=!0;const M$={toc:[]};function D$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}D$.isMDXComponent=!0;const _$={toc:[]};function X$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}X$.isMDXComponent=!0;const x$={toc:[]};function v$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}v$.isMDXComponent=!0;const C$={toc:[]};function T$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}T$.isMDXComponent=!0;const b$={toc:[]};function L$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}L$.isMDXComponent=!0;const Z$={toc:[]};function N$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}N$.isMDXComponent=!0;const S$={toc:[]};function R$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}R$.isMDXComponent=!0;const E$={toc:[]};function A$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}A$.isMDXComponent=!0;const z$={toc:[]};function P$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}P$.isMDXComponent=!0;const I$={toc:[]};function F$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}F$.isMDXComponent=!0;const W$={toc:[]};function B$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}B$.isMDXComponent=!0;const G$={toc:[]};function O$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}O$.isMDXComponent=!0;const j$={toc:[]};function q$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}q$.isMDXComponent=!0;const U$={toc:[]};function V$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},U$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}V$.isMDXComponent=!0;const H$={toc:[]};function $$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}$$.isMDXComponent=!0;const J$={toc:[]};function Y$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}Y$.isMDXComponent=!0;const K$={toc:[]};function Q$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}Q$.isMDXComponent=!0;const tJ={toc:[]};function eJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}eJ.isMDXComponent=!0;const nJ={toc:[]};function oJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}oJ.isMDXComponent=!0;const sJ={toc:[]};function rJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}rJ.isMDXComponent=!0;const iJ={toc:[]};function pJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}pJ.isMDXComponent=!0;const aJ={toc:[]};function cJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}cJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function yJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}yJ.isMDXComponent=!0;const fJ={toc:[]};function kJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}kJ.isMDXComponent=!0;const wJ={toc:[]};function gJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}gJ.isMDXComponent=!0;const MJ={toc:[]};function DJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}DJ.isMDXComponent=!0;const _J={toc:[]};function XJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_J,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}XJ.isMDXComponent=!0;const xJ={toc:[]};function vJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}vJ.isMDXComponent=!0;const CJ={toc:[]};function TJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}TJ.isMDXComponent=!0;const bJ={toc:[]};function LJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}LJ.isMDXComponent=!0;const ZJ={toc:[]};function NJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}NJ.isMDXComponent=!0;const SJ={toc:[]};function RJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}RJ.isMDXComponent=!0;const EJ={toc:[]};function AJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}AJ.isMDXComponent=!0;const zJ={toc:[]};function PJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}PJ.isMDXComponent=!0;const IJ={toc:[]};function FJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}FJ.isMDXComponent=!0;const WJ={toc:[]};function BJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}BJ.isMDXComponent=!0;const GJ={toc:[]};function OJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}OJ.isMDXComponent=!0;const jJ={toc:[]};function qJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}qJ.isMDXComponent=!0;const UJ={toc:[]};function VJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}VJ.isMDXComponent=!0;const HJ={toc:[]};function $J(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}$J.isMDXComponent=!0;const JJ={toc:[]};function YJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}YJ.isMDXComponent=!0;const KJ={toc:[]};function QJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}QJ.isMDXComponent=!0;const tY={toc:[]};function eY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}eY.isMDXComponent=!0;const nY={toc:[]};function oY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}oY.isMDXComponent=!0;const sY={toc:[]};function rY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}rY.isMDXComponent=!0;const iY={toc:[]};function pY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}pY.isMDXComponent=!0;const aY={toc:[]};function cY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}cY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}dY.isMDXComponent=!0;const hY={toc:[]};function yY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}yY.isMDXComponent=!0;const fY={toc:[]};function kY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}kY.isMDXComponent=!0;const wY={toc:[]};function gY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}gY.isMDXComponent=!0;const MY={toc:[]};function DY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}DY.isMDXComponent=!0;const _Y={toc:[]};function XY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_Y,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}XY.isMDXComponent=!0;const xY={toc:[]};function vY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}vY.isMDXComponent=!0;const CY={toc:[]};function TY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}TY.isMDXComponent=!0;const bY={toc:[]};function LY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}LY.isMDXComponent=!0;const ZY={toc:[]};function NY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}NY.isMDXComponent=!0;const SY={toc:[]};function RY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}RY.isMDXComponent=!0;const EY={toc:[]};function AY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}AY.isMDXComponent=!0;const zY={toc:[]};function PY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}PY.isMDXComponent=!0;const IY={toc:[]};function FY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}FY.isMDXComponent=!0;const WY={toc:[]};function BY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}BY.isMDXComponent=!0;const GY={toc:[]};function OY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}OY.isMDXComponent=!0;const jY={toc:[]};function qY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}qY.isMDXComponent=!0;const UY={toc:[]};function VY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}VY.isMDXComponent=!0;const HY={toc:[]};function $Y(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}$Y.isMDXComponent=!0;const JY={toc:[]};function YY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}YY.isMDXComponent=!0;const KY={toc:[]};function QY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}QY.isMDXComponent=!0;const tK={toc:[]};function eK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}eK.isMDXComponent=!0;const nK={toc:[]};function oK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}oK.isMDXComponent=!0;const sK={toc:[]};function rK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}rK.isMDXComponent=!0;const iK={toc:[]};function pK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}pK.isMDXComponent=!0;const aK={toc:[]};function cK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}cK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}dK.isMDXComponent=!0;const hK={toc:[]};function yK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}yK.isMDXComponent=!0;const fK={toc:[]};function kK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}kK.isMDXComponent=!0;const wK={toc:[]};function gK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}gK.isMDXComponent=!0;const MK={toc:[]};function DK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}DK.isMDXComponent=!0;const _K={toc:[]};function XK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_K,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}XK.isMDXComponent=!0;const xK={toc:[]};function vK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}vK.isMDXComponent=!0;const CK={toc:[]};function TK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}TK.isMDXComponent=!0;const bK={toc:[]};function LK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}LK.isMDXComponent=!0;const ZK={toc:[]};function NK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}NK.isMDXComponent=!0;const SK={toc:[]};function RK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}RK.isMDXComponent=!0;const EK={toc:[]};function AK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}AK.isMDXComponent=!0;const zK={toc:[]};function PK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}PK.isMDXComponent=!0;const IK={toc:[]};function FK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}FK.isMDXComponent=!0;const WK={toc:[]};function BK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}BK.isMDXComponent=!0;const GK={toc:[]};function OK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}OK.isMDXComponent=!0;const jK={toc:[]};function qK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}qK.isMDXComponent=!0;const UK={toc:[]};function VK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}VK.isMDXComponent=!0;const HK={toc:[]};function $K(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}$K.isMDXComponent=!0;const JK={toc:[]};function YK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}YK.isMDXComponent=!0;const KK={toc:[]};function QK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}QK.isMDXComponent=!0;const tQ={toc:[]};function eQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}eQ.isMDXComponent=!0;const nQ={toc:[]};function oQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}oQ.isMDXComponent=!0;const sQ={toc:[]};function rQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}rQ.isMDXComponent=!0;const iQ={toc:[]};function pQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}pQ.isMDXComponent=!0;const aQ={toc:[]};function cQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}cQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function yQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}yQ.isMDXComponent=!0;const fQ={toc:[]};function kQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}kQ.isMDXComponent=!0;const wQ={toc:[]};function gQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}gQ.isMDXComponent=!0;const MQ={toc:[]};function DQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}DQ.isMDXComponent=!0;const _Q={toc:[]};function XQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_Q,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}XQ.isMDXComponent=!0;const xQ={toc:[]};function vQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}vQ.isMDXComponent=!0;const CQ={toc:[]};function TQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}TQ.isMDXComponent=!0;const bQ={toc:[]};function LQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}LQ.isMDXComponent=!0;const ZQ={toc:[]};function NQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}NQ.isMDXComponent=!0;const SQ={toc:[]};function RQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}RQ.isMDXComponent=!0;const EQ={toc:[]};function AQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}AQ.isMDXComponent=!0;const zQ={toc:[]};function PQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}PQ.isMDXComponent=!0;const IQ={toc:[]};function FQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}FQ.isMDXComponent=!0;const WQ={toc:[]};function BQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}BQ.isMDXComponent=!0;const GQ={toc:[]};function OQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}OQ.isMDXComponent=!0;const jQ={toc:[]};function qQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}qQ.isMDXComponent=!0;const UQ={toc:[]};function VQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}VQ.isMDXComponent=!0;const HQ={toc:[]};function $Q(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}$Q.isMDXComponent=!0;const JQ={toc:[]};function YQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}YQ.isMDXComponent=!0;const KQ={toc:[]};function QQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}QQ.isMDXComponent=!0;const t0={toc:[]};function e0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}e0.isMDXComponent=!0;const n0={toc:[]};function o0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}o0.isMDXComponent=!0;const s0={toc:[]};function r0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}r0.isMDXComponent=!0;const i0={toc:[]};function p0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}p0.isMDXComponent=!0;const a0={toc:[]};function c0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}c0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}d0.isMDXComponent=!0;const h0={toc:[]};function y0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}y0.isMDXComponent=!0;const f0={toc:[]};function k0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}k0.isMDXComponent=!0;const w0={toc:[]};function g0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}g0.isMDXComponent=!0;const M0={toc:[]};function D0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}D0.isMDXComponent=!0;const _0={toc:[]};function X0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}X0.isMDXComponent=!0;const x0={toc:[]};function v0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}v0.isMDXComponent=!0;const C0={toc:[]};function T0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}T0.isMDXComponent=!0;const b0={toc:[]};function L0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}L0.isMDXComponent=!0;const Z0={toc:[]};function N0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}N0.isMDXComponent=!0;const S0={toc:[]};function R0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}R0.isMDXComponent=!0;const E0={toc:[]};function A0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}A0.isMDXComponent=!0;const z0={toc:[]};function P0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}P0.isMDXComponent=!0;const I0={toc:[]};function F0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}F0.isMDXComponent=!0;const W0={toc:[]};function B0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}B0.isMDXComponent=!0;const G0={toc:[]};function O0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}O0.isMDXComponent=!0;const j0={toc:[]};function q0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}q0.isMDXComponent=!0;const U0={toc:[]};function V0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},U0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}V0.isMDXComponent=!0;const H0={toc:[]};function $0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}$0.isMDXComponent=!0;const J0={toc:[]};function Y0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Y0.isMDXComponent=!0;const K0={toc:[]};function Q0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}Q0.isMDXComponent=!0;const t2={toc:[]};function e2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}e2.isMDXComponent=!0;const n2={toc:[]};function o2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}o2.isMDXComponent=!0;const s2={toc:[]};function r2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}r2.isMDXComponent=!0;const i2={toc:[]};function p2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}p2.isMDXComponent=!0;const a2={toc:[]};function c2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}c2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}d2.isMDXComponent=!0;const h2={toc:[]};function y2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}y2.isMDXComponent=!0;const f2={toc:[]};function k2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}k2.isMDXComponent=!0;const w2={toc:[]};function g2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}g2.isMDXComponent=!0;const M2={toc:[]};function D2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}D2.isMDXComponent=!0;const _2={toc:[]};function X2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}X2.isMDXComponent=!0;const x2={toc:[]};function v2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}v2.isMDXComponent=!0;const C2={toc:[]};function T2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}T2.isMDXComponent=!0;const b2={toc:[]};function L2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}L2.isMDXComponent=!0;const Z2={toc:[]};function N2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}N2.isMDXComponent=!0;const S2={toc:[]};function R2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}R2.isMDXComponent=!0;const E2={toc:[]};function A2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}A2.isMDXComponent=!0;const z2={toc:[]};function P2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}P2.isMDXComponent=!0;const I2={toc:[]};function F2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}F2.isMDXComponent=!0;const W2={toc:[]};function B2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}B2.isMDXComponent=!0;const G2={toc:[]};function O2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}O2.isMDXComponent=!0;const j2={toc:[]};function q2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}q2.isMDXComponent=!0;const U2={toc:[]};function V2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},U2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}V2.isMDXComponent=!0;const H2={toc:[]};function $2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}$2.isMDXComponent=!0;const J2={toc:[]};function Y2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}Y2.isMDXComponent=!0;const K2={toc:[]};function Q2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}Q2.isMDXComponent=!0;const t1={toc:[]};function e1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}e1.isMDXComponent=!0;const n1={toc:[]};function o1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}o1.isMDXComponent=!0;const s1={toc:[]};function r1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}r1.isMDXComponent=!0;const i1={toc:[]};function p1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}p1.isMDXComponent=!0;const a1={toc:[]};function c1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}c1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}d1.isMDXComponent=!0;const h1={toc:[]};function y1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}y1.isMDXComponent=!0;const f1={toc:[]};function k1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}k1.isMDXComponent=!0;const w1={toc:[]};function g1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}g1.isMDXComponent=!0;const M1={toc:[]};function D1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}D1.isMDXComponent=!0;const _1={toc:[]};function X1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}X1.isMDXComponent=!0;const x1={toc:[]};function v1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}v1.isMDXComponent=!0;const C1={toc:[]};function T1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}T1.isMDXComponent=!0;const b1={toc:[]};function L1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}L1.isMDXComponent=!0;const Z1={toc:[]};function N1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}N1.isMDXComponent=!0;const S1={toc:[]};function R1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}R1.isMDXComponent=!0;const E1={toc:[]};function A1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}A1.isMDXComponent=!0;const z1={toc:[]};function P1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}P1.isMDXComponent=!0;const I1={toc:[]};function F1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}F1.isMDXComponent=!0;const W1={toc:[]};function B1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}B1.isMDXComponent=!0;const G1={toc:[]};function O1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}O1.isMDXComponent=!0;const j1={toc:[]};function q1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}q1.isMDXComponent=!0;const U1={toc:[]};function V1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},U1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}V1.isMDXComponent=!0;const H1={toc:[]};function $1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}$1.isMDXComponent=!0;const J1={toc:[]};function Y1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Y1.isMDXComponent=!0;const K1={toc:[]};function Q1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}Q1.isMDXComponent=!0;const t5={toc:[]};function e5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}e5.isMDXComponent=!0;const n5={toc:[]};function o5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}o5.isMDXComponent=!0;const s5={toc:[]};function r5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}r5.isMDXComponent=!0;const i5={toc:[]};function p5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}p5.isMDXComponent=!0;const a5={toc:[]};function c5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}c5.isMDXComponent=!0;const l5={toc:[]};function u5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}u5.isMDXComponent=!0;const m5={toc:[]};function d5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}d5.isMDXComponent=!0;const h5={toc:[]};function y5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}y5.isMDXComponent=!0;const f5={toc:[]};function k5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}k5.isMDXComponent=!0;const w5={toc:[]};function g5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}g5.isMDXComponent=!0;const M5={toc:[]};function D5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}D5.isMDXComponent=!0;const _5={toc:[]};function X5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}X5.isMDXComponent=!0;const x5={toc:[]};function v5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}v5.isMDXComponent=!0;const C5={toc:[]};function T5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}T5.isMDXComponent=!0;const b5={toc:[]};function L5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}L5.isMDXComponent=!0;const Z5={toc:[]};function N5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}N5.isMDXComponent=!0;const S5={toc:[]};function R5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}R5.isMDXComponent=!0;const E5={toc:[]};function A5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}A5.isMDXComponent=!0;const z5={toc:[]};function P5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}P5.isMDXComponent=!0;const I5={toc:[]};function F5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}F5.isMDXComponent=!0;const W5={toc:[]};function B5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}B5.isMDXComponent=!0;const G5={toc:[]};function O5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}O5.isMDXComponent=!0;const j5={toc:[]};function q5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}q5.isMDXComponent=!0;const U5={toc:[]};function V5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},U5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}V5.isMDXComponent=!0;const H5={toc:[]};function $5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}$5.isMDXComponent=!0;const J5={toc:[]};function Y5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}Y5.isMDXComponent=!0;const K5={toc:[]};function Q5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}Q5.isMDXComponent=!0;const t3={toc:[]};function e3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}e3.isMDXComponent=!0;const n3={toc:[]};function o3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}o3.isMDXComponent=!0;const s3={toc:[]};function r3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}r3.isMDXComponent=!0;const i3={toc:[]};function p3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}p3.isMDXComponent=!0;const a3={toc:[]};function c3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}c3.isMDXComponent=!0;const l3={toc:[]};function u3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}d3.isMDXComponent=!0;const h3={toc:[]};function y3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}y3.isMDXComponent=!0;const f3={toc:[]};function k3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}k3.isMDXComponent=!0;const w3={toc:[]};function g3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}g3.isMDXComponent=!0;const M3={toc:[]};function D3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}D3.isMDXComponent=!0;const _3={toc:[]};function X3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}X3.isMDXComponent=!0;const x3={toc:[]};function v3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}v3.isMDXComponent=!0;const C3={toc:[]};function T3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}T3.isMDXComponent=!0;const b3={toc:[]};function L3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}L3.isMDXComponent=!0;const Z3={toc:[]};function N3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}N3.isMDXComponent=!0;const S3={toc:[]};function R3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}R3.isMDXComponent=!0;const E3={toc:[]};function A3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}A3.isMDXComponent=!0;const z3={toc:[]};function P3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}P3.isMDXComponent=!0;const I3={toc:[]};function F3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}F3.isMDXComponent=!0;const W3={toc:[]};function B3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}B3.isMDXComponent=!0;const G3={toc:[]};function O3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}O3.isMDXComponent=!0;const j3={toc:[]};function q3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}q3.isMDXComponent=!0;const U3={toc:[]};function V3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},U3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}V3.isMDXComponent=!0;const H3={toc:[]};function $3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}$3.isMDXComponent=!0;const J3={toc:[]};function Y3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Y3.isMDXComponent=!0;const K3={toc:[]};function Q3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Q3.isMDXComponent=!0;const t4={toc:[]};function e4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}e4.isMDXComponent=!0;const n4={toc:[]};function o4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}o4.isMDXComponent=!0;const s4={toc:[]};function r4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}r4.isMDXComponent=!0;const i4={toc:[]};function p4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}p4.isMDXComponent=!0;const a4={toc:[]};function c4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}c4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}d4.isMDXComponent=!0;const h4={toc:[]};function y4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}y4.isMDXComponent=!0;const f4={toc:[]};function k4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}k4.isMDXComponent=!0;const w4={toc:[]};function g4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}g4.isMDXComponent=!0;const M4={toc:[]};function D4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}D4.isMDXComponent=!0;const _4={toc:[]};function X4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}X4.isMDXComponent=!0;const x4={toc:[]};function v4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}v4.isMDXComponent=!0;const C4={toc:[]};function T4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}T4.isMDXComponent=!0;const b4={toc:[]};function L4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}L4.isMDXComponent=!0;const Z4={toc:[]};function N4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}N4.isMDXComponent=!0;const S4={toc:[]};function R4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}R4.isMDXComponent=!0;const E4={toc:[]};function A4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}A4.isMDXComponent=!0;const z4={toc:[]};function P4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}P4.isMDXComponent=!0;const I4={toc:[]};function F4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}F4.isMDXComponent=!0;const W4={toc:[]};function B4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}B4.isMDXComponent=!0;const G4={toc:[]};function O4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}O4.isMDXComponent=!0;const j4={toc:[]};function q4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}q4.isMDXComponent=!0;const U4={toc:[]};function V4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},U4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}V4.isMDXComponent=!0;const H4={toc:[]};function $4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}$4.isMDXComponent=!0;const J4={toc:[]};function Y4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,i.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,i.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticable if the number of sides is low, e.g. for a\ntriangle."))}Y4.isMDXComponent=!0;const K4={toc:[]};function Q4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A hexagon:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  sides={6}\n  size={300}\n  fill={'lightseagreen'}\n/>\n")),(0,i.kt)("p",null,"A pentagon outline:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  sides={5}\n  size={300}\n  stroke={'lightblue'}\n  lineWidth={8}\n/>\n")))}Q4.isMDXComponent=!0;const t8={toc:[]};function e8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node for drawing regular polygons."))}e8.isMDXComponent=!0;const n8={toc:[]};function o8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}o8.isMDXComponent=!0;const s8={toc:[]};function r8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}r8.isMDXComponent=!0;const i8={toc:[]};function p8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}p8.isMDXComponent=!0;const a8={toc:[]};function c8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}c8.isMDXComponent=!0;const l8={toc:[]};function u8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}u8.isMDXComponent=!0;const m8={toc:[]};function d8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}d8.isMDXComponent=!0;const h8={toc:[]};function y8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}y8.isMDXComponent=!0;const f8={toc:[]};function k8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}k8.isMDXComponent=!0;const w8={toc:[]};function g8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}g8.isMDXComponent=!0;const M8={toc:[]};function D8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}D8.isMDXComponent=!0;const _8={toc:[]};function X8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}X8.isMDXComponent=!0;const x8={toc:[]};function v8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}v8.isMDXComponent=!0;const C8={toc:[]};function T8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}T8.isMDXComponent=!0;const b8={toc:[]};function L8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"For example, a value of 6 creates a hexagon."))}L8.isMDXComponent=!0;const Z8={toc:[]};function N8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}N8.isMDXComponent=!0;const S8={toc:[]};function R8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Sets the number of sides of the polygon."))}R8.isMDXComponent=!0;const E8={toc:[]};function A8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}A8.isMDXComponent=!0;const z8={toc:[]};function P8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}P8.isMDXComponent=!0;const I8={toc:[]};function F8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}F8.isMDXComponent=!0;const W8={toc:[]};function B8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}B8.isMDXComponent=!0;const G8={toc:[]};function O8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}O8.isMDXComponent=!0;const j8={toc:[]};function q8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}q8.isMDXComponent=!0;const U8={toc:[]};function V8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},U8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}V8.isMDXComponent=!0;const H8={toc:[]};function $8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}$8.isMDXComponent=!0;const J8={toc:[]};function Y8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}Y8.isMDXComponent=!0;const K8={toc:[]};function Q8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Q8.isMDXComponent=!0;const t6={toc:[]};function e6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}e6.isMDXComponent=!0;const n6={toc:[]};function o6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}o6.isMDXComponent=!0;const s6={toc:[]};function r6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}r6.isMDXComponent=!0;const i6={toc:[]};function p6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}p6.isMDXComponent=!0;const a6={toc:[]};function c6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}c6.isMDXComponent=!0;const l6={toc:[]};function u6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}u6.isMDXComponent=!0;const m6={toc:[]};function d6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}d6.isMDXComponent=!0;const h6={toc:[]};function y6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}y6.isMDXComponent=!0;const f6={toc:[]};function k6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}k6.isMDXComponent=!0;const w6={toc:[]};function g6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}g6.isMDXComponent=!0;const M6={toc:[]};function D6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}D6.isMDXComponent=!0;const _6={toc:[]};function X6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}X6.isMDXComponent=!0;const x6={toc:[]};function v6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}v6.isMDXComponent=!0;const C6={toc:[]};function T6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}T6.isMDXComponent=!0;const b6={toc:[]};function L6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}L6.isMDXComponent=!0;const Z6={toc:[]};function N6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}N6.isMDXComponent=!0;const S6={toc:[]};function R6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}R6.isMDXComponent=!0;const E6={toc:[]};function A6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}A6.isMDXComponent=!0;const z6={toc:[]};function P6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}P6.isMDXComponent=!0;const I6={toc:[]};function F6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}F6.isMDXComponent=!0;const W6={toc:[]};function B6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}B6.isMDXComponent=!0;const G6={toc:[]};function O6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}O6.isMDXComponent=!0;const j6={toc:[]};function q6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}q6.isMDXComponent=!0;const U6={toc:[]};function V6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},U6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}V6.isMDXComponent=!0;const H6={toc:[]};function $6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}$6.isMDXComponent=!0;const J6={toc:[]};function Y6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Y6.isMDXComponent=!0;const K6={toc:[]};function Q6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Q6.isMDXComponent=!0;const t7={toc:[]};function e7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}e7.isMDXComponent=!0;const n7={toc:[]};function o7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}o7.isMDXComponent=!0;const s7={toc:[]};function r7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}r7.isMDXComponent=!0;const i7={toc:[]};function p7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}p7.isMDXComponent=!0;const a7={toc:[]};function c7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}c7.isMDXComponent=!0;const l7={toc:[]};function u7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}u7.isMDXComponent=!0;const m7={toc:[]};function d7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}d7.isMDXComponent=!0;const h7={toc:[]};function y7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}y7.isMDXComponent=!0;const f7={toc:[]};function k7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}k7.isMDXComponent=!0;const w7={toc:[]};function g7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}g7.isMDXComponent=!0;const M7={toc:[]};function D7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}D7.isMDXComponent=!0;const _7={toc:[]};function X7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}X7.isMDXComponent=!0;const x7={toc:[]};function v7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}v7.isMDXComponent=!0;const C7={toc:[]};function T7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}T7.isMDXComponent=!0;const b7={toc:[]};function L7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}L7.isMDXComponent=!0;const Z7={toc:[]};function N7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}N7.isMDXComponent=!0;const S7={toc:[]};function R7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}R7.isMDXComponent=!0;const E7={toc:[]};function A7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}A7.isMDXComponent=!0;const z7={toc:[]};function P7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}P7.isMDXComponent=!0;const I7={toc:[]};function F7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}F7.isMDXComponent=!0;const W7={toc:[]};function B7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}B7.isMDXComponent=!0;const G7={toc:[]};function O7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}O7.isMDXComponent=!0;const j7={toc:[]};function q7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}q7.isMDXComponent=!0;const U7={toc:[]};function V7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},U7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}V7.isMDXComponent=!0;const H7={toc:[]};function $7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}$7.isMDXComponent=!0;const J7={toc:[]};function Y7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}Y7.isMDXComponent=!0;const K7={toc:[]};function Q7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Q7.isMDXComponent=!0;const t9={toc:[]};function e9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}e9.isMDXComponent=!0;const n9={toc:[]};function o9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}o9.isMDXComponent=!0;const s9={toc:[]};function r9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}r9.isMDXComponent=!0;const i9={toc:[]};function p9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}p9.isMDXComponent=!0;const a9={toc:[]};function c9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}c9.isMDXComponent=!0;const l9={toc:[]};function u9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}u9.isMDXComponent=!0;const m9={toc:[]};function d9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}d9.isMDXComponent=!0;const h9={toc:[]};function y9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}y9.isMDXComponent=!0;const f9={toc:[]};function k9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}k9.isMDXComponent=!0;const w9={toc:[]};function g9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}g9.isMDXComponent=!0;const M9={toc:[]};function D9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}D9.isMDXComponent=!0;const _9={toc:[]};function X9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}X9.isMDXComponent=!0;const x9={toc:[]};function v9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}v9.isMDXComponent=!0;const C9={toc:[]};function T9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}T9.isMDXComponent=!0;const b9={toc:[]};function L9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}L9.isMDXComponent=!0;const Z9={toc:[]};function N9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}N9.isMDXComponent=!0;const S9={toc:[]};function R9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}R9.isMDXComponent=!0;const E9={toc:[]};function A9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}A9.isMDXComponent=!0;const z9={toc:[]};function P9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}P9.isMDXComponent=!0;const I9={toc:[]};function F9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}F9.isMDXComponent=!0;const W9={toc:[]};function B9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}B9.isMDXComponent=!0;const G9={toc:[]};function O9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}O9.isMDXComponent=!0;const j9={toc:[]};function q9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}q9.isMDXComponent=!0;const U9={toc:[]};function V9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},U9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}V9.isMDXComponent=!0;const H9={toc:[]};function $9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}$9.isMDXComponent=!0;const J9={toc:[]};function Y9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}Y9.isMDXComponent=!0;const K9={toc:[]};function Q9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Q9.isMDXComponent=!0;const ttt={toc:[]};function ett(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ttt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}ett.isMDXComponent=!0;const ntt={toc:[]};function ott(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ntt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}ott.isMDXComponent=!0;const stt={toc:[]};function rtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},stt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}rtt.isMDXComponent=!0;const itt={toc:[]};function ptt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},itt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}ptt.isMDXComponent=!0;const att={toc:[]};function ctt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},att,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ctt.isMDXComponent=!0;const ltt={toc:[]};function utt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ltt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}utt.isMDXComponent=!0;const mtt={toc:[]};function dtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}dtt.isMDXComponent=!0;const htt={toc:[]};function ytt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},htt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ytt.isMDXComponent=!0;const ftt={toc:[]};function ktt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ftt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}ktt.isMDXComponent=!0;const wtt={toc:[]};function gtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}gtt.isMDXComponent=!0;const Mtt={toc:[]};function Dtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Dtt.isMDXComponent=!0;const _tt={toc:[]};function Xtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_tt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Xtt.isMDXComponent=!0;const xtt={toc:[]};function vtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}vtt.isMDXComponent=!0;const Ctt={toc:[]};function Ttt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ctt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Ttt.isMDXComponent=!0;const btt={toc:[]};function Ltt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},btt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}Ltt.isMDXComponent=!0;const Ztt={toc:[]};function Ntt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ztt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Ntt.isMDXComponent=!0;const Stt={toc:[]};function Rtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Stt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}Rtt.isMDXComponent=!0;const Ett={toc:[]};function Att(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ett,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}Att.isMDXComponent=!0;const ztt={toc:[]};function Ptt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ztt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}Ptt.isMDXComponent=!0;const Itt={toc:[]};function Ftt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Itt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Ftt.isMDXComponent=!0;const Wtt={toc:[]};function Btt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Btt.isMDXComponent=!0;const Gtt={toc:[]};function Ott(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}Ott.isMDXComponent=!0;const jtt={toc:[]};function qtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}qtt.isMDXComponent=!0;const Utt={toc:[]};function Vtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Utt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Vtt.isMDXComponent=!0;const Htt={toc:[]};function $tt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Htt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}$tt.isMDXComponent=!0;const Jtt={toc:[]};function Ytt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}Ytt.isMDXComponent=!0;const Ktt={toc:[]};function Qtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ktt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Qtt.isMDXComponent=!0;const tet={toc:[]};function eet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}eet.isMDXComponent=!0;const net={toc:[]};function oet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},net,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}oet.isMDXComponent=!0;const set={toc:[]};function ret(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},set,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}ret.isMDXComponent=!0;const iet={toc:[]};function pet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}pet.isMDXComponent=!0;const aet={toc:[]};function cet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}cet.isMDXComponent=!0;const uet={toc:[]};function met(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}met.isMDXComponent=!0;const det={toc:[]};function het(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},det,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}het.isMDXComponent=!0;const yet={toc:[]};function fet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}fet.isMDXComponent=!0;const ket={toc:[]};function wet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ket,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}wet.isMDXComponent=!0;const get={toc:[]};function Met(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},get,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Met.isMDXComponent=!0;const Det={toc:[]};function _et(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Det,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}_et.isMDXComponent=!0;const Xet={toc:[]};function xet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}xet.isMDXComponent=!0;const vet={toc:[]};function Cet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}Cet.isMDXComponent=!0;const Tet={toc:[]};function bet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}bet.isMDXComponent=!0;const Let={toc:[]};function Zet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Let,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}Zet.isMDXComponent=!0;const Net={toc:[]};function Set(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Net,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}Set.isMDXComponent=!0;const Ret={toc:[]};function Eet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ret,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Eet.isMDXComponent=!0;const Aet={toc:[]};function zet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Aet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}zet.isMDXComponent=!0;const Pet={toc:[]};function Iet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Iet.isMDXComponent=!0;const Fet={toc:[]};function Wet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Wet.isMDXComponent=!0;const Bet={toc:[]};function Get(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}Get.isMDXComponent=!0;const Oet={toc:[]};function jet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}jet.isMDXComponent=!0;const qet={toc:[]};function Uet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}Uet.isMDXComponent=!0;const Vet={toc:[]};function Het(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Het.isMDXComponent=!0;const $et={toc:[]};function Jet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$et,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}Jet.isMDXComponent=!0;const Yet={toc:[]};function Ket(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Ket.isMDXComponent=!0;const Qet={toc:[]};function tnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}tnt.isMDXComponent=!0;const ent={toc:[]};function nnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ent,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}nnt.isMDXComponent=!0;const ont={toc:[]};function snt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ont,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}snt.isMDXComponent=!0;const rnt={toc:[]};function int(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}int.isMDXComponent=!0;const pnt={toc:[]};function ant(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}ant.isMDXComponent=!0;const cnt={toc:[]};function lnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}lnt.isMDXComponent=!0;const unt={toc:[]};function mnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},unt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}mnt.isMDXComponent=!0;const dnt={toc:[]};function hnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}hnt.isMDXComponent=!0;const ynt={toc:[]};function fnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ynt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}fnt.isMDXComponent=!0;const knt={toc:[]};function wnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},knt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}wnt.isMDXComponent=!0;const gnt={toc:[]};function Mnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Mnt.isMDXComponent=!0;const Dnt={toc:[]};function _nt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}_nt.isMDXComponent=!0;const Xnt={toc:[]};function xnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}xnt.isMDXComponent=!0;const vnt={toc:[]};function Cnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Cnt.isMDXComponent=!0;const Tnt={toc:[]};function bnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}bnt.isMDXComponent=!0;const Lnt={toc:[]};function Znt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}Znt.isMDXComponent=!0;const Nnt={toc:[]};function Snt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}Snt.isMDXComponent=!0;const Rnt={toc:[]};function Ent(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}Ent.isMDXComponent=!0;const Ant={toc:[]};function znt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ant,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}znt.isMDXComponent=!0;const Pnt={toc:[]};function Int(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Int.isMDXComponent=!0;const Fnt={toc:[]};function Wnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}Wnt.isMDXComponent=!0;const Bnt={toc:[]};function Gnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}Gnt.isMDXComponent=!0;const Ont={toc:[]};function jnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ont,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}jnt.isMDXComponent=!0;const qnt={toc:[]};function Unt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}Unt.isMDXComponent=!0;const Vnt={toc:[]};function Hnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Hnt.isMDXComponent=!0;const $nt={toc:[]};function Jnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$nt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}Jnt.isMDXComponent=!0;const Ynt={toc:[]};function Knt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ynt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Knt.isMDXComponent=!0;const Qnt={toc:[]};function tot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}tot.isMDXComponent=!0;const eot={toc:[]};function not(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}not.isMDXComponent=!0;const oot={toc:[]};function sot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}sot.isMDXComponent=!0;const rot={toc:[]};function iot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}iot.isMDXComponent=!0;const pot={toc:[]};function aot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}aot.isMDXComponent=!0;const cot={toc:[]};function lot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}lot.isMDXComponent=!0;const uot={toc:[]};function mot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}mot.isMDXComponent=!0;const dot={toc:[]};function hot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}hot.isMDXComponent=!0;const yot={toc:[]};function fot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}fot.isMDXComponent=!0;const kot={toc:[]};function wot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}wot.isMDXComponent=!0;const got={toc:[]};function Mot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},got,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Mot.isMDXComponent=!0;const Dot={toc:[]};function _ot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}_ot.isMDXComponent=!0;const Xot={toc:[]};function xot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}xot.isMDXComponent=!0;const vot={toc:[]};function Cot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Cot.isMDXComponent=!0;const Tot={toc:[]};function bot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}bot.isMDXComponent=!0;const Lot={toc:[]};function Zot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Zot.isMDXComponent=!0;const Not={toc:[]};function Sot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Not,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}Sot.isMDXComponent=!0;const Rot={toc:[]};function Eot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Eot.isMDXComponent=!0;const Aot={toc:[]};function zot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Aot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}zot.isMDXComponent=!0;const Pot={toc:[]};function Iot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Iot.isMDXComponent=!0;const Fot={toc:[]};function Wot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Wot.isMDXComponent=!0;const Bot={toc:[]};function Got(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}Got.isMDXComponent=!0;const Oot={toc:[]};function jot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}jot.isMDXComponent=!0;const qot={toc:[]};function Uot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Uot.isMDXComponent=!0;const Vot={toc:[]};function Hot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Hot.isMDXComponent=!0;const $ot={toc:[]};function Jot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$ot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}Jot.isMDXComponent=!0;const Yot={toc:[]};function Kot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Kot.isMDXComponent=!0;const Qot={toc:[]};function tst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}tst.isMDXComponent=!0;const est={toc:[]};function nst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},est,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}nst.isMDXComponent=!0;const ost={toc:[]};function sst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ost,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}sst.isMDXComponent=!0;const rst={toc:[]};function ist(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}ist.isMDXComponent=!0;const pst={toc:[]};function ast(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}ast.isMDXComponent=!0;const cst={toc:[]};function lst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}lst.isMDXComponent=!0;const ust={toc:[]};function mst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ust,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}mst.isMDXComponent=!0;const dst={toc:[]};function hst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}hst.isMDXComponent=!0;const yst={toc:[]};function fst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}fst.isMDXComponent=!0;const kst={toc:[]};function wst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}wst.isMDXComponent=!0;const gst={toc:[]};function Mst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}Mst.isMDXComponent=!0;const Dst={toc:[]};function _st(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}_st.isMDXComponent=!0;const Xst={toc:[]};function xst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}xst.isMDXComponent=!0;const vst={toc:[]};function Cst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}Cst.isMDXComponent=!0;const Tst={toc:[]};function bst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}bst.isMDXComponent=!0;const Lst={toc:[]};function Zst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Zst.isMDXComponent=!0;const Nst={toc:[]};function Sst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}Sst.isMDXComponent=!0;const Rst={toc:[]};function Est(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}Est.isMDXComponent=!0;const Ast={toc:[]};function zst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ast,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}zst.isMDXComponent=!0;const Pst={toc:[]};function Ist(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Ist.isMDXComponent=!0;const Fst={toc:[]};function Wst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Wst.isMDXComponent=!0;const Bst={toc:[]};function Gst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Gst.isMDXComponent=!0;const Ost={toc:[]};function jst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ost,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}jst.isMDXComponent=!0;const qst={toc:[]};function Ust(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}Ust.isMDXComponent=!0;const Vst={toc:[]};function Hst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Hst.isMDXComponent=!0;const $st={toc:[]};function Jst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$st,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}Jst.isMDXComponent=!0;const Yst={toc:[]};function Kst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Kst.isMDXComponent=!0;const Qst={toc:[]};function trt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}trt.isMDXComponent=!0;const ert={toc:[]};function nrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ert,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}nrt.isMDXComponent=!0;const ort={toc:[]};function srt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ort,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}srt.isMDXComponent=!0;const rrt={toc:[]};function irt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}irt.isMDXComponent=!0;const prt={toc:[]};function art(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},prt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}art.isMDXComponent=!0;const crt={toc:[]};function lrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},crt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}lrt.isMDXComponent=!0;const urt={toc:[]};function mrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},urt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}mrt.isMDXComponent=!0;const drt={toc:[]};function hrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},drt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}hrt.isMDXComponent=!0;const yrt={toc:[]};function frt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}frt.isMDXComponent=!0;const krt={toc:[]};function wrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},krt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}wrt.isMDXComponent=!0;const grt={toc:[]};function Mrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},grt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}Mrt.isMDXComponent=!0;const Drt={toc:[]};function _rt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Drt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}_rt.isMDXComponent=!0;const Xrt={toc:[]};function xrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}xrt.isMDXComponent=!0;const vrt={toc:[]};function Crt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Crt.isMDXComponent=!0;const Trt={toc:[]};function brt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Trt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}brt.isMDXComponent=!0;const Lrt={toc:[]};function Zrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}Zrt.isMDXComponent=!0;const Nrt={toc:[]};function Srt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Srt.isMDXComponent=!0;const Rrt={toc:[]};function Ert(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}Ert.isMDXComponent=!0;const Art={toc:[]};function zrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Art,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}zrt.isMDXComponent=!0;const Prt={toc:[]};function Irt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Prt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}Irt.isMDXComponent=!0;const Frt={toc:[]};function Wrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Frt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Wrt.isMDXComponent=!0;const Brt={toc:[]};function Grt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Brt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Grt.isMDXComponent=!0;const Ort={toc:[]};function jrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ort,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}jrt.isMDXComponent=!0;const qrt={toc:[]};function Urt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Urt.isMDXComponent=!0;const Vrt={toc:[]};function Hrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Hrt.isMDXComponent=!0;const $rt={toc:[]};function Jrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$rt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}Jrt.isMDXComponent=!0;const Yrt={toc:[]};function Krt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}Krt.isMDXComponent=!0;const Qrt={toc:[]};function tit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}tit.isMDXComponent=!0;const eit={toc:[]};function nit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}nit.isMDXComponent=!0;const oit={toc:[]};function sit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}sit.isMDXComponent=!0;const rit={toc:[]};function iit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}iit.isMDXComponent=!0;const pit={toc:[]};function ait(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}ait.isMDXComponent=!0;const cit={toc:[]};function lit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}lit.isMDXComponent=!0;const uit={toc:[]};function mit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}mit.isMDXComponent=!0;const dit={toc:[]};function hit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}hit.isMDXComponent=!0;const yit={toc:[]};function fit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}fit.isMDXComponent=!0;const kit={toc:[]};function wit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}wit.isMDXComponent=!0;const git={toc:[]};function Mit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},git,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Mit.isMDXComponent=!0;const Dit={toc:[]};function _it(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}_it.isMDXComponent=!0;const Xit={toc:[]};function xit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}xit.isMDXComponent=!0;const vit={toc:[]};function Cit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}Cit.isMDXComponent=!0;const Tit={toc:[]};function bit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}bit.isMDXComponent=!0;const Lit={toc:[]};function Zit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}Zit.isMDXComponent=!0;const Nit={toc:[]};function Sit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Sit.isMDXComponent=!0;const Rit={toc:[]};function Eit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}Eit.isMDXComponent=!0;const Ait={toc:[]};function zit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ait,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}zit.isMDXComponent=!0;const Pit={toc:[]};function Iit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Iit.isMDXComponent=!0;const Fit={toc:[]};function Wit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}Wit.isMDXComponent=!0;const Bit={toc:[]};function Git(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Git.isMDXComponent=!0;const Oit={toc:[]};function jit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}jit.isMDXComponent=!0;const qit={toc:[]};function Uit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Uit.isMDXComponent=!0;const Vit={toc:[]};function Hit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Hit.isMDXComponent=!0;const $it={toc:[]};function Jit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$it,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Jit.isMDXComponent=!0;const Yit={toc:[]};function Kit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Kit.isMDXComponent=!0;const Qit={toc:[]};function tpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}tpt.isMDXComponent=!0;const ept={toc:[]};function npt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ept,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}npt.isMDXComponent=!0;const opt={toc:[]};function spt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},opt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}spt.isMDXComponent=!0;const rpt={toc:[]};function ipt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}ipt.isMDXComponent=!0;const ppt={toc:[]};function apt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ppt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}apt.isMDXComponent=!0;const cpt={toc:[]};function lpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}lpt.isMDXComponent=!0;const upt={toc:[]};function mpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},upt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}mpt.isMDXComponent=!0;const dpt={toc:[]};function hpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}hpt.isMDXComponent=!0;const ypt={toc:[]};function fpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ypt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}fpt.isMDXComponent=!0;const kpt={toc:[]};function wpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}wpt.isMDXComponent=!0;const gpt={toc:[]};function Mpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Mpt.isMDXComponent=!0;const Dpt={toc:[]};function _pt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}_pt.isMDXComponent=!0;const Xpt={toc:[]};function xpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}xpt.isMDXComponent=!0;const vpt={toc:[]};function Cpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}Cpt.isMDXComponent=!0;const Tpt={toc:[]};function bpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}bpt.isMDXComponent=!0;const Lpt={toc:[]};function Zpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Zpt.isMDXComponent=!0;const Npt={toc:[]};function Spt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Npt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}Spt.isMDXComponent=!0;const Rpt={toc:[]};function Ept(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Ept.isMDXComponent=!0;const Apt={toc:[]};function zpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Apt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}zpt.isMDXComponent=!0;const Ppt={toc:[]};function Ipt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ppt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}Ipt.isMDXComponent=!0;const Fpt={toc:[]};function Wpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Wpt.isMDXComponent=!0;const Bpt={toc:[]};function Gpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Gpt.isMDXComponent=!0;const Opt={toc:[]};function jpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Opt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}jpt.isMDXComponent=!0;const qpt={toc:[]};function Upt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Upt.isMDXComponent=!0;const Vpt={toc:[]};function Hpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Hpt.isMDXComponent=!0;const $pt={toc:[]};function Jpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$pt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Jpt.isMDXComponent=!0;const Ypt={toc:[]};function Kpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ypt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Kpt.isMDXComponent=!0;const Qpt={toc:[]};function tat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}tat.isMDXComponent=!0;const eat={toc:[]};function nat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}nat.isMDXComponent=!0;const oat={toc:[]};function sat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}sat.isMDXComponent=!0;const rat={toc:[]};function iat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}iat.isMDXComponent=!0;const pat={toc:[]};function aat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}aat.isMDXComponent=!0;const cat={toc:[]};function lat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}lat.isMDXComponent=!0;const uat={toc:[]};function mat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}mat.isMDXComponent=!0;const dat={toc:[]};function hat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}hat.isMDXComponent=!0;const yat={toc:[]};function fat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}fat.isMDXComponent=!0;const kat={toc:[]};function wat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}wat.isMDXComponent=!0;const gat={toc:[]};function Mat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Mat.isMDXComponent=!0;const Dat={toc:[]};function _at(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}_at.isMDXComponent=!0;const Xat={toc:[]};function xat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}xat.isMDXComponent=!0;const vat={toc:[]};function Cat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}Cat.isMDXComponent=!0;const Tat={toc:[]};function bat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}bat.isMDXComponent=!0;const Lat={toc:[]};function Zat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}Zat.isMDXComponent=!0;const Nat={toc:[]};function Sat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Sat.isMDXComponent=!0;const Rat={toc:[]};function Eat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}Eat.isMDXComponent=!0;const Aat={toc:[]};function zat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Aat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}zat.isMDXComponent=!0;const Pat={toc:[]};function Iat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}Iat.isMDXComponent=!0;const Fat={toc:[]};function Wat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Wat.isMDXComponent=!0;const Bat={toc:[]};function Gat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Gat.isMDXComponent=!0;const Oat={toc:[]};function jat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}jat.isMDXComponent=!0;const qat={toc:[]};function Uat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}Uat.isMDXComponent=!0;const Vat={toc:[]};function Hat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Hat.isMDXComponent=!0;const $at={toc:[]};function Jat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$at,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Jat.isMDXComponent=!0;const Yat={toc:[]};function Kat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}Kat.isMDXComponent=!0;const Qat={toc:[]};function tct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}tct.isMDXComponent=!0;const ect={toc:[]};function nct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ect,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}nct.isMDXComponent=!0;const oct={toc:[]};function sct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}sct.isMDXComponent=!0;const rct={toc:[]};function ict(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}ict.isMDXComponent=!0;const pct={toc:[]};function act(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}act.isMDXComponent=!0;const cct={toc:[]};function lct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}lct.isMDXComponent=!0;const uct={toc:[]};function mct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}mct.isMDXComponent=!0;const dct={toc:[]};function hct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}hct.isMDXComponent=!0;const yct={toc:[]};function fct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}fct.isMDXComponent=!0;const kct={toc:[]};function wct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}wct.isMDXComponent=!0;const gct={toc:[]};function Mct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Mct.isMDXComponent=!0;const Dct={toc:[]};function _ct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}_ct.isMDXComponent=!0;const Xct={toc:[]};function xct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}xct.isMDXComponent=!0;const vct={toc:[]};function Cct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Cct.isMDXComponent=!0;const Tct={toc:[]};function bct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}bct.isMDXComponent=!0;const Lct={toc:[]};function Zct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}Zct.isMDXComponent=!0;const Nct={toc:[]};function Sct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Sct.isMDXComponent=!0;const Rct={toc:[]};function Ect(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Ect.isMDXComponent=!0;const Act={toc:[]};function zct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Act,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}zct.isMDXComponent=!0;const Pct={toc:[]};function Ict(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Ict.isMDXComponent=!0;const Fct={toc:[]};function Wct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}Wct.isMDXComponent=!0;const Bct={toc:[]};function Gct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Gct.isMDXComponent=!0;const Oct={toc:[]};function jct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}jct.isMDXComponent=!0;const qct={toc:[]};function Uct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}Uct.isMDXComponent=!0;const Vct={toc:[]};function Hct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Defining knots using the ",(0,i.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,i.kt)("p",null,"Defining knots with ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,i.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}Hct.isMDXComponent=!0;const $ct={toc:[]};function Jct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$ct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node for drawing a smooth line through a number of points."))}Jct.isMDXComponent=!0;const Yct={toc:[]};function Kct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}Kct.isMDXComponent=!0;const Qct={toc:[]};function tlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}tlt.isMDXComponent=!0;const elt={toc:[]};function nlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},elt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}nlt.isMDXComponent=!0;const olt={toc:[]};function slt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},olt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}slt.isMDXComponent=!0;const rlt={toc:[]};function ilt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}ilt.isMDXComponent=!0;const plt={toc:[]};function alt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},plt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}alt.isMDXComponent=!0;const clt={toc:[]};function llt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},clt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}llt.isMDXComponent=!0;const ult={toc:[]};function mlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ult,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}mlt.isMDXComponent=!0;const dlt={toc:[]};function hlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}hlt.isMDXComponent=!0;const ylt={toc:[]};function flt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ylt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}flt.isMDXComponent=!0;const klt={toc:[]};function wlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},klt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}wlt.isMDXComponent=!0;const glt={toc:[]};function Mlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},glt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Mlt.isMDXComponent=!0;const Dlt={toc:[]};function _lt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}_lt.isMDXComponent=!0;const Xlt={toc:[]};function xlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}xlt.isMDXComponent=!0;const vlt={toc:[]};function Clt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Clt.isMDXComponent=!0;const Tlt={toc:[]};function blt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}blt.isMDXComponent=!0;const Llt={toc:[]};function Zlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Llt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}Zlt.isMDXComponent=!0;const Nlt={toc:[]};function Slt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"0.4"))}Slt.isMDXComponent=!0;const Rlt={toc:[]};function Elt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}Elt.isMDXComponent=!0;const Alt={toc:[]};function zlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Alt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}zlt.isMDXComponent=!0;const Plt={toc:[]};function Ilt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Plt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Ilt.isMDXComponent=!0;const Flt={toc:[]};function Wlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Flt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}Wlt.isMDXComponent=!0;const Blt={toc:[]};function Glt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Blt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}Glt.isMDXComponent=!0;const Olt={toc:[]};function jlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Olt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}jlt.isMDXComponent=!0;const qlt={toc:[]};function Ult(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}Ult.isMDXComponent=!0;const Vlt={toc:[]};function Hlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Hlt.isMDXComponent=!0;const $lt={toc:[]};function Jlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$lt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Jlt.isMDXComponent=!0;const Ylt={toc:[]};function Klt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ylt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}Klt.isMDXComponent=!0;const Qlt={toc:[]};function tut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}tut.isMDXComponent=!0;const eut={toc:[]};function nut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}nut.isMDXComponent=!0;const out={toc:[]};function sut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},out,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}sut.isMDXComponent=!0;const rut={toc:[]};function iut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}iut.isMDXComponent=!0;const put={toc:[]};function aut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},put,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}aut.isMDXComponent=!0;const cut={toc:[]};function lut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}lut.isMDXComponent=!0;const uut={toc:[]};function mut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}mut.isMDXComponent=!0;const dut={toc:[]};function hut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}hut.isMDXComponent=!0;const yut={toc:[]};function fut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}fut.isMDXComponent=!0;const kut={toc:[]};function wut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}wut.isMDXComponent=!0;const gut={toc:[]};function Mut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}Mut.isMDXComponent=!0;const Dut={toc:[]};function _ut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}_ut.isMDXComponent=!0;const Xut={toc:[]};function xut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}xut.isMDXComponent=!0;const vut={toc:[]};function Cut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}Cut.isMDXComponent=!0;const Tut={toc:[]};function but(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}but.isMDXComponent=!0;const Lut={toc:[]};function Zut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}Zut.isMDXComponent=!0;const Nut={toc:[]};function Sut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Sut.isMDXComponent=!0;const Rut={toc:[]};function Eut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Eut.isMDXComponent=!0;const Aut={toc:[]};function zut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Aut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}zut.isMDXComponent=!0;const Put={toc:[]};function Iut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Put,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Iut.isMDXComponent=!0;const Fut={toc:[]};function Wut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}Wut.isMDXComponent=!0;const But={toc:[]};function Gut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},But,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}Gut.isMDXComponent=!0;const Out={toc:[]};function jut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Out,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}jut.isMDXComponent=!0;const qut={toc:[]};function Uut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Uut.isMDXComponent=!0;const Vut={toc:[]};function Hut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Hut.isMDXComponent=!0;const $ut={toc:[]};function Jut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$ut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Jut.isMDXComponent=!0;const Yut={toc:[]};function Kut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Kut.isMDXComponent=!0;const Qut={toc:[]};function tmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}tmt.isMDXComponent=!0;const emt={toc:[]};function nmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},emt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}nmt.isMDXComponent=!0;const omt={toc:[]};function smt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},omt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}smt.isMDXComponent=!0;const rmt={toc:[]};function imt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}imt.isMDXComponent=!0;const pmt={toc:[]};function amt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}amt.isMDXComponent=!0;const cmt={toc:[]};function lmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}lmt.isMDXComponent=!0;const umt={toc:[]};function mmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},umt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}mmt.isMDXComponent=!0;const dmt={toc:[]};function hmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}hmt.isMDXComponent=!0;const ymt={toc:[]};function fmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ymt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}fmt.isMDXComponent=!0;const kmt={toc:[]};function wmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}wmt.isMDXComponent=!0;const gmt={toc:[]};function Mmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Mmt.isMDXComponent=!0;const Dmt={toc:[]};function _mt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}_mt.isMDXComponent=!0;const Xmt={toc:[]};function xmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}xmt.isMDXComponent=!0;const vmt={toc:[]};function Cmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}Cmt.isMDXComponent=!0;const Tmt={toc:[]};function bmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}bmt.isMDXComponent=!0;const Lmt={toc:[]};function Zmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}Zmt.isMDXComponent=!0;const Nmt={toc:[]};function Smt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Smt.isMDXComponent=!0;const Rmt={toc:[]};function Emt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}Emt.isMDXComponent=!0;const Amt={toc:[]};function zmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Amt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}zmt.isMDXComponent=!0;const Pmt={toc:[]};function Imt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}Imt.isMDXComponent=!0;const Fmt={toc:[]};function Wmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}Wmt.isMDXComponent=!0;const Bmt={toc:[]};function Gmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}Gmt.isMDXComponent=!0;const Omt={toc:[]};function jmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Omt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}jmt.isMDXComponent=!0;const qmt={toc:[]};function Umt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Umt.isMDXComponent=!0;const Vmt={toc:[]};function Hmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Hmt.isMDXComponent=!0;const $mt={toc:[]};function Jmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$mt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}Jmt.isMDXComponent=!0;const Ymt={toc:[]};function Kmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ymt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Kmt.isMDXComponent=!0;const Qmt={toc:[]};function tdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}tdt.isMDXComponent=!0;const edt={toc:[]};function ndt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},edt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}ndt.isMDXComponent=!0;const odt={toc:[]};function sdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},odt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}sdt.isMDXComponent=!0;const rdt={toc:[]};function idt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}idt.isMDXComponent=!0;const pdt={toc:[]};function adt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}adt.isMDXComponent=!0;const cdt={toc:[]};function ldt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}ldt.isMDXComponent=!0;const udt={toc:[]};function mdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},udt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}mdt.isMDXComponent=!0;const ddt={toc:[]};function hdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ddt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}hdt.isMDXComponent=!0;const ydt={toc:[]};function fdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ydt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}fdt.isMDXComponent=!0;const kdt={toc:[]};function wdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wdt.isMDXComponent=!0;const gdt={toc:[]};function Mdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Mdt.isMDXComponent=!0;const Ddt={toc:[]};function _dt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ddt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}_dt.isMDXComponent=!0;const Xdt={toc:[]};function xdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}xdt.isMDXComponent=!0;const vdt={toc:[]};function Cdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}Cdt.isMDXComponent=!0;const Tdt={toc:[]};function bdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}bdt.isMDXComponent=!0;const Ldt={toc:[]};function Zdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ldt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Zdt.isMDXComponent=!0;const Ndt={toc:[]};function Sdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ndt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Sdt.isMDXComponent=!0;const Rdt={toc:[]};function Edt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}Edt.isMDXComponent=!0;const Adt={toc:[]};function zdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Adt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}zdt.isMDXComponent=!0;const Pdt={toc:[]};function Idt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Idt.isMDXComponent=!0;const Fdt={toc:[]};function Wdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Wdt.isMDXComponent=!0;const Bdt={toc:[]};function Gdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Gdt.isMDXComponent=!0;const Odt={toc:[]};function jdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Odt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}jdt.isMDXComponent=!0;const qdt={toc:[]};function Udt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Udt.isMDXComponent=!0;const Vdt={toc:[]};function Hdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}Hdt.isMDXComponent=!0;const $dt={toc:[]};function Jdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$dt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}Jdt.isMDXComponent=!0;const Ydt={toc:[]};function Kdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ydt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}Kdt.isMDXComponent=!0;const Qdt={toc:[]};function tht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}tht.isMDXComponent=!0;const eht={toc:[]};function nht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}nht.isMDXComponent=!0;const oht={toc:[]};function sht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}sht.isMDXComponent=!0;const rht={toc:[]};function iht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}iht.isMDXComponent=!0;const pht={toc:[]};function aht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}aht.isMDXComponent=!0;const cht={toc:[]};function lht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}lht.isMDXComponent=!0;const uht={toc:[]};function mht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}mht.isMDXComponent=!0;const dht={toc:[]};function hht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}hht.isMDXComponent=!0;const yht={toc:[]};function fht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}fht.isMDXComponent=!0;const kht={toc:[]};function wht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}wht.isMDXComponent=!0;const ght={toc:[]};function Mht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ght,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Mht.isMDXComponent=!0;const Dht={toc:[]};function _ht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}_ht.isMDXComponent=!0;const Xht={toc:[]};function xht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}xht.isMDXComponent=!0;const vht={toc:[]};function Cht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}Cht.isMDXComponent=!0;const Tht={toc:[]};function bht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}bht.isMDXComponent=!0;const Lht={toc:[]};function Zht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Zht.isMDXComponent=!0;const Nht={toc:[]};function Sht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}Sht.isMDXComponent=!0;const Rht={toc:[]};function Eht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}Eht.isMDXComponent=!0;const Aht={toc:[]};function zht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Aht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}zht.isMDXComponent=!0;const Pht={toc:[]};function Iht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}Iht.isMDXComponent=!0;const Fht={toc:[]};function Wht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Wht.isMDXComponent=!0;const Bht={toc:[]};function Ght(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Ght.isMDXComponent=!0;const Oht={toc:[]};function jht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}jht.isMDXComponent=!0;const qht={toc:[]};function Uht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Uht.isMDXComponent=!0;const Vht={toc:[]};function Hht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}Hht.isMDXComponent=!0;const $ht={toc:[]};function Jht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$ht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Jht.isMDXComponent=!0;const Yht={toc:[]};function Kht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}Kht.isMDXComponent=!0;const Qht={toc:[]};function tyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}tyt.isMDXComponent=!0;const eyt={toc:[]};function nyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}nyt.isMDXComponent=!0;const oyt={toc:[]};function syt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}syt.isMDXComponent=!0;const ryt={toc:[]};function iyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ryt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}iyt.isMDXComponent=!0;const pyt={toc:[]};function ayt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ayt.isMDXComponent=!0;const cyt={toc:[]};function lyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}lyt.isMDXComponent=!0;const uyt={toc:[]};function myt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}myt.isMDXComponent=!0;const dyt={toc:[]};function hyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}hyt.isMDXComponent=!0;const yyt={toc:[]};function fyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}fyt.isMDXComponent=!0;const kyt={toc:[]};function wyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}wyt.isMDXComponent=!0;const gyt={toc:[]};function Myt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}Myt.isMDXComponent=!0;const Dyt={toc:[]};function _yt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}_yt.isMDXComponent=!0;const Xyt={toc:[]};function xyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}xyt.isMDXComponent=!0;const vyt={toc:[]};function Cyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Cyt.isMDXComponent=!0;const Tyt={toc:[]};function byt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}byt.isMDXComponent=!0;const Lyt={toc:[]};function Zyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Zyt.isMDXComponent=!0;const Nyt={toc:[]};function Syt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}Syt.isMDXComponent=!0;const Ryt={toc:[]};function Eyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ryt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}Eyt.isMDXComponent=!0;const Ayt={toc:[]};function zyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ayt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}zyt.isMDXComponent=!0;const Pyt={toc:[]};function Iyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Iyt.isMDXComponent=!0;const Fyt={toc:[]};function Wyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Wyt.isMDXComponent=!0;const Byt={toc:[]};function Gyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Byt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}Gyt.isMDXComponent=!0;const Oyt={toc:[]};function jyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}jyt.isMDXComponent=!0;const qyt={toc:[]};function Uyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}Uyt.isMDXComponent=!0;const Vyt={toc:[]};function Hyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}Hyt.isMDXComponent=!0;const $yt={toc:[]};function Jyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$yt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Jyt.isMDXComponent=!0;const Yyt={toc:[]};function Kyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}Kyt.isMDXComponent=!0;const Qyt={toc:[]};function tft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}tft.isMDXComponent=!0;const eft={toc:[]};function nft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}nft.isMDXComponent=!0;const oft={toc:[]};function sft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}sft.isMDXComponent=!0;const rft={toc:[]};function ift(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}ift.isMDXComponent=!0;const pft={toc:[]};function aft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}aft.isMDXComponent=!0;const cft={toc:[]};function lft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}lft.isMDXComponent=!0;const uft={toc:[]};function mft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}mft.isMDXComponent=!0;const dft={toc:[]};function hft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}hft.isMDXComponent=!0;const yft={toc:[]};function fft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}fft.isMDXComponent=!0;const kft={toc:[]};function wft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}wft.isMDXComponent=!0;const gft={toc:[]};function Mft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Mft.isMDXComponent=!0;const Dft={toc:[]};function _ft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}_ft.isMDXComponent=!0;const Xft={toc:[]};function xft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}xft.isMDXComponent=!0;const vft={toc:[]};function Cft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Cft.isMDXComponent=!0;const Tft={toc:[]};function bft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}bft.isMDXComponent=!0;const Lft={toc:[]};function Zft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Zft.isMDXComponent=!0;const Nft={toc:[]};function Sft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Sft.isMDXComponent=!0;const Rft={toc:[]};function Eft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}Eft.isMDXComponent=!0;const Aft={toc:[]};function zft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Aft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}zft.isMDXComponent=!0;const Pft={toc:[]};function Ift(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}Ift.isMDXComponent=!0;const Fft={toc:[]};function Wft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Wft.isMDXComponent=!0;const Bft={toc:[]};function Gft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Gft.isMDXComponent=!0;const Oft={toc:[]};function jft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}jft.isMDXComponent=!0;const qft={toc:[]};function Uft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Uft.isMDXComponent=!0;const Vft={toc:[]};function Hft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Hft.isMDXComponent=!0;const $ft={toc:[]};function Jft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$ft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Jft.isMDXComponent=!0;const Yft={toc:[]};function Kft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}Kft.isMDXComponent=!0;const Qft={toc:[]};function tkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}tkt.isMDXComponent=!0;const ekt={toc:[]};function nkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ekt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}nkt.isMDXComponent=!0;const okt={toc:[]};function skt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},okt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}skt.isMDXComponent=!0;const rkt={toc:[]};function ikt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}ikt.isMDXComponent=!0;const pkt={toc:[]};function akt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}akt.isMDXComponent=!0;const ckt={toc:[]};function lkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ckt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}lkt.isMDXComponent=!0;const ukt={toc:[]};function mkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ukt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}mkt.isMDXComponent=!0;const dkt={toc:[]};function hkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}hkt.isMDXComponent=!0;const ykt={toc:[]};function fkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ykt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}fkt.isMDXComponent=!0;const kkt={toc:[]};function wkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}wkt.isMDXComponent=!0;const gkt={toc:[]};function Mkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Mkt.isMDXComponent=!0;const Dkt={toc:[]};function _kt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}_kt.isMDXComponent=!0;const Xkt={toc:[]};function xkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}xkt.isMDXComponent=!0;const vkt={toc:[]};function Ckt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Ckt.isMDXComponent=!0;const Tkt={toc:[]};function bkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}bkt.isMDXComponent=!0;const Lkt={toc:[]};function Zkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Zkt.isMDXComponent=!0;const Nkt={toc:[]};function Skt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Skt.isMDXComponent=!0;const Rkt={toc:[]};function Ekt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}Ekt.isMDXComponent=!0;const Akt={toc:[]};function zkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Akt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}zkt.isMDXComponent=!0;const Pkt={toc:[]};function Ikt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}Ikt.isMDXComponent=!0;const Fkt={toc:[]};function Wkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Wkt.isMDXComponent=!0;const Bkt={toc:[]};function Gkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Gkt.isMDXComponent=!0;const Okt={toc:[]};function jkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Okt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}jkt.isMDXComponent=!0;const qkt={toc:[]};function Ukt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Ukt.isMDXComponent=!0;const Vkt={toc:[]};function Hkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}Hkt.isMDXComponent=!0;const $kt={toc:[]};function Jkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$kt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Jkt.isMDXComponent=!0;const Ykt={toc:[]};function Kkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ykt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}Kkt.isMDXComponent=!0;const Qkt={toc:[]};function twt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}twt.isMDXComponent=!0;const ewt={toc:[]};function nwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ewt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}nwt.isMDXComponent=!0;const owt={toc:[]};function swt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},owt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}swt.isMDXComponent=!0;const rwt={toc:[]};function iwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}iwt.isMDXComponent=!0;const pwt={toc:[]};function awt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}awt.isMDXComponent=!0;const cwt={toc:[]};function lwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}lwt.isMDXComponent=!0;const uwt={toc:[]};function mwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}mwt.isMDXComponent=!0;const dwt={toc:[]};function hwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}hwt.isMDXComponent=!0;const ywt={toc:[]};function fwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ywt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}fwt.isMDXComponent=!0;const kwt={toc:[]};function wwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}wwt.isMDXComponent=!0;const gwt={toc:[]};function Mwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}Mwt.isMDXComponent=!0;const Dwt={toc:[]};function _wt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}_wt.isMDXComponent=!0;const Xwt={toc:[]};function xwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}xwt.isMDXComponent=!0;const vwt={toc:[]};function Cwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Cwt.isMDXComponent=!0;const Twt={toc:[]};function bwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Twt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}bwt.isMDXComponent=!0;const Lwt={toc:[]};function Zwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}Zwt.isMDXComponent=!0;const Nwt={toc:[]};function Swt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}Swt.isMDXComponent=!0;const Rwt={toc:[]};function Ewt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Ewt.isMDXComponent=!0;const Awt={toc:[]};function zwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Awt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}zwt.isMDXComponent=!0;const Pwt={toc:[]};function Iwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}Iwt.isMDXComponent=!0;const Fwt={toc:[]};function Wwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Wwt.isMDXComponent=!0;const Bwt={toc:[]};function Gwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}Gwt.isMDXComponent=!0;const Owt={toc:[]};function jwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Owt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}jwt.isMDXComponent=!0;const qwt={toc:[]};function Uwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}Uwt.isMDXComponent=!0;const Vwt={toc:[]};function Hwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Hwt.isMDXComponent=!0;const $wt={toc:[]};function Jwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$wt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Jwt.isMDXComponent=!0;const Ywt={toc:[]};function Kwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ywt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Kwt.isMDXComponent=!0;const Qwt={toc:[]};function tgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}tgt.isMDXComponent=!0;const egt={toc:[]};function ngt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},egt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ngt.isMDXComponent=!0;const ogt={toc:[]};function sgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ogt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}sgt.isMDXComponent=!0;const rgt={toc:[]};function igt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}igt.isMDXComponent=!0;const pgt={toc:[]};function agt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}agt.isMDXComponent=!0;const cgt={toc:[]};function lgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}lgt.isMDXComponent=!0;const ugt={toc:[]};function mgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ugt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}mgt.isMDXComponent=!0;const dgt={toc:[]};function hgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}hgt.isMDXComponent=!0;const ygt={toc:[]};function fgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ygt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}fgt.isMDXComponent=!0;const kgt={toc:[]};function wgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}wgt.isMDXComponent=!0;const ggt={toc:[]};function Mgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ggt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Mgt.isMDXComponent=!0;const Dgt={toc:[]};function _gt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}_gt.isMDXComponent=!0;const Xgt={toc:[]};function xgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}xgt.isMDXComponent=!0;const vgt={toc:[]};function Cgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Cgt.isMDXComponent=!0;const Tgt={toc:[]};function bgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}bgt.isMDXComponent=!0;const Lgt={toc:[]};function Zgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Zgt.isMDXComponent=!0;const Ngt={toc:[]};function Sgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ngt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}Sgt.isMDXComponent=!0;const Rgt={toc:[]};function Egt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Egt.isMDXComponent=!0;const Agt={toc:[]};function zgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Agt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}zgt.isMDXComponent=!0;const Pgt={toc:[]};function Igt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Igt.isMDXComponent=!0;const Fgt={toc:[]};function Wgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}Wgt.isMDXComponent=!0;const Bgt={toc:[]};function Ggt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Ggt.isMDXComponent=!0;const Ogt={toc:[]};function jgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ogt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}jgt.isMDXComponent=!0;const qgt={toc:[]};function Ugt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Ugt.isMDXComponent=!0;const Vgt={toc:[]};function Hgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}Hgt.isMDXComponent=!0;const $gt={toc:[]};function Jgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$gt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Jgt.isMDXComponent=!0;const Ygt={toc:[]};function Kgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ygt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Kgt.isMDXComponent=!0;const Qgt={toc:[]};function tMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}tMt.isMDXComponent=!0;const eMt={toc:[]};function nMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}nMt.isMDXComponent=!0;const oMt={toc:[]};function sMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}sMt.isMDXComponent=!0;const rMt={toc:[]};function iMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}iMt.isMDXComponent=!0;const pMt={toc:[]};function aMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}aMt.isMDXComponent=!0;const cMt={toc:[]};function lMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}lMt.isMDXComponent=!0;const uMt={toc:[]};function mMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}mMt.isMDXComponent=!0;const dMt={toc:[]};function hMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}hMt.isMDXComponent=!0;const yMt={toc:[]};function fMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}fMt.isMDXComponent=!0;const kMt={toc:[]};function wMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}wMt.isMDXComponent=!0;const gMt={toc:[]};function MMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}MMt.isMDXComponent=!0;const DMt={toc:[]};function _Mt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}_Mt.isMDXComponent=!0;const XMt={toc:[]};function xMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}xMt.isMDXComponent=!0;const vMt={toc:[]};function CMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}CMt.isMDXComponent=!0;const TMt={toc:[]};function bMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}bMt.isMDXComponent=!0;const LMt={toc:[]};function ZMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}ZMt.isMDXComponent=!0;const NMt={toc:[]};function SMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}SMt.isMDXComponent=!0;const RMt={toc:[]};function EMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}EMt.isMDXComponent=!0;const AMt={toc:[]};function zMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}zMt.isMDXComponent=!0;const PMt={toc:[]};function IMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}IMt.isMDXComponent=!0;const FMt={toc:[]};function WMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}WMt.isMDXComponent=!0;const BMt={toc:[]};function GMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}GMt.isMDXComponent=!0;const OMt={toc:[]};function jMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}jMt.isMDXComponent=!0;const qMt={toc:[]};function UMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}UMt.isMDXComponent=!0;const VMt={toc:[]};function HMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}HMt.isMDXComponent=!0;const $Mt={toc:[]};function JMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Mt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}JMt.isMDXComponent=!0;const YMt={toc:[]};function KMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}KMt.isMDXComponent=!0;const QMt={toc:[]};function tDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}tDt.isMDXComponent=!0;const eDt={toc:[]};function nDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}nDt.isMDXComponent=!0;const oDt={toc:[]};function sDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}sDt.isMDXComponent=!0;const rDt={toc:[]};function iDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}iDt.isMDXComponent=!0;const pDt={toc:[]};function aDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}aDt.isMDXComponent=!0;const cDt={toc:[]};function lDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}lDt.isMDXComponent=!0;const uDt={toc:[]};function mDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}mDt.isMDXComponent=!0;const dDt={toc:[]};function hDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}hDt.isMDXComponent=!0;const yDt={toc:[]};function fDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}fDt.isMDXComponent=!0;const kDt={toc:[]};function wDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}wDt.isMDXComponent=!0;const gDt={toc:[]};function MDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}MDt.isMDXComponent=!0;const DDt={toc:[]};function _Dt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}_Dt.isMDXComponent=!0;const XDt={toc:[]};function xDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}xDt.isMDXComponent=!0;const vDt={toc:[]};function CDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}CDt.isMDXComponent=!0;const TDt={toc:[]};function bDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}bDt.isMDXComponent=!0;const LDt={toc:[]};function ZDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}ZDt.isMDXComponent=!0;const NDt={toc:[]};function SDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}SDt.isMDXComponent=!0;const RDt={toc:[]};function EDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}EDt.isMDXComponent=!0;const ADt={toc:[]};function zDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ADt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}zDt.isMDXComponent=!0;const PDt={toc:[]};function IDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}IDt.isMDXComponent=!0;const FDt={toc:[]};function WDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}WDt.isMDXComponent=!0;const BDt={toc:[]};function GDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}GDt.isMDXComponent=!0;const ODt={toc:[]};function jDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ODt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}jDt.isMDXComponent=!0;const qDt={toc:[]};function UDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}UDt.isMDXComponent=!0;const VDt={toc:[]};function HDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}HDt.isMDXComponent=!0;const $Dt={toc:[]};function JDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Dt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}JDt.isMDXComponent=!0;const YDt={toc:[]};function KDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}KDt.isMDXComponent=!0;const QDt={toc:[]};function t_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}t_t.isMDXComponent=!0;const e_t={toc:[]};function n_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},e_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}n_t.isMDXComponent=!0;const o_t={toc:[]};function s_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},o_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}s_t.isMDXComponent=!0;const r_t={toc:[]};function i_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},r_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}i_t.isMDXComponent=!0;const p_t={toc:[]};function a_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},p_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}a_t.isMDXComponent=!0;const c_t={toc:[]};function l_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},c_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}l_t.isMDXComponent=!0;const u_t={toc:[]};function m_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},u_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}m_t.isMDXComponent=!0;const d_t={toc:[]};function h_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},d_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}h_t.isMDXComponent=!0;const y_t={toc:[]};function f_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},y_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}f_t.isMDXComponent=!0;const k_t={toc:[]};function w_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},k_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}w_t.isMDXComponent=!0;const g_t={toc:[]};function M_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},g_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}M_t.isMDXComponent=!0;const D_t={toc:[]};function __t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},D_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}__t.isMDXComponent=!0;const X_t={toc:[]};function x_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},X_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}x_t.isMDXComponent=!0;const v_t={toc:[]};function C_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},v_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}C_t.isMDXComponent=!0;const T_t={toc:[]};function b_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},T_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}b_t.isMDXComponent=!0;const L_t={toc:[]};function Z_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},L_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Z_t.isMDXComponent=!0;const N_t={toc:[]};function S_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},N_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}S_t.isMDXComponent=!0;const R_t={toc:[]};function E_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},R_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}E_t.isMDXComponent=!0;const A_t={toc:[]};function z_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},A_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}z_t.isMDXComponent=!0;const P_t={toc:[]};function I_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},P_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}I_t.isMDXComponent=!0;const F_t={toc:[]};function W_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},F_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}W_t.isMDXComponent=!0;const B_t={toc:[]};function G_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},B_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}G_t.isMDXComponent=!0;const O_t={toc:[]};function j_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},O_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}j_t.isMDXComponent=!0;const q_t={toc:[]};function U_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}U_t.isMDXComponent=!0;const V_t={toc:[]};function H_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},V_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}H_t.isMDXComponent=!0;const $_t={toc:[]};function J_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}J_t.isMDXComponent=!0;const Y_t={toc:[]};function K_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Y_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}K_t.isMDXComponent=!0;const Q_t={toc:[]};function tXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Q_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}tXt.isMDXComponent=!0;const eXt={toc:[]};function nXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}nXt.isMDXComponent=!0;const oXt={toc:[]};function sXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}sXt.isMDXComponent=!0;const rXt={toc:[]};function iXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}iXt.isMDXComponent=!0;const pXt={toc:[]};function aXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}aXt.isMDXComponent=!0;const cXt={toc:[]};function lXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}lXt.isMDXComponent=!0;const uXt={toc:[]};function mXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}mXt.isMDXComponent=!0;const dXt={toc:[]};function hXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}hXt.isMDXComponent=!0;const yXt={toc:[]};function fXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}fXt.isMDXComponent=!0;const kXt={toc:[]};function wXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}wXt.isMDXComponent=!0;const gXt={toc:[]};function MXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}MXt.isMDXComponent=!0;const DXt={toc:[]};function _Xt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}_Xt.isMDXComponent=!0;const XXt={toc:[]};function xXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}xXt.isMDXComponent=!0;const vXt={toc:[]};function CXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}CXt.isMDXComponent=!0;const TXt={toc:[]};function bXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}bXt.isMDXComponent=!0;const LXt={toc:[]};function ZXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}ZXt.isMDXComponent=!0;const NXt={toc:[]};function SXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}SXt.isMDXComponent=!0;const RXt={toc:[]};function EXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}EXt.isMDXComponent=!0;const AXt={toc:[]};function zXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}zXt.isMDXComponent=!0;const PXt={toc:[]};function IXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}IXt.isMDXComponent=!0;const FXt={toc:[]};function WXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}WXt.isMDXComponent=!0;const BXt={toc:[]};function GXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}GXt.isMDXComponent=!0;const OXt={toc:[]};function jXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}jXt.isMDXComponent=!0;const qXt={toc:[]};function UXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}UXt.isMDXComponent=!0;const VXt={toc:[]};function HXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}HXt.isMDXComponent=!0;const $Xt={toc:[]};function JXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Xt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}JXt.isMDXComponent=!0;const YXt={toc:[]};function KXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}KXt.isMDXComponent=!0;const QXt={toc:[]};function txt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}txt.isMDXComponent=!0;const ext={toc:[]};function nxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ext,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}nxt.isMDXComponent=!0;const oxt={toc:[]};function sxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}sxt.isMDXComponent=!0;const rxt={toc:[]};function ixt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}ixt.isMDXComponent=!0;const pxt={toc:[]};function axt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}axt.isMDXComponent=!0;const cxt={toc:[]};function lxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lxt.isMDXComponent=!0;const uxt={toc:[]};function mxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}mxt.isMDXComponent=!0;const dxt={toc:[]};function hxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}hxt.isMDXComponent=!0;const yxt={toc:[]};function fxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}fxt.isMDXComponent=!0;const kxt={toc:[]};function wxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}wxt.isMDXComponent=!0;const gxt={toc:[]};function Mxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}Mxt.isMDXComponent=!0;const Dxt={toc:[]};function _xt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}_xt.isMDXComponent=!0;const Xxt={toc:[]};function xxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}xxt.isMDXComponent=!0;const vxt={toc:[]};function Cxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Cxt.isMDXComponent=!0;const Txt={toc:[]};function bxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Txt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}bxt.isMDXComponent=!0;const Lxt={toc:[]};function Zxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Zxt.isMDXComponent=!0;const Nxt={toc:[]};function Sxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}Sxt.isMDXComponent=!0;const Rxt={toc:[]};function Ext(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Ext.isMDXComponent=!0;const Axt={toc:[]};function zxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Axt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}zxt.isMDXComponent=!0;const Pxt={toc:[]};function Ixt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}Ixt.isMDXComponent=!0;const Fxt={toc:[]};function Wxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Wxt.isMDXComponent=!0;const Bxt={toc:[]};function Gxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}Gxt.isMDXComponent=!0;const Oxt={toc:[]};function jxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}jxt.isMDXComponent=!0;const qxt={toc:[]};function Uxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Uxt.isMDXComponent=!0;const Vxt={toc:[]};function Hxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Hxt.isMDXComponent=!0;const $xt={toc:[]};function Jxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$xt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Jxt.isMDXComponent=!0;const Yxt={toc:[]};function Kxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Kxt.isMDXComponent=!0;const Qxt={toc:[]};function tvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}tvt.isMDXComponent=!0;const evt={toc:[]};function nvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},evt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}nvt.isMDXComponent=!0;const ovt={toc:[]};function svt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ovt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}svt.isMDXComponent=!0;const rvt={toc:[]};function ivt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}ivt.isMDXComponent=!0;const pvt={toc:[]};function avt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}avt.isMDXComponent=!0;const cvt={toc:[]};function lvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}lvt.isMDXComponent=!0;const uvt={toc:[]};function mvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}mvt.isMDXComponent=!0;const dvt={toc:[]};function hvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}hvt.isMDXComponent=!0;const yvt={toc:[]};function fvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}fvt.isMDXComponent=!0;const kvt={toc:[]};function wvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}wvt.isMDXComponent=!0;const gvt={toc:[]};function Mvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}Mvt.isMDXComponent=!0;const Dvt={toc:[]};function _vt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}_vt.isMDXComponent=!0;const Xvt={toc:[]};function xvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}xvt.isMDXComponent=!0;const vvt={toc:[]};function Cvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Cvt.isMDXComponent=!0;const Tvt={toc:[]};function bvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}bvt.isMDXComponent=!0;const Lvt={toc:[]};function Zvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}Zvt.isMDXComponent=!0;const Nvt={toc:[]};function Svt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Svt.isMDXComponent=!0;const Rvt={toc:[]};function Evt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}Evt.isMDXComponent=!0;const Avt={toc:[]};function zvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Avt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}zvt.isMDXComponent=!0;const Pvt={toc:[]};function Ivt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Ivt.isMDXComponent=!0;const Fvt={toc:[]};function Wvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Wvt.isMDXComponent=!0;const Bvt={toc:[]};function Gvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Gvt.isMDXComponent=!0;const Ovt={toc:[]};function jvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ovt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}jvt.isMDXComponent=!0;const qvt={toc:[]};function Uvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Uvt.isMDXComponent=!0;const Vvt={toc:[]};function Hvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Hvt.isMDXComponent=!0;const $vt={toc:[]};function Jvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$vt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Jvt.isMDXComponent=!0;const Yvt={toc:[]};function Kvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Kvt.isMDXComponent=!0;const Qvt={toc:[]};function tCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}tCt.isMDXComponent=!0;const eCt={toc:[]};function nCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}nCt.isMDXComponent=!0;const oCt={toc:[]};function sCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}sCt.isMDXComponent=!0;const rCt={toc:[]};function iCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}iCt.isMDXComponent=!0;const pCt={toc:[]};function aCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}aCt.isMDXComponent=!0;const cCt={toc:[]};function lCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}lCt.isMDXComponent=!0;const uCt={toc:[]};function mCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}mCt.isMDXComponent=!0;const dCt={toc:[]};function hCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}hCt.isMDXComponent=!0;const yCt={toc:[]};function fCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}fCt.isMDXComponent=!0;const kCt={toc:[]};function wCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}wCt.isMDXComponent=!0;const gCt={toc:[]};function MCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}MCt.isMDXComponent=!0;const DCt={toc:[]};function _Ct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}_Ct.isMDXComponent=!0;const XCt={toc:[]};function xCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}xCt.isMDXComponent=!0;const vCt={toc:[]};function CCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}CCt.isMDXComponent=!0;const TCt={toc:[]};function bCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}bCt.isMDXComponent=!0;const LCt={toc:[]};function ZCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}ZCt.isMDXComponent=!0;const NCt={toc:[]};function SCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}SCt.isMDXComponent=!0;const RCt={toc:[]};function ECt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}ECt.isMDXComponent=!0;const ACt={toc:[]};function zCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ACt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}zCt.isMDXComponent=!0;const PCt={toc:[]};function ICt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}ICt.isMDXComponent=!0;const FCt={toc:[]};function WCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}WCt.isMDXComponent=!0;const BCt={toc:[]};function GCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}GCt.isMDXComponent=!0;const OCt={toc:[]};function jCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}jCt.isMDXComponent=!0;const qCt={toc:[]};function UCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}UCt.isMDXComponent=!0;const VCt={toc:[]};function HCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}HCt.isMDXComponent=!0;const $Ct={toc:[]};function JCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Ct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}JCt.isMDXComponent=!0;const YCt={toc:[]};function KCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}KCt.isMDXComponent=!0;const QCt={toc:[]};function tTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}tTt.isMDXComponent=!0;const eTt={toc:[]};function nTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}nTt.isMDXComponent=!0;const oTt={toc:[]};function sTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}sTt.isMDXComponent=!0;const rTt={toc:[]};function iTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}iTt.isMDXComponent=!0;const pTt={toc:[]};function aTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}aTt.isMDXComponent=!0;const cTt={toc:[]};function lTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}lTt.isMDXComponent=!0;const uTt={toc:[]};function mTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}mTt.isMDXComponent=!0;const dTt={toc:[]};function hTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}hTt.isMDXComponent=!0;const yTt={toc:[]};function fTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}fTt.isMDXComponent=!0;const kTt={toc:[]};function wTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}wTt.isMDXComponent=!0;const gTt={toc:[]};function MTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}MTt.isMDXComponent=!0;const DTt={toc:[]};function _Tt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}_Tt.isMDXComponent=!0;const XTt={toc:[]};function xTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}xTt.isMDXComponent=!0;const vTt={toc:[]};function CTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}CTt.isMDXComponent=!0;const TTt={toc:[]};function bTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}bTt.isMDXComponent=!0;const LTt={toc:[]};function ZTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}ZTt.isMDXComponent=!0;const NTt={toc:[]};function STt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}STt.isMDXComponent=!0;const RTt={toc:[]};function ETt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}ETt.isMDXComponent=!0;const ATt={toc:[]};function zTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ATt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}zTt.isMDXComponent=!0;const PTt={toc:[]};function ITt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}ITt.isMDXComponent=!0;const FTt={toc:[]};function WTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}WTt.isMDXComponent=!0;const BTt={toc:[]};function GTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}GTt.isMDXComponent=!0;const OTt={toc:[]};function jTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}jTt.isMDXComponent=!0;const qTt={toc:[]};function UTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the path of this circle should be closed."))}UTt.isMDXComponent=!0;const VTt={toc:[]};function HTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property can be used together with ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,i.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}HTt.isMDXComponent=!0;const $Tt={toc:[]};function JTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Tt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ending angle in degrees for the circle sector."))}JTt.isMDXComponent=!0;const YTt={toc:[]};function KTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property can be used together with ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,i.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}KTt.isMDXComponent=!0;const QTt={toc:[]};function tbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The starting angle in degrees for the circle sector."))}tbt.isMDXComponent=!0;const ebt={toc:[]};function nbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ebt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provide the color in one of the following formats:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"named color like ",(0,i.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,i.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}nbt.isMDXComponent=!0;const obt={toc:[]};function sbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},obt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The color of the icon"))}sbt.isMDXComponent=!0;const rbt={toc:[]};function ibt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}ibt.isMDXComponent=!0;const pbt={toc:[]};function abt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}abt.isMDXComponent=!0;const cbt={toc:[]};function lbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"You can find identifiers on ",(0,i.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}lbt.isMDXComponent=!0;const ubt={toc:[]};function mbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ubt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The identifier of the icon."))}mbt.isMDXComponent=!0;const dbt={toc:[]};function hbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}hbt.isMDXComponent=!0;const ybt={toc:[]};function fbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ybt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}fbt.isMDXComponent=!0;const kbt={toc:[]};function wbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}wbt.isMDXComponent=!0;const gbt={toc:[]};function Mbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}Mbt.isMDXComponent=!0;const Dbt={toc:[]};function _bt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}_bt.isMDXComponent=!0;const Xbt={toc:[]};function xbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}xbt.isMDXComponent=!0;const vbt={toc:[]};function Cbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}Cbt.isMDXComponent=!0;const Tbt={toc:[]};function bbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}bbt.isMDXComponent=!0;const Lbt={toc:[]};function Zbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,i.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,i.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,i.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,i.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Zbt.isMDXComponent=!0;const Nbt={toc:[]};function Sbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}Sbt.isMDXComponent=!0;const Rbt={toc:[]};function Ebt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,i.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,i.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,i.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,i.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Ebt.isMDXComponent=!0;const Abt={toc:[]};function zbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Abt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}zbt.isMDXComponent=!0;const Pbt={toc:[]};function Ibt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Ibt.isMDXComponent=!0;const Fbt={toc:[]};function Wbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}Wbt.isMDXComponent=!0;const Bbt={toc:[]};function Gbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Gbt.isMDXComponent=!0;const Obt={toc:[]};function jbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Obt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}jbt.isMDXComponent=!0;const qbt={toc:[]};function Ubt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"For example, a value of 6 creates a hexagon."))}Ubt.isMDXComponent=!0;const Vbt={toc:[]};function Hbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Sets the number of sides of the polygon."))}Hbt.isMDXComponent=!0;const $bt={toc:[]};function Jbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$bt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Jbt.isMDXComponent=!0;const Ybt={toc:[]};function Kbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ybt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}Kbt.isMDXComponent=!0;const Qbt={toc:[]};function tLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}tLt.isMDXComponent=!0;const eLt={toc:[]};function nLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}nLt.isMDXComponent=!0;const oLt={toc:[]};function sLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Spline.points"))}sLt.isMDXComponent=!0;const rLt={toc:[]};function iLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}iLt.isMDXComponent=!0;const pLt={toc:[]};function aLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}aLt.isMDXComponent=!0;const cLt={toc:[]};function lLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}lLt.isMDXComponent=!0;const uLt={toc:[]};function mLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}mLt.isMDXComponent=!0;const dLt={toc:[]};function hLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}hLt.isMDXComponent=!0;const yLt={toc:[]};function fLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}fLt.isMDXComponent=!0;const kLt={toc:[]};function wLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}wLt.isMDXComponent=!0;const gLt={toc:[]};function MLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Evaluate the polynomial at the given t value."))}MLt.isMDXComponent=!0;const DLt={toc:[]};function _Lt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The t value at which to evaluate the curve."))}_Lt.isMDXComponent=!0;const XLt={toc:[]};function xLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}xLt.isMDXComponent=!0;const vLt={toc:[]};function CLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The t value at which to evaluate the curve."))}CLt.isMDXComponent=!0;const TLt={toc:[]};function bLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,i.kt)("p",null,"Source code liberally taken from:\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}bLt.isMDXComponent=!0;const LLt={toc:[]};function ZLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constant coefficient"))}ZLt.isMDXComponent=!0;const NLt={toc:[]};function SLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constant coefficient"))}SLt.isMDXComponent=!0;const RLt={toc:[]};function ELt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The linear coefficient"))}ELt.isMDXComponent=!0;const ALt={toc:[]};function zLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ALt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constant coefficient"))}zLt.isMDXComponent=!0;const PLt={toc:[]};function ILt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The linear coefficient"))}ILt.isMDXComponent=!0;const FLt={toc:[]};function WLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The quadratic coefficient"))}WLt.isMDXComponent=!0;const BLt={toc:[]};function GLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constant coefficient"))}GLt.isMDXComponent=!0;const OLt={toc:[]};function jLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The linear coefficient"))}jLt.isMDXComponent=!0;const qLt={toc:[]};function ULt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The quadratic coefficient"))}ULt.isMDXComponent=!0;const VLt={toc:[]};function HLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The cubic coefficient"))}HLt.isMDXComponent=!0;const $Lt={toc:[]};function JLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Lt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The degree of the polynomial"))}JLt.isMDXComponent=!0;const YLt={toc:[]};function KLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the nth derivative of the polynomial."))}KLt.isMDXComponent=!0;const QLt={toc:[]};function tZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The number of times to differentiate the polynomial."))}tZt.isMDXComponent=!0;const eZt={toc:[]};function nZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Evaluate the polynomial at the given value t."))}nZt.isMDXComponent=!0;const oZt={toc:[]};function sZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value to sample at"))}sZt.isMDXComponent=!0;const rZt={toc:[]};function iZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}iZt.isMDXComponent=!0;const pZt={toc:[]};function aZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value to sample at"))}aZt.isMDXComponent=!0;const cZt={toc:[]};function lZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The derivative of the polynomial to sample from"))}lZt.isMDXComponent=!0;const uZt={toc:[]};function mZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the local extrema of the polynomial."))}mZt.isMDXComponent=!0;const dZt={toc:[]};function hZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}hZt.isMDXComponent=!0;const yZt={toc:[]};function fZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the output value range within the unit interval."))}fZt.isMDXComponent=!0;const kZt={toc:[]};function wZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}wZt.isMDXComponent=!0;const gZt={toc:[]};function MZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}MZt.isMDXComponent=!0;const DZt={toc:[]};function _Zt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}_Zt.isMDXComponent=!0;const XZt={toc:[]};function xZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The point at which to split the polynomial."))}xZt.isMDXComponent=!0;const vZt={toc:[]};function CZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Constructs a constant polynomial"))}CZt.isMDXComponent=!0;const TZt={toc:[]};function bZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constant coefficient"))}bZt.isMDXComponent=!0;const LZt={toc:[]};function ZZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Constructs a cubic polynomial"))}ZZt.isMDXComponent=!0;const NZt={toc:[]};function SZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constant coefficient"))}SZt.isMDXComponent=!0;const RZt={toc:[]};function EZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The linear coefficient"))}EZt.isMDXComponent=!0;const AZt={toc:[]};function zZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The quadratic coefficient"))}zZt.isMDXComponent=!0;const PZt={toc:[]};function IZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The cubic coefficient"))}IZt.isMDXComponent=!0;const FZt={toc:[]};function WZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Constructs a linear polynomial"))}WZt.isMDXComponent=!0;const BZt={toc:[]};function GZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constant coefficient"))}GZt.isMDXComponent=!0;const OZt={toc:[]};function jZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The linear coefficient"))}jZt.isMDXComponent=!0;const qZt={toc:[]};function UZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Constructs a quadratic polynomial"))}UZt.isMDXComponent=!0;const VZt={toc:[]};function HZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constant coefficient"))}HZt.isMDXComponent=!0;const $Zt={toc:[]};function JZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Zt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The linear coefficient"))}JZt.isMDXComponent=!0;const YZt={toc:[]};function KZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The quadratic coefficient"))}KZt.isMDXComponent=!0;const QZt={toc:[]};function tNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}tNt.isMDXComponent=!0;const eNt={toc:[]};function nNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}nNt.isMDXComponent=!0;const oNt={toc:[]};function sNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Evaluate the polynomial at the given t value."))}sNt.isMDXComponent=!0;const rNt={toc:[]};function iNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The t value at which to evaluate the curve."))}iNt.isMDXComponent=!0;const pNt={toc:[]};function aNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}aNt.isMDXComponent=!0;const cNt={toc:[]};function lNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The t value at which to evaluate the curve."))}lNt.isMDXComponent=!0;const uNt={toc:[]};function mNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,i.kt)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}mNt.isMDXComponent=!0;const dNt={toc:[]};function hNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dNt,n,{components:e,mdxType:"MDXLayout"}))}hNt.isMDXComponent=!0;const yNt={toc:[]};function fNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}fNt.isMDXComponent=!0;const kNt={toc:[]};function wNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The knots defining the spline"))}wNt.isMDXComponent=!0;const gNt={toc:[]};function MNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the spline should be closed or not"))}MNt.isMDXComponent=!0;const DNt={toc:[]};function _Nt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}_Nt.isMDXComponent=!0;const XNt={toc:[]};function xNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}xNt.isMDXComponent=!0;const vNt={toc:[]};function CNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the signal is currently using its initial value."))}CNt.isMDXComponent=!0;const TNt={toc:[]};function bNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,i.kt)("p",null,"This method can be used to create copies of signals."))}bNt.isMDXComponent=!0;const LNt={toc:[]};function ZNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}ZNt.isMDXComponent=!0;const NNt={toc:[]};function SNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the raw value of this signal."))}SNt.isMDXComponent=!0;const RNt={toc:[]};function ENt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}ENt.isMDXComponent=!0;const ANt={toc:[]};function zNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ANt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}zNt.isMDXComponent=!0;const PNt={toc:[]};function INt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}INt.isMDXComponent=!0;const FNt={toc:[]};function WNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}WNt.isMDXComponent=!0;const BNt={toc:[]};function GNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Compute the current value of the signal and immediately set it."))}GNt.isMDXComponent=!0;const ONt={toc:[]};function jNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ONt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,i.kt)("p",null,"By default, any property is cloneable."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}jNt.isMDXComponent=!0;const qNt={toc:[]};function UNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}UNt.isMDXComponent=!0;const VNt={toc:[]};function HNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a cloneable property decorator."))}HNt.isMDXComponent=!0;const $Nt={toc:[]};function JNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Nt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the property should be cloneable."))}JNt.isMDXComponent=!0;const YNt={toc:[]};function KNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}KNt.isMDXComponent=!0;const QNt={toc:[]};function tSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}tSt.isMDXComponent=!0;const eSt={toc:[]};function nSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a compound property decorator."))}nSt.isMDXComponent=!0;const oSt={toc:[]};function sSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}sSt.isMDXComponent=!0;const rSt={toc:[]};function iSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,i.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,i.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}iSt.isMDXComponent=!0;const pSt={toc:[]};function aSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a computed method decorator."))}aSt.isMDXComponent=!0;const cSt={toc:[]};function lSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator specifies the initial value of a property."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}lSt.isMDXComponent=!0;const uSt={toc:[]};function mSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}mSt.isMDXComponent=!0;const dSt={toc:[]};function hSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an initial signal value decorator."))}hSt.isMDXComponent=!0;const ySt={toc:[]};function fSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ySt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The initial value of the property."))}fSt.isMDXComponent=!0;const kSt={toc:[]};function wSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,i.kt)("p",null,"By default, any property is inspectable."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}wSt.isMDXComponent=!0;const gSt={toc:[]};function MSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}MSt.isMDXComponent=!0;const DSt={toc:[]};function _St(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an inspectable property decorator."))}_St.isMDXComponent=!0;const XSt={toc:[]};function xSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the property should be inspectable."))}xSt.isMDXComponent=!0;const vSt={toc:[]};function CSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}CSt.isMDXComponent=!0;const TSt={toc:[]};function bSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}bSt.isMDXComponent=!0;const LSt={toc:[]};function ZSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a signal interpolation function decorator."))}ZSt.isMDXComponent=!0;const NSt={toc:[]};function SSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The interpolation function for the property."))}SSt.isMDXComponent=!0;const RSt={toc:[]};function ESt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,i.kt)("p",null,"If the wrapper class has a method called ",(0,i.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}ESt.isMDXComponent=!0;const ASt={toc:[]};function zSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ASt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}zSt.isMDXComponent=!0;const PSt={toc:[]};function ISt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a signal parser decorator."))}ISt.isMDXComponent=!0;const FSt={toc:[]};function WSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The wrapper class for the property."))}WSt.isMDXComponent=!0;const BSt={toc:[]};function GSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator turns the given property into a signal."),(0,i.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}GSt.isMDXComponent=!0;const OSt={toc:[]};function jSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}jSt.isMDXComponent=!0;const qSt={toc:[]};function USt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a signal decorator."))}USt.isMDXComponent=!0;const VSt={toc:[]};function HSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,i.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,i.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,i.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,i.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}HSt.isMDXComponent=!0;const $St={toc:[]};function JSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$St,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}JSt.isMDXComponent=!0;const YSt={toc:[]};function KSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a signal wrapper decorator."))}KSt.isMDXComponent=!0;const QSt={toc:[]};function tRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The wrapper class for the property."))}tRt.isMDXComponent=!0;const eRt={toc:[]};function nRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A unified abstraction for all CSS filters."))}nRt.isMDXComponent=!0;const oRt={toc:[]};function sRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the desired length is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}sRt.isMDXComponent=!0;const rRt={toc:[]};function iRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}iRt.isMDXComponent=!0;const pRt={toc:[]};function aRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value can be either:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'"))))}aRt.isMDXComponent=!0;const cRt={toc:[]};function lRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents a length used by most layout properties."))}lRt.isMDXComponent=!0;const uRt={toc:[]};function mRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,i.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}mRt.isMDXComponent=!0;const dRt={toc:[]};function hRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,i.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}hRt.isMDXComponent=!0;const yRt={toc:[]};function fRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter in pixels."))}fRt.isMDXComponent=!0;const kRt={toc:[]};function wRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,i.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}wRt.isMDXComponent=!0;const gRt={toc:[]};function MRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}MRt.isMDXComponent=!0;const DRt={toc:[]};function _Rt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,i.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}_Rt.isMDXComponent=!0;const XRt={toc:[]};function xRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}xRt.isMDXComponent=!0;const vRt={toc:[]};function CRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,i.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}CRt.isMDXComponent=!0;const TRt={toc:[]};function bRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}bRt.isMDXComponent=!0;const LRt={toc:[]};function ZRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,i.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}ZRt.isMDXComponent=!0;const NRt={toc:[]};function SRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter in degrees."))}SRt.isMDXComponent=!0;const RRt={toc:[]};function ERt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,i.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}ERt.isMDXComponent=!0;const ARt={toc:[]};function zRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ARt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}zRt.isMDXComponent=!0;const PRt={toc:[]};function IRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,i.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}IRt.isMDXComponent=!0;const FRt={toc:[]};function WRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}WRt.isMDXComponent=!0;const BRt={toc:[]};function GRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,i.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}GRt.isMDXComponent=!0;const ORt={toc:[]};function jRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ORt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}jRt.isMDXComponent=!0;const qRt={toc:[]};function URt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}URt.isMDXComponent=!0;const VRt={toc:[]};function HRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Invoke the given callback in the context of this scene."))}HRt.isMDXComponent=!0;const $Rt={toc:[]};function JRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Rt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The callback to invoke."))}JRt.isMDXComponent=!0;const YRt={toc:[]};function KRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the view."),(0,i.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,i.kt)("p",null,"Can modify the state of the view."))}function QRt(t){let{id:e}=t;const n=o[e]??s.Fragment;return s.createElement(n,null)}KRt.isMDXComponent=!0},79322:(t,e,n)=>{"use strict";n.d(e,{Z:()=>m});var o=n(2784),s=n(93342),r=n(28698);const i="toggle_S_IX",p="collapsed_wdUB",a="collapse_TjTN",c="inverse_g6vW",l="clearFix_HQ1T";var u=n(6277);function m(t){let{comment:e,full:n=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@remarks"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(s.Z,{id:null==e?void 0:e.summaryId}),o.createElement(s.Z,{id:null==r?void 0:r.contentId}),n&&o.createElement(d,{comment:e}))}function d(t){let{comment:e}=t;const[n,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return(null==e||null==(t=e.blockTags)?void 0:t.filter((t=>{let{tag:e}=t;return"@example"===e})))??[]}),[e]),h=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@defaultValue"===e}))}),[e]),y=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@deprecated"===e}))}),[e]),f=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@see"===e}))}),[e]);return o.createElement(o.Fragment,null,d.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(i,n&&p),onClick:t=>{t.preventDefault(),m(!n)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:n},o.createElement("div",{className:a},d.map((t=>o.createElement(s.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,c)})),h&&o.createElement(o.Fragment,null,"Default Value:"," ",o.createElement("code",null,h.content.map((t=>t.text)).join(""))),y&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(s.Z,{id:y.contentId})),f&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(s.Z,{id:f.contentId})))}},31930:(t,e,n)=>{"use strict";n.d(e,{Z:()=>Gt});var o=n(2784),s=n(37390),r=n(66835),i=n(80068),p=n(6277),a=n(68569);const c={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=n(7896);function u(t){let{width:e=24,height:n=24,...s}=t;return o.createElement("svg",(0,l.Z)({width:e,height:n,"aria-hidden":"true",viewBox:"0 0 24 24"},s),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:e,highlight:n,onClick:s,link:l}=t;const m=(0,r.F)(),d=(0,i.s2)();return o.createElement("div",{className:(0,p.Z)(a.Z.codeBlockContent,c.codeBlock,n&&c.highlight,s&&c.pointer)},o.createElement("pre",{onClick:s,onKeyDown:t=>{"Enter"===t.key&&(null==s||s())},tabIndex:0,ref:m.codeBlockRef,className:(0,p.Z)(a.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:a.Z.codeBlockLines,style:d},e)),l&&o.createElement("div",{className:a.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=n(39318);function h(t){let{children:e}=t;return o.createElement(d.Z,{as:"div",className:(0,p.Z)(c.codeBlockContainer,"language-typescript")},e)}var y=n(89817);function f(t){let{children:e,type:n,to:s,id:r,tooltip:p}=t;const a=(0,i.Ld)(n);return s?o.createElement(y.Z,(0,l.Z)({id:r,to:s,"data-tooltip":p},a),e):o.createElement("span",(0,l.Z)({id:r},a),e)}let k,w;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(k||(k={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(w||(w={}));const g={[k.None]:c.none,[k.Angle]:c.angle,[k.Curly]:c.curly,[k.Square]:c.square,[k.Parentheses]:c.parentheses};function M(t){let{children:e,type:n,separator:s=w.Comma}=t;return o.createElement("span",{className:(0,p.Z)(c.list,g[n??k.None])},o.createElement("span",{className:(0,p.Z)(c.elements,s!==w.Comma&&c.left)},(Array.isArray(e)?e:[e]).flatMap(((t,e)=>o.createElement("span",{"data-separator":s,key:e,className:c.element},t)))))}var D=n(88617);function _(t){var e;let{type:n}=t;const s=(0,D.RU)(n.project),r=null==s?void 0:s[n.id],i=n.externalUrl??(0,D.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(f,{to:i,type:i?"class-name":"constant",tooltip:!0},n.name),!(null==(e=n.typeArguments)||!e.length)&&o.createElement(M,{type:k.Angle},n.typeArguments.map(((t,e)=>o.createElement(F,{key:e,type:t})))))}function X(t){let{type:e}=t;return o.createElement(f,{type:"keyword"},e.name)}function x(t){let{type:e}=t;return e.elements?o.createElement(M,{type:k.Square},e.elements.map(((t,e)=>o.createElement(F,{key:e,type:t})))):o.createElement(o.Fragment,null,"[]")}function v(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(F,{type:e.elementType}),"[]")}function C(t){let{type:e}=t;return o.createElement(M,{type:k.Parentheses,separator:w.Pipe},e.types.map(((t,e)=>o.createElement(F,{key:e,type:t}))))}function T(t){let{type:e}=t;const[n,s]=(0,o.useMemo)((()=>{if(null===e.value)return["null","keyword"];switch(typeof e.value){case"object":return[(e.value.negative?"-":"")+e.value.value,"number"];case"boolean":return[e.value,"keyword"];case"number":return[e.value,"number"];case"string":return[`'${e.value}'`,"string"];default:return[e.value,"constant"]}}),[e.value]);return o.createElement(f,{type:s},n)}function b(t){let{type:e}=t;return e.asserts?o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"asserts "),o.createElement(f,null,e.name," ")):o.createElement(o.Fragment,null,o.createElement(f,null,e.name," "),o.createElement(f,{type:"keyword"},"is "),o.createElement(F,{type:e.targetType}))}function L(t){let{type:e}=t;const n=(0,D.in)();return o.createElement(J,{reflection:n(e.declaration)})}function Z(t){let{type:e}=t;return o.createElement(M,{type:k.Parentheses,separator:w.Ampersand},e.types.map(((t,e)=>o.createElement(F,{key:e,type:t}))))}function N(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(f,{type:"string"},"`",e.head),e.tail.map(((t,e)=>{let[n,s]=t;return o.createElement(o.Fragment,null,"${",o.createElement(F,{key:e,type:n}),"}",o.createElement(f,{type:"string"},s))})),o.createElement(f,{type:"string"},"`"))}function S(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"typeof "),o.createElement(F,{type:e.queryType}))}function R(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(F,{type:e.checkType}),o.createElement(f,{type:"keyword"}," extends "),o.createElement(F,{type:e.extendsType})," ? ",o.createElement(F,{type:e.trueType})," : ",o.createElement(F,{type:e.falseType}))}function E(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"infer "),o.createElement(f,{type:"constant"},e.name))}function A(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(F,{type:e.objectType}),"[",o.createElement(F,{type:e.indexType}),"]")}function z(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},e.operator," "),o.createElement(F,{type:e.target}))}function P(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(M,{type:k.Curly},o.createElement(o.Fragment,null,"[",o.createElement(f,{type:"class"},e.parameter),o.createElement(f,{type:"keyword"}," in "),o.createElement(F,{type:e.parameterType}),"]: ",o.createElement(F,{type:e.templateType}))))}function I(t){let{type:e}=t;return o.createElement(o.Fragment,null,e.name,": ",o.createElement(F,{type:e.element}))}function F(t){const e=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return z;case"conditional":return R;case"reflection":return L;case"query":return S;case"named-tuple-member":return I;case"union":return C;case"intrinsic":return X;case"literal":return T;case"reference":return _;case"predicate":return b;case"tuple":return x;case"array":return v;case"intersection":return Z;case"inferred":return E;case"mapped":return P;case"template-literal":return N;case"indexedAccess":return A}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(e,t)}function W(t){let{flags:e,explicitAccessModifier:n}=t;const s=[];return null!=e&&e.isAbstract&&s.push("abstract"),null!=e&&e.isStatic&&s.push("static"),null!=e&&e.isConst&&s.push("const"),null!=e&&e.isReadonly&&s.push("readonly"),null!=e&&e.isPrivate&&s.push("private"),null!=e&&e.isProtected&&s.push("protected"),(null==e||!e.isPublic)&&(!n||null!=e&&e.isProtected||null!=e&&e.isPrivate)||s.push("public"),o.createElement(o.Fragment,null,s.map((t=>o.createElement(f,{key:t,type:"keyword"},t," "))))}function B(t){let{reflection:e}=t;const n="__namedParameters"===e.name?"{...}":e.name;return o.createElement(o.Fragment,null,o.createElement(W,{flags:e.flags}),e.flags.isRest&&"...",o.createElement(f,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"plain"},n),e.flags.isOptional&&"?",": ",e.type&&o.createElement(F,{type:e.type}),e.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(f,{type:"plain"},e.defaultValue)))}function G(t){let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(W,{flags:e.flags}),e.varianceModifier&&o.createElement(f,{type:"keyword"},e.varianceModifier," "),o.createElement(f,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"class-name"},e.name),e.type&&o.createElement(o.Fragment,null," extends ",o.createElement(F,{type:e.type})),e.default&&o.createElement(o.Fragment,null," = ",o.createElement(F,{type:e.default})))}function O(t){var e,n;let{reflection:r,flags:i}=t;const p=(0,D.in)(),a="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(W,{flags:i??r.flags,explicitAccessModifier:!a}),r.kind===s.W.GetSignature&&o.createElement(f,{type:"keyword"},"get "),r.kind===s.W.SetSignature&&o.createElement(f,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(f,{to:r.overwrites.externalUrl??(0,D.Gr)(p(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===s.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(f,{to:"#",type:"keyword"},"new")," ",o.createElement(f,{type:"plain"},r.type.name)):a?"":o.createElement(f,{type:"function"},r.name),!(null==(e=r.typeParameter)||!e.length)&&o.createElement(M,{type:k.Angle},r.typeParameter.map((t=>o.createElement(G,{key:t.id,reflection:p(t)})))),null!=(n=r.parameters)&&n.length?o.createElement(M,{type:k.Parentheses},r.parameters.map((t=>o.createElement(B,{key:t,reflection:p(t)})))):"()",r.type&&o.createElement(o.Fragment,null,a?" => ":": ",o.createElement(F,{type:r.type})))}function j(t){let{reflection:e}=t;return o.createElement(B,{reflection:e})}const q={[s.W.Namespace]:"namespace",[s.W.Enum]:"enum",[s.W.Class]:"class",[s.W.Interface]:"interface"};function U(t){var e,n,s;let{reflection:r}=t;const i=(0,D.in)();return o.createElement(o.Fragment,null,o.createElement(W,{flags:r.flags}),o.createElement(f,{type:"keyword"},q[r.kind]," "),o.createElement(f,{type:"class-name"},r.name),!(null==(e=r.typeParameters)||!e.length)&&o.createElement(M,{type:k.Angle},r.typeParameters.map((t=>o.createElement(G,{key:t.id,reflection:i(t)}))))," ",!(null==(n=r.extendedTypes)||!n.length)&&o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"extends "),o.createElement(M,null,r.extendedTypes.map(((t,e)=>o.createElement(F,{key:e,type:t}))))),!(null==(s=r.implementedTypes)||!s.length)&&o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"implements "),o.createElement(M,null,r.implementedTypes.map(((t,e)=>o.createElement(F,{key:e,type:t}))))))}function V(t){let{reflection:e}=t;const n=(0,D.in)();return o.createElement(o.Fragment,null,o.createElement(W,{flags:e.flags}),o.createElement(f,{type:"keyword"},"type "),o.createElement(f,{type:"class-name"},e.name),e.typeParameters&&o.createElement(M,{type:k.Angle},e.typeParameters.map((t=>o.createElement(G,{key:t.id,reflection:n(t)}))))," = ",o.createElement(F,{type:e.type}))}function H(t){let{reflection:e}=t;const n=(0,D.in)();return e.signatures?o.createElement(O,{reflection:e.signatures[0]}):e.children?o.createElement(M,{type:k.Curly},e.children.map((t=>o.createElement(J,{key:t.id,reflection:n(t)})))):o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"unknown"))}function $(t){var e;let{reflection:n}=t;const s=(null==(e=n.signatures)?void 0:e[0])??n.getSignature??n.setSignature??n.indexSignature;return o.createElement(O,{reflection:s})}function J(t){let{reflection:e}=t;const n=(0,o.useMemo)((()=>{switch(e.kind){case s.W.Project:case s.W.Module:case s.W.EnumMember:case s.W.Variable:case s.W.Function:break;case s.W.Namespace:case s.W.Enum:case s.W.Class:case s.W.Interface:return U;case s.W.Constructor:return O;case s.W.Property:return j;case s.W.Method:return $;case s.W.CallSignature:case s.W.IndexSignature:case s.W.ConstructorSignature:case s.W.Parameter:break;case s.W.TypeLiteral:return H;case s.W.TypeParameter:return G;case s.W.Accessor:case s.W.GetSignature:case s.W.SetSignature:case s.W.ObjectLiteral:break;case s.W.TypeAlias:return V;case s.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.id]);return o.createElement(n,{reflection:e})}function Y(t){let{children:e}=t;const n=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!n.current)return;const t=n.current.closest("pre");if(t.scrollWidth>t.clientWidth){const e=Array.from(n.current.querySelectorAll(`.${c.elements}`)).sort(((t,e)=>function(t,e){return t>e?1:t<e?-1:0}(e.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&e.length>0;)e.shift().classList.add(c.wrap)}})),o.createElement(o.Fragment,null,e&&o.createElement("span",{ref:n,className:(0,p.Z)(c.line,"token-line")},e),o.createElement("br",null))}var K=n(79322),Q=n(93342);function tt(t){let{parameters:e}=t;const n=(0,D.in)(),s=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=s&&s.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,s.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(G,{reflection:t})),o.createElement(Q.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{parameters:e}=t;const n=(0,D.in)(),s=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=s&&s.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,s.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(B,{reflection:t})),o.createElement(Q.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{signatures:e,flags:n,source:s}=t;const r=(0,D.in)(),i=(0,o.useMemo)((()=>e.map(r)),[e]),[p,a]=(0,o.useState)(i[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,i.map((t=>o.createElement(m,{link:null==s?void 0:s.url,key:t.id,highlight:e.length>1&&t.id===p.id,onClick:e.length>1?()=>a(t):void 0},o.createElement(Y,null,o.createElement(O,{reflection:t,flags:n})))))),o.createElement(K.Z,{comment:p.comment}),o.createElement(tt,{parameters:p.typeParameter}),o.createElement(et,{parameters:p.parameters}))}var ot=n(57708);function st(t){let{width:e=24,height:n=24,...s}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},s),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",it="filters_z1iC",pt="icon_ROIU";function at(){const t=(0,o.useRef)(null),[e,n]=(0,o.useState)(!1),[s,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const e=e=>{t.current&&!t.current.contains(e.target)&&n(!1)};return document.addEventListener("mousedown",e),document.addEventListener("touchstart",e),()=>{document.removeEventListener("mousedown",e),document.removeEventListener("touchstart",e)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,p.Z)("dropdown dropdown--right margin-bottom--md",e&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),n(!e)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),n(!e))}},"Filters",o.createElement(st,{className:pt})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,p.Z)("dropdown__link",s.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:s.private,onChange:t=>{r({...s,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&n(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,p.Z)("dropdown__link",s.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:s.inherited,onChange:t=>{r({...s,inherited:t.target.checked})}}),"Inherited members")))))}function ct(t){let{children:e,kind:n}=t;return n===s.W.Class||n===s.W.Interface?o.createElement("div",{className:(0,p.Z)("row",rt)},o.createElement("div",{className:(0,p.Z)("col",it)},o.createElement(at,null)),o.createElement("div",{className:"col"},e)):o.createElement(o.Fragment,null,e)}var lt=n(53181),ut=n(83851),mt=n(24126),dt=n(32424),ht=n(42244),yt=n(24155);function ft(t){return function(t){return o.Children.map(t,(t=>{if((0,o.isValidElement)(t)&&"value"in t.props)return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(t).map((t=>{let{props:{value:e,label:n,attributes:o,default:s}}=t;return{value:e,label:n,attributes:o,default:s}}))}function kt(t){const{values:e,children:n}=t;return(0,o.useMemo)((()=>{const t=e??ft(n);return function(t){const e=(0,ht.l)(t,((t,e)=>t.value===e.value));if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[e,n])}function wt(t){let{value:e,tabValues:n}=t;return n.some((t=>t.value===e))}function gt(t){let{queryString:e=!1,groupId:n}=t;const s=(0,lt.k6)(),r=function(t){let{queryString:e=!1,groupId:n}=t;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,dt._X)(r),(0,o.useCallback)((t=>{if(!r)return;const e=new URLSearchParams(s.location.search);e.set(r,t),s.replace({...s.location,search:e.toString()})}),[r,s])]}function Mt(t){const{defaultValue:e,queryString:n=!1,groupId:s}=t,r=kt(t),[i,p]=(0,o.useState)((()=>function(t){let{defaultValue:e,tabValues:n}=t;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!wt({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const o=n.find((t=>t.default))??n[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:e,tabValues:r}))),[a,c]=gt({queryString:n,groupId:s}),[l,u]=function(t){let{groupId:e}=t;const n=function(t){return t?`docusaurus.tab.${t}`:null}(e),[s,r]=(0,yt.Nk)(n);return[s,(0,o.useCallback)((t=>{n&&r.set(t)}),[n,r])]}({groupId:s}),m=(()=>{const t=a??l;return wt({value:t,tabValues:r})?t:null})();(0,o.useLayoutEffect)((()=>{m&&p(m)}),[m]);return{selectedValue:i,selectValue:(0,o.useCallback)((t=>{if(!wt({value:t,tabValues:r}))throw new Error(`Can't select invalid tab value=${t}`);p(t),c(t),u(t)}),[c,u,r]),tabValues:r}}var Dt=n(89741);const _t="tabList_M0Dn",Xt="tabItem_ysIP";function xt(t){let{className:e,block:n,selectedValue:s,selectValue:r,tabValues:i}=t;const a=[],{blockElementScrollPositionUntilNextRender:c}=(0,mt.o5)(),u=t=>{const e=t.currentTarget,n=a.indexOf(e),o=i[n].value;o!==s&&(c(e),r(o))},m=t=>{var e;let n=null;switch(t.key){case"Enter":u(t);break;case"ArrowRight":{const e=a.indexOf(t.currentTarget)+1;n=a[e]??a[0];break}case"ArrowLeft":{const e=a.indexOf(t.currentTarget)-1;n=a[e]??a[a.length-1];break}}null==(e=n)||e.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,p.Z)("tabs",{"tabs--block":n},e)},i.map((t=>{let{value:e,label:n,attributes:r}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:s===e?0:-1,"aria-selected":s===e,key:e,ref:t=>a.push(t),onKeyDown:m,onClick:u},r,{className:(0,p.Z)("tabs__item",Xt,null==r?void 0:r.className,{"tabs__item--active":s===e})}),n??e)})))}function vt(t){let{lazy:e,children:n,selectedValue:s}=t;if(n=Array.isArray(n)?n:[n],e){const t=n.find((t=>t.props.value===s));return t?(0,o.cloneElement)(t,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},n.map(((t,e)=>(0,o.cloneElement)(t,{key:e,hidden:t.props.value!==s}))))}function Ct(t){const e=Mt(t);return o.createElement("div",{className:(0,p.Z)("tabs-container",_t)},o.createElement(xt,(0,l.Z)({},t,e)),o.createElement(vt,(0,l.Z)({},t,e)))}function Tt(t){const e=(0,Dt.Z)();return o.createElement(Ct,(0,l.Z)({key:String(e)},t))}const bt="tabItem_OMyP";function Lt(t){let{children:e,hidden:n,className:s}=t;return o.createElement("div",{role:"tabpanel",className:(0,p.Z)(bt,s),hidden:n},e)}function Zt(t){let{group:e}=t;return"Constructors"===e.title&&0===e.external.length&&1===e.nested.length?o.createElement(Gt,{reflection:e.nested[0]}):o.createElement(o.Fragment,null,e.external.length>0&&o.createElement("ul",null,e.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(_,{type:t})))))),e.nested.length>0&&e.nested.map(((t,e)=>o.createElement(o.Fragment,{key:t.id},e>0&&o.createElement("hr",null),o.createElement(Gt,{reflection:t})))))}function Nt(t){let{group:e,project:n}=t;const s=(0,lt.TH)(),r=(0,D.RU)(n),i=s.hash.split("-")[0].slice(1),[p]=(0,ot.mN)(),a=(0,o.useMemo)((()=>(e.categories??[e]).map((t=>function(t,e,n){const o=[],s=[],r=[];for(const i of t.children){const t=e[i];t&&(0,ot.It)(n,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):s.push(t))}if(o.length>0||s.length>0)return{title:t.title,external:o,nested:s,anchors:r}}(t,r,p))).filter((t=>!!t))),[e,r,p]);return(0,o.useEffect)((()=>{if(1===a.length)return;const t=s.hash.split("-")[0].slice(1);for(const e of a)if(e.anchors.includes(t))return}),[s.hash,a]),0===a.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h2",id:e.title},e.title),a.length>1?o.createElement(Tt,{groupId:e.title},a.map((t=>o.createElement(Lt,{default:t.anchors.includes(i),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(Zt,{group:t}))))):o.createElement(Zt,{group:a[0]}))}function St(t){var e,n,s,r,i;let{reflection:p}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(e=p.sources)||null==(n=e[0])?void 0:n.url},o.createElement(Y,null,o.createElement(J,{reflection:p})))),o.createElement(ct,{kind:p.kind},o.createElement(K.Z,{comment:p.comment})),o.createElement(tt,{parameters:p.typeParameters}),(null==(s=p.implementedBy)?void 0:s.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,p.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(_,{type:t}))))))),(null==(r=p.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,p.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(_,{type:t}))))))),p.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:p.signatures})),null==(i=p.groups)?void 0:i.map((t=>o.createElement(Nt,{group:t,key:t.title,project:p.project}))))}function Rt(t){var e;let{reflection:n,headless:s}=t;const r=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!s&&(n.hasOwnPage?o.createElement("h1",null,n.name):o.createElement(ut.Z,{as:"h3",id:n.anchor},o.createElement("code",null,n.name))),o.createElement(nt,{signatures:r,flags:n.flags,source:null==(e=n.sources)?void 0:e[0]}),n.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(_,{type:n.inheritedFrom}))),n.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(_,{type:n.overwrites}))))}function Et(t){var e,n;let{reflection:s,headless:r}=t;return o.createElement(o.Fragment,null,!r&&(s.hasOwnPage?o.createElement("h1",null,s.name):o.createElement(ut.Z,{as:"h3",id:s.anchor},o.createElement("code",null,s.name))),o.createElement(h,null,o.createElement(m,{link:null==(e=s.sources)||null==(n=e[0])?void 0:n.url},o.createElement(Y,null,o.createElement(j,{reflection:s})))),o.createElement(K.Z,{comment:s.comment}),s.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(_,{type:s.inheritedFrom}))))}function At(t){var e,n,s;let{reflection:r}=t;const i=(0,D.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(e=r.sources)||null==(n=e[0])?void 0:n.url},o.createElement(Y,null,o.createElement(J,{reflection:r})))),o.createElement(K.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:r.signatures})),null==(s=r.groups)?void 0:s.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>i[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Gt,{key:t.id,reflection:t})))))))}var zt=n(78128);function Pt(t){var e;let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(zt.Z,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),o.createElement(ct,{kind:n.kind},o.createElement(K.Z,{comment:n.comment})),null==(e=n.groups)?void 0:e.map((t=>o.createElement(Nt,{group:t,key:t.title,project:n.project}))))}const It="cardContainer_ybwo",Ft="cardTitle_Ehd1",Wt="cardDescription_b6wr";function Bt(t){let{reflection:e}=t;const n=(0,D.RU)(e.project),s=e.groups[0].children.map((t=>n[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,p.Z)("row")},s.map((t=>{var e;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(y.Z,{href:t.href,className:(0,p.Z)("card padding--lg",It)},o.createElement("h2",{className:(0,p.Z)("text--truncate",Ft)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,p.Z)("text--truncate",Wt)},(null==(e=t.comment)?void 0:e.summaryText)??"\xa0")))}))))}function Gt(t){let{reflection:e,headless:n=!1}=t;const r=(0,o.useMemo)((()=>{switch(e.kind){case s.W.Project:return Bt;case s.W.Module:return Pt;case s.W.Namespace:case s.W.Enum:case s.W.Class:case s.W.Interface:return St;case s.W.Function:case s.W.Accessor:case s.W.Constructor:case s.W.Method:return Rt;case s.W.Variable:case s.W.Property:case s.W.EnumMember:return Et;case s.W.CallSignature:case s.W.IndexSignature:case s.W.ConstructorSignature:case s.W.Parameter:case s.W.TypeLiteral:case s.W.TypeParameter:case s.W.GetSignature:case s.W.SetSignature:case s.W.ObjectLiteral:break;case s.W.TypeAlias:return At;case s.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.kind]);return o.createElement(r,{reflection:e,headless:n})}},37390:(t,e,n)=>{"use strict";let o;n.d(e,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},21354:(t,e,n)=>{"use strict";n.d(e,{Z:()=>Fe});var o={};n.r(o),n.d(o,{Circle:()=>f,Grid:()=>A,Icon:()=>S,Img:()=>L,Knot:()=>F,Latex:()=>$,Layout:()=>J.A,Line:()=>it,Node:()=>z.N,Polygon:()=>at,Rect:()=>_.U,Shape:()=>d.b,Spline:()=>Xt,Txt:()=>Ct,Video:()=>Zt,View2D:()=>xt.h});var s={};n.r(s),n.d(s,{all:()=>Nt.$,any:()=>At,chain:()=>Pt,delay:()=>Gt,every:()=>Ot,loop:()=>jt,noop:()=>qt,run:()=>Ut.K,sequence:()=>Vt,waitFor:()=>Bt,waitUntil:()=>Wt});var r={};n.r(r),n.d(r,{DetailedError:()=>Qt.t,Semaphore:()=>oe.L,beginSlide:()=>Ht,capitalize:()=>$t.k,createRef:()=>ie,debug:()=>Yt,deprecate:()=>Kt,endPlayback:()=>Ft.Mh,endScene:()=>x.ug,endThread:()=>Tt.kw,errorToLog:()=>te.d,finishScene:()=>x.vl,getContext:()=>ee.f,isProxyEnabled:()=>C,makeRef:()=>pe,makeRefs:()=>ae,range:()=>ne.w,startPlayback:()=>Ft.wA,startScene:()=>x.DO,startThread:()=>Tt.h$,useContext:()=>le,useContextAfter:()=>ue,useDuration:()=>It,useLogger:()=>x.wL,usePlayback:()=>Ft.te,useRandom:()=>re,useScene:()=>x.$r,useThread:()=>Tt.nn,useTime:()=>ce,viaProxy:()=>v});var i={};n.r(i),n.d(i,{CompoundSignalContext:()=>me.N,ComputedContext:()=>de.h,DEFAULT:()=>we.T,DependencyContext:()=>X.k,SignalContext:()=>ke.V,createComputed:()=>he.D,createComputedAsync:()=>fe,createSignal:()=>ye.g,isReactive:()=>Y.P});var p={};n.r(p),n.d(p,{BBox:()=>w.b,Center:()=>_e.M5,Color:()=>M.I,Direction:()=>_e.Nm,EPSILON:()=>Me.I,Matrix2D:()=>De,Origin:()=>_e.aP,Spacing:()=>Xe.K,Vector2:()=>g.F,flipOrigin:()=>_e.lk,isType:()=>Me.P,originToOffset:()=>_e.WS,transformAngle:()=>ge.$,transformScalar:()=>ge.X});var a={};n.r(a),n.d(a,{BeatSpring:()=>be,BounceSpring:()=>Ze,JumpSpring:()=>Se,PlopSpring:()=>Le,SmoothSpring:()=>Ee,StrikeSpring:()=>Re,SwingSpring:()=>Ne,arcLerp:()=>tt.Vz,clamp:()=>tt.uZ,clampRemap:()=>tt.vl,cos:()=>xe.mC,createEaseInBack:()=>xe.j$,createEaseInBounce:()=>xe.jv,createEaseInElastic:()=>xe.qS,createEaseInOutBack:()=>xe.Bl,createEaseInOutBounce:()=>xe.Ij,createEaseInOutElastic:()=>xe.du,createEaseOutBack:()=>xe.lj,createEaseOutBounce:()=>xe.zk,createEaseOutElastic:()=>xe.Kx,deepLerp:()=>tt.o0,easeInBack:()=>xe.Yw,easeInBounce:()=>xe.SJ,easeInCirc:()=>xe.Mg,easeInCubic:()=>xe.Q9,easeInElastic:()=>xe.eE,easeInExpo:()=>xe.e_,easeInOutBack:()=>xe.BH,easeInOutBounce:()=>xe.en,easeInOutCirc:()=>xe.Ge,easeInOutCubic:()=>xe.qb,easeInOutElastic:()=>xe.cv,easeInOutExpo:()=>xe.hN,easeInOutQuad:()=>xe.to,easeInOutQuart:()=>xe.J7,easeInOutQuint:()=>xe.rz,easeInOutSine:()=>xe.Fs,easeInQuad:()=>xe.FG,easeInQuart:()=>xe.g4,easeInQuint:()=>xe.n5,easeInSine:()=>xe.N1,easeOutBack:()=>xe.UE,easeOutBounce:()=>xe.C6,easeOutCirc:()=>xe.ei,easeOutCubic:()=>xe.w2,easeOutElastic:()=>xe.sK,easeOutExpo:()=>xe.ad,easeOutQuad:()=>xe.hl,easeOutQuart:()=>xe.Y3,easeOutQuint:()=>xe.pl,easeOutSine:()=>xe.vh,linear:()=>xe.GE,makeSpring:()=>Te,map:()=>tt.UI,remap:()=>tt.a2,sin:()=>xe.O$,spring:()=>Ce,textLerp:()=>tt.JC,tween:()=>ve.i});var c={};n.r(c),n.d(c,{Thread:()=>Pe.j,cancel:()=>Ae,getTaskName:()=>ze.z,isPromisable:()=>zt.x,isPromise:()=>Ie.t,isThreadGenerator:()=>zt.R,join:()=>St.v,setTaskName:()=>ze.i,threads:()=>Ie.C});var l=n(15914);const u=Symbol.for("@motion-canvas/2d/fragment");function m(t,e){const{ref:n,children:o,...s}=e,r=Array.isArray(o)?o.flat():o;if(t===u)return r;if(null!=(i=t.prototype)&&i.isClass){const e=new t({...s,children:r});return null==n||n(e),e}return t({...s,ref:n,children:r});var i}var d=n(13730),h=n(93091),y=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class f extends d.b{constructor(t){super(t)}getPath(){return this.createPath()}getRipplePath(){return this.createPath(this.rippleSize())}createPath(t){void 0===t&&(t=0);const e=new Path2D,n=this.startAngle()/180*Math.PI,o=this.endAngle()/180*Math.PI,s=this.size().scale(.5),r=this.closed();return r&&e.moveTo(0,0),e.ellipse(0,0,s.x+t,s.y+t,0,n,o),r&&e.closePath(),e}}y([(0,h.nn)(0),(0,h.td)()],f.prototype,"startAngle",void 0),y([(0,h.nn)(360),(0,h.td)()],f.prototype,"endAngle",void 0),y([(0,h.nn)(!1),(0,h.td)()],f.prototype,"closed",void 0);var k=n(46350),w=n(23357),g=n(29797),M=n(30204),D=n(11258),_=n(15498),X=n(76062),x=n(3163);function v(t){if(!C())return t;if(t.startsWith("/cors-proxy/"))return t;const e=new URL(window.location.toString());try{const n=new URL(t,e);if(!n.protocol.startsWith("http"))return t;if(e.host===n.host)return t;if(!function(t){const e=function(){if("true"!==(void 0).VITEST&&T)return[...T];const t=(C(),[]);return T=t,[...T]}();if(0===e.length)return!0;for(const n of e)if(n.toLowerCase().trim()===t)return!0;return!1}(n.host))return t}catch(n){return t}return`/cors-proxy/${encodeURIComponent(t)}`}function C(){return!1}let T;var b=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class L extends _.U{constructor(t){super(t)}desiredSize(){const t=super.desiredSize();if(null===t.x&&null===t.y){const t=this.image();return{x:t.naturalWidth,y:t.naturalHeight}}return t}image(){const t=v(this.src());if(L.pool[t])return L.pool[t];const e=document.createElement("img");return e.crossOrigin="anonymous",e.src=t,e.complete||X.k.collectPromise(new Promise(((t,n)=>{e.addEventListener("load",t),e.addEventListener("error",n)}))),L.pool[t]=e,e}imageCanvas(){const t=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});if(!t)throw new Error("Could not create an image canvas");return t}filledImageCanvas(){const t=this.imageCanvas(),e=this.image();return t.canvas.width=e.naturalWidth,t.canvas.height=e.naturalHeight,t.imageSmoothingEnabled=this.smoothing(),t.drawImage(e,0,0),t}draw(t){this.drawShape(t),this.clip()&&t.clip(this.getPath());const e=this.alpha();if(e>0){const n=w.b.fromSizeCentered(this.computedSize());t.save(),e<1&&(t.globalAlpha*=e),t.imageSmoothingEnabled=this.smoothing(),(0,D.AE)(t,this.image(),n),t.restore()}this.drawChildren(t)}applyFlex(){super.applyFlex();const t=this.image();this.element.style.aspectRatio=(this.ratio()??t.naturalWidth/t.naturalHeight).toString()}getColorAtPoint(t){const e=this.image(),n=this.computedSize(),o=new g.F(e.naturalWidth,e.naturalHeight),s=new g.F(t).add(this.computedSize().scale(.5)).mul(o.div(n).safe);return this.getPixelColor(s)}getPixelColor(t){const e=this.filledImageCanvas(),n=new g.F(t),o=e.getImageData(n.x,n.y,1,1).data;return new M.I({r:o[0],g:o[1],b:o[2],a:o[3]/255})}collectAsyncResources(){super.collectAsyncResources(),this.image()}}L.pool={},b([(0,h.td)()],L.prototype,"src",void 0),b([(0,h.nn)(1),(0,h.td)()],L.prototype,"alpha",void 0),b([(0,h.nn)(!0),(0,h.td)()],L.prototype,"smoothing",void 0),b([(0,k.F)()],L.prototype,"image",null),b([(0,k.F)()],L.prototype,"imageCanvas",null),b([(0,k.F)()],L.prototype,"filledImageCanvas",null);var Z=n(43595),N=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class S extends L{constructor(t){super(t)}svgUrl(){return`https://api.iconify.design/${this.icon().replace(":","/")}.svg?color=${encodeURIComponent(this.color().hex())}`}getSrc(){return this.svgUrl()}setSrc(){(0,x.wL)().warn("The Icon Component does not accept setting the `src`. If you need access to `src`, use '<Img/>` instead.")}}N([(0,h.td)()],S.prototype,"icon",void 0),N([(0,h.nn)("white"),(0,Z.j)()],S.prototype,"color",void 0),N([(0,k.F)()],S.prototype,"svgUrl",null);var R=n(88104),E=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class A extends d.b{constructor(t){super(t)}drawShape(t){t.save(),this.applyStyle(t),this.drawRipple(t);const e=this.spacing(),n=this.computedSize().scale(.5),o=n.div(e).floored;for(let s=-o.x;s<=o.x;s++)t.beginPath(),t.moveTo(e.x*s,-n.height),t.lineTo(e.x*s,n.height),t.stroke();for(let s=-o.y;s<=o.y;s++)t.beginPath(),t.moveTo(-n.width,e.y*s),t.lineTo(n.width,e.y*s),t.stroke();t.restore()}}E([(0,h.nn)(80),(0,R.y)("spacing")],A.prototype,"spacing",void 0);var z=n(20092),P=n(37060),I=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class F extends z.N{get startHandleAuto(){return this.auto.startHandle}get endHandleAuto(){return this.auto.endHandle}constructor(t){super(void 0===t.startHandle&&void 0===t.endHandle?{auto:1,...t}:t)}points(){const t=!this.startHandle.isInitial()||!this.endHandle.isInitial(),e=t?this.startHandle():g.F.zero,n=t?this.endHandle():g.F.zero;return{position:this.position(),startHandle:e.transformAsPoint(this.localToParent()),endHandle:n.transformAsPoint(this.localToParent()),auto:{start:this.startHandleAuto(),end:this.endHandleAuto()}}}getDefaultEndHandle(){return this.startHandle().flipped}getDefaultStartHandle(){return this.endHandle().flipped}}I([(0,h.YS)(g.F),(0,h.td)()],F.prototype,"startHandle",void 0),I([(0,h.YS)(g.F),(0,h.td)()],F.prototype,"endHandle",void 0),I([(0,h.r_)(!1),(0,h.nn)((()=>({startHandle:0,endHandle:0}))),(0,h.E2)((t=>"object"!=typeof t||Array.isArray(t)?("number"==typeof t&&(t=[t,t]),{startHandle:t[0],endHandle:t[1]}):t)),(0,P.I)({startHandle:"startHandleAuto",endHandle:"endHandleAuto"})],F.prototype,"auto",void 0),I([(0,k.F)()],F.prototype,"points",null);var W=n(98911),B=n(2322),G=n(64238),O=n(81962),j=n(86226),q=n(50099),U=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};const V=(0,j.liteAdaptor)();(0,q.Q)(V);const H=W.mathjax.document("",{InputJax:new B.TeX({packages:O.b}),OutputJax:new G.SVG({fontCache:"local"})});class $ extends L{constructor(t){super(t),this.imageElement=document.createElement("img")}image(){const t=`${this.tex()}::${JSON.stringify(this.options())}`;if($.svgContentsPool[t])return this.imageElement.src=$.svgContentsPool[t],this.imageElement;const e=this.tex(),n=V.innerHTML(H.convert(e,this.options()));if(n.includes("data-mjx-error")){const t=n.match(/data-mjx-error="(.*?)"/);t&&t.length>0&&(0,x.wL)().error(`Invalid MathJax: ${t[1]}`)}const o=`data:image/svg+xml;base64,${btoa(`<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n${n}`)}`;$.svgContentsPool[t]=o;const s=document.createElement("img");return s.src=o,s.src=o,s.complete||X.k.collectPromise(new Promise(((t,e)=>{s.addEventListener("load",t),s.addEventListener("error",e)}))),s}}$.svgContentsPool={},U([(0,h.nn)({}),(0,h.td)()],$.prototype,"options",void 0),U([(0,h.td)()],$.prototype,"tex",void 0);var J=n(70989),Y=n(93214);class K{}class Q extends K{constructor(t,e){super(),this.from=t,this.to=e,this.vector=e.sub(t),this.length=this.vector.magnitude,this.normal=this.vector.perpendicular.normalized.safe}get arcLength(){return this.length}draw(t,e,n,o){void 0===e&&(e=0),void 0===n&&(n=1),void 0===o&&(o=!1);const s=this.from.add(this.vector.scale(e)),r=this.from.add(this.vector.scale(n));return o&&(0,D.Ao)(t,s),(0,D.kZ)(t,r),[{position:s,tangent:this.normal.flipped,normal:this.normal},{position:r,tangent:this.normal,normal:this.normal}]}getPoint(t){return{position:this.from.add(this.vector.scale(t)),tangent:this.normal.flipped,normal:this.normal}}}var tt=n(13170);class et extends K{constructor(t,e,n,o,s){super(),this.center=t,this.radius=e,this.from=n,this.to=o,this.counter=s,this.angle=Math.acos((0,tt.uZ)(-1,1,n.dot(o))),this.length=Math.abs(this.angle*e)}get arcLength(){return this.length}draw(t,e,n){const o=this.counter?-1:1,s=this.from.radians+e*this.angle*o,r=this.to.radians-(1-n)*this.angle*o;Math.abs(this.angle)>1e-4&&t.arc(this.center.x,this.center.y,this.radius,s,r,this.counter);const i=g.F.fromRadians(s),p=g.F.fromRadians(r);return[{position:this.center.add(i.scale(this.radius)),tangent:this.counter?i:i.flipped,normal:this.counter?i:i.flipped},{position:this.center.add(p.scale(this.radius)),tangent:this.counter?p.flipped:p,normal:this.counter?p.flipped:p}]}getPoint(t){const e=this.counter?-1:1,n=this.from.radians+t*this.angle*e,o=g.F.fromRadians(n);return{position:this.center.add(o.scale(this.radius)),tangent:this.counter?o:o.flipped,normal:this.counter?o:o.flipped}}}function nt(t,e){const n=(0,tt.uZ)(0,t.arcLength,e);let o=0;for(const s of t.segments){const t=o;if(o+=s.arcLength,o>=n){const e=(n-t)/s.arcLength;return s.getPoint((0,tt.uZ)(0,1,e))}}return{position:g.F.zero,tangent:g.F.up,normal:g.F.up}}var ot=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class st extends d.b{desiredSize(){return this.childrenBBox().size}constructor(t){super(t)}percentageToDistance(t){const{arcLength:e}=this.profile(),n=this.startOffset();return n+(e-n-this.endOffset())*t}curveDrawingInfo(){const t=new Path2D,e=this.profile();let n=this.percentageToDistance(this.start()),o=this.percentageToDistance(this.end());n>o&&([n,o]=[o,n]);const s=o-n,r=Math.min(s/2,this.arrowSize());this.startArrow()&&(n+=r/2),this.endArrow()&&(o-=r/2);let i=0,p=null,a=null,c=null,l=null;for(const u of e.segments){const e=i;if(i+=u.arcLength,i<n)continue;const s=(n-e)/u.arcLength,r=(o-e)/u.arcLength,m=(0,tt.uZ)(0,1,s),d=(0,tt.uZ)(0,1,r),[h,y]=u.draw(t,m,d,null===p);if(null===p&&(p=h.position,a=h.normal.flipped.perpendicular),c=y.position,l=y.normal.flipped.perpendicular,i>o)break}return 1===this.end()&&this.closed()&&t.closePath(),{startPoint:p??g.F.zero,startTangent:a??g.F.right,endPoint:c??g.F.zero,endTangent:l??g.F.right,arrowSize:r,path:t,startOffset:n}}getPointAtDistance(t){return nt(this.profile(),t+this.startOffset())}getPointAtPercentage(t){return nt(this.profile(),this.percentageToDistance(t))}applyStyle(t){super.applyStyle(t);const{arcLength:e}=this.profile();t.lineDashOffset-=e/2}getComputedLayout(){return this.offsetComputedLayout(super.getComputedLayout())}offsetComputedLayout(t){return t.position=t.position.sub(this.childrenBBox().center),t}getPath(){return this.curveDrawingInfo().path}getCacheBBox(){const t=this.childrenBBox(),e=this.arrowSize(),n=this.lineWidth(),o=this.lineWidthCoefficient();return t.expand(Math.max(0,e,n*o))}lineWidthCoefficient(){return"square"===this.lineCap()?.70715:.5}drawShape(t){super.drawShape(t);const{startPoint:e,startTangent:n,endPoint:o,endTangent:s,arrowSize:r}=this.curveDrawingInfo();r<.001||(t.save(),t.beginPath(),this.endArrow()&&this.drawArrow(t,o,s.flipped,r),this.startArrow()&&this.drawArrow(t,e,n,r),t.fillStyle=(0,D.ho)(this.stroke(),t),t.closePath(),t.fill(),t.restore())}drawArrow(t,e,n,o){const s=n.perpendicular,r=e.add(n.scale(-o/2));(0,D.Ao)(t,r),(0,D.kZ)(t,r.add(n.add(s).scale(o))),(0,D.kZ)(t,r.add(n.sub(s).scale(o))),(0,D.kZ)(t,r),t.closePath()}}ot([(0,h.nn)(!1),(0,h.td)()],st.prototype,"closed",void 0),ot([(0,h.nn)(0),(0,h.td)()],st.prototype,"start",void 0),ot([(0,h.nn)(0),(0,h.td)()],st.prototype,"startOffset",void 0),ot([(0,h.nn)(!1),(0,h.td)()],st.prototype,"startArrow",void 0),ot([(0,h.nn)(1),(0,h.td)()],st.prototype,"end",void 0),ot([(0,h.nn)(0),(0,h.td)()],st.prototype,"endOffset",void 0),ot([(0,h.nn)(!1),(0,h.td)()],st.prototype,"endArrow",void 0),ot([(0,h.nn)(24),(0,h.td)()],st.prototype,"arrowSize",void 0),ot([(0,k.F)()],st.prototype,"curveDrawingInfo",null);var rt=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class it extends st{constructor(t){super(t),void 0===t.children&&void 0===t.points&&(0,x.wL)().warn({message:"No points specified for the line",remarks:'<p>The line won&#39;t be visible unless you specify at least two points:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span>\n  stroke=<span class="hljs-string">&quot;#fff&quot;</span>\n  lineWidth={<span class="hljs-number">8</span>}\n  points={[\n    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],\n  ]}\n/&gt;\n</code></pre>\n<p>Alternatively, you can define the points using the children:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>\n&lt;/<span class="hljs-title class_">Line</span>&gt;\n</code></pre>\n<p>If you did this intentionally, and want to disable this message, set the\n<code>points</code> property to <code>null</code>:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>} points={<span class="hljs-literal">null</span>} /&gt;\n</code></pre>\n',inspect:this.key})}childrenBBox(){const t=this.points(),e=t?t.map((t=>new g.F((0,Y.P)(t)?t():t))):this.children().filter((t=>!(t instanceof J.A)||t.isLayoutRoot())).map((t=>t.position()));return w.b.fromPoints(...e)}parsedPoints(){const t=this.points();return t?t.map((t=>new g.F((0,Y.P)(t)?t():t))):this.children().map((t=>t.position()))}profile(){return function(t,e,n){const o={arcLength:0,segments:[],minSin:1};if(0===t.length)return o;if(n){const e=t[0].add(t[t.length-1]).scale(.5);t.unshift(e),t.push(e)}let s=t[0];for(let i=2;i<t.length;i++){const n=t[i-2],r=t[i-1],p=t[i],a=n.sub(r),c=p.sub(r),l=a.normalized.safe,u=c.normalized.safe,m=Math.acos((0,tt.uZ)(-1,1,l.dot(u))),d=Math.tan(m/2),h=Math.sin(m/2),y=Math.min(e,d*a.magnitude*(2===i?1:.5),d*c.magnitude*(i===t.length-1?1:.5)),f=0===h?0:y/h,k=0===d?0:y/d,w=l.add(u).scale(.5).normalized.safe.scale(f).add(r),g=l.perpendicular.dot(u)<0,M=new Q(s,r.add(l.scale(k))),D=new et(w,y,l.perpendicular.scale(g?1:-1),u.perpendicular.scale(g?-1:1),g);o.segments.push(M),o.segments.push(D),o.arcLength+=M.arcLength,o.arcLength+=D.arcLength,o.minSin=Math.min(o.minSin,Math.abs(h)),s=r.add(u.scale(k))}const r=new Q(s,t[t.length-1]);return o.segments.push(r),o.arcLength+=r.arcLength,o}(this.parsedPoints(),this.radius(),this.closed())}lineWidthCoefficient(){const t=this.radius(),e=this.lineJoin();let n=super.lineWidthCoefficient();if(0===t&&"miter"===e){const{minSin:t}=this.profile();t>0&&(n=Math.max(n,.5/t))}return n}drawOverlay(t,e){const n=this.childrenBBox().transformCorners(e),o=this.computedSize().mul(this.offset()).scale(.5).transformAsPoint(e);t.fillStyle="white",t.strokeStyle="black",t.lineWidth=1;const s=new Path2D,r=this.parsedPoints().map((t=>t.transformAsPoint(e)));if(r.length>0){(0,D.Ao)(s,r[0]);for(const e of r)(0,D.kZ)(s,e),t.beginPath(),(0,D.Nb)(t,e,4),t.closePath(),t.fill(),t.stroke()}t.strokeStyle="white",t.stroke(s);t.beginPath(),(0,D.kZ)(t,o.addY(-8)),(0,D.kZ)(t,o.addY(8)),(0,D.kZ)(t,o),(0,D.kZ)(t,o.addX(-8)),t.arc(o.x,o.y,8,0,2*Math.PI),t.stroke(),t.beginPath(),(0,D.pS)(t,n),t.closePath(),t.stroke()}}rt([(0,h.nn)(0),(0,h.td)()],it.prototype,"radius",void 0),rt([(0,h.nn)(null),(0,h.td)()],it.prototype,"points",void 0),rt([(0,k.F)()],it.prototype,"childrenBBox",null),rt([(0,k.F)()],it.prototype,"parsedPoints",null),rt([(0,k.F)()],it.prototype,"profile",null);var pt=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class at extends d.b{constructor(t){super(t)}getPath(){const t=new Path2D,e=this.sides(),n=w.b.fromSizeCentered(this.size());return(0,D.is)(t,n,e),t}getRipplePath(){const t=new Path2D,e=this.sides(),n=this.rippleSize(),o=w.b.fromSizeCentered(this.size()).expand(n);return(0,D.is)(t,o,e),t}}pt([(0,h.nn)(6),(0,h.td)()],at.prototype,"sides",void 0);class ct{constructor(t,e){void 0===e&&(e=20),this.curve=t,this.sampledDistances=[],this.resample(e)}resample(t){this.sampledDistances=[0];let e=0,n=this.curve.eval(0).position;for(let o=1;o<t;o++){const s=o/(t-1),r=this.curve.eval(s);e+=n.sub(r.position).magnitude,this.sampledDistances.push(e),n=r.position}this.sampledDistances[this.sampledDistances.length-1]=this.curve.arcLength}pointAtDistance(t){return this.curve.eval(this.distanceToT(t))}distanceToT(t){const e=this.sampledDistances.length;t=(0,tt.uZ)(0,this.curve.arcLength,t);for(let n=0;n<e;n++){const o=this.sampledDistances[n],s=this.sampledDistances[n+1];if(t>=o&&t<=s)return(0,tt.a2)(o,s,n/(e-1),(n+1)/(e-1),t)}return 1}}class lt extends K{get arcLength(){return this.length}constructor(t,e){super(),this.curve=t,this.length=e,this.pointSampler=new ct(this)}getBBox(){return this.curve.getBounds()}eval(t){const e=this.tangent(t);return{position:this.curve.eval(t),tangent:e,normal:e.perpendicular}}getPoint(t){const e=this.pointSampler.pointAtDistance(this.arcLength*t);return{position:e.position,tangent:e.tangent,normal:e.tangent.perpendicular}}transformPoints(t){return this.points.map((e=>e.transformAsPoint(t)))}tangent(t){return this.curve.evalDerivative(t).normalized}draw(t,e,n,o){void 0===e&&(e=0),void 0===n&&(n=1),void 0===o&&(o=!0);let s=null,r=e,i=n,p=this.points;if(0!==e||1!==n){const t=this.length*e,o=this.length*n;r=this.pointSampler.distanceToT(t),i=this.pointSampler.distanceToT(o),i=(i-r)/(1-r);const[,a]=this.split(r);[s]=a.split(i),p=s.points}o&&(0,D.Ao)(t,p[0]),(s??this).doDraw(t);const a=this.tangent(r),c=this.tangent(i);return[{position:p[0],tangent:a,normal:a.perpendicular},{position:p.at(-1),tangent:c,normal:c.perpendicular}]}}class ut{static constant(t){return new ut(t)}static linear(t,e){return new ut(t,e)}static quadratic(t,e,n){return new ut(t,e,n)}static cubic(t,e,n,o){return new ut(t,e,n,o)}get degree(){return 0!==this.c3?3:0!==this.c2?2:0!==this.c1?1:0}constructor(t,e,n,o){this.c0=t,this.c1=e??0,this.c2=n??0,this.c3=o??0}differentiate(t){switch(void 0===t&&(t=1),t){case 0:return this;case 1:return new ut(this.c1,2*this.c2,3*this.c3,0);case 2:return new ut(2*this.c2,6*this.c3,0,0);case 3:return new ut(6*this.c3,0,0,0);default:throw new Error("Unsupported derivative")}}eval(t,e){return void 0===e&&(e=0),0!==e?this.differentiate(e).eval(t):this.c3*(t*t*t)+this.c2*(t*t)+this.c1*t+this.c0}split(t){const e=1-t;return[new ut(this.c0,this.c1*t,this.c2*t*t,this.c3*t*t*t),new ut(this.eval(0),e*this.differentiate(1).eval(t),e*e/2*this.differentiate(2).eval(t),e*e*e/6*this.differentiate(3).eval(t))]}roots(){switch(this.degree){case 3:return this.solveCubicRoots();case 2:return this.solveQuadraticRoots();case 1:return this.solveLinearRoot();case 0:return[];default:throw new Error(`Unsupported polynomial degree: ${this.degree}`)}}localExtrema(){return this.differentiate().roots()}localExtrema01(){const t=this.localExtrema(),e=[];for(let n=0;n<t.length;n++){const o=t[n];o>=0&&o<=1&&e.push(t[n])}return e}outputRange01(){let t=[this.eval(0),this.eval(1)];return this.localExtrema01().forEach((e=>{return n=this.eval(e),void(t=t[1]>t[0]?[Math.min(t[0],n),Math.max(t[1],n)]:[Math.min(t[1],n),Math.max(t[0],n)]);var n})),t}solveCubicRoots(){const t=this.c0,e=this.c1,n=this.c2,o=this.c3,s=t*t,r=t*n,i=e*e,p=(3*r-i)/(3*s),a=(2*i*e-9*r*e+27*s*o)/(27*s*t),c=this.solveDepressedCubicRoots(p,a),l=n=>n-e/(3*t);switch(c.length){case 1:return[l(c[0])];case 2:return[l(c[0]),l(c[1])];case 3:return[l(c[0]),l(c[1]),l(c[2])];default:return[]}}solveDepressedCubicRoots(t,e){if(this.almostZero(t))return[Math.cbrt(-e)];const n=2*Math.PI,o=4*t*t*t+27*e*e;if(o<1e-5){const o=2*Math.sqrt(-t/3),s=3*e/(2*t)*Math.sqrt(-3/t),r=t=>o*Math.cos(1/3*Math.acos((0,tt.uZ)(-1,1,s))-n/3*t);return s>=.9999?[r(0),r(2)]:s<=-.9999?[r(1),r(2)]:[r(0),r(1),r(2)]}if(o>0&&t<0){const n=1/3*Math.acosh(-3*Math.abs(e)/(2*t)*Math.sqrt(-3/t));return[-2*Math.sign(e)*Math.sqrt(-t/3)*Math.cosh(n)]}if(t>0){const n=1/3*Math.asinh(3*e/(2*t)*Math.sqrt(3/t));return[-2*Math.sqrt(t/3)*Math.sinh(n)]}return[]}solveQuadraticRoots(){const t=this.c2,e=this.c1,n=e*e-4*t*this.c0;if(this.almostZero(n))return[-e/(2*t)];if(n>=0){const o=Math.sqrt(n),s=(-e-o)/(2*t),r=(-e+o)/(2*t);return[Math.min(s,r),Math.max(s,r)]}return[]}solveLinearRoot(){return[-this.c0/this.c1]}almostZero(t){return Math.abs(0-t)<=Number.EPSILON}}class mt{constructor(t,e,n,o){this.c0=t,this.c1=e,this.c2=n,this.c3=o,t instanceof ut?(this.x=t,this.y=e):void 0!==o?(this.x=new ut(t.x,e.x,n.x,o.x),this.y=new ut(t.y,e.y,n.y,o.y)):(this.x=new ut(t.x,e.x,n.x),this.y=new ut(t.y,e.y,n.y))}eval(t,e){return void 0===e&&(e=0),new g.F(this.x.differentiate(e).eval(t),this.y.differentiate(e).eval(t))}split(t){const[e,n]=this.x.split(t),[o,s]=this.y.split(t);return[new mt(e,o),new mt(n,s)]}differentiate(t){return void 0===t&&(t=1),new mt(this.x.differentiate(t),this.y.differentiate(t))}evalDerivative(t){return this.differentiate().eval(t)}getBounds(){const t=this.x.outputRange01(),e=this.y.outputRange01();return w.b.fromPoints(new g.F(Math.min(...t),Math.max(...e)),new g.F(Math.max(...t),Math.min(...e)))}}var dt=n(79116),ht=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class yt extends lt{get points(){return[this.p0,this.p1,this.p2,this.p3]}constructor(t,e,n,o){super(new mt(t,t.flipped.add(e).scale(3),t.scale(3).sub(e.scale(6)).add(n.scale(3)),t.flipped.add(e.scale(3)).sub(n.scale(3)).add(o)),yt.getLength(t,e,n,o)),this.p0=t,this.p1=e,this.p2=n,this.p3=o}split(t){const e=new g.F(this.p0.x+(this.p1.x-this.p0.x)*t,this.p0.y+(this.p1.y-this.p0.y)*t),n=new g.F(this.p1.x+(this.p2.x-this.p1.x)*t,this.p1.y+(this.p2.y-this.p1.y)*t),o=new g.F(this.p2.x+(this.p3.x-this.p2.x)*t,this.p2.y+(this.p3.y-this.p2.y)*t),s=new g.F(e.x+(n.x-e.x)*t,e.y+(n.y-e.y)*t),r=new g.F(n.x+(o.x-n.x)*t,n.y+(o.y-n.y)*t),i=new g.F(s.x+(r.x-s.x)*t,s.y+(r.y-s.y)*t);return[new yt(this.p0,e,s,i),new yt(i,r,o,this.p3)]}doDraw(t){(0,D.JQ)(t,this.p1,this.p2,this.p3)}static getLength(t,e,n,o){return yt.el.setAttribute("d",`M ${t.x} ${t.y} C ${e.x} ${e.y} ${n.x} ${n.y} ${o.x} ${o.y}`),yt.el.getTotalLength()}}ht([(0,dt.V)((()=>document.createElementNS("http://www.w3.org/2000/svg","path")))],yt,"el",void 0);var ft=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class kt extends lt{get points(){return[this.p0,this.p1,this.p2]}constructor(t,e,n){super(new mt(t,t.flipped.add(e).scale(2),t.sub(e.scale(2)).add(n)),kt.getLength(t,e,n)),this.p0=t,this.p1=e,this.p2=n}split(t){const e=new g.F(this.p0.x+(this.p1.x-this.p0.x)*t,this.p0.y+(this.p1.y-this.p0.y)*t),n=new g.F(this.p1.x+(this.p2.x-this.p1.x)*t,this.p1.y+(this.p2.y-this.p1.y)*t),o=new g.F(e.x+(n.x-e.x)*t,e.y+(n.y-e.y)*t);return[new kt(this.p0,e,o),new kt(o,n,this.p2)]}static getLength(t,e,n){return kt.el.setAttribute("d",`M ${t.x} ${t.y} Q ${e.x} ${e.y} ${n.x} ${n.y}`),kt.el.getTotalLength()}doDraw(t){(0,D.pt)(t,this.p1,this.p2)}}function wt(t){return t instanceof yt}function gt(t,e,n,o){if(0===t.auto.start&&0===t.auto.end)return;const s=t.position.sub(e.position).magnitude,r=o*s/(s+n.position.sub(t.position).magnitude),i=o-r,p=new g.F(t.position.x-r*(n.position.x-e.position.x),t.position.y-r*(n.position.y-e.position.y)),a=new g.F(t.position.x+i*(n.position.x-e.position.x),t.position.y+i*(n.position.y-e.position.y));t.startHandle=t.startHandle.lerp(p,t.auto.start),t.endHandle=t.endHandle.lerp(a,t.auto.end)}function Mt(t,e,n,o,s){const r=void 0!==s?new yt(e,n,o,s):new kt(e,n,o);t.segments.push(r),t.arcLength+=r.arcLength}function Dt(t,e,n){const o={segments:[],arcLength:0,minSin:1},s=t.length;for(let c=0;c<s;c++){const e=(c-1+s)%s,o=(c+1)%s;gt(t[c],t[e],t[o],n)}const r=t[0],i=t[1];e||1!==r.auto.start||1!==r.auto.end?Mt(o,r.position,r.endHandle,i.startHandle,i.position):Mt(o,r.position,i.startHandle,i.position);for(let c=1;c<s-2;c++){const e=t[c],n=t[c+1];Mt(o,e.position,e.endHandle,n.startHandle,n.position)}const p=t.at(-1),a=t.at(-2);return t.length>2&&(e||1!==p.auto.start||1!==p.auto.end?Mt(o,a.position,a.endHandle,p.startHandle,p.position):Mt(o,a.position,a.endHandle,p.position)),e&&Mt(o,p.position,p.endHandle,r.startHandle,r.position),function(t){for(let e=0;e<t.segments.length;e++){const n=t.segments[e],o=t.segments[(e+1)%t.segments.length];if(!wt(n)||!wt(o))continue;const s=n.p2.sub(n.p3).normalized.safe,r=o.p1.sub(o.p0).normalized.safe,i=s.dot(r);if(!(1-Math.abs(i)>1e-4))continue;const p=Math.acos((0,tt.uZ)(-1,1,i)),a=Math.sin(p/2);t.minSin=Math.min(t.minSin,Math.abs(a))}}(o),o}ft([(0,dt.V)((()=>document.createElementNS("http://www.w3.org/2000/svg","path")))],kt,"el",void 0);var _t=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class Xt extends st{constructor(t){super(t),(void 0===t.children||t.children.length<2)&&(void 0===t.points||t.points.length<2)&&void 0===t.spawner&&(0,x.wL)().warn({message:"Insufficient number of knots specified for spline. A spline needs at least two knots.",remarks:'<p>The spline won&#39;t be visible unless you specify at least two knots:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Spline</span>\n  stroke=<span class="hljs-string">&quot;#fff&quot;</span>\n  lineWidth={<span class="hljs-number">8</span>}\n  points={[\n    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],\n  ]}\n/&gt;\n</code></pre>\n<p>For more control over the knot handles, you can alternatively provide the knots\nas children to the spline using the <code>Knot</code> component:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Spline</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Knot</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> <span class="hljs-attr">endHandle</span>=<span class="hljs-string">{[-50,</span> <span class="hljs-attr">0</span>]} /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Knot</span> /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Knot</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> <span class="hljs-attr">startHandle</span>=<span class="hljs-string">{[-100,</span> <span class="hljs-attr">50</span>]} /&gt;</span></span>\n&lt;/<span class="hljs-title class_">Spline</span>&gt;\n</code></pre>\n',inspect:this.key})}profile(){return Dt(this.knots(),this.closed(),this.smoothness())}knots(){const t=this.points();return t?t.map((t=>{const e=new g.F((0,Y.P)(t)?t():t);return{position:e,startHandle:e,endHandle:e,auto:{start:1,end:1}}})):this.children().filter(this.isKnot).map((t=>t.points()))}childrenBBox(){const t=this.profile().segments.flatMap((t=>t.points));return w.b.fromPoints(...t)}lineWidthCoefficient(){const t=this.lineJoin();let e=super.lineWidthCoefficient();if("miter"!==t)return e;const{minSin:n}=this.profile();return n>0&&(e=Math.max(e,.5/n)),e}desiredSize(){return this.getTightBBox().size}offsetComputedLayout(t){return t.position=t.position.sub(this.getTightBBox().center),t}getTightBBox(){const t=this.profile().segments.map((t=>t.getBBox()));return w.b.fromBBoxes(...t)}drawOverlay(t,e){const n=this.computedSize(),o=this.childrenBBox().transformCorners(e),s=n.mul(this.offset()).scale(.5).transformAsPoint(e),r=this.profile().segments;t.lineWidth=1,t.strokeStyle="white",t.fillStyle="white";const i=new Path2D;for(let p=0;p<r.length;p++){const t=r[p],[n,o,s,a]=t.transformPoints(e);(0,D.Ao)(i,n),t instanceof yt?(0,D.JQ)(i,o,s,a):(0,D.pt)(i,o,s)}t.stroke(i);for(let p=0;p<r.length;p++){const n=r[p];t.fillStyle="white";const[o,s,i,a]=n.transformPoints(e),c=new Path2D;t.globalAlpha=.5,(0,D.Ao)(c,o),(0,D.kZ)(c,s),n instanceof yt?((0,D.Ao)(c,i),(0,D.kZ)(c,a),t.beginPath(),t.stroke(c)):((0,D.kZ)(c,i),t.beginPath(),t.stroke(c)),t.globalAlpha=1,t.lineWidth=2,(0,D.Ao)(t,o),t.beginPath(),(0,D.Nb)(t,o,4),t.closePath(),t.stroke(),t.fill(),p===r.length-1&&void 0!==a&&((0,D.Ao)(t,a),t.beginPath(),(0,D.Nb)(t,a,4),t.closePath(),t.stroke(),t.fill()),t.fillStyle="black";for(const e of[s,i])e.magnitude>0&&((0,D.Ao)(t,e),t.beginPath(),(0,D.Nb)(t,e,4),t.closePath(),t.fill(),t.stroke())}t.lineWidth=1;t.beginPath(),(0,D.kZ)(t,s.addY(-8)),(0,D.kZ)(t,s.addY(8)),(0,D.kZ)(t,s),(0,D.kZ)(t,s.addX(-8)),t.arc(s.x,s.y,8,0,2*Math.PI),t.stroke(),t.beginPath(),(0,D.pS)(t,o),t.closePath(),t.stroke()}isKnot(t){return t instanceof F}}_t([(0,h.nn)(.4),(0,h.td)()],Xt.prototype,"smoothness",void 0),_t([(0,h.nn)(null),(0,h.td)()],Xt.prototype,"points",void 0),_t([(0,k.F)()],Xt.prototype,"profile",null),_t([(0,k.F)()],Xt.prototype,"knots",null),_t([(0,k.F)()],Xt.prototype,"childrenBBox",null),_t([(0,k.F)()],Xt.prototype,"getTightBBox",null);var xt=n(70419),vt=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class Ct extends d.b{constructor(t){let{children:e,...n}=t;super(n),e&&this.text(e)}draw(t){this.requestFontUpdate(),this.applyStyle(t),this.applyText(t),t.font=this.styles.font,"letterSpacing"in t&&(t.letterSpacing=`${this.letterSpacing()}px`);const e=this.element.getBoundingClientRect(),{width:n,height:o}=this.size(),s=document.createRange();let r="";const i=new w.b;for(const p of this.element.childNodes){if(!p.textContent)continue;s.selectNodeContents(p);const a=s.getBoundingClientRect(),c=n/-2+a.left-e.left,l=o/-2+a.top-e.top;i.y===l?(i.width+=a.width,r+=p.textContent):(this.drawText(t,r,i),i.x=c,i.y=l,i.width=a.width,i.height=a.height,r=p.textContent)}this.drawText(t,r,i)}drawText(t,e,n){const o=n.y+n.height/2;t.save(),t.textBaseline="middle",this.lineWidth()<=0?t.fillText(e,n.x,o):this.strokeFirst()?(t.strokeText(e,n.x,o),t.fillText(e,n.x,o)):(t.fillText(e,n.x,o),t.strokeText(e,n.x,o)),t.restore()}formattedText(){return Ct.formatter.innerText=this.text(),Ct.formatter.innerText}updateLayout(){this.applyFont(),this.applyFlex(),this.justifyContent.isInitial()&&(this.element.style.justifyContent=this.styles.getPropertyValue("text-align"));if("nowrap"!==this.styles.whiteSpace&&"pre"!==this.styles.whiteSpace)if(this.element.innerText="",Ct.segmenter)for(const t of Ct.segmenter.segment(this.formattedText()))this.element.appendChild(document.createTextNode(t.segment));else for(const t of this.formattedText().split(""))this.element.appendChild(document.createTextNode(t));else if("pre"===this.styles.whiteSpace){this.element.innerText="";for(const t of this.text().split("\n"))this.element.appendChild(document.createTextNode(t+"\n"))}else this.element.innerText=this.formattedText()}}vt([(0,h.nn)(""),(0,h.JI)(tt.JC),(0,h.td)()],Ct.prototype,"text",void 0),vt([(0,k.F)()],Ct.prototype,"formattedText",null),vt([(0,dt.V)((()=>{const t=document.createElement("div");return xt.h.shadowRoot.append(t),t}))],Ct,"formatter",void 0),vt([(0,dt.V)((()=>{try{return new Intl.Segmenter(void 0,{granularity:"grapheme"})}catch(t){return null}}))],Ct,"segmenter",void 0);var Tt=n(56632),bt=n(88733),Lt=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class Zt extends _.U{constructor(t){super(t),this.lastTime=-1}isPlaying(){return this.playing()}getCurrentTime(){return this.time()}getDuration(){return this.video().duration}desiredSize(){const t=super.desiredSize();if(null===t.x&&null===t.y){const t=this.video();return{x:t.videoWidth,y:t.videoHeight}}return t}completion(){return this.clampTime(this.time())/this.video().duration}video(){const t=this.src(),e=`${this.key}/${t}`;if(Zt.pool[e])return Zt.pool[e];const n=document.createElement("video");return n.src=t,n.readyState<2&&X.k.collectPromise(new Promise((t=>{const e=()=>{t(),n.removeEventListener("canplay",e)};n.addEventListener("canplay",e)}))),Zt.pool[e]=n,n}seekedVideo(){const t=this.video(),e=this.clampTime(this.time());return t.paused||t.pause(),this.lastTime===e||this.setCurrentTime(e),t}fastSeekedVideo(){const t=this.video(),e=this.clampTime(this.time());if(this.lastTime===e)return t;const n=this.playing()&&e<t.duration;return n?t.paused&&X.k.collectPromise(t.play()):t.paused||t.pause(),Math.abs(t.currentTime-e)>.2?this.setCurrentTime(e):n||(t.currentTime=e),t}draw(t){this.drawShape(t),this.clip()&&t.clip(this.getPath());const e=this.alpha();if(e>0){const n=this.view().playbackState()===bt.q.Playing?this.fastSeekedVideo():this.seekedVideo(),o=w.b.fromSizeCentered(this.computedSize());t.save(),e<1&&(t.globalAlpha*=e),t.imageSmoothingEnabled=this.smoothing(),(0,D.AE)(t,n,o),t.restore()}this.drawChildren(t)}applyFlex(){super.applyFlex();const t=this.video();this.element.style.aspectRatio=(this.ratio()??t.videoWidth/t.videoHeight).toString()}setCurrentTime(t){const e=this.video();e.readyState<2||(e.currentTime=t,this.lastTime=t,e.seeking&&X.k.collectPromise(new Promise((t=>{const n=()=>{t(),e.removeEventListener("seeked",n)};e.addEventListener("seeked",n)}))))}play(){const t=(0,Tt.nn)().time,e=t()-this.time();this.playing(!0),this.time((()=>this.clampTime(t()-e)))}pause(){this.playing(!1),this.time.save(),this.video().pause()}seek(t){const e=this.playing();this.time(this.clampTime(t)),e?this.play():this.pause()}clampTime(t){return(0,tt.uZ)(0,this.video().duration,t)}collectAsyncResources(){super.collectAsyncResources(),this.seekedVideo()}}Zt.pool={},Lt([(0,h.td)()],Zt.prototype,"src",void 0),Lt([(0,h.nn)(1),(0,h.td)()],Zt.prototype,"alpha",void 0),Lt([(0,h.nn)(!0),(0,h.td)()],Zt.prototype,"smoothing",void 0),Lt([(0,h.nn)(0),(0,h.td)()],Zt.prototype,"time",void 0),Lt([(0,h.nn)(!1),(0,h.td)()],Zt.prototype,"playing",void 0),Lt([(0,k.F)()],Zt.prototype,"completion",null),Lt([(0,k.F)()],Zt.prototype,"video",null),Lt([(0,k.F)()],Zt.prototype,"seekedVideo",null),Lt([(0,k.F)()],Zt.prototype,"fastSeekedVideo",null);var Nt=n(5376),St=n(51284),Rt=n(42075),Et=n(67292);function*At(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];for(const o of e)yield o;yield*(0,St.v)(!1,...e)}(0,Rt.G)(At,(0,Et.C)());var zt=n(80638);function*Pt(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];for(const o of e)(0,zt.R)(o)?yield*o:o()}function It(t){const e=(0,x.$r)(),n=(0,Tt.nn)();return e.timeEvents.register(t,n.time())}(0,Rt.G)(Pt,(0,Et.C)());var Ft=n(97715);function*Wt(t,e){yield*Bt(It(t)),e&&(yield*e)}function*Bt(t,e){void 0===t&&(t=0);const n=(0,Tt.nn)(),o=(0,Ft.te)().framesToSeconds(1),s=n.time()+t;for(;s-o>n.fixed;)yield;n.time(s),e&&(yield*e)}function*Gt(t,e){yield*Bt(t),(0,zt.R)(e)?yield*e:e()}function Ot(t,e){let n=!1;function*o(){const o=(0,Ft.te)();let s=0,r=0;for(e(r),n=!0;;)s>=o.secondsToFrames(t)?(s=0,r++,e(r),n=!0):n=!1,s++,yield}return(0,Rt.G)(o,(0,Et.C)("every")),{runner:o(),setInterval(e){t=e,n=!1},setCallback(t){e=t,n=!1},*sync(){for(;!n;)yield}}}function*jt(t,e){for(let n=0;n<t;n++){const t=e(n);t?yield*t:yield}}function*qt(){}(0,Rt.G)(Wt,(0,Et.C)()),(0,Rt.G)(Bt,(0,Et.C)()),(0,Rt.G)(Gt,(0,Et.C)()),(0,Rt.G)(jt,(0,Et.C)()),(0,Rt.G)(qt,(0,Et.C)());var Ut=n(77396);function*Vt(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),o=1;o<e;o++)n[o-1]=arguments[o];for(const s of n)yield s,yield*Bt(t);yield*(0,St.v)(...n)}function*Ht(t){const{slides:e}=(0,x.$r)(),n=(0,Tt.nn)();for(e.register(t,n.fixed),yield;e.shouldWait(t);)yield}(0,Rt.G)(Vt,(0,Et.C)());var $t=n(15688);function Jt(t){switch(typeof t){case"string":return t;case"undefined":return"undefined";default:return Number.isNaN(t)?"NaN":JSON.stringify(t)}}function Yt(t){const e={message:Jt(t)};t&&"object"==typeof t&&(e.object=t),(0,x.wL)().debug(e)}function Kt(t,e,n){return function(){(0,x.wL)().warn({message:e,remarks:n,stack:(new Error).stack});for(var o=arguments.length,s=new Array(o),r=0;r<o;r++)s[r]=arguments[r];return t.apply(this,s)}}var Qt=n(49111),te=n(90031),ee=n(1119),ne=n(37762),oe=n(15649),se=n(11726);function re(t,e){return void 0===e&&(e=!0),"number"==typeof t?new se.k(e?t:t+(0,x.$r)().meta.seed.get()):(0,x.$r)().random}function ie(){let t;return e=>{if(void 0===e)return t;t=e}}function pe(t,e){return n=>{t[e]=n}}function ae(){return{}}function ce(){return(0,Tt.nn)().time()}function le(t){return(0,x.$r)().lifecycleEvents.onBeginRender.subscribe(t)}function ue(t){return(0,x.$r)().lifecycleEvents.onFinishRender.subscribe(t)}var me=n(46096),de=n(81865),he=n(73662),ye=n(97140);function fe(t,e){let n;void 0===e&&(e=null);const o=(0,ye.g)(t);return(0,he.D)((()=>{const t=o();var s;n&&n.promise===t||(n=de.h.collectPromise(t,(null==(s=n)?void 0:s.value)??e));return n.value}))}var ke=n(16249),we=n(60771),ge=n(74741),Me=n(57292);class De{static fromRotation(t){return De.identity.rotate(t)}static fromTranslation(t){return De.identity.translate(new g.F(t))}static fromScaling(t){return De.identity.scale(new g.F(t))}get x(){return new g.F(this.values[0],this.values[1])}get y(){return new g.F(this.values[2],this.values[3])}get scaleX(){return this.values[0]}set scaleX(t){this.values[0]=this.x.normalized.scale(t).x}set scaleY(t){this.values[3]=this.y.normalized.scale(t).y}get scaleY(){return this.values[3]}set translateX(t){this.values[4]=t}get translateX(){return this.values[4]}set translateY(t){this.values[5]=t}get translateY(){return this.values[5]}set rotation(t){const e=this.rotate(t-this.rotation);this.values[0]=e.values[0],this.values[1]=e.values[1],this.values[2]=e.values[2],this.values[3]=e.values[3]}get rotation(){return 180*Math.atan2(this.values[1],this.values[0])/Math.PI}set translation(t){const e=new g.F(t);this.values[4]=e.x,this.values[5]=e.y}get translation(){return new g.F(this.values[4],this.values[5])}set scaling(t){const e=new g.F(t),n=new g.F(this.values[0],this.values[1]).normalized,o=new g.F(this.values[2],this.values[3]).normalized;this.values[0]=n.x*e.x,this.values[1]=n.y*e.y,this.values[2]=o.x*e.x,this.values[3]=o.y*e.y}get scaling(){return new g.F(this.values[0],this.values[3])}get inverse(){const t=this.values[0],e=this.values[1],n=this.values[2],o=this.values[3],s=this.values[4],r=this.values[5];let i=t*o-e*n;return i?(i=1/i,new De(o*i,-e*i,-n*i,t*i,(n*r-o*s)*i,(e*s-t*r)*i)):null}get determinant(){return this.values[0]*this.values[3]-this.values[1]*this.values[2]}get domMatrix(){return new DOMMatrix([this.values[0],this.values[1],this.values[2],this.values[3],this.values[4],this.values[5]])}constructor(t,e,n,o,s,r){if(this.values=new Float32Array(6),0===arguments.length)return void(this.values=new Float32Array([1,0,0,1,0,0]));if(6===arguments.length)return this.values[0]=t,this.values[1]=e,this.values[2]=n,this.values[3]=o,this.values[4]=s,void(this.values[5]=r);if(t instanceof De)return void(this.values=t.values);if(Array.isArray(t)){if(2===t.length)return this.values[0]=t[0],this.values[1]=t[1],this.values[2]=e[0],this.values[3]=e[1],this.values[4]=n[0],void(this.values[5]=n[1]);if(3===t.length){const e=new g.F(t[0]),n=new g.F(t[1]),o=new g.F(t[2]);return this.values[0]=e.x,this.values[1]=e.y,this.values[2]=n.x,this.values[3]=n.y,this.values[4]=o.x,void(this.values[5]=o.y)}return this.values[0]=t[0],this.values[1]=t[1],this.values[2]=t[2],this.values[3]=t[3],this.values[4]=t[4],void(this.values[5]=t[5])}const i=new g.F(t),p=new g.F(e),a=new g.F(n);this.values[0]=i.x,this.values[1]=i.y,this.values[2]=p.x,this.values[3]=p.y,this.values[4]=a.x,this.values[5]=a.y}column(t){return new g.F(this.values[2*t],this.values[2*t+1])}row(t){return[this.values[t],this.values[t+2],this.values[t+4]]}mul(t){const e=this.values[0],n=this.values[1],o=this.values[2],s=this.values[3],r=this.values[4],i=this.values[5],p=t.values[0],a=t.values[1],c=t.values[2],l=t.values[3],u=t.values[4],m=t.values[5];return new De(e*p+o*a,n*p+s*a,e*c+o*l,n*c+s*l,e*u+o*m+r,n*u+s*m+i)}rotate(t,e){void 0===e&&(e=!0),e&&(t=t*Math.PI/180);const n=this.values[0],o=this.values[1],s=this.values[2],r=this.values[3],i=this.values[4],p=this.values[5],a=Math.sin(t),c=Math.cos(t);return new De(n*c+s*a,o*c+r*a,n*-a+s*c,o*-a+r*c,i,p)}scale(t){const e=new g.F(t);return new De(this.values[0]*e.x,this.values[1]*e.x,this.values[2]*e.y,this.values[3]*e.y,this.values[4],this.values[5])}mulScalar(t){return new De(this.values[0]*t,this.values[1]*t,this.values[2]*t,this.values[3]*t,this.values[4]*t,this.values[5]*t)}translate(t){const e=new g.F(t);return new De(this.values[0],this.values[1],this.values[2],this.values[3],this.values[0]*e.x+this.values[2]*e.y+this.values[4],this.values[1]*e.x+this.values[3]*e.y+this.values[5])}add(t){return new De(this.values[0]+t.values[0],this.values[1]+t.values[1],this.values[2]+t.values[2],this.values[3]+t.values[3],this.values[4]+t.values[4],this.values[5]+t.values[5])}sub(t){return new De(this.values[0]-t.values[0],this.values[1]-t.values[1],this.values[2]-t.values[2],this.values[3]-t.values[3],this.values[4]-t.values[4],this.values[5]-t.values[5])}toSymbol(){return De.symbol}equals(t,e){return void 0===e&&(e=Me.I),Math.abs(this.values[0]-t.values[0])<=e+Number.EPSILON&&Math.abs(this.values[1]-t.values[1])<=e+Number.EPSILON&&Math.abs(this.values[2]-t.values[2])<=e+Number.EPSILON&&Math.abs(this.values[3]-t.values[3])<=e+Number.EPSILON&&Math.abs(this.values[4]-t.values[4])<=e+Number.EPSILON&&Math.abs(this.values[5]-t.values[5])<=e+Number.EPSILON}exactlyEquals(t){return this.values[0]===t.values[0]&&this.values[1]===t.values[1]&&this.values[2]===t.values[2]&&this.values[3]===t.values[3]&&this.values[4]===t.values[4]&&this.values[5]===t.values[5]}}De.symbol=Symbol.for("@motion-canvas/core/types/Matrix2D"),De.identity=new De(1,0,0,1,0,0),De.zero=new De(0,0,0,0,0,0);var _e=n(98378),Xe=n(43188),xe=n(97074),ve=n(74534);function*Ce(t,e,n,o,s,r){const i="number"==typeof o?o:.001;r="number"==typeof o?r:s;const p=(t,e)=>{"function"==typeof o?o(t,e):"function"==typeof s&&s(t,e)};if((t=t??{mass:.05,stiffness:10,damping:.5}).mass<=0)return void(0,x.wL)().error(new Error("Spring mass must be greater than 0."));if(t.stiffness<0)return void(0,x.wL)().error(new Error("Spring stiffness must be greater or equal to 0."));if(t.damping<0)return void(0,x.wL)().error(new Error("Spring damping must be greater or equal to 0."));const a=(0,Tt.nn)();let c=e,l=t.initialVelocity??0;const u=e=>{if(null===t)return;const o=c-n,s=-t.stiffness*o-t.damping*l;l+=s/t.mass*e,c+=l*e},m=1/120;p(e,0);const d=a.time();let h=d,y=!1;for(;!y;){for(;h<a.fixed;){const t=a.fixed-h;if(m>t?(u(t),h=a.fixed):(u(m),h+=m),Math.abs(n-c)<i&&Math.abs(l)<i){a.time(h),y=!0;break}}y||(p(c,a.fixed-d),yield)}p(n,a.fixed-d),null==r||r(n,a.fixed-d)}function Te(t,e,n,o){return{mass:t,stiffness:e,damping:n,initialVelocity:o}}(0,Rt.G)(Ce,(0,Et.C)());const be=Te(.13,5.7,1.2,10),Le=Te(.2,20,.68,0),Ze=Te(.08,4.75,.05,0),Ne=Te(.39,19.85,2.82,0),Se=Te(.04,10,.7,8),Re=Te(.03,20,.9,4.8),Ee=Te(.16,15.35,1.88,0);function Ae(){const t=(0,Tt.nn)();for(var e=arguments.length,n=new Array(e),o=0;o<e;o++)n[o]=arguments[o];for(const s of n){const e=t.children.find((t=>t.runner===s));e&&!e.canceled&&(e.cancel(),e.time(t.time()))}}var ze=n(75168),Pe=n(50580),Ie=n(5881);const Fe={...o,...s,...r,...i,...p,...a,...c,_Fragment:u,_jsx:m,_jsxs:m,makeScene2D:l.r}},53487:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{v:()=>transform});var _babel_standalone__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(87243),_babel_standalone__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(_babel_standalone__WEBPACK_IMPORTED_MODULE_0__),_site_src_components_Fiddle_runtime__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(21354);function transform(code){try{const result=_babel_standalone__WEBPACK_IMPORTED_MODULE_0__.transform(code,{filename:"fiddle.tsx",presets:["typescript",["react",{runtime:"automatic",importSource:"@motion-canvas/2d/lib"}]],plugins:["mc"]});eval(result.code)}catch(e){return e}return null}_babel_standalone__WEBPACK_IMPORTED_MODULE_0__.registerPlugin("mc",(t=>{let{types:e}=t;return{visitor:{Program(t){t.node.body.unshift(e.variableDeclaration("const",[e.variableDeclarator(e.objectPattern(Object.keys(_site_src_components_Fiddle_runtime__WEBPACK_IMPORTED_MODULE_1__.Z).map((t=>e.objectProperty(e.identifier(t),e.identifier(t),!1,!0)))),e.memberExpression(e.identifier("window"),e.identifier("mc")))]))},ImportDeclaration(t){t.remove()},ExportDefaultDeclaration(t){t.replaceWith(t.node.declaration)}}}}))},70532:(t,e,n)=>{"use strict";n.d(e,{Z:()=>l});var o=n(2784),s=n(89741);const r="tooltip_lI6R",i="active_DOSD";var p=n(6277),a=n(88617),c=n(79322);function l(t){let{children:e}=t;const n=(0,s.Z)(),l=(0,a.rG)(),[u,m]=(0,o.useState)(!1),[d,h]=(0,o.useState)(null),y=(0,o.useRef)(),f=(0,o.useRef)(),k=(0,o.useRef)(),w=(0,o.useCallback)((()=>{if(!f.current||!k.current)return;const t=f.current.getBoundingClientRect();let e=window.innerWidth-t.left-496;e<0&&(e=0),k.current.style.right=`${e}px`,k.current.style.top=`${t.bottom}px`}),[]);return(0,o.useEffect)((()=>{if(!n)return;const t=t=>{var e,n,o;if(!t.target.href||null==(e=y.current)||!e.contains(t.target)||null!=(n=k.current)&&n.contains(t.target))return;const s=new URL(t.target.href,document.baseURI);if(s.pathname===window.location.pathname)return;const r=l(s.pathname+s.hash);null!=r&&null!=(o=r.comment)&&o.summary&&(f.current=t.target,m(!0),h(r.comment),w())},e=t=>{t.target===f.current&&m(!1)};return document.addEventListener("mouseenter",t,!0),document.addEventListener("focus",t,!0),document.addEventListener("mouseleave",e,!0),document.addEventListener("blur",e,!0),document.addEventListener("scroll",w),()=>{document.removeEventListener("mouseenter",t,!0),document.removeEventListener("focus",t,!0),document.removeEventListener("mouseleave",e,!0),document.removeEventListener("blur",e,!0),document.removeEventListener("scroll",w)}}),[n]),(0,o.useEffect)((()=>{w()})),o.createElement("div",{ref:y},e,o.createElement("div",{ref:k,className:(0,p.Z)(r,"padding--md margin-horiz--md",u&&i)},d&&o.createElement(c.Z,{comment:d,full:!1})))}},88617:(t,e,n)=>{"use strict";n.d(e,{Gr:()=>c,RU:()=>i,gs:()=>r,in:()=>p,rG:()=>a});var o=n(2784);const s=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:e,lookup:n,urlLookup:r}=t;return o.createElement(s.Provider,{value:{lookup:n,urlLookup:r}},e)}function i(t){const{lookup:e}=(0,o.useContext)(s);return e[t]}function p(){const{lookup:t}=(0,o.useContext)(s);return e=>{if("number"==typeof(null==e?void 0:e.project))return t[e.project][e.id]}}function a(){const{urlLookup:t,lookup:e}=(0,o.useContext)(s);return n=>{var o;const s=t[n];return s?(null==(o=e[s.projectId])?void 0:o[s.id])??null:null}}function c(t){if(t)return t.href}},80068:(t,e,n)=>{"use strict";n.d(e,{Ld:()=>p,Y0:()=>i,s2:()=>a});var o=n(2784),s=n(50822);const r=o.createContext(null);function i(t){let{children:e}=t;const n=(0,s.p)(),i=(0,o.useMemo)((()=>function(t,e){const{plain:n}=t,o=Object.create(null),s=t.styles.reduce(((t,n)=>{const{languages:o,style:s}=n;return o&&!o.includes(e)||n.types.forEach((e=>{t[e]={...t[e],...s}})),t}),o);return s.root=n,s.plain={...n,backgroundColor:null},s}(n,"typescript")),[n]);return o.createElement(r.Provider,{value:i},e)}function p(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return{className:`token ${t}`,style:e[t]??e.plain}}function a(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return e[t]??e.plain}},57708:(t,e,n)=>{"use strict";n.d(e,{It:()=>m,Wy:()=>l,mN:()=>u});var o=n(2784),s=n(31263),r=n(89741);const i="api-filters",p=s.Z.canUseDOM?localStorage.getItem(i):null,a=p?JSON.parse(p):{inherited:!0,private:!1},c=o.createContext([a,()=>{}]);function l(t){let{children:e}=t;const[n,s]=(0,o.useState)(a),p=(0,r.Z)();return o.createElement(c.Provider,{value:[n,t=>{p&&localStorage.setItem(i,JSON.stringify(t)),s(t)}]},e)}function u(){return(0,o.useContext)(c)}function m(t,e){var n,o;const s=(null==(n=e.flags)?void 0:n.isPrivate)||(null==(o=e.flags)?void 0:o.isProtected);if(!t.private&&s)return!1;const r=!!e.inheritedFrom;return!(!t.inherited&&r)}},26047:(t,e,n)=>{"use strict";n.d(e,{Z:()=>u});var o=n(7896),s=n(2784),r=n(59055);const i="icon_Fw4I";function p(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),s.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"}))}function a(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),s.createElement("path",{d:"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"}))}function c(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),s.createElement("path",{d:"M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"}))}function l(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),s.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"}))}function u(t){const e=(0,s.useMemo)((()=>{switch(t.type){case"tip":return l;case"caution":return a;case"danger":return c;default:return p}}),[t.type]);return s.createElement(s.Fragment,null,s.createElement(r.Z,(0,o.Z)({icon:s.createElement(e,{className:i})},t)))}},94141:(t,e,n)=>{"use strict";n.d(e,{Z:()=>p});var o=n(7896),s=n(2784),r=n(6277);const i="iconEdit_N_05";function p(t){let{className:e,...n}=t;return s.createElement("svg",(0,o.Z)({fill:"currentColor",width:"24px",height:"24px",viewBox:"0 0 24 24",className:(0,r.Z)(i,e),"aria-hidden":"true"},n),s.createElement("path",{d:"M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"}))}},44648:(t,e,n)=>{"use strict";n.d(e,{Z:()=>r});var o=n(7896),s=n(2784);function r(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",style:{width:16,height:16,marginTop:"0.1rem"}},t),s.createElement("path",{d:"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z",fill:"currentColor"}))}},14941:(t,e,n)=>{"use strict";n.d(e,{Z:()=>ct});var o=n(2784),s=n(52203),r=n(18888),i=n(35565),p=n(1727),a=n(99387),c=n(77120),l=n(53947),u=n(86253);const m=c.Qf.define([{tag:u.pJ.comment,color:"var(--hl-comment)"},{tag:u.pJ.docComment,color:"var(--hl-comment)"},{tag:u.pJ.blockComment,color:"var(--hl-comment)"},{tag:u.pJ.keyword,color:"var(--hl-keyword)"},{tag:u.pJ.number,color:"var(--hl-number)"},{tag:u.pJ.inserted,color:"var(--hl-number)"},{tag:u.pJ.constant(u.pJ.propertyName),color:"var(--hl-constant)"},{tag:u.pJ.attributeName,color:"var(--hl-variable)"},{tag:u.pJ.variableName,color:"var(--hl-variable)"},{tag:u.pJ.propertyName,color:"var(--hl-variable)"},{tag:u.pJ.deleted,color:"var(--hl-string)"},{tag:u.pJ.string,color:"var(--hl-string)"},{tag:u.pJ.attributeValue,color:"var(--hl-string)"},{tag:u.pJ.tagName,color:"var(--hl-tag)"},{tag:u.pJ.typeName,color:"var(--hl-tag)"},{tag:u.pJ.punctuation,color:"var(--hl-punctuation)"},{tag:u.pJ.operator,color:"var(--hl-punctuation)"},{tag:u.pJ.function(u.pJ.variableName),color:"var(--hl-function)"},{tag:u.pJ.function(u.pJ.propertyName),color:"var(--hl-function)"},{tag:u.pJ.className,color:"var(--hl-class)"},{tag:u.pJ.character,color:"var(--hl-char)"}]),d=i.tk.theme({"&":{fontSize:"var(--ifm-code-font-size)",lineHeight:"21.04px",fontFamily:"var(--ifm-font-family-monospace)",color:"var(--hl-color)",backgroundColor:"var(--hl-background)"},"&.cm-focused .cm-cursor":{borderLeftColor:"var(--hl-color)"},"&.cm-focused":{outline:"none"},".cm-gutters":{backgroundColor:"var(--hl-background)",color:"var(--ifm-color-secondary-darkest)",borderRight:"1px solid var(--ifm-background-color)"},"& .cm-lineNumbers .cm-gutterElement":{paddingLeft:"var(--ifm-pre-padding)"},".cm-activeLineGutter":{backgroundColor:"var(--ifm-code-active-color)"},".cm-scroller":{fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",paddingTop:"var(--ifm-pre-padding)",paddingBottom:"var(--ifm-pre-padding)"},".cm-content":{padding:"0"},"& .cm-line":{paddingRight:"var(--ifm-pre-padding)"},"& .cm-selectionBackground, &.cm-focused .cm-selectionBackground, ::selection":{backgroundColor:"var(--ifm-code-selection-color)"},".cm-activeLine":{backgroundColor:"var(--ifm-code-active-color)"},".cm-selectionMatch":{backgroundColor:"var(--ifm-code-selection-color)"},".cm-foldPlaceholder":{backgroundColor:"var(--ifm-code-selection-color)",borderColor:"var(--ifm-color-emphasis-300)"},".cm-tooltip":{backgroundColor:"var(--ifm-background-surface-color)"}});var h=n(78128);function y(t){const[e,n]=(0,o.useState)(null==t?void 0:t.current);return(0,o.useEffect)((()=>t&&t.subscribe(n)),[t]),e}function f(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M6 6h2v12H6zm3.5 6l8.5 6V6z"}))}function k(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"}))}function w(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M8 5v14l11-7z"}))}function g(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M6 19h4V5H6v14zm8-14v14h4V5h-4z"}))}var M=n(21354);const D=Object.entries(M.Z).map((t=>{let[e,n]=t;return{label:e,type:"function"==typeof n?(o=n,o.prototype&&o.prototype.constructor.name?"class":"function"):"variable"};var o}));var _,X=n(96881);!function(t){t.Error="error",t.Warn="warn",t.Info="info",t.Http="http",t.Verbose="verbose",t.Debug="debug",t.Silly="silly"}(_||(_={}));class x{constructor(){this.logged=new X.p,this.history=[],this.profilers={}}get onLogged(){return this.logged.subscribable}log(t){this.logged.dispatch(t),this.history.push(t)}error(t){this.logLevel(_.Error,t)}warn(t){this.logLevel(_.Warn,t)}info(t){this.logLevel(_.Info,t)}http(t){this.logLevel(_.Http,t)}verbose(t){this.logLevel(_.Verbose,t)}debug(t){this.logLevel(_.Debug,t)}silly(t){this.logLevel(_.Silly,t)}logLevel(t,e){const n="string"==typeof e?{message:e}:e;n.level=t,this.log(n)}profile(t,e){const n=performance.now();if(this.profilers[t]){const o=this.profilers[t];delete this.profilers[t];const s=e??{message:t};return s.level??(s.level=_.Debug),s.durationMs=n-o,void this.log(s)}this.profilers[t]=n}}var v=n(82344),C=n(92673),T=n(30204);class b extends v.C{constructor(){super(...arguments),this.type=T.I.symbol}parse(t){return null===t?null:new T.I(t)}serialize(){var t;return(null==(t=this.value.current)?void 0:t.serialize())??null}}var L=n(57292),Z=n(13170);class N extends v.C{constructor(){super(...arguments),this.type=N.symbol}parse(t){return this.parseRange(1/0,t[0],t[1]??1/0)}update(t,e,n,o){this.value.current=this.parseRange(n/o-L.I,t/o-L.I,e/o-L.I)}parseRange(t,e,n){return void 0===e&&(e=this.value.current[0]),void 0===n&&(n=this.value.current[1]),(e=(0,Z.uZ)(0,t,e))>(n=(0,Z.uZ)(0,t,n??1/0))&&([e,n]=[n,e]),n>=t&&(n=1/0),[e,n]}}N.symbol=Symbol.for("@motion-canvas/core/meta/RangeMetaField");var S=n(29797);class R extends v.C{constructor(){super(...arguments),this.type=S.F.symbol}parse(t){return new S.F(t)}serialize(){return this.value.current.serialize()}}class E extends v.C{constructor(){super(...arguments),this.type=Number,this.presets=[]}parse(t){let e=parseFloat(t);return void 0!==this.min&&e<this.min&&(e=this.min),void 0!==this.max&&e>this.max&&(e=this.max),e}getPresets(){return this.presets}setPresets(t){return this.presets=t,this}setRange(t,e){return this.min=t,this.max=e,this}}class A extends v.C{constructor(t,e,n){void 0===n&&(n=e[0].value),super(t,n),this.options=e,this.type=A.symbol}set(t){super.set(this.getOption(t).value)}parse(t){return this.getOption(t).value}getOption(t){return this.options.find((e=>e.value===t))??this.options[0]}}A.symbol=Symbol.for("@motion-canvas/core/meta/EnumMetaField");var z=n(1323);class P extends v.C{get onFieldsChanged(){return this.fields.subscribable}get options(){return this.optionFields[this.current]}get exporter(){return this.exporters[this.current]}constructor(t,e,n){void 0===n&&(n=0);const o=e.map((t=>t.meta())),s=new A("exporter",e.map((t=>({value:t.name,text:t.name}))),e[n].name);super(t,{name:s.get(),options:o[n].get()}),this.exporters=e,this.current=n,this.type=Object,this.handleChange=()=>{const t=this.exporterField.get(),e=Math.max(this.exporters.findIndex((e=>e.name===t)),0);this.current!==e&&(this.options.onChanged.unsubscribe(this.handleChange),this.current=e,this.options.onChanged.subscribe(this.handleChange,!1),this.fields.current=[this.exporterField,this.options]),this.value.current={name:this.exporterField.get(),options:this.options.get()}},this.exporterField=s,this.exporterField.onChanged.subscribe(this.handleChange,!1),this.exporterField.disable(o.length<2).space(),this.optionFields=o,this.optionFields[n].onChanged.subscribe(this.handleChange,!1),this.fields=new z.G([this.exporterField,this.options])}set(t){this.exporterField.set(t.name),this.options.set(t.options)}serialize(){return{name:this.exporterField.serialize(),options:this.options.serialize()}}clone(){return new this.constructor(this.name,this.exporters,this.current)}}const I=[{value:.25,text:"0.25x (Quarter)"},{value:.5,text:"0.5x (Half)"},{value:1,text:"1.0x (Full)"},{value:2,text:"2.0x (Double)"}],F=[{value:"srgb",text:"sRGB"},{value:"display-p3",text:"DCI-P3"}],W=[{value:"image/png",text:"png"},{value:"image/jpeg",text:"jpeg"},{value:"image/webp",text:"webp"}],B=[{value:30,text:"30 FPS"},{value:60,text:"60 FPS"}];class G extends C.v{constructor(t){super("project",function(t){const e={version:new v.C("version",1),shared:new C.v("General",{background:new b("background",null),range:new N("range",[0,1/0]),size:new R("resolution",new S.F(1920,1080)),audioOffset:new E("audio offset",0)}),preview:new C.v("Preview",{fps:new E("frame rate",30).setPresets(B),resolutionScale:new A("scale",I,1)}),rendering:new C.v("Rendering",{fps:new E("frame rate",60).setPresets(B),resolutionScale:new A("scale",I,1),colorSpace:new A("color space",F),exporter:new P("exporter",t.plugins.flatMap((e=>(null==e.exporters?void 0:e.exporters(t))??[])))})};return e.shared.audioOffset.disable(!t.audio),e}(t))}getFullPreviewSettings(){return{...this.shared.get(),...this.preview.get()}}getFullRenderingSettings(){return{...this.shared.get(),...this.rendering.get()}}}var O=n(2672),j=n(9989),q=n(15914);class U extends v.C{constructor(){super(...arguments),this.type=Boolean}parse(t){return!!t}}class V{constructor(t){this.logger=t,this.name="image sequence",this.frameLookup=new Map,this.frameCounter=0,this.projectName="unknown",this.quality=1,this.fileType="image/png",this.groupByScene=!1}meta(){const t=new C.v(this.name,{fileType:new A("file type",W),quality:new E("quality",100).setRange(0,100),groupByScene:new U("group by scene",!1)});return t.fileType.onChanged.subscribe((e=>{t.quality.disable("image/png"===e)})),t}async configure(t){const e=t.exporter.options;this.projectName=t.name,this.quality=(0,Z.uZ)(0,1,e.quality/100),this.fileType=e.fileType,this.groupByScene=e.groupByScene}async start(){this.frameLookup.clear()}async handleFrame(t,e,n,o,s){this.frameLookup.has(e)&&this.logger.warn(`Frame no. ${e} is already being exported.`)}async stop(){for(;this.frameCounter>0;)await new Promise((t=>setTimeout(t,1e3)))}}const H={name:"mc-default-plugin",exporters:t=>[new V(t.logger)]};let $=null,J=null,Y=null,K=null,Q=null,tt=null;function et(t,e){var n;if(t!==Q)return $||(window.mc={...M.Z,makeScene2D:t=>(J.config=t,J.onReplaced.current=J,J)},J=(0,q.r)((function*(){yield})),J.onReplaced=new z.G(J),$={name:"fiddle",logger:new x,plugins:[H],scenes:[J]},$.meta=new G($),$.meta.shared.size.set([960,240]),Y=new O.J($,{size:$.meta.shared.size.get()}),K=new j.H,K.configure({size:$.meta.shared.size.get()}),Y.onRender.subscribe((async()=>{await K.render(Y.playback.currentScene,Y.playback.previousScene)})),Y.onRecalculated.subscribe((()=>{var t;K.finalBuffer.parentElement!==tt&&(null==(t=tt)||t.append(K.finalBuffer),Q(Y))}))),null==(n=tt)||n.removeChild(K.finalBuffer),null==Q||Q(null),Q=t,tt=e,Y.activate(),Y.requestReset(),Y}const nt={root:"root_icgl",progress:"progress_HsLC",controls:"controls_R4ai",section:"section_UscS",icon:"icon_brRG",error:"error_N64d",editor:"editor_xQGp",source:"source_Dq6N",preview:"preview_C9cZ",button:"button_ESGX"};var ot=n(53487);const st=/ *\/\/ ?(\S+) ?(.*)/,rt=["highlight-next-line","highlight-start","highlight-end"];var it=n(6277);function pt(t){var e;let{options:n,value:s,className:r,onChange:i}=t;const p=(0,o.useRef)(),a=(0,o.useRef)(),[c,l]=(0,o.useState)(!1);return(0,o.useEffect)((()=>{const t=t=>{p.current&&!p.current.contains(t.target)&&l(!1)};return document.addEventListener("mousedown",t),document.addEventListener("touchstart",t),()=>{document.removeEventListener("mousedown",t),document.removeEventListener("touchstart",t)}}),[p]),o.createElement("div",{ref:p,className:(0,it.Z)("dropdown dropdown--right",c&&"dropdown--show",r)},o.createElement("a",{ref:a,className:"navbar__link",href:"#",onClick:t=>{t.preventDefault(),l(!c)}},(null==(e=n.find((t=>t.value===s)))?void 0:e.name)??s),o.createElement("ul",{className:"dropdown__menu"},n.map(((t,e)=>o.createElement("li",{key:t.value},o.createElement("a",{href:"#",className:(0,it.Z)("dropdown__link",s===t.value&&"dropdown__link--active"),onClick:e=>{e.preventDefault(),i(t.value),l(!1),a.current.focus()},onKeyDown:t=>{e!==n.length-1||"Tab"!==t.key||t.shiftKey||(t.preventDefault(),l(!1),a.current.focus())}},t.name))))))}function at(t){let{children:e}=t;const[n,s]=(0,o.useState)(null),u=(0,o.useRef)(null),M=(0,o.useRef)(),_=(0,o.useRef)(),[X,x]=(0,o.useState)(null),v=y(null==n?void 0:n.onDurationChanged),C=y(null==n?void 0:n.onFrameChanged),T=y(null==n?void 0:n.onStateChanged),[b,L]=(0,o.useState)(null),[Z,N]=(0,o.useState)(null),S=function(t,e){void 0===e&&(e=!0),et(s,_.current);const n=(0,ot.v)(t.sliceString(0));var o;x(n),n||(N(t),!e||null!=Z&&Z.eq(t)||_.current.animate((void 0===o&&(o=4),[{boxShadow:"0 0 0px 0 #ccc inset",easing:"cubic-bezier(0.33, 1, 0.68, 1)"},{boxShadow:`0 0 0px ${o}px #ccc inset`,easing:"cubic-bezier(0.32, 0, 0.67, 0)"},{boxShadow:"0 0 0px 0 #ccc inset"}]),{duration:300}))},[R,E]=(0,o.useState)(0),A=(0,o.useMemo)((()=>function(t){let e={name:"Default",lines:[]};const n=[e];for(const o of t.split("\n")){const t=st.exec(o);if(!t){e.lines.push(o);continue}const[,s,r]=t;rt.includes(s)||("snippet"===s?e.lines.length>0?(e={name:r,lines:[]},n.push(e)):e.name=r:e.lines.push(o))}return n}(e).map((t=>({name:t.name,state:p.yy.create({doc:p.xv.of(t.lines),extensions:[r.Xy,i.$f.of([l.oc,{key:"Mod-s",preventDefault:!0,run:t=>(S(t.state.doc),!0)}]),i.tk.updateListener.of((t=>{L(t.state.doc),x(null)})),a.Lz.data.of({autocomplete:t=>{if("String"===(0,c.qz)(t.state).resolveInner(t.pos,-1).name)return;const e=t.matchBefore(/\w*/);return e.from!=e.to||t.explicit?{from:e.from,options:D}:null}}),(0,a.eJ)({jsx:!0,typescript:!0}),(0,c.nF)(m),d]})})))),[e]);(0,o.useEffect)((()=>{u.current=new i.tk({parent:M.current,state:A[R].state});var t,e;return(t=s,e=_.current,Q?null:et(t,e))&&S(A[R].state.doc,!1),()=>{!function(t){Q===t&&$&&(Y.deactivate(),Q=null,tt=null,K.finalBuffer.remove())}(s),u.current.destroy()}}),[]);const z=Z&&b&&!b.eq(Z),P=b&&!b.eq(A[R].state.doc)||z;return o.createElement("div",{className:nt.root},o.createElement("div",{className:nt.preview,ref:_},!n&&o.createElement("div",null,"Press play to preview the animation")),o.createElement("div",{className:nt.progress,style:{width:n?C/v*100+"%":0}}),o.createElement("div",{className:nt.controls},o.createElement("div",{className:nt.section},z&&o.createElement("button",{onClick:()=>S(u.current.state.doc),className:nt.button},o.createElement("kbd",null,"CTRL"),o.createElement("kbd",null,"S"),o.createElement("small",null,"Update preview"))),o.createElement("div",{className:nt.section},o.createElement("button",{className:nt.icon,onClick:()=>null==n?void 0:n.requestPreviousFrame()},o.createElement(f,null)),o.createElement("button",{className:nt.icon,onClick:()=>{if(n)Z||S(u.current.state.doc),n.togglePlayback();else{const t=et(s,_.current);S(u.current.state.doc),t.togglePlayback(!0)}}},!n||((null==T?void 0:T.paused)??1)?o.createElement(w,null):o.createElement(g,null)),o.createElement("button",{className:nt.icon,onClick:()=>null==n?void 0:n.requestNextFrame()},o.createElement(k,null))),o.createElement("div",{className:nt.section},0===A.length&&P&&o.createElement("button",{className:nt.button,onClick:()=>{u.current.setState(A[R].state),S(A[R].state.doc),L(A[R].state.doc)}},o.createElement("small",null,"Reset example")),A.length>1&&o.createElement(pt,{className:nt.picker,value:P?-1:R,onChange:t=>{E(t),u.current.setState(A[t].state),S(A[t].state.doc)},options:A.map(((t,e)=>({value:e,name:t.name}))).concat(P?{value:-1,name:"Custom"}:[])}))),X&&o.createElement("pre",{className:nt.error},X.message),o.createElement("div",{className:nt.editor,ref:M},o.createElement(h.Z,{className:nt.source,language:"tsx"},A[0].state.doc.toString()+"\n")))}const ct={...s.Z,pre:function(t){var e,n;return(0,o.isValidElement)(t.children)&&null!=(e=t.children.props)&&e.editor?o.createElement(at,null,t.children.props.children):o.createElement(h.Z,(0,o.isValidElement)(t.children)&&"code"===(null==(n=t.children.props)?void 0:n.originalType)?t.children.props:{...t})}}},47733:(t,e,n)=>{"use strict";n.d(e,{Z:()=>p});var o=n(7896),s=n(2784),r=n(77287);const i="root_ZAv1";function p(t){const e=s.Children.toArray(t.children),n=e.find((t=>{var e;return s.isValidElement(t)&&"summary"===(null==(e=t.props)?void 0:e.mdxType)})),p=s.createElement(s.Fragment,null,e.filter((t=>t!==n)));return s.createElement(s.Fragment,null,s.createElement(r.P,(0,o.Z)({},t,{summary:n,className:i}),p))}},46155:(t,e,n)=>{var o={"./locale":99394,"./locale.js":99394};function s(t){var e=r(t);return n(e)}function r(t){if(!n.o(o,t)){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}return o[t]}s.keys=function(){return Object.keys(o)},s.resolve=r,t.exports=s,s.id=46155}}]);
(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[3239],{61532:t=>{function e(t){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}e.keys=()=>[],e.resolve=e,e.id=61532,t.exports=e},70989:(t,e,n)=>{"use strict";n.d(e,{A:()=>w});var o=n(93091),s=n(88104),r=n(15688);function i(t,e){return void 0===e&&(e=t=>t),(n,o)=>{n[`getDefault${(0,r.k)(o)}`]=function(){this.requestLayoutUpdate();const n=this.element.style[t];this.element.style[t]="";const o=e.call(this,this.styles.getPropertyValue(t));return this.element.style[t]=n,o}}}var p=n(46350),a=n(29797),c=n(23357),l=n(98378),u=n(74534),m=n(67292),d=n(20092),h=n(11258),y=n(53693),f=n(97140),k=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class w extends d.N{get columnGap(){return this.gap.x}get rowGap(){return this.gap.y}getX(){return this.isLayoutRoot()?this.customX():this.computedPosition().x}setX(t){this.customX(t)}getY(){return this.isLayoutRoot()?this.customY():this.computedPosition().y}setY(t){this.customY(t)}get width(){return this.size.x}get height(){return this.size.y}getWidth(){return this.computedSize().width}setWidth(t){this.customWidth(t)}*tweenWidth(t,e,n,o){const s=this.desiredSize().x,r="number"!=typeof s||"number"!=typeof t;let i,p;i=r?this.size.x():s,r?(this.size.x(t),p=this.size.x()):p=t,this.size.x(i),r&&this.lockSize(),yield*(0,u.i)(e,(t=>this.size.x(o(i,p,n(t))))),this.size.x(t),r&&this.releaseSize()}getHeight(){return this.computedSize().height}setHeight(t){this.customHeight(t)}*tweenHeight(t,e,n,o){const s=this.desiredSize().y,r="number"!=typeof s||"number"!=typeof t;let i,p;i=r?this.size.y():s,r?(this.size.y(t),p=this.size.y()):p=t,this.size.y(i),r&&this.lockSize(),yield*(0,u.i)(e,(t=>this.size.y(o(i,p,n(t))))),this.size.y(t),r&&this.releaseSize()}desiredSize(){return{x:this.customWidth(),y:this.customHeight()}}*tweenSize(t,e,n,o){const s=this.desiredSize();let r,i;r="number"!=typeof s.x||"number"!=typeof s.y?this.size():new a.F(s),"object"==typeof t&&"number"==typeof t.x&&"number"==typeof t.y?i=new a.F(t):(this.size(t),i=this.size()),this.size(r),this.lockSize(),yield*(0,u.i)(e,(t=>this.size(o(r,i,n(t))))),this.releaseSize(),this.size(t)}constructor(t){let{tagName:e="div",...n}=t;super(n),this.sizeLockCounter=(0,f.g)(0),this.element=document.createElement(e),this.element.style.display="flex",this.element.style.boxSizing="border-box",this.styles=getComputedStyle(this.element)}lockSize(){this.sizeLockCounter(this.sizeLockCounter()+1)}releaseSize(){this.sizeLockCounter(this.sizeLockCounter()-1)}parentTransform(){let t=this.parent();for(;t;){if(t instanceof w)return t;t=t.parent()}return null}anchorPosition(){const t=this.computedSize(),e=this.offset();return t.scale(.5).mul(e)}layoutEnabled(){var t;return this.layout()??(null==(t=this.parentTransform())?void 0:t.layoutEnabled())??!1}isLayoutRoot(){var t;return!this.layoutEnabled()||!(null!=(t=this.parentTransform())&&t.layoutEnabled())}localToParent(){const t=new DOMMatrix,e=this.size().mul(this.offset()).scale(-.5);return t.translateSelf(this.position.x(),this.position.y()),t.rotateSelf(0,0,this.rotation()),t.scaleSelf(this.scale.x(),this.scale.y()),t.translateSelf(e.x,e.y),t}getComputedLayout(){return new c.b(this.element.getBoundingClientRect())}computedPosition(){this.requestLayoutUpdate();const t=this.getComputedLayout(),e=new a.F(t.x+t.width/2*this.offset.x(),t.y+t.height/2*this.offset.y()),n=this.parentTransform();if(n){const o=n.getComputedLayout();e.x-=o.x+(o.width-t.width)/2,e.y-=o.y+(o.height-t.height)/2}return e}computedSize(){return this.requestLayoutUpdate(),this.getComputedLayout().size}requestLayoutUpdate(){const t=this.parentTransform();this.appendedToView()?(null==t||t.requestFontUpdate(),this.updateLayout()):t.requestLayoutUpdate()}appendedToView(){const t=this.isLayoutRoot();return t&&this.view().element.append(this.element),t}updateLayout(){if(this.applyFont(),this.applyFlex(),this.layoutEnabled()){const t=this.layoutChildren();for(const e of t)e.updateLayout()}}layoutChildren(){const t=[...this.children()],e=[],n=[];for(;t.length;){const o=t.shift();o instanceof w?(e.push(o),n.push(o.element)):o&&t.unshift(...o.children())}return this.element.replaceChildren(...n),e}requestFontUpdate(){var t;null==(t=this.parentTransform())||t.requestFontUpdate(),this.applyFont()}getCacheBBox(){return c.b.fromSizeCentered(this.computedSize())}draw(t){if(this.clip()){const e=this.computedSize();if(0===e.width||0===e.height)return;t.beginPath(),t.rect(e.width/-2,e.height/-2,e.width,e.height),t.closePath(),t.clip()}this.drawChildren(t)}drawOverlay(t,e){const n=this.computedSize(),o=n.mul(this.offset()).scale(.5).transformAsPoint(e),s=c.b.fromSizeCentered(n),r=s.transformCorners(e),i=s.addSpacing(this.padding().scale(-1)).transformCorners(e),p=s.addSpacing(this.margin()).transformCorners(e);t.beginPath(),(0,h.pS)(t,p),(0,h.pS)(t,r),t.closePath(),t.fillStyle="rgba(255,193,125,0.6)",t.fill("evenodd"),t.beginPath(),(0,h.pS)(t,r),(0,h.pS)(t,i),t.closePath(),t.fillStyle="rgba(180,255,147,0.6)",t.fill("evenodd"),t.beginPath(),(0,h.pS)(t,r),t.closePath(),t.lineWidth=1,t.strokeStyle="white",t.stroke();t.beginPath(),(0,h.kZ)(t,o.addY(-8)),(0,h.kZ)(t,o.addY(8)),(0,h.kZ)(t,o),(0,h.kZ)(t,o.addX(-8)),t.arc(o.x,o.y,8,0,2*Math.PI),t.stroke()}getOriginDelta(t){const e=this.computedSize().scale(.5),n=this.offset().mul(e);if(t===l.aP.Middle)return n.flipped;return(0,l.WS)(t).mul(e).sub(n)}moveOffset(t){const e=this.computedSize().scale(.5),n=this.offset().mul(e),o=t.mul(e);this.offset(t),this.position(this.position().add(o).sub(n))}parsePixels(t){return null===t?"":`${t}px`}parseLength(t){return null===t?"":"string"==typeof t?t:`${t}px`}applyFlex(){this.element.style.position=this.isLayoutRoot()?"absolute":"relative";const t=this.desiredSize();this.element.style.width=this.parseLength(t.x),this.element.style.height=this.parseLength(t.y),this.element.style.maxWidth=this.parseLength(this.maxWidth()),this.element.style.minWidth=this.parseLength(this.minWidth()),this.element.style.maxHeight=this.parseLength(this.maxHeight()),this.element.style.minHeight=this.parseLength(this.minHeight()),this.element.style.aspectRatio=null===this.ratio()?"":this.ratio().toString(),this.element.style.marginTop=this.parsePixels(this.margin.top()),this.element.style.marginBottom=this.parsePixels(this.margin.bottom()),this.element.style.marginLeft=this.parsePixels(this.margin.left()),this.element.style.marginRight=this.parsePixels(this.margin.right()),this.element.style.paddingTop=this.parsePixels(this.padding.top()),this.element.style.paddingBottom=this.parsePixels(this.padding.bottom()),this.element.style.paddingLeft=this.parsePixels(this.padding.left()),this.element.style.paddingRight=this.parsePixels(this.padding.right()),this.element.style.flexDirection=this.direction(),this.element.style.flexBasis=this.parseLength(this.basis()),this.element.style.flexWrap=this.wrap(),this.element.style.justifyContent=this.justifyContent(),this.element.style.alignContent=this.alignContent(),this.element.style.alignItems=this.alignItems(),this.element.style.alignSelf=this.alignSelf(),this.element.style.columnGap=this.parseLength(this.gap.x()),this.element.style.rowGap=this.parseLength(this.gap.y()),this.sizeLockCounter()>0?(this.element.style.flexGrow="0",this.element.style.flexShrink="0"):(this.element.style.flexGrow=this.grow().toString(),this.element.style.flexShrink=this.shrink().toString())}applyFont(){if(this.element.style.fontFamily=this.fontFamily.isInitial()?"":this.fontFamily(),this.element.style.fontSize=this.fontSize.isInitial()?"":`${this.fontSize()}px`,this.element.style.fontStyle=this.fontStyle.isInitial()?"":this.fontStyle(),this.lineHeight.isInitial())this.element.style.lineHeight="";else{const t=this.lineHeight();this.element.style.lineHeight="string"==typeof t?(parseFloat(t)/100).toString():`${t}px`}if(this.element.style.fontWeight=this.fontWeight.isInitial()?"":this.fontWeight().toString(),this.element.style.letterSpacing=this.letterSpacing.isInitial()?"":`${this.letterSpacing()}px`,this.element.style.textAlign=this.textAlign.isInitial()?"":this.textAlign(),this.textWrap.isInitial())this.element.style.whiteSpace="";else{const t=this.textWrap();this.element.style.whiteSpace="boolean"==typeof t?t?"normal":"nowrap":t}}dispose(){var t;super.dispose(),null==(t=this.sizeLockCounter)||t.context.dispose(),this.element&&(this.element.remove(),this.element.innerHTML=""),this.element=null,this.styles=null}hit(t){const e=t.transformAsPoint(this.localToParent().inverse());return this.cacheBBox().includes(e)?super.hit(t)??this:null}}k([(0,o.nn)(null),(0,o.td)()],w.prototype,"layout",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"maxWidth",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"maxHeight",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"minWidth",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"minHeight",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"ratio",void 0),k([(0,y.g)("margin")],w.prototype,"margin",void 0),k([(0,y.g)("padding")],w.prototype,"padding",void 0),k([(0,o.nn)("row"),(0,o.td)()],w.prototype,"direction",void 0),k([(0,o.nn)(null),(0,o.td)()],w.prototype,"basis",void 0),k([(0,o.nn)(0),(0,o.td)()],w.prototype,"grow",void 0),k([(0,o.nn)(1),(0,o.td)()],w.prototype,"shrink",void 0),k([(0,o.nn)("nowrap"),(0,o.td)()],w.prototype,"wrap",void 0),k([(0,o.nn)("start"),(0,o.td)()],w.prototype,"justifyContent",void 0),k([(0,o.nn)("normal"),(0,o.td)()],w.prototype,"alignContent",void 0),k([(0,o.nn)("stretch"),(0,o.td)()],w.prototype,"alignItems",void 0),k([(0,o.nn)("auto"),(0,o.td)()],w.prototype,"alignSelf",void 0),k([(0,o.nn)(0),(0,s.y)({x:"columnGap",y:"rowGap"})],w.prototype,"gap",void 0),k([i("font-family"),(0,o.td)()],w.prototype,"fontFamily",void 0),k([i("font-size",parseFloat),(0,o.td)()],w.prototype,"fontSize",void 0),k([i("font-style"),(0,o.td)()],w.prototype,"fontStyle",void 0),k([i("font-weight",parseInt),(0,o.td)()],w.prototype,"fontWeight",void 0),k([i("line-height",parseFloat),(0,o.td)()],w.prototype,"lineHeight",void 0),k([i("letter-spacing",(t=>"normal"===t?0:parseFloat(t))),(0,o.td)()],w.prototype,"letterSpacing",void 0),k([i("white-space",(t=>"pre"===t?"pre":"normal"===t)),(0,o.td)()],w.prototype,"textWrap",void 0),k([(0,o.nn)("inherit"),(0,o.td)()],w.prototype,"textDirection",void 0),k([i("text-align"),(0,o.td)()],w.prototype,"textAlign",void 0),k([(0,o.r_)(!1),(0,o.Oq)(!1),(0,o.td)()],w.prototype,"customX",void 0),k([(0,o.r_)(!1),(0,o.Oq)(!1),(0,o.td)()],w.prototype,"customY",void 0),k([(0,o.r_)(!1),(0,o.nn)({x:null,y:null}),(0,s.y)({x:"width",y:"height"})],w.prototype,"size",void 0),k([(0,o.Oq)(!1),(0,o.td)()],w.prototype,"customWidth",void 0),k([(0,m.C)()],w.prototype,"tweenWidth",null),k([(0,o.Oq)(!1),(0,o.td)()],w.prototype,"customHeight",void 0),k([(0,m.C)()],w.prototype,"tweenHeight",null),k([(0,p.F)()],w.prototype,"desiredSize",null),k([(0,m.C)()],w.prototype,"tweenSize",null),k([(0,s.y)("offset")],w.prototype,"offset",void 0),k([(0,o.nn)(!1),(0,o.td)()],w.prototype,"clip",void 0),k([(0,p.F)()],w.prototype,"parentTransform",null),k([(0,p.F)()],w.prototype,"anchorPosition",null),k([(0,p.F)()],w.prototype,"layoutEnabled",null),k([(0,p.F)()],w.prototype,"isLayoutRoot",null),k([(0,p.F)()],w.prototype,"computedPosition",null),k([(0,p.F)()],w.prototype,"computedSize",null),k([(0,p.F)()],w.prototype,"requestLayoutUpdate",null),k([(0,p.F)()],w.prototype,"appendedToView",null),k([(0,p.F)()],w.prototype,"updateLayout",null),k([(0,p.F)()],w.prototype,"layoutChildren",null),k([(0,p.F)()],w.prototype,"requestFontUpdate",null),k([(0,p.F)()],w.prototype,"applyFlex",null),k([(0,p.F)()],w.prototype,"applyFont",null)},20092:(t,e,n)=>{"use strict";n.d(e,{N:()=>T});var o=n(93091),s=n(88104),r=n(46350),i=n(43595),p=n(29797),a=n(74741),c=n(23357),l=n(49111),u=n(3163);var m=n(97074),d=n(74534),h=n(13170),y=n(67292),f=n(11258),k=n(97140);const w={invert:{name:"invert"},sepia:{name:"sepia"},grayscale:{name:"grayscale"},brightness:{name:"brightness",default:1},contrast:{name:"contrast",default:1},saturate:{name:"saturate",default:1},hue:{name:"hue-rotate",unit:"deg",scale:1},blur:{name:"blur",transform:!0,unit:"px",scale:1}};class g{get name(){return this.props.name}get default(){return this.props.default}constructor(t){this.props={name:"invert",default:0,unit:"%",scale:100,transform:!1,...t,value:t.value??t.default??0},this.value=(0,k.g)(this.props.value,h.UI,this)}isActive(){return this.value()!==this.props.default}serialize(t){let e=this.value();return this.props.transform&&(e=(0,a.X)(e,t)),`${this.props.name}(${e*this.props.scale}${this.props.unit})`}}var M=n(5376),D=n(5788),_=n(16249),X=n(93214);class x extends _.V{constructor(t,e){var n;super(t,h.o0,e),n=this;for(const o in w){const t=w[o];Object.defineProperty(this.invokable,o,{value:function(e,o,s){var r,i,p;if(void 0===s&&(s=m.qb),void 0===e)return(null==(i=n.get())||null==(p=i.find((e=>e.name===t.name)))?void 0:p.value())??t.default??0;let a=null==(r=n.get())?void 0:r.find((e=>e.name===t.name));return a||(a=new g(t),n.set([...n.get(),a])),void 0===o?(a.value(e),n.owner):a.value(e,o,s)}})}}*doTween(t,e,n){const o=this.get(),s=(0,X.P)(t)?t():t;if(function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n].name!==e[n].name)return!1;return!0}(o,s))return yield*(0,M.$)(...o.map(((t,o)=>t.value(s[o].value(),e,n)))),void this.set(s);for(const p of s)p.value(p.default);const r=s.map((t=>t.value.context.raw())),i=o.length>0&&s.length>0?e/2:e;o.length>0&&(yield*(0,M.$)(...o.map((t=>t.value(t.default,i,n))))),this.set(s),s.length>0&&(yield*(0,M.$)(...s.map(((t,e)=>t.value(r[e],i,n)))))}}var v=n(76062),C=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class T{getAbsolutePosition(){const t=this.localToWorld();return new p.F(t.m41,t.m42)}setAbsolutePosition(t){(0,X.P)(t)?this.position((()=>t().transformAsPoint(this.worldToParent()))):this.position(t.transformAsPoint(this.worldToParent()))}getAbsoluteRotation(){const t=this.localToWorld();return 180*Math.atan2(t.m12,t.m11)/Math.PI}setAbsoluteRotation(t){(0,X.P)(t)?this.rotation((()=>(0,a.$)(t(),this.worldToParent()))):this.rotation((0,a.$)(t,this.worldToParent()))}getAbsoluteScale(){const t=this.localToWorld();return new p.F(p.F.magnitude(t.m11,t.m12),p.F.magnitude(t.m21,t.m22))}setAbsoluteScale(t){(0,X.P)(t)?this.scale((()=>this.getRelativeScale(t()))):this.scale(this.getRelativeScale(t))}getRelativeScale(t){var e;const n=(null==(e=this.parent())?void 0:e.absoluteScale())??p.F.one;return t.div(n)}*tweenCompositeOperation(t,e,n){const o=(0,X.P)(t)?t():t;"source-over"===o?(yield*this.compositeOverride(1,e,n),this.compositeOverride(0),this.compositeOperation(o)):(this.compositeOperation(o),this.compositeOverride(1),yield*this.compositeOverride(0,e,n))}absoluteOpacity(){var t;return((null==(t=this.parent())?void 0:t.absoluteOpacity())??1)*this.opacity()}hasFilters(){return!!this.filters().find((t=>t.isActive()))}hasShadow(){return!!this.shadowColor()&&(this.shadowBlur()>0||0!==this.shadowOffset.x()||0!==this.shadowOffset.y())}filterString(){let t="";const e=this.compositeToWorld();for(const n of this.filters())n.isActive()&&(t+=" "+n.serialize(e));return t}setChildren(t){this.spawner(t)}getChildren(){return this.spawnChildren(),this.realChildren}spawnChildren(){const t=this.spawner();if((0,X.P)(this.spawner.context.raw())){const e=new Set;for(const n of t){const t=n.parent.context.raw();if(t&&t!==this)throw new l.t("The spawner returned a node that already has a parent","A spawner should either create entirely new nodes or reuse nodes from a pool.");n.parent(this),e.add(n.key)}for(const t of this.realChildren)e.has(t.key)||t.parent(null);this.realChildren=t}else this.realChildren=t}sortedChildren(){return[...this.children()].sort(((t,e)=>Math.sign(t.zIndex()-e.zIndex())))}constructor(t){let{children:e,spawner:n,key:s,...r}=t;this.compositeOverride=(0,k.g)(0),this.stateStack=[],this.realChildren=[],this.parent=(0,k.g)(null),this.properties=(0,o.RG)(this);const i=(0,u.$r)();this.key=i.registerNode(this,s),this.view2D=i.getView(),this.creationStack=(new Error).stack,(0,o.Xd)(this,r),this.add(e),n&&this.children(n)}localToWorld(){const t=this.parent();return t?t.localToWorld().multiply(this.localToParent()):this.localToParent()}worldToLocal(){return this.localToWorld().inverse()}worldToParent(){var t;return(null==(t=this.parent())?void 0:t.worldToLocal())??new DOMMatrix}localToParent(){const t=new DOMMatrix;return t.translateSelf(this.position.x(),this.position.y()),t.rotateSelf(0,0,this.rotation()),t.scaleSelf(this.scale.x(),this.scale.y()),t}compositeToWorld(){var t;return(null==(t=this.compositeRoot())?void 0:t.localToWorld())??new DOMMatrix}compositeRoot(){var t;return this.composite()?this:(null==(t=this.parent())?void 0:t.compositeRoot())??null}compositeToLocal(){const t=this.compositeRoot();if(t){const e=this.worldToLocal();return e.m44=1,t.localToWorld().multiply(e)}return new DOMMatrix}view(){return this.view2D}add(t){return this.insert(t,1/0)}insert(t,e){void 0===e&&(e=0);const n=Array.isArray(t)?t:[t];if(0===n.length)return this;const o=this.children(),s=o.slice(0,e);for(const r of n)r instanceof T&&(s.push(r),r.remove(),r.parent(this));return s.push(...o.slice(e)),this.children(s),this}remove(){const t=this.parent();return null===t||(t.children(t.children().filter((t=>t!==this))),this.parent(null)),this}move(t){void 0===t&&(t=1);const e=this.parent();if(0===t||!e)return this;const n=e.children(),o=[];if(t>0)for(let s=0;s<n.length;s++){const e=n[s];if(e===this){const e=s+t;for(;s<e&&s+1<n.length;s++)o[s]=n[s+1]}o[s]=e}else for(let s=n.length-1;s>=0;s--){const e=n[s];if(e===this){const e=s+t;for(;s>e&&s>0;s--)o[s]=n[s-1]}o[s]=e}return e.children(o),this}moveUp(){return this.move(1)}moveDown(){return this.move(-1)}moveToTop(){return this.move(1/0)}moveToBottom(){return this.move(-1/0)}moveTo(t){const e=this.parent();if(!e)return this;const n=t-e.children().indexOf(this);return this.move(n)}moveBelow(t,e){void 0===e&&(e=!1);const n=this.parent();if(!n)return this;if(t.parent()!==n)return(0,u.wL)().error("Cannot position nodes relative to each other if they don't belong to the same parent."),this;const o=n.children(),s=o.indexOf(this),r=o.indexOf(t);if(!e&&s<r)return this;const i=r-s-1;return this.move(i)}moveAbove(t,e){void 0===e&&(e=!1);const n=this.parent();if(!n)return this;if(t.parent()!==n)return(0,u.wL)().error("Cannot position nodes relative to each other if they don't belong to the same parent."),this;const o=n.children(),s=o.indexOf(this),r=o.indexOf(t);if(!e&&s>r)return this;const i=r-s+1;return this.move(i)}reparent(t){const e=this.absolutePosition(),n=this.absoluteRotation(),o=this.absoluteScale();t.add(this),this.absolutePosition(e),this.absoluteRotation(n),this.absoluteScale(o)}removeChildren(){for(const t of this.children())t.remove()}dispose(){this.stateStack=[];for(const{signal:t}of this)null==t||t.context.dispose()}clone(t){void 0===t&&(t={});const e={...t};(0,X.P)(this.spawner.context.raw())?e.spawner=this.spawner.context.raw():this.children().length>0&&(e.children??(e.children=this.children().map((t=>t.clone()))));for(const{key:n,meta:o,signal:s}of this)if(o.cloneable&&!(n in e))if(o.compound)for(const[t,r]of o.compoundEntries)r in e||(e[r]=s[t].context.raw());else e[n]=s.context.raw();return this.instantiate(e)}snapshotClone(t){void 0===t&&(t={});const e={...this.getState(),...t};return this.children().length>0&&(e.children??(e.children=this.children().map((t=>t.snapshotClone())))),this.instantiate(e)}reactiveClone(t){void 0===t&&(t={});const e={...t};this.children().length>0&&(e.children??(e.children=this.children().map((t=>t.reactiveClone()))));for(const{key:n,meta:o,signal:s}of this)o.cloneable&&!(n in e)&&(e[n]=()=>s());return this.instantiate(e)}instantiate(t){return void 0===t&&(t={}),new this.constructor(t)}requiresCache(){return this.cache()||this.opacity()<1||"source-over"!==this.compositeOperation()||this.hasFilters()||this.hasShadow()}cacheCanvas(){const t=document.createElement("canvas").getContext("2d");if(!t)throw new Error("Could not create a cache canvas");return t}cachedCanvas(){const t=this.cacheCanvas(),e=this.worldSpaceCacheBBox(),n=this.localToWorld();return t.canvas.width=e.width,t.canvas.height=e.height,t.setTransform(n.a,n.b,n.c,n.d,n.e-e.x,n.f-e.y),this.draw(t),t}getCacheBBox(){return new c.b}cacheBBox(){const t=this.getCacheBBox(),e=this.children();if(0===e.length)return t;const n=t.corners;for(const o of e){const t=o.fullCacheBBox(),e=o.localToParent();n.push(...t.corners.map((t=>t.transformAsPoint(e))))}return c.b.fromPoints(...n)}fullCacheBBox(){const t=this.compositeToLocal(),e=this.shadowOffset().transform(t),n=(0,a.X)(this.shadowBlur(),t),o=this.cacheBBox().expand(2*this.filters.blur()+n);return e.x<0?(o.x+=e.x,o.width-=e.x):o.width+=e.x,e.y<0?(o.y+=e.y,o.height-=e.y):o.height+=e.y,o}worldSpaceCacheBBox(){const t=c.b.fromSizeCentered(this.view().size()),e=c.b.fromPoints(...t.transformCorners(this.view().localToWorld())),n=c.b.fromPoints(...this.cacheBBox().transformCorners(this.localToWorld()));return e.intersection(n).pixelPerfect}setupDrawFromCache(t){if(t.globalCompositeOperation=this.compositeOperation(),t.globalAlpha*=this.opacity(),this.hasFilters()&&(t.filter=this.filterString()),this.hasShadow()){const e=this.compositeToWorld(),n=this.shadowOffset().transform(e),o=(0,a.X)(this.shadowBlur(),e);t.shadowColor=this.shadowColor().serialize(),t.shadowBlur=o,t.shadowOffsetX=n.x,t.shadowOffsetY=n.y}}render(t){if(!(this.absoluteOpacity()<=0)){if(t.save(),this.transformContext(t),this.requiresCache()){const e=this.worldSpaceCacheBBox();if(0!==e.width&&0!==e.height){this.setupDrawFromCache(t);const n=this.cachedCanvas(),o=this.compositeOverride(),s=this.worldToLocal();t.transform(s.a,s.b,s.c,s.d,s.e,s.f),t.drawImage(n.canvas,e.position.x,e.position.y),o>0&&(t.save(),t.globalAlpha*=o,t.globalCompositeOperation="source-over",t.drawImage(n.canvas,e.position.x,e.position.y),t.restore())}}else this.draw(t);t.restore()}}draw(t){this.drawChildren(t)}drawChildren(t){for(const e of this.sortedChildren())e.render(t)}drawOverlay(t,e){const n=this.cacheBBox().transformCorners(e),o=this.getCacheBBox().transformCorners(e);t.strokeStyle="white",t.lineWidth=1,t.beginPath(),(0,f.pS)(t,n),t.closePath(),t.stroke(),t.strokeStyle="blue",t.beginPath(),(0,f.pS)(t,o),t.closePath(),t.stroke()}transformContext(t){const e=this.localToParent();t.transform(e.a,e.b,e.c,e.d,e.e,e.f)}hit(t){let e=null;const n=t.transformAsPoint(this.localToParent().inverse());for(const o of this.children().reverse())if(e=o.hit(n),e)break;return e}collectAsyncResources(){for(const t of this.children())t.collectAsyncResources()}async toPromise(){let t=v.k.consumePromises();do{await Promise.all(t.map((t=>t.promise))),this.collectAsyncResources(),t=v.k.consumePromises()}while(t.length>0);return this}getState(){const t={};for(const{key:e,meta:n,signal:o}of this)n.cloneable&&!(e in t)&&(t[e]=o());return t}applyState(t){for(const e in t){const n=this.signalByKey(e);n&&n(t[e])}}save(){this.stateStack.push(this.getState())}restore(t,e){void 0===e&&(e=m.qb);const n=this.stateStack.pop();if(void 0===n)return;const o=this.getState();for(const s in n)o[s]===n[s]&&delete n[s];return(0,d.i)(t,(t=>{const s=e(t),r=Object.keys(n).reduce(((t,e)=>(t[e]=(0,h.o0)(o[e],n[e],s),t)),{});this.applyState(r)}))}*[Symbol.iterator](){for(const t in this.properties){const e=this.properties[t],n=this.signalByKey(t);yield{meta:e,signal:n,key:t}}}signalByKey(t){return this[t]}}C([(0,s.y)()],T.prototype,"position",void 0),C([(0,o.YS)(p.F),(0,o.r_)(!1),(0,o.td)()],T.prototype,"absolutePosition",void 0),C([(0,o.nn)(0),(0,o.td)()],T.prototype,"rotation",void 0),C([(0,o.r_)(!1),(0,o.td)()],T.prototype,"absoluteRotation",void 0),C([(0,o.nn)(p.F.one),(0,s.y)("scale")],T.prototype,"scale",void 0),C([(0,o.YS)(p.F),(0,o.r_)(!1),(0,o.td)()],T.prototype,"absoluteScale",void 0),C([(0,o.nn)(0),(0,o.td)()],T.prototype,"zIndex",void 0),C([(0,o.nn)(!1),(0,o.td)()],T.prototype,"cache",void 0),C([(0,o.nn)(!1),(0,o.td)()],T.prototype,"composite",void 0),C([(0,o.nn)("source-over"),(0,o.td)()],T.prototype,"compositeOperation",void 0),C([(0,y.C)()],T.prototype,"tweenCompositeOperation",null),C([(0,o.nn)(1),(0,o.td)()],T.prototype,"opacity",void 0),C([(0,r.F)()],T.prototype,"absoluteOpacity",null),C([(t,e)=>{const n=(0,o.J)(t,e);(0,D.f)(t,(t=>{t[e]=new x(n.default??[],t).toSignal()}))}],T.prototype,"filters",void 0),C([(0,o.nn)("#0000"),(0,i.j)()],T.prototype,"shadowColor",void 0),C([(0,o.nn)(0),(0,o.td)()],T.prototype,"shadowBlur",void 0),C([(0,s.y)("shadowOffset")],T.prototype,"shadowOffset",void 0),C([(0,r.F)()],T.prototype,"hasFilters",null),C([(0,r.F)()],T.prototype,"hasShadow",null),C([(0,r.F)()],T.prototype,"filterString",null),C([(0,o.Oq)(!1),(0,o.r_)(!1),(0,o.nn)([]),(0,o.td)()],T.prototype,"spawner",void 0),C([(0,o.Oq)(!1),(0,o.r_)(!1),(0,o.td)()],T.prototype,"children",void 0),C([(0,r.F)()],T.prototype,"spawnChildren",null),C([(0,r.F)()],T.prototype,"sortedChildren",null),C([(0,r.F)()],T.prototype,"localToWorld",null),C([(0,r.F)()],T.prototype,"worldToLocal",null),C([(0,r.F)()],T.prototype,"worldToParent",null),C([(0,r.F)()],T.prototype,"localToParent",null),C([(0,r.F)()],T.prototype,"compositeToWorld",null),C([(0,r.F)()],T.prototype,"compositeRoot",null),C([(0,r.F)()],T.prototype,"compositeToLocal",null),C([(0,r.F)()],T.prototype,"cacheCanvas",null),C([(0,r.F)()],T.prototype,"cachedCanvas",null),C([(0,r.F)()],T.prototype,"cacheBBox",null),C([(0,r.F)()],T.prototype,"fullCacheBBox",null),C([(0,r.F)()],T.prototype,"worldSpaceCacheBBox",null),T.prototype.isClass=!0},15498:(t,e,n)=>{"use strict";n.d(e,{U:()=>c});var o=n(23357),s=n(13730),r=n(11258),i=n(93091),p=n(53693),a=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class c extends s.b{constructor(t){super(t)}getPath(){const t=new Path2D,e=this.radius(),n=this.smoothCorners(),s=this.cornerSharpness(),i=o.b.fromSizeCentered(this.size());return(0,r.Zy)(t,i,e,n,s),t}getCacheBBox(){return super.getCacheBBox().expand(this.rippleSize())}getRipplePath(){const t=new Path2D,e=this.rippleSize(),n=this.radius().addScalar(e),s=this.smoothCorners(),i=this.cornerSharpness(),p=o.b.fromSizeCentered(this.size()).expand(e);return(0,r.Zy)(t,p,n,s,i),t}}a([(0,p.g)("radius")],c.prototype,"radius",void 0),a([(0,i.nn)(!1),(0,i.td)()],c.prototype,"smoothCorners",void 0),a([(0,i.nn)(.6),(0,i.td)()],c.prototype,"cornerSharpness",void 0)},13730:(t,e,n)=>{"use strict";n.d(e,{b:()=>h});var o=n(93091),s=n(46350),r=n(70989),i=n(67292),p=n(97074),a=n(13170),c=n(11258),l=n(30204);function u(){return(t,e)=>{(0,o.td)()(t,e),(0,o.E2)(c.av)(t,e),(0,o.JI)(l.I.lerp)(t,e),(0,o.nn)(null)(t,e)}}var m=n(97140),d=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class h extends r.A{rippleSize(){return(0,p.ad)(this.rippleStrength(),0,50)}constructor(t){super(t),this.rippleStrength=(0,m.g)(0)}applyText(t){t.direction=this.textDirection(),this.element.dir=this.textDirection()}applyStyle(t){t.fillStyle=(0,c.ho)(this.fill(),t),t.strokeStyle=(0,c.ho)(this.stroke(),t),t.lineWidth=this.lineWidth(),t.lineJoin=this.lineJoin(),t.lineCap=this.lineCap(),t.setLineDash(this.lineDash()),t.lineDashOffset=this.lineDashOffset(),this.antialiased()||(t.filter="url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxmaWx0ZXIgaWQ9ImZpbHRlciIgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj48ZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVGdW5jUiB0eXBlPSJpZGVudGl0eSIvPjxmZUZ1bmNHIHR5cGU9ImlkZW50aXR5Ii8+PGZlRnVuY0IgdHlwZT0iaWRlbnRpdHkiLz48ZmVGdW5jQSB0eXBlPSJkaXNjcmV0ZSIgdGFibGVWYWx1ZXM9IjAgMSIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj48L2ZpbHRlcj48L3N2Zz4=#filter)")}draw(t){this.drawShape(t),this.clip()&&t.clip(this.getPath()),this.drawChildren(t)}drawShape(t){const e=this.getPath(),n=this.lineWidth()>0&&null!==this.stroke(),o=null!==this.fill();t.save(),this.applyStyle(t),this.drawRipple(t),this.strokeFirst()?(n&&t.stroke(e),o&&t.fill(e)):(o&&t.fill(e),n&&t.stroke(e)),t.restore()}getCacheBBox(){return super.getCacheBBox().expand(this.lineWidth()/2)}getPath(){return new Path2D}getRipplePath(){return new Path2D}drawRipple(t){const e=this.rippleStrength();if(e>0){const n=this.getRipplePath();t.save(),t.globalAlpha*=(0,a.UI)(.54,0,e),t.fill(n),t.restore()}}*ripple(t){void 0===t&&(t=1),this.rippleStrength(0),yield*this.rippleStrength(1,t,p.GE),this.rippleStrength(0)}}d([u()],h.prototype,"fill",void 0),d([u()],h.prototype,"stroke",void 0),d([(0,o.nn)(!1),(0,o.td)()],h.prototype,"strokeFirst",void 0),d([(0,o.nn)(0),(0,o.td)()],h.prototype,"lineWidth",void 0),d([(0,o.nn)("miter"),(0,o.td)()],h.prototype,"lineJoin",void 0),d([(0,o.nn)("butt"),(0,o.td)()],h.prototype,"lineCap",void 0),d([(0,o.nn)([]),(0,o.td)()],h.prototype,"lineDash",void 0),d([(0,o.nn)(0),(0,o.td)()],h.prototype,"lineDashOffset",void 0),d([(0,o.nn)(!0),(0,o.td)()],h.prototype,"antialiased",void 0),d([(0,s.F)()],h.prototype,"rippleSize",null),d([(0,s.F)()],h.prototype,"getPath",null),d([(0,i.C)()],h.prototype,"ripple",null)},70419:(t,e,n)=>{"use strict";n.d(e,{h:()=>a});var o=n(15498),s=n(93091),r=n(88733),i=n(79116),p=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class a extends o.U{constructor(t){super({composite:!0,fontFamily:"Roboto",fontSize:48,lineHeight:"120%",textWrap:!1,fontStyle:"normal",...t}),this.view2D=this,a.shadowRoot.append(this.element),this.applyFlex()}transformContext(){}dispose(){this.removeChildren(),super.dispose()}render(t){this.computedSize(),this.computedPosition(),super.render(t)}requestLayoutUpdate(){this.updateLayout()}view(){return this}}p([(0,s.nn)(r.q.Paused),(0,s.td)()],a.prototype,"playbackState",void 0),p([(0,i.V)((()=>{const t="motion-canvas-2d-frame";let e=document.querySelector(`#${t}`);return e||(e=document.createElement("div"),e.id=t,e.style.position="absolute",e.style.pointerEvents="none",e.style.top="0",e.style.left="0",e.style.opacity="0",e.style.overflow="hidden",document.body.prepend(e)),e.shadowRoot??e.attachShadow({mode:"open"})}))],a,"shadowRoot",void 0)},43595:(t,e,n)=>{"use strict";n.d(e,{j:()=>r});var o=n(30204),s=n(93091);function r(){return(t,e)=>{(0,s.td)()(t,e),(0,s.YS)(o.I)(t,e)}}},37060:(t,e,n)=>{"use strict";n.d(e,{I:()=>c});var o=n(3163),s=n(93091),r=n(5788),i=n(13170),p=n(46096),a=n(14455);function c(t){return(e,n)=>{const c=(0,s.J)(e,n);c.compound=!0,c.compoundEntries=Object.entries(t),(0,r.f)(e,(e=>{if(!c.parser)return void(0,o.wL)().error(`Missing parser decorator for "${n.toString()}"`);const s=new p.N(Object.keys(t),c.parser,c.default,c.interpolationFunction??i.o0,e);(0,a.I)(s,c.parser,e,n);const r=s.toSignal();for(const[t,n]of c.compoundEntries)(0,a.I)(r[t].context,void 0,e,n);e[n]=r}))}}},46350:(t,e,n)=>{"use strict";n.d(e,{F:()=>r});var o=n(5788),s=n(73662);function r(){return(t,e)=>{(0,o.f)(t,(t=>{const n=Object.getPrototypeOf(t)[e];t[e]=(0,s.D)(n.bind(t),t)}))}}},5788:(t,e,n)=>{"use strict";n.d(e,{f:()=>s,j:()=>r});const o=Symbol.for("@motion-canvas/2d/decorators/initializers");function s(t,e){if(t[o]){if(t[o]&&!Object.prototype.hasOwnProperty.call(t,o)){const e=Object.getPrototypeOf(t);t[o]=[...e[o]]}}else t[o]=[];t[o].push(e)}function r(t,e){if(t[o])try{t[o].forEach((n=>n(t,e)))}catch(n){throw n.inspect??(n.inspect=t.key),n}}},93091:(t,e,n)=>{"use strict";n.d(e,{E2:()=>k,J:()=>u,JI:()=>f,Oq:()=>M,RG:()=>m,Xd:()=>d,YS:()=>w,nn:()=>y,r_:()=>g,td:()=>h});var o=n(13170),s=n(5788),r=n(15688),i=n(3163),p=n(14455),a=n(16249);const c=Symbol.for("@motion-canvas/2d/decorators/properties");function l(t,e){var n;return(null==(n=t[c])?void 0:n[e])??null}function u(t,e){let n;return t[c]?t[c]&&!Object.prototype.hasOwnProperty.call(t,c)?t[c]=n=Object.fromEntries(Object.entries(t[c]).map((t=>{let[e,n]=t;return[e,{...n}]}))):n=t[c]:t[c]=n={},n[e]??(n[e]={cloneable:!0,inspectable:!0,compoundEntries:[]}),n[e]}function m(t){return t&&"object"==typeof t?t[c]??{}:{}}function d(t,e){(0,s.j)(t);for(const[n,o]of Object.entries(m(t))){const s=t[n];if(s.reset(),void 0!==e[n]&&s(e[n]),void 0!==o.compoundEntries)for(const[t,n]of o.compoundEntries)n in e&&s[t](e[n])}}function h(){return(t,e)=>{const n=u(t,e);(0,s.f)(t,(t=>{var s;const i=null==(s=t[`getDefault${(0,r.k)(e)}`])?void 0:s.bind(t),c=new a.V(i??n.default,n.interpolationFunction??o.o0,t);(0,p.I)(c,n.parser,t,e),t[e]=c.toSignal()}))}}function y(t){return(e,n)=>{const o=l(e,n);o?o.default=t:(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function f(t){return(e,n)=>{const o=l(e,n);o?o.interpolationFunction=t:(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function k(t){return(e,n)=>{const o=l(e,n);o?o.parser=t:(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function w(t){return(e,n)=>{const o=l(e,n);o?(o.parser=e=>new t(e),"lerp"in t&&(o.interpolationFunction??(o.interpolationFunction=t.lerp))):(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function g(t){return void 0===t&&(t=!0),(e,n)=>{const o=l(e,n);o?o.cloneable=t:(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}function M(t){return void 0===t&&(t=!0),(e,n)=>{const o=l(e,n);o?o.inspectable=t:(0,i.wL)().error(`Missing property decorator for "${n.toString()}"`)}}},53693:(t,e,n)=>{"use strict";n.d(e,{g:()=>i});var o=n(43188),s=n(37060),r=n(93091);function i(t){return(e,n)=>{(0,s.I)({top:t?`${t}Top`:"top",right:t?`${t}Right`:"right",bottom:t?`${t}Bottom`:"bottom",left:t?`${t}Left`:"left"})(e,n),(0,r.YS)(o.K)(e,n)}}},88104:(t,e,n)=>{"use strict";n.d(e,{y:()=>i});var o=n(29797),s=n(37060),r=n(93091);function i(t){return(e,n)=>{(0,s.I)("object"==typeof t?t:{x:t?`${t}X`:"x",y:t?`${t}Y`:"y"})(e,n),(0,r.YS)(o.F)(e,n)}}},15914:(t,e,n)=>{"use strict";n.d(e,{r:()=>T});var o=n(92673),s=n(82344),r=n(11726);var i=n(80638),p=n(5881),a=n(97140);class c{constructor(t){this.scene=t,this.signals={},this.variables={},this.handleReset=()=>{this.signals={}},t.onReset.subscribe(this.handleReset)}get(t,e){var n;return(n=this.signals)[t]??(n[t]=(0,a.g)(this.variables[t]??e)),()=>this.signals[t]()}updateSignals(t){this.variables=t,Object.keys(t).map((e=>{e in this.signals&&this.signals[e](t[e])}))}}var l,u=n(1323),m=n(96881),d=n(42075),h=n(67292),y=n(3163),f=n(97715);!function(t){t[t.BeforeRender=0]="BeforeRender",t[t.BeginRender=1]="BeginRender",t[t.FinishRender=2]="FinishRender",t[t.AfterRender=3]="AfterRender"}(l||(l={}));class k{get onBeforeRender(){return this.beforeRender.subscribable}get onBeginRender(){return this.beginRender.subscribable}get onFinishRender(){return this.finishRender.subscribable}get onAfterRender(){return this.afterRender.subscribable}constructor(t){this.scene=t,this.beforeRender=new m.p,this.beginRender=new m.p,this.finishRender=new m.p,this.afterRender=new m.p,this.scene.onRenderLifecycle.subscribe((t=>{let[e,n]=t;switch(e){case l.BeforeRender:return this.beforeRender.dispatch(n);case l.BeginRender:return this.beginRender.dispatch(n);case l.FinishRender:return this.finishRender.dispatch(n);case l.AfterRender:return this.afterRender.dispatch(n)}})),this.scene.onReset.subscribe((()=>{this.beforeRender.clear(),this.beginRender.clear(),this.finishRender.clear(),this.afterRender.clear()}))}}var w,g=n(23357);!function(t){t[t.Initial=0]="Initial",t[t.AfterTransitionIn=1]="AfterTransitionIn",t[t.CanTransitionOut=2]="CanTransitionOut",t[t.Finished=3]="Finished"}(w||(w={}));var M=n(76062),D=n(88733);class _{get onChanged(){return this.slides.subscribable}constructor(t){this.scene=t,this.slides=new u.G([]),this.lookup=new Map,this.collisionLookup=new Set,this.current=null,this.canResume=!1,this.waitsForId=null,this.targetId=null,this.handleReload=()=>{this.lookup.clear(),this.collisionLookup.clear(),this.current=null,this.waitsForId=null,this.targetId=null},this.handleReset=()=>{this.collisionLookup.clear(),this.current=null,this.waitsForId=null},this.handleRecalculated=()=>{this.slides.current=[...this.lookup.values()]},this.scene.onReloaded.subscribe(this.handleReload),this.scene.onReset.subscribe(this.handleReset),this.scene.onRecalculated.subscribe(this.handleRecalculated)}setTarget(t){this.targetId=t}resume(){this.canResume=!0}isWaitingFor(t){return this.waitsForId===t}isWaiting(){return null!==this.waitsForId}didHappen(t){if(null===this.current)return!1;for(const n of this.lookup.keys()){var e;if(n===t)return!0;if(n===(null==(e=this.current)?void 0:e.id))return!1}return!1}getCurrent(){return this.current}register(t,e){if(null!==this.waitsForId)throw new Error(`The animation already waits for a slide: ${this.waitsForId}.`);const n=this.toId(t);this.scene.playback.state!==D.q.Presenting&&(this.lookup.has(n)||this.lookup.set(n,{id:n,name:t,time:e,scene:this.scene,stack:(new Error).stack}),this.collisionLookup.has(t)?this.scene.logger.warn({message:`A slide named "${t}" already exists.`,stack:(new Error).stack}):this.collisionLookup.add(t)),this.waitsForId=n,this.current=this.lookup.get(n)??null,this.canResume=!1}shouldWait(t){const e=this.toId(t);if(this.waitsForId!==e)throw new Error(`The animation waits for a different slide: ${this.waitsForId}.`);if(!this.lookup.get(e))throw new Error(`Could not find the "${t}" slide.`);let n=this.canResume;return this.scene.playback.state!==D.q.Presenting&&(n=e!==this.targetId),n&&(this.waitsForId=null),!n}toId(t){return`${this.scene.name}:${t}`}}class X{get firstFrame(){return this.cache.current.firstFrame}get lastFrame(){return this.firstFrame+this.cache.current.duration}get onCacheChanged(){return this.cache.subscribable}get onReloaded(){return this.reloaded.subscribable}get onRecalculated(){return this.recalculated.subscribable}get onThreadChanged(){return this.thread.subscribable}get onRenderLifecycle(){return this.renderLifecycle.subscribable}get onReset(){return this.afterReset.subscribable}get LifecycleEvents(){return this.logger.warn("LifecycleEvents is deprecated. Use lifecycleEvents instead."),this.lifecycleEvents}get previous(){return this.previousScene}constructor(t){this.cache=new u.G({firstFrame:0,transitionDuration:0,duration:0,lastFrame:0}),this.reloaded=new m.p,this.recalculated=new m.p,this.thread=new u.G(null),this.renderLifecycle=new m.p,this.afterReset=new m.p,this.lifecycleEvents=new k(this),this.previousScene=null,this.runner=null,this.state=w.Initial,this.cached=!1,this.counters={},this.name=t.name,this.size=t.size,this.resolutionScale=t.resolutionScale,this.logger=t.logger,this.playback=t.playback,this.meta=t.meta,this.runnerFactory=t.config,this.creationStack=t.stack,(0,d.G)(this.runnerFactory,(0,h.C)(this.name)),this.timeEvents=new t.timeEventsClass(this),this.variables=new c(this),this.slides=new _(this),this.random=new r.k(this.meta.seed.get())}update(){}async render(t){let e=M.k.consumePromises(),n=0;do{n++,await Promise.all(e.map((t=>t.promise))),t.save();const o=g.b.fromSizeCentered(this.getSize());t.clearRect(o.x,o.y,o.width,o.height),this.execute((()=>this.draw(t))),t.restore(),e=M.k.consumePromises()}while(e.length>0&&n<10);n>1&&this.logger.debug(`render iterations: ${n}`)}reload(t){let{config:e,size:n,stack:o,resolutionScale:s}=void 0===t?{}:t;e&&(this.runnerFactory=e),n&&(this.size=n),s&&(this.resolutionScale=s),o&&(this.creationStack=o),this.cached=!1,this.reloaded.dispatch()}async recalculate(t){const e=this.cache.current;if(e.firstFrame=this.playback.frame,e.lastFrame=e.firstFrame+e.duration,this.isCached())return t(e.lastFrame),void(this.cache.current={...e});for(e.transitionDuration=-1,await this.reset();!this.canTransitionOut();)e.transitionDuration<0&&this.state===w.AfterTransitionIn&&(e.transitionDuration=this.playback.frame-e.firstFrame),t(this.playback.frame+1),await this.next();-1===e.transitionDuration&&(e.transitionDuration=0),e.lastFrame=this.playback.frame,e.duration=e.lastFrame-e.firstFrame,await new Promise((t=>setTimeout(t,0))),this.cached=!0,this.cache.current={...e},this.recalculated.dispatch()}async next(){if(!this.runner)return;let t=this.execute((()=>this.runner.next()));for(this.update();t.value;){if((0,i.x)(t.value)){const e=await t.value.toPromise();t=this.execute((()=>this.runner.next(e)))}else if((0,p.t)(t.value)){const e=await t.value;t=this.execute((()=>this.runner.next(e)))}else this.logger.warn({message:"Invalid value yielded by the scene.",object:t.value}),t=this.execute((()=>this.runner.next(t.value)));this.update()}const e=M.k.consumePromises();var n;e.length>0&&(await Promise.all(e.map((t=>t.promise))),this.logger.error({message:"Tried to access an asynchronous property before the node was ready. Make sure to yield the node before accessing the property.",stack:e[0].stack,inspect:(null==(n=e[0].owner)?void 0:n.key)??void 0}));t.done&&(this.state=w.Finished)}async reset(t){void 0===t&&(t=null),this.counters={},this.previousScene=t,this.random=new r.k(this.meta.seed.get()),this.runner=(0,p.C)((()=>this.runnerFactory(this.getView())),(t=>{this.thread.current=t})),this.state=w.AfterTransitionIn,this.afterReset.dispatch(),await this.next()}getSize(){return this.size}isAfterTransitionIn(){return this.state===w.AfterTransitionIn}canTransitionOut(){return this.state===w.CanTransitionOut||this.state===w.Finished}isFinished(){return this.state===w.Finished}enterInitial(){this.state===w.AfterTransitionIn?this.state=w.Initial:this.logger.warn(`Scene ${this.name} entered initial in an unexpected state: ${this.state}`)}enterAfterTransitionIn(){this.state===w.Initial?this.state=w.AfterTransitionIn:this.logger.warn(`Scene ${this.name} transitioned in an unexpected state: ${this.state}`)}enterCanTransitionOut(){this.state===w.AfterTransitionIn||this.state===w.Initial?this.state=w.CanTransitionOut:this.logger.warn(`Scene ${this.name} was marked as finished in an unexpected state: ${this.state}`)}isCached(){return this.cached}execute(t){let e;(0,y.DO)(this),(0,f.wA)(this.playback);try{e=t()}finally{(0,f.Mh)(this.playback),(0,y.ug)(this)}return e}}var x=n(29797),v=n(70419);class C extends X{constructor(t){super(t),this.view=null,this.registeredNodes={},this.nodeCounters={},this.recreateView()}getView(){return this.view}next(){var t;return null==(t=this.getView())||t.playbackState(this.playback.state),super.next()}draw(t){t.save(),this.renderLifecycle.dispatch([l.BeforeRender,t]),t.save(),this.renderLifecycle.dispatch([l.BeginRender,t]),this.getView().playbackState(this.playback.state),this.getView().render(t),this.renderLifecycle.dispatch([l.FinishRender,t]),t.restore(),this.renderLifecycle.dispatch([l.AfterRender,t]),t.restore()}reset(t){for(const n in this.registeredNodes)try{this.registeredNodes[n].dispose()}catch(e){this.logger.error(e)}return this.registeredNodes={},this.nodeCounters={},this.recreateView(),super.reset(t)}inspectPosition(t,e){return this.execute((()=>{var n;return(null==(n=this.getView().hit(new x.F(t,e).scale(this.resolutionScale)))?void 0:n.key)??null}))}validateInspection(t){var e;return(null==(e=this.getNode(t))?void 0:e.key)??null}inspectAttributes(t){const e=this.getNode(t);if(!e)return null;const n={stack:e.creationStack,key:e.key};for(const{key:o,meta:s,signal:r}of e)s.inspectable&&(n[o]=r());return n}drawOverlay(t,e,n){const o=this.getNode(t);o&&this.execute((()=>{o.drawOverlay(n,e.scale(1/this.resolutionScale,1/this.resolutionScale).multiplySelf(o.localToWorld()))}))}registerNode(t,e){var n,o;const s=(null==(n=t.constructor)?void 0:n.name)??"unknown";(o=this.nodeCounters)[s]??(o[s]=0);const r=this.nodeCounters[s]++;return e??(e=`${this.name}/${s}[${r}]`),this.registeredNodes[e]=t,e}getNode(t){return"string"!=typeof t?null:this.registeredNodes[t]??null}recreateView(){this.execute((()=>{const t=this.getSize();this.view=new v.h({position:t.scale(this.resolutionScale/2),scale:this.resolutionScale,size:t})}))}}function T(t){return{klass:C,config:t,stack:(new Error).stack,meta:new o.v("scene",{version:new s.C("version",1),timeEvents:new s.C("time events",[]),seed:new s.C("seed",r.k.createSeed())})}}},11258:(t,e,n)=>{"use strict";n.d(e,{Nb:()=>_,JQ:()=>X,av:()=>d,AE:()=>w,pS:()=>D,is:()=>k,Zy:()=>y,kZ:()=>M,Ao:()=>g,pt:()=>x,ho:()=>h});var o=n(93091),s=n(88104),r=n(46350),i=n(30204),p=n(93214),a=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class c{constructor(t){(0,o.Xd)(this,t)}canvasGradient(t){let e;switch(this.type()){case"linear":e=t.createLinearGradient(this.from.x(),this.from.y(),this.to.x(),this.to.y());break;case"conic":e=t.createConicGradient(this.angle(),this.from.x(),this.from.y());break;case"radial":e=t.createRadialGradient(this.from.x(),this.from.y(),this.fromRadius(),this.to.x(),this.to.y(),this.toRadius())}for(const{offset:n,color:o}of this.stops())e.addColorStop((0,p.P)(n)?n():n,new i.I((0,p.P)(o)?o():o).serialize());return e}}a([(0,o.nn)("linear"),(0,o.td)()],c.prototype,"type",void 0),a([(0,s.y)("from")],c.prototype,"from",void 0),a([(0,s.y)("to")],c.prototype,"to",void 0),a([(0,o.nn)(0),(0,o.td)()],c.prototype,"angle",void 0),a([(0,o.nn)(0),(0,o.td)()],c.prototype,"fromRadius",void 0),a([(0,o.nn)(0),(0,o.td)()],c.prototype,"toRadius",void 0),a([(0,o.nn)([]),(0,o.td)()],c.prototype,"stops",void 0),a([(0,r.F)()],c.prototype,"canvasGradient",null);var l=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class u{constructor(t){(0,o.Xd)(this,t)}canvasPattern(t){return t.createPattern(this.image(),this.repetition())}}l([(0,o.td)()],u.prototype,"image",void 0),l([(0,o.nn)(null),(0,o.td)()],u.prototype,"repetition",void 0),l([(0,r.F)()],u.prototype,"canvasPattern",null);var m=n(29797);function d(t){return null===t?null:t instanceof c||t instanceof u?t:new i.I(t)}function h(t,e){return null===t?"":t instanceof i.I?t.serialize():t instanceof c?t.canvasGradient(e):t instanceof u?t.canvasPattern(e)??"":""}function y(t,e,n,o,s){if(0===n.top&&0===n.right&&0===n.bottom&&0===n.left)return void function(t,e){t.rect(e.x,e.y,e.width,e.height)}(t,e);const r=f(n.top,n.right,n.left,e),i=f(n.right,n.top,n.bottom,e),p=f(n.bottom,n.left,n.right,e),a=f(n.left,n.bottom,n.top,e);if(o){const n=t=>t-t*s;return t.moveTo(e.left+r,e.top),t.lineTo(e.right-i,e.top),t.bezierCurveTo(e.right-n(i),e.top,e.right,e.top+n(i),e.right,e.top+i),t.lineTo(e.right,e.bottom-p),t.bezierCurveTo(e.right,e.bottom-n(p),e.right-n(p),e.bottom,e.right-p,e.bottom),t.lineTo(e.left+a,e.bottom),t.bezierCurveTo(e.left+n(a),e.bottom,e.left,e.bottom-n(a),e.left,e.bottom-a),t.lineTo(e.left,e.top+r),void t.bezierCurveTo(e.left,e.top+n(r),e.left+n(r),e.top,e.left+r,e.top)}t.moveTo(e.left+r,e.top),t.arcTo(e.right,e.top,e.right,e.bottom,i),t.arcTo(e.right,e.bottom,e.left,e.bottom,p),t.arcTo(e.left,e.bottom,e.left,e.top,a),t.arcTo(e.left,e.top,e.right,e.top,r)}function f(t,e,n,o){const s=t+e>o.width?o.width*(t/(t+e)):t,r=t+n>o.height?o.height*(t/(t+n)):t;return Math.min(s,r)}function k(t,e,n){const o=e.size.scale(.5);for(let s=0;s<=n;s++){const e=2*s*Math.PI/n,r=m.F.fromRadians(e).perpendicular.mul(o);0==s?g(t,r):M(t,r)}t.closePath()}function w(t,e,n,o){o?t.drawImage(e,n.x,n.y,n.width,n.height,o.x,o.y,o.width,o.height):t.drawImage(e,n.x,n.y,n.width,n.height)}function g(t,e){t.moveTo(e.x,e.y)}function M(t,e){t.lineTo(e.x,e.y)}function D(t,e){if(!(e.length<2)){g(t,e[0]);for(const n of e.slice(1))M(t,n)}}function _(t,e,n,o,s,r){void 0===o&&(o=0),void 0===s&&(s=2*Math.PI),void 0===r&&(r=!1),t.arc(e.x,e.y,n,o,s,r)}function X(t,e,n,o){t.bezierCurveTo(e.x,e.y,n.x,n.y,o.x,o.y)}function x(t,e,n){t.quadraticCurveTo(e.x,e.y,n.x,n.y)}},14455:(t,e,n)=>{"use strict";n.d(e,{I:()=>s});var o=n(15688);function s(t,e,n,s){if(e&&t.setParser(e.bind(n)),s&&n){const e=null==n?void 0:n[`set${(0,o.k)(s)}`];e&&(t.set=function(){for(var t=arguments.length,o=new Array(t),s=0;s<t;s++)o[s]=arguments[s];return e.apply(n,o),n});const r=null==n?void 0:n[`get${(0,o.k)(s)}`];r&&(t.get=r.bind(n));const i=null==n?void 0:n[`tween${(0,o.k)(s)}`];i&&(t.doTween=i.bind(n))}}},88733:(t,e,n)=>{"use strict";n.d(e,{q:()=>o,r:()=>r});var o,s=n(1323);!function(t){t[t.Playing=0]="Playing",t[t.Rendering=1]="Rendering",t[t.Paused=2]="Paused",t[t.Presenting=3]="Presenting"}(o||(o={}));class r{constructor(){this.frame=0,this.speed=1,this.fps=30,this.duration=0,this.finished=!1,this.slides=[],this.previousScene=null,this.state=o.Paused,this.currentSceneReference=null,this.scenes=new s.G([])}get onSceneChanged(){if(null===this.currentSceneReference)throw new Error("PlaybackManager has not been properly initialized");return this.currentSceneReference.subscribable}get onScenesRecalculated(){return this.scenes.subscribable}get currentScene(){if(null===this.currentSceneReference)throw new Error("PlaybackManager has not been properly initialized");return this.currentSceneReference.current}set currentScene(t){if(!t)throw new Error("Invalid scene.");this.currentSceneReference??(this.currentSceneReference=new s.G(t)),this.currentSceneReference.current=t}setup(t){this.scenes.current=t,this.currentScene=t[0]}async progress(){return this.finished=await this.next(),this.finished}async seek(t){if(t<=this.frame||this.currentScene.isCached()&&this.currentScene.lastFrame<t){const e=this.findBestScene(t);e!==this.currentScene?(this.previousScene=null,this.currentScene=e,this.frame=this.currentScene.firstFrame,await this.currentScene.reset()):this.frame>=t&&(this.previousScene=null,this.frame=this.currentScene.firstFrame,await this.currentScene.reset())}for(this.finished=!1;this.frame<t&&!this.finished;)this.finished=await this.next();return this.finished}async goBack(){let t=this.currentScene.slides.getCurrent();if(t&&this.currentScene.slides.isWaiting()){const e=this.slides.indexOf(t);t=this.slides[e-1]}await this.seekSlide(t)}async goForward(){const t=this.currentScene.slides.getCurrent(),e=this.slides.indexOf(t);await this.seekSlide(this.slides[e+1])}async goTo(t){await this.seekSlide(this.slides.find((e=>e.id===t)))}async seekSlide(t){if(void 0===t&&(t=null),!t)return;const{id:e,scene:n}=t;for((this.currentScene!==n||this.currentScene.slides.didHappen(e))&&(this.previousScene=null,this.currentScene=n,this.frame=this.currentScene.firstFrame,this.currentScene.slides.setTarget(e),await this.currentScene.reset()),this.finished=!1,this.currentScene.slides.setTarget(e);!this.currentScene.slides.isWaitingFor(e)&&!this.finished;)this.finished=await this.next();return this.currentScene.slides.setTarget(null),this.finished}async reset(){this.previousScene=null,this.currentScene=this.scenes.current[0],this.frame=0,await this.currentScene.reset()}reload(t){this.scenes.current.forEach((e=>e.reload(t)))}async recalculate(){this.previousScene=null,this.slides=[];const t=this.speed;this.frame=0,this.speed=1;const e=[];try{for(const t of this.scenes.current)await t.recalculate((t=>{this.frame=t})),this.slides.push(...t.slides.onChanged.current),e.push(t)}finally{this.speed=t}this.scenes.current=e,this.duration=this.frame}async next(){if(this.previousScene&&(await this.previousScene.next(),this.currentScene.isFinished()&&(this.previousScene=null)),this.frame+=this.speed,this.currentScene.isFinished())return!0;if(await this.currentScene.next(),this.previousScene&&this.currentScene.isAfterTransitionIn()&&(this.previousScene=null),this.currentScene.canTransitionOut()){this.previousScene=this.currentScene;const t=this.getNextScene(this.previousScene);t&&(this.currentScene=t,await this.currentScene.reset(this.previousScene)),t&&!this.currentScene.isAfterTransitionIn()||(this.previousScene=null)}return this.currentScene.isFinished()}findBestScene(t){let e=this.scenes.current[0];for(const n of this.scenes.current){if(!n.isCached()||n.lastFrame>t)return n;e=n}return e}getNextScene(t){const e=this.scenes.current;if(!t)return e[0];const n=e.findIndex((e=>e===t));return n<0?null:e[n+1]??null}}},2672:(t,e,n)=>{"use strict";n.d(e,{J:()=>y});var o=n(88733),s=n(1323),r=n(3163);class i{get onDataChanged(){return this.data.subscribable}constructor(t){this.logger=t,this.data=new s.G(null),this.context=new AudioContext,this.audioElement=new Audio,this.source=null,this.error=!1,this.abortController=null,this.offset=0}getTime(){return this.toAbsoluteTime(this.audioElement.currentTime)}setTime(t){this.audioElement.currentTime=this.toRelativeTime(t)}setOffset(t){this.offset=t}setMuted(t){this.audioElement.muted=t}setSource(t){var e;this.source=t,this.audioElement.src=t,null==(e=this.abortController)||e.abort(),this.abortController=new AbortController,this.loadData(this.abortController.signal).catch((t=>{"AbortError"!==t.name&&this.logger.error(t)}))}isInRange(t){return t>=this.offset&&t<this.audioElement.duration}toRelativeTime(t){return Math.max(0,t-this.offset)}toAbsoluteTime(t){return t+this.offset}isReady(){return this.source&&!this.error}async setPaused(t){if(this.source&&this.audioElement.paused!==t)if(t)this.audioElement.pause();else try{return await this.audioElement.play(),this.error=!1,!0}catch(e){this.error||(0,r.wL)().error(e),this.error=!0}return!1}async loadData(t){if(this.data.current=null,!this.source)return;const e=await fetch(this.source,{signal:t}),n=await e.arrayBuffer();if(t.aborted)return;const o=await this.decodeAudioData(n);if(t.aborted)return;const s=256,r=~~(o.length/s),i=[];let p=0;for(let a=0;a<o.numberOfChannels;a++){const t=o.getChannelData(a);for(let e=0;e<r;e++){const n=~~(e*s),o=~~(n+s);let r=t[n],c=r;for(let e=n;e<o;e++){const n=t[e];n>c&&(c=n),n<r&&(r=n)}(0===a||c>i[2*e])&&(i[2*e]=c),(0===a||r<i[2*e+1])&&(i[2*e+1]=r),c>p&&(p=c),Math.abs(r)>p&&(p=Math.abs(r))}}this.data.current={peaks:i,absoluteMax:p,length:r,sampleRate:o.sampleRate/s*2}}decodeAudioData(t){return new Promise(((e,n)=>this.context.decodeAudioData(t,e,n)))}}var p=n(13170),a=n(11395);class c extends a.p{async dispatch(t){await Promise.all(this.notifySubscribers(t))}}var l=n(96881),u=n(29797);class m{constructor(t){this.playback=t}secondsToFrames(t){return Math.ceil(t*this.playback.fps)}framesToSeconds(t){return t/this.playback.fps}get time(){return this.framesToSeconds(this.playback.frame)}get frame(){return this.playback.frame}get speed(){return this.playback.speed}get fps(){return this.playback.fps}get state(){return this.playback.state}}var d=n(15649);class h{get onChanged(){return this.events.subscribable}constructor(t){this.scene=t,this.events=new s.G([]),this.registeredEvents={},this.lookup={},this.collisionLookup=new Set,this.previousReference=[],this.didEventsChange=!1,this.preserveTiming=!0,this.handleReload=()=>{this.registeredEvents={},this.collisionLookup.clear()},this.handleRecalculated=()=>{var t;this.preserveTiming=!0,this.events.current=Object.values(this.registeredEvents),(this.didEventsChange||((null==(t=this.previousReference)?void 0:t.length)??0)!==this.events.current.length)&&(this.didEventsChange=!1,this.previousReference=Object.values(this.registeredEvents).map((t=>({name:t.name,targetTime:t.targetTime}))),this.scene.meta.timeEvents.set(this.previousReference))},this.handleReset=()=>{this.collisionLookup.clear()},this.handleMetaChanged=t=>{t!==this.previousReference&&(this.previousReference=t,this.load(t),this.scene.reload())},this.previousReference=t.meta.timeEvents.get(),this.load(this.previousReference),t.onReloaded.subscribe(this.handleReload),t.onRecalculated.subscribe(this.handleRecalculated),t.onReset.subscribe(this.handleReset),t.meta.timeEvents.onChanged.subscribe(this.handleMetaChanged,!1)}set(t,e,n){void 0===n&&(n=!0),this.lookup[t]&&this.lookup[t].offset!==e&&(this.preserveTiming=n,this.lookup[t]={...this.lookup[t],targetTime:this.lookup[t].initialTime+e,offset:e},this.registeredEvents[t]=this.lookup[t],this.events.current=Object.values(this.registeredEvents),this.didEventsChange=!0,this.scene.reload())}register(t,e){if(this.collisionLookup.has(t))return this.scene.logger.error({message:`name "${t}" has already been used for another event name.`,stack:(new Error).stack}),0;if(this.collisionLookup.add(t),this.lookup[t]){let n=!1;const o={...this.lookup[t]},s=(new Error).stack;o.stack!==s&&(o.stack=s,n=!0),o.initialTime!==e&&(o.initialTime=e,n=!0);const r=Math.max(0,o.targetTime-o.initialTime);this.preserveTiming&&o.offset!==r&&(o.offset=r,n=!0);const i=o.initialTime+o.offset;this.preserveTiming||o.targetTime===i||(this.didEventsChange=!0,o.targetTime=i,n=!0),n&&(this.lookup[t]=o)}else this.didEventsChange=!0,this.lookup[t]={name:t,initialTime:e,targetTime:e,offset:0,stack:(new Error).stack};return this.registeredEvents[t]=this.lookup[t],this.lookup[t].offset}load(t){for(const e of t){const t=this.lookup[e.name]??{name:e.name,initialTime:0,offset:0};this.lookup[e.name]={...t,targetTime:e.targetTime}}}}class y{get onRender(){return this.render.subscribable}get onStateChanged(){return this.playerState.subscribable}get onFrameChanged(){return this.frame.subscribable}get onDurationChanged(){return this.duration.subscribable}get onRecalculated(){return this.recalculated.subscribable}get startFrame(){return Math.min(this.playback.duration,this.status.secondsToFrames(this.startTime))}get endFrame(){return Math.min(this.playback.duration,this.status.secondsToFrames(this.endTime))}get finished(){return this.playback.finished||this.playback.frame>=this.endFrame}constructor(t,e,n,r){var p,a;void 0===e&&(e={}),void 0===n&&(n={}),void 0===r&&(r=-1),this.project=t,this.settings=e,this.initialState=n,this.initialFrame=r,this.render=new c,this.frame=new s.G(0),this.duration=new s.G(0),this.recalculated=new l.p,this.lock=new d.L,this.startTime=0,this.endTime=1/0,this.requestId=null,this.renderTime=0,this.requestedSeek=-1,this.requestedRecalculation=!0,this.active=!1,this.playerState=new s.G({loop:!0,muted:!0,speed:1,...n,paused:!0}),this.requestedSeek=r,this.logger=this.project.logger,this.playback=new o.r,this.status=new m(this.playback),this.audio=new i(this.logger),this.size=e.size??new u.F(1920,1080),this.resolutionScale=e.resolutionScale??1,this.startTime=(null==(p=e.range)?void 0:p[0])??0,this.endTime=(null==(a=e.range)?void 0:a[1])??1/0,this.playback.fps=e.fps??60,this.audio.setOffset(e.audioOffset??0),t.audio&&this.audio.setSource(t.audio);const y=[];for(const o of t.scenes){var f;const e=new o.klass({...o,playback:this.status,logger:this.project.logger,size:this.size,resolutionScale:this.resolutionScale,timeEventsClass:h});null==(f=o.onReplaced)||f.subscribe((t=>{e.reload(t)}),!1),e.onReloaded.subscribe((()=>this.requestRecalculation())),e.variables.updateSignals(t.variables??{}),y.push(e)}this.playback.setup(y),this.activate()}async configure(t){await this.lock.acquire();let e=this.playback.frame,n=!1;if(this.startTime=t.range[0],this.endTime=t.range[1],this.playback.fps!==t.fps){const o=t.fps/this.playback.fps;this.playback.fps=t.fps,e=Math.floor(e*o),n=!0}t.size.exactlyEquals(this.size)&&t.resolutionScale===this.resolutionScale||(this.size=t.size,this.resolutionScale=t.resolutionScale,this.playback.reload({size:this.size,resolutionScale:this.resolutionScale})),void 0!==t.audioOffset&&this.audio.setOffset(t.audioOffset),this.lock.release(),n&&(this.playback.reload(),this.frame.current=e,this.requestRecalculation(),this.requestedSeek=e)}requestSeek(t){this.requestedSeek=this.clampRange(t)}requestPreviousFrame(){this.requestedSeek=this.frame.current-this.playback.speed}requestNextFrame(){this.requestedSeek=this.frame.current+this.playback.speed}requestReset(){this.requestedSeek=0}toggleLoop(t){void 0===t&&(t=!this.playerState.current.loop),t!==this.playerState.current.loop&&(this.playerState.current={...this.playerState.current,loop:t})}togglePlayback(t){void 0===t&&(t=this.playerState.current.paused),t===this.playerState.current.paused&&(this.playerState.current={...this.playerState.current,paused:!t},t&&!this.playerState.current.loop&&this.playback.frame===this.playback.duration&&this.requestReset())}toggleAudio(t){void 0===t&&(t=this.playerState.current.muted),t===this.playerState.current.muted&&(this.playerState.current={...this.playerState.current,muted:!t})}setSpeed(t){t!==this.playerState.current.speed&&(this.playback.speed=t,this.playback.reload(),this.playerState.current={...this.playerState.current,speed:t},this.requestRecalculation())}setVariables(t){for(const e of this.playback.onScenesRecalculated.current)e.variables.updateSignals(t)}activate(){this.active=!0,this.request()}deactivate(){this.active=!1,null!==this.requestId&&(cancelAnimationFrame(this.requestId),this.requestId=null)}requestRecalculation(){this.requestedRecalculation=!0,this.request()}async prepare(){const t={...this.playerState.current,seek:this.requestedSeek};if(this.requestedSeek=-1,this.requestedRecalculation){t.seek<0&&(t.seek=this.playback.frame);try{await this.playback.recalculate(),this.duration.current=this.playback.frame,this.recalculated.dispatch()}catch(n){throw this.requestSeek(t.seek),n}finally{this.requestedRecalculation=!1}}(!t.loop&&this.finished&&!t.paused&&t.seek<0||this.endFrame===this.startFrame)&&(this.togglePlayback(!1),t.paused=!0),t.loop&&(t.seek>this.endFrame||this.finished&&!t.paused)&&this.startFrame!==this.endTime&&(t.seek=this.startFrame);const e=t.paused||this.finished||!this.audio.isInRange(this.status.time);return await this.audio.setPaused(e)&&this.syncAudio(-3),this.audio.setMuted(t.muted),t}async run(){const t=await this.prepare(),e=this.playback.state;if(this.playback.state=t.paused?o.q.Paused:o.q.Playing,t.seek>=0||!this.isInRange(this.status.frame)){const e=t.seek<0?this.status.frame:t.seek,n=this.clampRange(e);this.logger.profile("seek time"),await this.playback.seek(n),this.logger.profile("seek time"),this.syncAudio(-3)}else{if(t.paused||1===t.speed&&this.audio.isReady()&&this.audio.isInRange(this.status.time)&&this.audio.getTime()<this.status.time)return t.paused&&e!==o.q.Paused&&await this.render.dispatch(),!t.paused&&this.status.time>this.audio.getTime()+.02&&this.syncAudio(),void this.request();if(this.audio.isReady()&&1===t.speed&&this.audio.isInRange(this.status.time)&&this.status.framesToSeconds(this.playback.frame+1)<this.audio.getTime()-.02){const t=this.status.secondsToFrames(this.audio.getTime());await this.playback.seek(t)}else this.status.frame<this.endFrame&&(await this.playback.progress(),1!==t.speed&&this.syncAudio())}!t.paused&&this.playback.currentScene.slides.isWaiting()&&(this.togglePlayback(!1),t.paused=!0),await this.render.dispatch(),this.frame.current=this.playback.frame,this.request()}request(){this.active&&(this.requestId??(this.requestId=requestAnimationFrame((async t=>{if(this.requestId=null,t-this.renderTime>=1e3/(this.status.fps+5)){this.renderTime=t,await this.lock.acquire();try{await this.run()}catch(e){this.logger.error(e)}this.lock.release()}else this.request()}))))}clampRange(t){return(0,p.uZ)(this.startFrame,this.endFrame,t)}isInRange(t){return t>=this.startFrame&&t<=this.endFrame}syncAudio(t){void 0===t&&(t=0),this.audio.setTime(this.status.framesToSeconds(this.playback.frame+t))}}},9989:(t,e,n)=>{"use strict";n.d(e,{H:()=>r});var o=n(1119),s=n(29797);class r{get canvasSize(){return this.size.scale(this.resolutionScale)}constructor(){this.background=null,this.resolutionScale=1,this.colorSpace="srgb",this.size=s.F.zero,this.finalBuffer=document.createElement("canvas"),this.currentBuffer=document.createElement("canvas"),this.previousBuffer=document.createElement("canvas");const t=this.colorSpace;this.context=(0,o.f)({colorSpace:t},this.finalBuffer),this.currentContext=(0,o.f)({colorSpace:t},this.currentBuffer),this.previousContext=(0,o.f)({colorSpace:t},this.previousBuffer)}configure(t){let{colorSpace:e=this.colorSpace,size:n=this.size,resolutionScale:s=this.resolutionScale,background:r=this.background}=t;e!==this.colorSpace&&(this.colorSpace=e,this.context=(0,o.f)({colorSpace:e},this.finalBuffer),this.currentContext=(0,o.f)({colorSpace:e},this.currentBuffer),this.previousContext=(0,o.f)({colorSpace:e},this.previousBuffer)),n.exactlyEquals(this.size)&&s===this.resolutionScale||(this.resolutionScale=s,this.size=n,this.resizeCanvas(this.context),this.resizeCanvas(this.currentContext),this.resizeCanvas(this.previousContext)),this.background="string"==typeof r?r:(null==r?void 0:r.serialize())??null}async render(t,e){e&&(this.transformCanvas(this.previousContext),await e.render(this.previousContext)),this.transformCanvas(this.currentContext),await t.render(this.currentContext);const n=this.canvasSize;this.context.clearRect(0,0,n.width,n.height),this.background&&(this.context.save(),this.context.fillStyle=this.background,this.context.fillRect(0,0,n.width,n.height),this.context.restore()),e&&this.context.drawImage(this.previousBuffer,0,0),this.context.drawImage(this.currentBuffer,0,0)}transformCanvas(t){const e=this.canvasSize.scale(.5);t.setTransform(this.resolutionScale,0,0,this.resolutionScale,e.x,e.y)}resizeCanvas(t){const e=this.canvasSize;t.canvas.width=e.width,t.canvas.height=e.height}}},42075:(t,e,n)=>{"use strict";function o(t){const e={[t.name]:t},n=Object.getOwnPropertyDescriptor(e,t.name);if(n){for(var o=arguments.length,s=new Array(o>1?o-1:0),r=1;r<o;r++)s[r-1]=arguments[r];for(let o=s.length-1;o>=0;o--)s[o](e,t.name,n)}}n.d(e,{G:()=>o})},79116:(t,e,n)=>{"use strict";n.d(e,{V:()=>s});const o=Symbol.for("@motion-canvas/core/decorators/UNINITIALIZED");function s(t){return(e,n)=>{let s=o;Object.defineProperty(e,n,{get(){return s===o&&(s=t.call(this)),s}})}}},67292:(t,e,n)=>{"use strict";function o(t){return function(e,n,o){o.value.prototype.name=t??n,o.value.prototype.threadable=!0}}n.d(e,{C:()=>o})},96881:(t,e,n)=>{"use strict";n.d(e,{p:()=>s});var o=n(11395);class s extends o.p{dispatch(t){this.notifySubscribers(t)}}},11395:(t,e,n)=>{"use strict";n.d(e,{l:()=>s,p:()=>o});class o{constructor(){this.subscribable=new s(this),this.subscribers=new Set}subscribe(t){return this.subscribers.add(t),()=>this.unsubscribe(t)}unsubscribe(t){this.subscribers.delete(t)}clear(){this.subscribers.clear()}notifySubscribers(t){return[...this.subscribers].map((e=>e(t)))}}class s{constructor(t){this.dispatcher=t}subscribe(t){return this.dispatcher.subscribe(t)}unsubscribe(t){this.dispatcher.unsubscribe(t)}}},1323:(t,e,n)=>{"use strict";n.d(e,{G:()=>s});var o=n(11395);class s extends o.p{set current(t){this.value=t,this.notifySubscribers(t)}get current(){return this.value}constructor(t){super(),this.value=t,this.subscribable=new r(this)}subscribe(t,e){void 0===e&&(e=!0);const n=super.subscribe(t);return e&&t(this.value),n}}class r extends o.l{get current(){return this.dispatcher.current}subscribe(t,e){return void 0===e&&(e=!0),this.dispatcher.subscribe(t,e)}}},5376:(t,e,n)=>{"use strict";n.d(e,{$:()=>i});var o=n(51284),s=n(42075),r=n(67292);function*i(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];for(const o of e)yield o;yield*(0,o.v)(...e)}(0,s.G)(i,(0,r.C)())},77396:(t,e,n)=>{"use strict";n.d(e,{K:()=>s});var o=n(75168);function s(t,e){let n;return"string"==typeof t?(n=e(),(0,o.i)(n,t)):(n=t(),(0,o.i)(n,n)),n}},82344:(t,e,n)=>{"use strict";n.d(e,{C:()=>s});var o=n(1323);class s{get onChanged(){return this.value.subscribable}get onDisabled(){return this.disabled.subscribable}constructor(t,e){this.name=t,this.type=void 0,this.spacing=!1,this.disabled=new o.G(!1),this.value=new o.G(e)}get(){return this.value.current}set(t){this.value.current=this.parse(t)}parse(t){return t}serialize(){return this.value.current}clone(){return new this.constructor(this.name,this.get())}disable(t){return void 0===t&&(t=!0),this.disabled.current=t,this}space(t){return void 0===t&&(t=!0),this.spacing=t,this}}},92673:(t,e,n)=>{"use strict";n.d(e,{v:()=>i});var o=n(82344),s=n(1323);class r extends o.C{get onFieldsChanged(){return this.event.subscribable}constructor(t,e){const n=new Map(Object.entries(e));super(t,Object.fromEntries(Array.from(n,(t=>{let[e,n]=t;return[e,n.get()]})))),this.type=Object,this.ignoreChange=!1,this.customFields={},this.handleChange=()=>{this.ignoreChange||(this.value.current=this.transform("get"))},this.event=new s.G([...n.values()]),this.fields=n;for(const[o,s]of this.fields)Object.defineProperty(this,o,{value:s}),s.onChanged.subscribe(this.handleChange)}set(t){this.ignoreChange=!0;for(const[e,n]of Object.entries(t)){const t=this.fields.get(e);t?t.set(n):this.customFields[e]=n}this.ignoreChange=!1,this.handleChange()}serialize(){return this.transform("serialize")}clone(){return new this.constructor(this.name,this.transform("clone"))}transform(t){return{...Object.fromEntries(Array.from(this.fields,(e=>{let[n,o]=e;return[n,o[t]()]}))),...this.customFields}}}const i=r},11726:(t,e,n)=>{"use strict";n.d(e,{k:()=>r});var o=n(13170),s=n(37762);class r{constructor(t){this.state=t}static createSeed(){return Math.floor(4294967296*Math.random())}nextFloat(t,e){return void 0===t&&(t=0),void 0===e&&(e=1),(0,o.UI)(t,e,this.next())}nextInt(t,e){void 0===t&&(t=0),void 0===e&&(e=4294967296);let n=Math.floor((0,o.UI)(t,e,this.next()));return n===e&&(n=t),n}floatArray(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,s.w)(t).map((()=>this.nextFloat(e,n)))}intArray(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=4294967296),(0,s.w)(t).map((()=>this.nextInt(e,n)))}spawn(){return new r(this.nextInt())}next(){this.state|=0,this.state=this.state+1831565813|0;let t=Math.imul(this.state^this.state>>>15,1|this.state);return t=t+Math.imul(t^t>>>7,61|t)^t,((t^t>>>14)>>>0)/4294967296}}},46096:(t,e,n)=>{"use strict";n.d(e,{N:()=>i});var o=n(13170),s=n(16249),r=n(93214);class i extends s.V{constructor(t,e,n,i,p){void 0===p&&(p=void 0),super(void 0,i,p),this.entries=t,this.signals=[],this.parser=e;for(const a of t){const t=new s.V((0,r.P)(n)?()=>e(n())[a]:e(n)[a],o.UI,p??this.invokable).toSignal();this.signals.push([a,t]),Object.defineProperty(this.invokable,a,{value:t})}}toSignal(){return this.invokable}parse(t){return this.parser(t)}get(){return this.parse(Object.fromEntries(this.signals.map((t=>{let[e,n]=t;return[e,n()]}))))}set(t){if((0,r.P)(t))for(const[e,n]of this.signals)n((()=>this.parser(t())[e]));else{const e=this.parse(t);for(const[t,n]of this.signals)n(e[t])}return this.owner}reset(){for(const[,t]of this.signals)t.reset();return this.owner}save(){for(const[,t]of this.signals)t.save();return this.owner}}},81865:(t,e,n)=>{"use strict";n.d(e,{h:()=>i});var o=n(3163),s=n(90031),r=n(76062);class i extends r.k{constructor(t,e){super(e),this.factory=t,this.markDirty()}toSignal(){return this.invokable}dispose(){super.dispose(),this.last=void 0}invoke(){if(this.event.isRaised()){this.clearDependencies(),this.startCollecting();try{this.last=this.factory(...arguments)}catch(e){var t;(0,o.wL)().error({...(0,s.d)(e),inspect:null==(t=this.owner)?void 0:t.key})}this.finishCollecting()}return this.event.reset(),this.collect(),this.last}}},76062:(t,e,n)=>{"use strict";n.d(e,{k:()=>i});var o=n(11395);class s extends o.p{constructor(){super(...arguments),this.value=!1}raise(){this.value||(this.value=!0,this.notifySubscribers())}reset(){this.value=!1}isRaised(){return this.value}subscribe(t){const e=super.subscribe(t);return this.value&&t(),e}}var r=n(49111);class i{static collectPromise(t,e){void 0===e&&(e=null);const n={promise:t,value:e,stack:(new Error).stack},o=this.collectionStack.at(-1);return o&&(n.owner=o.owner),t.then((t=>{n.value=t,null==o||o.markDirty()})),this.promises.push(n),n}static consumePromises(){const t=this.promises;return this.promises=[],t}constructor(t){this.owner=t,this.dependencies=new Set,this.event=new s,this.markDirty=()=>this.event.raise(),this.invokable=this.invoke.bind(this),Object.defineProperty(this.invokable,"context",{value:this}),Object.defineProperty(this.invokable,"toPromise",{value:this.toPromise.bind(this)})}invoke(){}startCollecting(){if(i.collectionSet.has(this))throw new r.t("A circular dependency occurred between signals.","This can happen when signals reference each other in a loop.\n        Try using the attached stack trace to locate said loop.");i.collectionSet.add(this),i.collectionStack.push(this)}finishCollecting(){if(i.collectionSet.delete(this),i.collectionStack.pop()!==this)throw new Error("collectStart/collectEnd was called out of order.")}clearDependencies(){this.dependencies.forEach((t=>t.unsubscribe(this.markDirty))),this.dependencies.clear()}collect(){const t=i.collectionStack.at(-1);t&&(t.dependencies.add(this.event.subscribable),this.event.subscribe(t.markDirty))}dispose(){this.clearDependencies(),this.event.clear(),this.owner=null}async toPromise(){let t=i.consumePromises();do{await Promise.all(t.map((t=>t.promise))),this.invokable(),t=i.consumePromises()}while(t.length>0);return this.invokable}}i.collectionSet=new Set,i.collectionStack=[],i.promises=[]},16249:(t,e,n)=>{"use strict";n.d(e,{V:()=>u});var o=n(97074),s=n(74534),r=n(3163),i=n(90031),p=n(77396),a=n(76062),c=n(93214),l=n(60771);class u extends a.k{constructor(t,e,n){void 0===n&&(n=void 0),super(n),this.initial=t,this.interpolation=e,this.parser=t=>t,Object.defineProperty(this.invokable,"reset",{value:this.reset.bind(this)}),Object.defineProperty(this.invokable,"save",{value:this.save.bind(this)}),Object.defineProperty(this.invokable,"isInitial",{value:this.isInitial.bind(this)}),void 0!==this.initial&&(this.current=this.initial,this.markDirty(),(0,c.P)(this.initial)||(this.last=this.parse(this.initial)))}toSignal(){return this.invokable}parse(t){return this.parser(t)}wrap(t){return(0,c.P)(t)?()=>this.parse(t()):this.parse(t)}setInitial(t){this.initial=t}setParser(t){this.parser=t,void 0===this.current||(0,c.P)(this.current)||(this.last=this.parse(this.current)),this.markDirty()}set(t){return t===l.T&&(t=this.initial),this.current===t||(this.current=t,this.markDirty(),this.clearDependencies(),(0,c.P)(t)||(this.last=this.parse(t))),this.owner}get(){if(this.event.isRaised()&&(0,c.P)(this.current)){this.clearDependencies(),this.startCollecting();try{this.last=this.parse(this.current())}catch(e){var t;(0,r.wL)().error({...(0,i.d)(e),inspect:null==(t=this.owner)?void 0:t.key})}this.finishCollecting()}return this.event.reset(),this.collect(),this.last}invoke(t,e,n,s){return void 0===n&&(n=o.qb),void 0===s&&(s=this.interpolation),void 0===t?this.get():void 0===e?this.set(t):this.makeAnimate(n,s)(t,e)}makeAnimate(t,e,n){var o=this;return function(s,r,i,a){void 0===i&&(i=t),void 0===a&&(a=e);const c=o.tween(s,r,i,a);let l=c;return n&&(l=(0,p.K)((function*(){yield*n,yield*c}))),l.to=o.makeAnimate(i,a,l),l}}*tween(t,e,n,o){t===l.T&&(t=this.initial),yield*this.doTween(this.parse((0,c.P)(t)?t():t),e,n,o),this.set(t)}*doTween(t,e,n,o){const r=this.get();yield*(0,s.i)(e,(e=>{this.set(o(r,t,n(e)))}))}dispose(){super.dispose(),this.initial=void 0,this.current=void 0,this.last=void 0}reset(){return void 0!==this.initial&&this.set(this.initial),this.owner}save(){return this.set(this.get())}isInitial(){return this.collect(),this.current===this.initial}raw(){return this.current}}},73662:(t,e,n)=>{"use strict";n.d(e,{D:()=>s});var o=n(81865);function s(t,e){return new o.h(t,e).toSignal()}},97140:(t,e,n)=>{"use strict";n.d(e,{g:()=>r});var o=n(13170),s=n(16249);function r(t,e,n){return void 0===e&&(e=o.o0),new s.V(t,e,n).toSignal()}},93214:(t,e,n)=>{"use strict";function o(t){return"function"==typeof t}n.d(e,{P:()=>o})},60771:(t,e,n)=>{"use strict";n.d(e,{T:()=>o});const o=Symbol.for("@motion-canvas/core/signals/default")},50580:(t,e,n)=>{"use strict";n.d(e,{j:()=>i});var o=n(56632),s=n(97140),r=n(75168);class i{get fixed(){return this.fixedTime}get canceled(){var t;return this.isCanceled||((null==(t=this.parent)?void 0:t.canceled)??!1)}constructor(t){this.runner=t,this.children=[],this.time=(0,s.g)(0),this.parent=null,this.isCanceled=!1,this.fixedTime=0}next(){(0,o.h$)(this);const t=this.runner.next(this.value);return(0,o.kw)(this),this.value=null,t}update(t){this.time(this.time()+t),this.fixedTime+=t,this.children=this.children.filter((t=>!t.canceled))}add(t){t.cancel(),t.parent=this,t.isCanceled=!1,t.time(this.time()),t.fixedTime=this.fixedTime,this.children.push(t),(0,r.i)(t.runner,`unknown ${this.children.length}`)}cancel(){this.isCanceled=!0,this.parent=null}}},80638:(t,e,n)=>{"use strict";function o(t){return t&&("object"==typeof t||"function"==typeof t)&&"toPromise"in t}function s(t){return null!==t&&"object"==typeof t&&Symbol.iterator in t&&"next"in t}n.d(e,{R:()=>s,x:()=>o})},51284:(t,e,n)=>{"use strict";n.d(e,{v:()=>i});var o=n(42075),s=n(67292),r=n(56632);function*i(t){let e=!0;for(var n=arguments.length,o=new Array(n>1?n-1:0),s=1;s<n;s++)o[s-1]=arguments[s];"boolean"==typeof t?e=t:o.push(t);const i=(0,r.nn)(),p=o.map((t=>i.children.find((e=>e.runner===t)))).filter((t=>t)),a=i.time();let c;if(e){for(;p.find((t=>!t.canceled));)yield;c=Math.max(...p.map((t=>t.time())))}else{for(;!p.find((t=>t.canceled));)yield;const t=p.filter((t=>t.canceled));c=Math.min(...t.map((t=>t.time())))}i.time(Math.max(a,c))}(0,o.G)(i,(0,s.C)())},75168:(t,e,n)=>{"use strict";function o(t,e){const n=Object.getPrototypeOf(t);n.threadable||(n.threadable=!0,n.name="string"==typeof e?e:s(e))}function s(t){return Object.getPrototypeOf(t).name??null}n.d(e,{i:()=>o,z:()=>s})},5881:(t,e,n)=>{"use strict";n.d(e,{C:()=>l,t:()=>c});var o=n(42075),s=n(67292),r=n(50580),i=n(80638),p=n(75168),a=n(97715);function c(t){return"function"==typeof(null==t?void 0:t.then)}function*l(t,e){const n=(0,a.te)(),o=t();(0,p.i)(o,"root");const s=new r.j(o);null==e||e(s);let c=[s];for(;c.length>0;){const t=[],e=[...c],o=n.framesToSeconds(1)*n.speed;for(;e.length>0;){const n=e.pop();if(!n||n.canceled)continue;const s=n.next();if(s.done)n.cancel();else if((0,i.R)(s.value)){const t=new r.j(s.value);n.value=s.value,n.add(t),e.push(n),e.push(t)}else s.value?(n.value=yield s.value,e.push(n)):(n.update(o),t.unshift(n))}c=t.filter((t=>!t.canceled)),c.length>0&&(yield)}}(0,o.G)(l,(0,s.C)())},13170:(t,e,n)=>{"use strict";n.d(e,{JC:()=>r,UI:()=>p,Vz:()=>u,a2:()=>a,o0:()=>i,uZ:()=>c,vl:()=>l});var o=n(3163),s=n(29797);function r(t,e,n){if(e.length>=t.length){const o=Math.floor(e.length*n),s=Math.floor(p(t.length-1,e.length,n));let r="";for(let n=0;n<e.length;n++)n<o?r+=e[n]:(t[n]||n<=s)&&(r+=t[n]??e[n]);return r}{const o=Math.round(t.length*(1-n)),s=Math.floor(p(t.length+1,e.length,n)),r=[];for(let n=t.length-1;n>=0;n--)n<o?r.unshift(t[n]):(e[n]||n<s)&&r.unshift(e[n]??t[n]);return r.join("")}}function i(t,e,n,s){if(void 0===s&&(s=!1),0===n)return t;if(1===n)return e;if(null!=t&&null!=e){if("number"==typeof t&&"number"==typeof e)return p(t,e,n);if("string"==typeof t&&"string"==typeof e)return r(t,e,n);if("boolean"==typeof t&&"boolean"==typeof e)return n<.5?t:e;if("lerp"in t)return t.lerp(e,n);if(t&&e&&"object"==typeof t&&"object"==typeof e)if(Array.isArray(t)&&Array.isArray(e)){if(t.length===e.length)return t.map(((t,o)=>i(t,e[o],n)))}else{let o=!1;if(t instanceof Map||e instanceof Map||(o=!0,t=new Map(Object.entries(t)),e=new Map(Object.entries(e))),t instanceof Map&&e instanceof Map){const s=new Map;for(const o of new Set([...t.keys(),...e.keys()])){const r=i(t.get(o),e.get(o),n,!0);void 0!==r&&s.set(o,r)}return o?Object.fromEntries(s):s}}return e}s||(0,o.wL)().warn(`Attempting to lerp ${t} -> ${e} may result in unexpected behavior.`)}function p(t,e,n){return t+(e-t)*n}function a(t,e,n,o,s){return n+(s-t)*(o-n)/(e-t)}function c(t,e,n){return n<t?t:n>e?e:n}function l(t,e,n,o,s){const r=a(t,e,n,o,s);return n>o&&([n,o]=[o,n]),c(n,o,r)}function u(t,e,n){let o=e;n>1?n=1/n:o=!o;const r=p(o?Math.acos(c(-1,1,1-t)):Math.asin(t),p(0,Math.PI/2,t),n);let i=Math.sin(r),a=1-Math.cos(r);return e&&([i,a]=[a,i]),new s.F(i,a)}},97074:(t,e,n)=>{"use strict";n.d(e,{BH:()=>F,Bl:()=>b,C6:()=>B,FG:()=>a,Fs:()=>p,GE:()=>A,Ge:()=>v,Ij:()=>z,J7:()=>f,Kx:()=>Z,Mg:()=>X,N1:()=>r,O$:()=>s,Q9:()=>u,SJ:()=>W,UE:()=>I,Y3:()=>y,Yw:()=>P,ad:()=>D,cv:()=>U,du:()=>N,eE:()=>O,e_:()=>M,ei:()=>x,en:()=>G,g4:()=>h,hN:()=>_,hl:()=>c,j$:()=>C,jv:()=>S,lj:()=>T,mC:()=>E,n5:()=>k,pl:()=>w,qS:()=>L,qb:()=>d,rz:()=>g,sK:()=>j,to:()=>l,vh:()=>i,w2:()=>m,zk:()=>R});var o=n(13170);function s(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,o.a2)(-1,1,e,n,Math.sin(t))}function r(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.cos(t*Math.PI/2),(0,o.UI)(e,n,t)}function i(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=Math.sin(t*Math.PI/2),(0,o.UI)(e,n,t)}function p(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=-(Math.cos(Math.PI*t)-1)/2,(0,o.UI)(e,n,t)}function a(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t,(0,o.UI)(e,n,t)}function c(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,2),(0,o.UI)(e,n,t)}function l(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2,(0,o.UI)(e,n,t)}function u(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t*t,(0,o.UI)(e,n,t)}function m(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,3),(0,o.UI)(e,n,t)}function d(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,(0,o.UI)(e,n,t)}function h(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t*t*t,(0,o.UI)(e,n,t)}function y(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,4),(0,o.UI)(e,n,t)}function f(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?8*t*t*t*t:1-Math.pow(-2*t+2,4)/2,(0,o.UI)(e,n,t)}function k(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t*=t*t*t*t,(0,o.UI)(e,n,t)}function w(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.pow(1-t,5),(0,o.UI)(e,n,t)}function g(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?16*t*t*t*t*t:1-Math.pow(-2*t+2,5)/2,(0,o.UI)(e,n,t)}function M(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=0===t?0:Math.pow(2,10*t-10),(0,o.UI)(e,n,t)}function D(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1===t?1:1-Math.pow(2,-10*t),(0,o.UI)(e,n,t)}function _(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=0===t?0:1===t?1:t<.5?Math.pow(2,20*t-10)/2:(2-Math.pow(2,-20*t+10))/2,(0,o.UI)(e,n,t)}function X(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=1-Math.sqrt(1-Math.pow(t,2)),(0,o.UI)(e,n,t)}function x(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=Math.sqrt(1-Math.pow(t-1,2)),(0,o.UI)(e,n,t)}function v(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),t=t<.5?(1-Math.sqrt(1-Math.pow(2*t,2)))/2:(Math.sqrt(1-Math.pow(-2*t+2,2))+1)/2,(0,o.UI)(e,n,t)}function C(t){return void 0===t&&(t=1.70158),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=(t+1)*e*e*e-t*e*e,(0,o.UI)(n,s,e)}}function T(t){return void 0===t&&(t=1.70158),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=1+(t+1)*Math.pow(e-1,3)+t*Math.pow(e-1,2),(0,o.UI)(n,s,e)}}function b(t,e){return void 0===t&&(t=1.70158),void 0===e&&(e=1.525),function(n,s,r){return void 0===s&&(s=0),void 0===r&&(r=1),n=n<.5?Math.pow(2*n,2)*(2*(t*e+1)*n-t*e)/2:(Math.pow(2*n-2,2)*((t*e+1)*(2*n-2)+t*e)+2)/2,(0,o.UI)(s,r,n)}}function L(t){return void 0===t&&(t=2.094395),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=0===e?0:1===e?1:-Math.pow(2,10*e-10)*Math.sin((10*e-10.75)*t),(0,o.UI)(n,s,e)}}function Z(t){return void 0===t&&(t=2.094395),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=0===e?0:1===e?1:Math.pow(2,-10*e)*Math.sin((10*e-.75)*t)+1,(0,o.UI)(n,s,e)}}function N(t){return void 0===t&&(t=1.39626),function(e,n,s){return void 0===n&&(n=0),void 0===s&&(s=1),e=0===e?0:1===e?1:e<.5?-Math.pow(2,20*e-10)*Math.sin((20*e-11.125)*t)/2:Math.pow(2,-20*e+10)*Math.sin((20*e-11.125)*t)/2+1,(0,o.UI)(n,s,e)}}function S(t,e){void 0===t&&(t=7.5625),void 0===e&&(e=2.75);const n=R(t,e);return function(t,e,o){return void 0===e&&(e=0),void 0===o&&(o=1),1-n(1-t,e,o)}}function R(t,e){return void 0===t&&(t=7.5625),void 0===e&&(e=2.75),function(n,s,r){return void 0===s&&(s=0),void 0===r&&(r=1),n<1/e?n*=t*n:n=n<2/e?t*(n-=1.505/e)*n+.75:n<2.5/e?t*(n-=2.25/e)*n+.9375:t*(n-=2.625/e)*n+.984375,(0,o.UI)(s,r,n)}}function z(t,e){void 0===t&&(t=7.5625),void 0===e&&(e=2.75);const n=R(t,e);return function(t,e,o){return void 0===e&&(e=0),void 0===o&&(o=1),t<.5?(1-n(1-2*t,e,o))/2:(1+n(2*t-1,e,o))/2}}function A(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,o.UI)(e,n,t)}function E(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),(0,o.a2)(-1,1,e,n,Math.cos(t))}const P=C(),I=T(),F=b(),W=S(),B=R(),G=z(),O=L(),j=Z(),U=N()},74534:(t,e,n)=>{"use strict";n.d(e,{i:()=>i});var o=n(42075),s=n(67292),r=n(56632);function*i(t,e,n){const o=(0,r.nn)(),s=o.time(),i=o.time()+t;for(e(0,0);i>o.fixed;){const n=o.fixed-s;n>0&&e(n/t,n),yield}o.time(i),e(1,t),null==n||n(1,t)}(0,o.G)(i,(0,s.C)())},23357:(t,e,n)=>{"use strict";n.d(e,{b:()=>i});var o=n(29797),s=n(13170),r=n(46096);class i{static createSignal(t,e){return void 0===e&&(e=i.lerp),new r.N(["x","y","width","height"],(t=>new i(t)),t,e).toSignal()}static lerp(t,e,n){let r,p,a,c;return"number"==typeof n?r=p=a=c=n:n instanceof o.F?(r=a=n.x,p=c=n.y):(r=n.x,p=n.y,a=n.width,c=n.height),new i((0,s.UI)(t.x,e.x,r),(0,s.UI)(t.y,e.y,p),(0,s.UI)(t.width,e.width,a),(0,s.UI)(t.height,e.height,c))}static arcLerp(t,e,n,o,r){return void 0===o&&(o=!1),r??(r=(t.position.sub(e.position).ctg+t.size.sub(e.size).ctg)/2),i.lerp(t,e,(0,s.Vz)(n,o,r))}static fromSizeCentered(t){return new i(-t.width/2,-t.height/2,t.width,t.height)}static fromPoints(){let t=1/0,e=1/0,n=-1/0,o=-1/0;for(var s=arguments.length,r=new Array(s),p=0;p<s;p++)r[p]=arguments[p];for(const i of r)i.x>n&&(n=i.x),i.x<t&&(t=i.x),i.y>o&&(o=i.y),i.y<e&&(e=i.y);return new i(t,e,n-t,o-e)}static fromBBoxes(){let t=1/0,e=1/0,n=-1/0,o=-1/0;for(var s=arguments.length,r=new Array(s),p=0;p<s;p++)r[p]=arguments[p];for(const i of r){const s=i.x+i.width;s>n&&(n=s),i.x<t&&(t=i.x);const r=i.y+i.height;r>o&&(o=r),i.y<e&&(e=i.y)}return new i(t,e,n-t,o-e)}lerp(t,e){return i.lerp(this,t,e)}get position(){return new o.F(this.x,this.y)}set position(t){this.x=t.x,this.y=t.y}get size(){return new o.F(this.width,this.height)}get center(){return new o.F(this.x+this.width/2,this.y+this.height/2)}get left(){return this.x}set left(t){this.width+=this.x-t,this.x=t}get right(){return this.x+this.width}set right(t){this.width=t-this.x}get top(){return this.y}set top(t){this.height+=this.y-t,this.y=t}get bottom(){return this.y+this.height}set bottom(t){this.height=t-this.y}get topLeft(){return this.position}get topRight(){return new o.F(this.x+this.width,this.y)}get bottomLeft(){return new o.F(this.x,this.y+this.height)}get bottomRight(){return new o.F(this.x+this.width,this.y+this.height)}get corners(){return[this.topLeft,this.topRight,this.bottomRight,this.bottomLeft]}get pixelPerfect(){return new i(Math.floor(this.x),Math.floor(this.y),Math.ceil(this.width+1),Math.ceil(this.height+1))}constructor(t,e,n,s){if(void 0===e&&(e=0),void 0===n&&(n=0),void 0===s&&(s=0),this.x=0,this.y=0,this.width=0,this.height=0,null!=t){if("number"==typeof t)return this.x=t,this.y=e,this.width=n,void(this.height=s);if(t instanceof o.F)return this.x=t.x,this.y=t.y,void(e instanceof o.F&&(this.width=e.x,this.height=e.y));if(Array.isArray(t))return this.x=t[0],this.y=t[1],this.width=t[2],void(this.height=t[3]);this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height}}transform(t){return new i(this.position.transformAsPoint(t),this.size.transform(t))}transformCorners(t){return this.corners.map((e=>e.transformAsPoint(t)))}expand(t){return new i(this.x-t,this.y-t,this.width+2*t,this.height+2*t)}addSpacing(t){const e=new i(this);return e.left-=t.left,e.top-=t.top,e.right+=t.right,e.bottom+=t.bottom,e}includes(t){return t.x>=this.x&&t.x<=this.x+this.width&&t.y>=this.y&&t.y<=this.y+this.height}intersects(t){return this.left<t.right&&this.right>t.left&&this.top<t.bottom&&this.bottom>t.top}intersection(t){const e=new i;return this.intersects(t)&&(e.left=Math.max(this.left,t.left),e.top=Math.max(this.top,t.top),e.right=Math.min(this.right,t.right),e.bottom=Math.min(this.bottom,t.bottom)),e}toSymbol(){return i.symbol}serialize(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}i.symbol=Symbol.for("@motion-canvas/core/types/Rect")},30204:(t,e,n)=>{"use strict";n.d(e,{I:()=>o.Color});var o=n(5392),s=n(16249);o.Color.symbol=o.Color.prototype.symbol=Symbol.for("@motion-canvas/core/types/Color"),o.Color.lerp=o.Color.prototype.lerp=function(t,e,n,s){void 0===s&&(s="lch"),"string"==typeof t&&(t=new o.Color(t)),"string"==typeof e&&(e=new o.Color(e));const r=t instanceof o.Color,i=e instanceof o.Color;return r||(t=i?e.alpha(0):new o.Color("rgba(0, 0, 0, 0)")),i||(e=r?t.alpha(0):new o.Color("rgba(0, 0, 0, 0)")),(0,o.mix)(t,e,n,s)},o.Color.createLerp=o.Color.prototype.createLerp=t=>(e,n,s)=>o.Color.lerp(e,n,s,t),o.Color.createSignal=function(t,e){void 0===e&&(e=o.Color.lerp);const n=new s.V(t,e);return n.setParser((t=>new o.Color(t))),n.toSignal()},o.Color.prototype.toSymbol=()=>o.Color.symbol,o.Color.prototype.serialize=function(){return this.css()},o.Color.prototype.lerp=function(t,e,n){return o.Color.lerp(this,t,e,n)}},74741:(t,e,n)=>{"use strict";n.d(e,{$:()=>s,X:()=>r});var o=n(29797);function s(t,e){const n=t/180*Math.PI;return 180*o.F.fromRadians(n).transform(e).radians/Math.PI}function r(t,e){return Math.sqrt(e.m11*e.m11+e.m12*e.m12)*t}},98378:(t,e,n)=>{"use strict";n.d(e,{M5:()=>o,Nm:()=>s,WS:()=>a,aP:()=>r,lk:()=>p});var o,s,r,i=n(29797);function p(t,e){return void 0===e&&(e=o.Horizontal|o.Vertical),e&o.Vertical&&(t&s.Top?t=t&~s.Top|s.Bottom:t&s.Bottom&&(t=t&~s.Bottom|s.Top)),e&o.Horizontal&&(t&s.Left?t=t&~s.Left|s.Right:t&s.Right&&(t=t&~s.Right|s.Left)),t}function a(t){if(t===r.Middle)return i.F.zero;let e=0;t&s.Left?e=-1:t&s.Right&&(e=1);let n=0;return t&s.Top?n=-1:t&s.Bottom&&(n=1),new i.F(e,n)}!function(t){t[t.Vertical=1]="Vertical",t[t.Horizontal=2]="Horizontal"}(o||(o={})),function(t){t[t.Top=4]="Top",t[t.Bottom=8]="Bottom",t[t.Left=16]="Left",t[t.Right=32]="Right"}(s||(s={})),function(t){t[t.Middle=3]="Middle",t[t.Top=5]="Top",t[t.Bottom=9]="Bottom",t[t.Left=18]="Left",t[t.Right=34]="Right",t[t.TopLeft=20]="TopLeft",t[t.TopRight=36]="TopRight",t[t.BottomLeft=24]="BottomLeft",t[t.BottomRight=40]="BottomRight"}(r||(r={}))},43188:(t,e,n)=>{"use strict";n.d(e,{K:()=>r});var o=n(13170),s=n(46096);class r{static createSignal(t,e){return void 0===e&&(e=r.lerp),new s.N(["top","right","bottom","left"],(t=>new r(t)),t,e).toSignal()}static lerp(t,e,n){return new r((0,o.UI)(t.top,e.top,n),(0,o.UI)(t.right,e.right,n),(0,o.UI)(t.bottom,e.bottom,n),(0,o.UI)(t.left,e.left,n))}get x(){return this.left+this.right}get y(){return this.top+this.bottom}constructor(t,e,n,o){if(void 0===t&&(t=0),this.top=0,this.right=0,this.bottom=0,this.left=0,null!=t){if(Array.isArray(t)&&(o=t[3],n=t[2],e=t[1],t=t[0]),"number"==typeof t)return this.top=t,this.right=void 0!==e?e:t,this.bottom=void 0!==n?n:t,void(this.left=void 0!==o?o:void 0!==e?e:t);this.top=t.top,this.right=t.right,this.bottom=t.bottom,this.left=t.left}}lerp(t,e){return r.lerp(this,t,e)}scale(t){return new r(this.top*t,this.right*t,this.bottom*t,this.left*t)}addScalar(t){return new r(this.top+t,this.right+t,this.bottom+t,this.left+t)}toSymbol(){return r.symbol}serialize(){return{top:this.top,right:this.right,bottom:this.bottom,left:this.left}}}r.symbol=Symbol.for("@motion-canvas/core/types/Spacing")},57292:(t,e,n)=>{"use strict";n.d(e,{I:()=>o,P:()=>s});const o=1e-6;function s(t){return t&&"object"==typeof t&&"toSymbol"in t}},29797:(t,e,n)=>{"use strict";n.d(e,{F:()=>p});var o=n(13170),s=n(98378),r=n(57292),i=n(46096);class p{static createSignal(t,e,n){return void 0===e&&(e=p.lerp),new i.N(["x","y"],(t=>new p(t)),t,e,n).toSignal()}static lerp(t,e,n){let s,r;return"number"==typeof n?s=r=n:(s=n.x,r=n.y),new p((0,o.UI)(t.x,e.x,s),(0,o.UI)(t.y,e.y,r))}static arcLerp(t,e,n,s,r){return void 0===s&&(s=!1),r??(r=t.sub(e).ctg),p.lerp(t,e,(0,o.Vz)(n,s,r))}static fromOrigin(t){const e=new p;return t===s.aP.Middle||(t&s.Nm.Left?e.x=-1:t&s.Nm.Right&&(e.x=1),t&s.Nm.Top?e.y=-1:t&s.Nm.Bottom&&(e.y=1)),e}static fromScalar(t){return new p(t,t)}static fromRadians(t){return new p(Math.cos(t),Math.sin(t))}static radians(t,e){return Math.atan2(e,t)}static degrees(t,e){return 180*p.radians(t,e)/Math.PI}static magnitude(t,e){return Math.sqrt(t*t+e*e)}static squaredMagnitude(t,e){return t*t+e*e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}get magnitude(){return p.magnitude(this.x,this.y)}get squaredMagnitude(){return p.squaredMagnitude(this.x,this.y)}get normalized(){return this.scale(1/p.magnitude(this.x,this.y))}get safe(){return new p(isNaN(this.x)?0:this.x,isNaN(this.y)?0:this.y)}get flipped(){return new p(-this.x,-this.y)}get floored(){return new p(Math.floor(this.x),Math.floor(this.y))}get perpendicular(){return new p(this.y,-this.x)}get radians(){return p.radians(this.x,this.y)}get degrees(){return p.degrees(this.x,this.y)}get ctg(){return this.x/this.y}constructor(t,e){if(this.x=0,this.y=0,null!=t){if("object"!=typeof t)return this.x=t,void(this.y=e??t);if(Array.isArray(t))return this.x=t[0],void(this.y=t[1]);if("width"in t)return this.x=t.width,void(this.y=t.height);this.x=t.x,this.y=t.y}}lerp(t,e){return p.lerp(this,t,e)}getOriginOffset(t){const e=p.fromOrigin(t);return e.x*=this.x/2,e.y*=this.y/2,e}scale(t){return new p(this.x*t,this.y*t)}transformAsPoint(t){return new p(this.x*t.m11+this.y*t.m21+t.m41,this.x*t.m12+this.y*t.m22+t.m42)}transform(t){return new p(this.x*t.m11+this.y*t.m21,this.x*t.m12+this.y*t.m22)}mul(t){const e=new p(t);return new p(this.x*e.x,this.y*e.y)}div(t){const e=new p(t);return new p(this.x/e.x,this.y/e.y)}add(t){const e=new p(t);return new p(this.x+e.x,this.y+e.y)}sub(t){const e=new p(t);return new p(this.x-e.x,this.y-e.y)}dot(t){const e=new p(t);return this.x*e.x+this.y*e.y}addX(t){return new p(this.x+t,this.y)}addY(t){return new p(this.x,this.y+t)}toSymbol(){return p.symbol}serialize(){return{x:this.x,y:this.y}}exactlyEquals(t){return this.x===t.x&&this.y===t.y}equals(t,e){return void 0===e&&(e=r.I),Math.abs(this.x-t.x)<=e+Number.EPSILON&&Math.abs(this.y-t.y)<=e+Number.EPSILON}}p.symbol=Symbol.for("@motion-canvas/core/types/Vector2"),p.zero=new p,p.one=new p(1,1),p.right=new p(1,0),p.left=new p(-1,0),p.up=new p(0,1),p.down=new p(0,-1)},49111:(t,e,n)=>{"use strict";n.d(e,{t:()=>o});class o extends Error{constructor(t,e){super(t),this.remarks=e}}},15649:(t,e,n)=>{"use strict";n.d(e,{L:()=>o});class o{constructor(){this.resolveCurrent=null,this.current=null}async acquire(){for(;this.current;)await this.current;this.current=new Promise((t=>{this.resolveCurrent=t}))}release(){var t;this.current=null,null==(t=this.resolveCurrent)||t.call(this),this.resolveCurrent=null}}},15688:(t,e,n)=>{"use strict";function o(t){return t[0].toUpperCase()+t.slice(1)}n.d(e,{k:()=>o})},90031:(t,e,n)=>{"use strict";function o(t){return{message:t.message,stack:t.stack,remarks:t.remarks}}n.d(e,{d:()=>o})},1119:(t,e,n)=>{"use strict";function o(t,e){void 0===e&&(e=document.createElement("canvas"));const n=e.getContext("2d",t);if(!n)throw new Error("Could not create a 2D context.");return n}n.d(e,{f:()=>o})},37762:(t,e,n)=>{"use strict";function o(t,e,n){let o=0,s=t;void 0!==e&&(o=t,s=e),n=void 0===n?o<s?1:-1:n;const r=[];let i=Math.max(Math.ceil((s-o)/n),0),p=0;for(;i--;)r[p++]=o,o+=n;return r}n.d(e,{w:()=>o})},97715:(t,e,n)=>{"use strict";n.d(e,{Mh:()=>i,te:()=>s,wA:()=>r});const o=[];function s(){const t=o.at(-1);if(!t)throw new Error("The playback is not available in the current context.");return t}function r(t){o.push(t)}function i(t){if(o.pop()!==t)throw new Error("startPlayback/endPlayback were called out of order.")}},3163:(t,e,n)=>{"use strict";n.d(e,{$r:()=>s,DO:()=>r,ug:()=>i,vl:()=>a,wL:()=>p});const o=[];function s(){const t=o.at(-1);if(!t)throw new Error("The scene is not available in the current context.");return t}function r(t){o.push(t)}function i(t){if(o.pop()!==t)throw new Error("startScene/endScene were called out of order.")}function p(){var t;return(null==(t=o.at(-1))?void 0:t.logger)??console}function a(){s().enterCanTransitionOut()}},56632:(t,e,n)=>{"use strict";n.d(e,{h$:()=>i,kw:()=>p,nn:()=>r});var o=n(49111);const s=[];function r(){const t=s.at(-1);if(!t)throw new o.t("The thread is not available in the current context.","<p><code>useThread()</code> can only be called from within generator functions.\n      It&#39;s not available during rendering.</p>\n");return t}function i(t){s.push(t)}function p(t){if(s.pop()!==t)throw new Error("startThread/endThread was called out of order.")}},64415:(t,e,n)=>{"use strict";n.r(e),n.d(e,{default:()=>h});var o=n(2784),s=n(42104),r=n(49072),i=n(76183),p=n(31930),a=n(88617),c=n(80068),l=n(57708),u=n(70532),m=n(37390),d=n(89741);function h(t){var e,n,h;let{route:y}=t;const f=(0,a.RU)(y.projectId),k=f[y.reflectionId],[w]=(0,l.mN)(),g=(0,d.Z)(),M=(0,o.useMemo)((()=>{const t=[];if(!k.groups||k.kind===m.W.Project)return t;for(const e of k.groups)if(t.push({value:e.title,id:e.title,level:2}),e.children)for(const n of e.children){const e=f[n];!e||e.hasOwnPage||g&&!(0,l.It)(w,e)||t.push({value:`<code>${e.name}</code>`,id:e.anchor,level:3})}return t}),[w,k,g]);return o.createElement(i.b,{content:{frontMatter:{},metadata:{id:k.docId,unversionedId:k.docId,version:"current",title:k.name,description:null==(e=k.comment)?void 0:e.summaryText,slug:k.url,permalink:k.url,editUrl:(null==(n=k.sources)||null==(h=n[0])?void 0:h.url)??void 0,draft:!1,tags:[],frontMatter:{},next:k.next,previous:k.previous},toc:M,assets:{}}},o.createElement(c.Y0,null,o.createElement(s.Z,null),o.createElement(u.Z,null,o.createElement(r.Z,null,o.createElement(p.Z,{reflection:k})))))}},24983:(t,e,n)=>{"use strict";n.d(e,{Z:()=>gjt});var o={};n.r(o),n.d(o,{content_0_0:()=>a,content_0_10:()=>w,content_0_100:()=>te,content_0_1000:()=>Fk,content_0_1002:()=>Bk,content_0_1004:()=>Ok,content_0_1006:()=>Uk,content_0_1008:()=>Vk,content_0_1010:()=>$k,content_0_1012:()=>Yk,content_0_1014:()=>Qk,content_0_1016:()=>ew,content_0_1018:()=>ow,content_0_102:()=>ne,content_0_1020:()=>rw,content_0_1022:()=>pw,content_0_1024:()=>cw,content_0_1026:()=>uw,content_0_1028:()=>dw,content_0_1030:()=>yw,content_0_1032:()=>kw,content_0_1034:()=>gw,content_0_1036:()=>Dw,content_0_1038:()=>Xw,content_0_104:()=>se,content_0_1040:()=>vw,content_0_1042:()=>Tw,content_0_1044:()=>Lw,content_0_1046:()=>Nw,content_0_1048:()=>Rw,content_0_1050:()=>Aw,content_0_1052:()=>Pw,content_0_1054:()=>Fw,content_0_1056:()=>Bw,content_0_1058:()=>Ow,content_0_106:()=>ie,content_0_1060:()=>Uw,content_0_1062:()=>Vw,content_0_1064:()=>$w,content_0_108:()=>ae,content_0_110:()=>le,content_0_112:()=>me,content_0_114:()=>he,content_0_116:()=>fe,content_0_118:()=>we,content_0_12:()=>M,content_0_120:()=>Me,content_0_122:()=>_e,content_0_124:()=>xe,content_0_126:()=>Ce,content_0_128:()=>be,content_0_130:()=>Ze,content_0_132:()=>Se,content_0_134:()=>ze,content_0_136:()=>Ee,content_0_138:()=>Ie,content_0_14:()=>_,content_0_140:()=>We,content_0_142:()=>Ge,content_0_144:()=>je,content_0_146:()=>qe,content_0_148:()=>He,content_0_150:()=>Je,content_0_152:()=>Ke,content_0_154:()=>tn,content_0_156:()=>nn,content_0_158:()=>sn,content_0_16:()=>x,content_0_160:()=>pn,content_0_162:()=>cn,content_0_164:()=>un,content_0_166:()=>dn,content_0_168:()=>yn,content_0_170:()=>kn,content_0_172:()=>gn,content_0_174:()=>Dn,content_0_176:()=>Xn,content_0_178:()=>vn,content_0_18:()=>C,content_0_180:()=>Tn,content_0_182:()=>Ln,content_0_184:()=>Nn,content_0_186:()=>Rn,content_0_188:()=>An,content_0_190:()=>Pn,content_0_192:()=>Fn,content_0_194:()=>Bn,content_0_196:()=>On,content_0_198:()=>Un,content_0_2:()=>l,content_0_20:()=>b,content_0_200:()=>Vn,content_0_202:()=>$n,content_0_204:()=>Yn,content_0_206:()=>Qn,content_0_208:()=>eo,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>po,content_0_216:()=>co,content_0_218:()=>uo,content_0_22:()=>Z,content_0_220:()=>ho,content_0_222:()=>fo,content_0_224:()=>wo,content_0_226:()=>Mo,content_0_228:()=>_o,content_0_230:()=>xo,content_0_232:()=>Co,content_0_234:()=>bo,content_0_236:()=>Zo,content_0_238:()=>So,content_0_24:()=>S,content_0_240:()=>zo,content_0_242:()=>Eo,content_0_244:()=>Io,content_0_246:()=>Wo,content_0_248:()=>Go,content_0_250:()=>jo,content_0_252:()=>qo,content_0_254:()=>Ho,content_0_256:()=>Jo,content_0_258:()=>Ko,content_0_26:()=>z,content_0_260:()=>ts,content_0_262:()=>ns,content_0_264:()=>ss,content_0_266:()=>is,content_0_268:()=>as,content_0_270:()=>ls,content_0_272:()=>ms,content_0_274:()=>hs,content_0_276:()=>fs,content_0_278:()=>ws,content_0_28:()=>E,content_0_280:()=>Ms,content_0_282:()=>_s,content_0_284:()=>xs,content_0_286:()=>Cs,content_0_288:()=>bs,content_0_290:()=>Zs,content_0_292:()=>Ss,content_0_294:()=>zs,content_0_296:()=>Es,content_0_298:()=>Is,content_0_30:()=>I,content_0_300:()=>Ws,content_0_302:()=>Gs,content_0_304:()=>js,content_0_306:()=>qs,content_0_308:()=>Hs,content_0_310:()=>Js,content_0_312:()=>Ks,content_0_314:()=>tr,content_0_316:()=>nr,content_0_318:()=>sr,content_0_32:()=>W,content_0_320:()=>ir,content_0_322:()=>ar,content_0_324:()=>lr,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>fr,content_0_332:()=>wr,content_0_334:()=>Mr,content_0_336:()=>_r,content_0_338:()=>xr,content_0_34:()=>G,content_0_340:()=>Cr,content_0_342:()=>br,content_0_344:()=>Zr,content_0_346:()=>Sr,content_0_348:()=>zr,content_0_350:()=>Er,content_0_352:()=>Ir,content_0_354:()=>Wr,content_0_356:()=>Gr,content_0_358:()=>jr,content_0_36:()=>j,content_0_360:()=>qr,content_0_362:()=>Hr,content_0_364:()=>Jr,content_0_366:()=>Kr,content_0_368:()=>ti,content_0_370:()=>ni,content_0_372:()=>si,content_0_374:()=>ii,content_0_376:()=>ai,content_0_378:()=>li,content_0_38:()=>q,content_0_380:()=>mi,content_0_382:()=>hi,content_0_384:()=>fi,content_0_386:()=>wi,content_0_388:()=>Mi,content_0_390:()=>_i,content_0_392:()=>xi,content_0_394:()=>Ci,content_0_396:()=>bi,content_0_398:()=>Zi,content_0_4:()=>m,content_0_40:()=>H,content_0_400:()=>Si,content_0_402:()=>zi,content_0_404:()=>Ei,content_0_406:()=>Ii,content_0_408:()=>Wi,content_0_410:()=>Gi,content_0_412:()=>ji,content_0_414:()=>qi,content_0_416:()=>Hi,content_0_418:()=>Ji,content_0_42:()=>J,content_0_420:()=>Ki,content_0_422:()=>tp,content_0_424:()=>np,content_0_426:()=>sp,content_0_428:()=>ip,content_0_430:()=>ap,content_0_432:()=>lp,content_0_434:()=>mp,content_0_436:()=>hp,content_0_438:()=>fp,content_0_44:()=>K,content_0_440:()=>wp,content_0_442:()=>Mp,content_0_444:()=>_p,content_0_446:()=>xp,content_0_448:()=>Cp,content_0_450:()=>bp,content_0_452:()=>Zp,content_0_454:()=>Sp,content_0_456:()=>zp,content_0_458:()=>Ep,content_0_46:()=>tt,content_0_460:()=>Ip,content_0_462:()=>Wp,content_0_464:()=>Gp,content_0_466:()=>jp,content_0_468:()=>qp,content_0_470:()=>Hp,content_0_472:()=>Jp,content_0_474:()=>Kp,content_0_476:()=>ta,content_0_478:()=>na,content_0_48:()=>nt,content_0_480:()=>sa,content_0_482:()=>ia,content_0_484:()=>aa,content_0_486:()=>la,content_0_488:()=>ma,content_0_490:()=>ha,content_0_492:()=>fa,content_0_494:()=>wa,content_0_496:()=>Ma,content_0_498:()=>_a,content_0_50:()=>st,content_0_500:()=>xa,content_0_502:()=>Ca,content_0_504:()=>ba,content_0_506:()=>Za,content_0_508:()=>Sa,content_0_510:()=>za,content_0_512:()=>Ea,content_0_514:()=>Ia,content_0_516:()=>Wa,content_0_518:()=>Ga,content_0_52:()=>it,content_0_520:()=>ja,content_0_522:()=>qa,content_0_524:()=>Ha,content_0_526:()=>Ja,content_0_528:()=>Ka,content_0_530:()=>tc,content_0_532:()=>nc,content_0_534:()=>sc,content_0_536:()=>ic,content_0_538:()=>ac,content_0_54:()=>at,content_0_540:()=>lc,content_0_542:()=>mc,content_0_544:()=>hc,content_0_546:()=>fc,content_0_548:()=>wc,content_0_550:()=>Mc,content_0_552:()=>_c,content_0_554:()=>xc,content_0_556:()=>Cc,content_0_558:()=>bc,content_0_56:()=>lt,content_0_560:()=>Zc,content_0_562:()=>Sc,content_0_564:()=>zc,content_0_566:()=>Ec,content_0_568:()=>Ic,content_0_570:()=>Wc,content_0_572:()=>Gc,content_0_574:()=>jc,content_0_576:()=>qc,content_0_578:()=>Hc,content_0_58:()=>mt,content_0_580:()=>Jc,content_0_582:()=>Kc,content_0_584:()=>tl,content_0_586:()=>nl,content_0_588:()=>sl,content_0_590:()=>il,content_0_592:()=>al,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>fl,content_0_602:()=>wl,content_0_604:()=>Ml,content_0_606:()=>_l,content_0_608:()=>xl,content_0_610:()=>Cl,content_0_612:()=>bl,content_0_614:()=>Zl,content_0_616:()=>Sl,content_0_618:()=>zl,content_0_62:()=>ft,content_0_620:()=>El,content_0_622:()=>Il,content_0_624:()=>Wl,content_0_626:()=>Gl,content_0_628:()=>jl,content_0_630:()=>ql,content_0_632:()=>Hl,content_0_634:()=>Jl,content_0_636:()=>Kl,content_0_638:()=>tu,content_0_64:()=>wt,content_0_640:()=>nu,content_0_642:()=>su,content_0_644:()=>iu,content_0_646:()=>au,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>fu,content_0_656:()=>wu,content_0_658:()=>Mu,content_0_66:()=>Mt,content_0_660:()=>_u,content_0_662:()=>xu,content_0_664:()=>Cu,content_0_666:()=>bu,content_0_668:()=>Zu,content_0_670:()=>Su,content_0_672:()=>zu,content_0_674:()=>Eu,content_0_676:()=>Iu,content_0_678:()=>Wu,content_0_68:()=>_t,content_0_680:()=>Gu,content_0_682:()=>ju,content_0_684:()=>qu,content_0_686:()=>Hu,content_0_688:()=>Ju,content_0_690:()=>Ku,content_0_692:()=>tm,content_0_694:()=>nm,content_0_696:()=>sm,content_0_698:()=>im,content_0_70:()=>xt,content_0_700:()=>am,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>fm,content_0_710:()=>wm,content_0_712:()=>Mm,content_0_714:()=>_m,content_0_716:()=>xm,content_0_718:()=>Cm,content_0_72:()=>Ct,content_0_720:()=>bm,content_0_722:()=>Zm,content_0_724:()=>Sm,content_0_726:()=>zm,content_0_728:()=>Em,content_0_730:()=>Im,content_0_732:()=>Wm,content_0_734:()=>Gm,content_0_736:()=>jm,content_0_738:()=>qm,content_0_74:()=>bt,content_0_740:()=>Hm,content_0_742:()=>Jm,content_0_744:()=>Km,content_0_746:()=>td,content_0_748:()=>nd,content_0_750:()=>sd,content_0_752:()=>id,content_0_754:()=>ad,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>Zt,content_0_760:()=>hd,content_0_762:()=>fd,content_0_764:()=>wd,content_0_766:()=>Md,content_0_768:()=>_d,content_0_770:()=>xd,content_0_772:()=>Cd,content_0_774:()=>bd,content_0_776:()=>Zd,content_0_778:()=>Sd,content_0_78:()=>St,content_0_780:()=>zd,content_0_782:()=>Ed,content_0_784:()=>Id,content_0_786:()=>Wd,content_0_788:()=>Gd,content_0_790:()=>jd,content_0_792:()=>qd,content_0_794:()=>Hd,content_0_796:()=>Jd,content_0_798:()=>Kd,content_0_8:()=>f,content_0_80:()=>zt,content_0_800:()=>th,content_0_802:()=>nh,content_0_804:()=>sh,content_0_806:()=>ih,content_0_808:()=>ah,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>fh,content_0_818:()=>wh,content_0_82:()=>Et,content_0_820:()=>Mh,content_0_822:()=>_h,content_0_824:()=>xh,content_0_826:()=>Ch,content_0_828:()=>bh,content_0_830:()=>Zh,content_0_832:()=>Sh,content_0_834:()=>zh,content_0_836:()=>Eh,content_0_838:()=>Ih,content_0_84:()=>It,content_0_840:()=>Wh,content_0_842:()=>Gh,content_0_844:()=>jh,content_0_846:()=>qh,content_0_848:()=>Hh,content_0_850:()=>Jh,content_0_852:()=>Kh,content_0_854:()=>ty,content_0_856:()=>ny,content_0_858:()=>sy,content_0_86:()=>Wt,content_0_860:()=>iy,content_0_862:()=>ay,content_0_864:()=>ly,content_0_866:()=>my,content_0_868:()=>hy,content_0_870:()=>fy,content_0_872:()=>wy,content_0_874:()=>My,content_0_876:()=>_y,content_0_878:()=>xy,content_0_88:()=>Gt,content_0_880:()=>Cy,content_0_882:()=>by,content_0_884:()=>Zy,content_0_886:()=>Sy,content_0_888:()=>zy,content_0_890:()=>Ey,content_0_892:()=>Iy,content_0_894:()=>Wy,content_0_896:()=>Gy,content_0_898:()=>jy,content_0_90:()=>jt,content_0_900:()=>qy,content_0_902:()=>Hy,content_0_904:()=>Jy,content_0_906:()=>Ky,content_0_908:()=>tf,content_0_910:()=>nf,content_0_912:()=>sf,content_0_914:()=>pf,content_0_916:()=>cf,content_0_918:()=>uf,content_0_92:()=>qt,content_0_920:()=>df,content_0_922:()=>yf,content_0_924:()=>kf,content_0_926:()=>gf,content_0_928:()=>Df,content_0_930:()=>Xf,content_0_932:()=>vf,content_0_934:()=>Tf,content_0_936:()=>Lf,content_0_938:()=>Nf,content_0_94:()=>Ht,content_0_940:()=>Rf,content_0_942:()=>Af,content_0_944:()=>Pf,content_0_946:()=>Ff,content_0_948:()=>Bf,content_0_950:()=>Of,content_0_952:()=>Uf,content_0_954:()=>Vf,content_0_956:()=>$f,content_0_958:()=>Yf,content_0_96:()=>Jt,content_0_960:()=>Qf,content_0_962:()=>ek,content_0_964:()=>ok,content_0_966:()=>rk,content_0_968:()=>pk,content_0_970:()=>ck,content_0_972:()=>uk,content_0_974:()=>dk,content_0_976:()=>yk,content_0_978:()=>kk,content_0_98:()=>Kt,content_0_980:()=>gk,content_0_982:()=>Dk,content_0_984:()=>Xk,content_0_986:()=>vk,content_0_988:()=>Tk,content_0_990:()=>Lk,content_0_992:()=>Nk,content_0_994:()=>Rk,content_0_996:()=>Ak,content_0_998:()=>Pk,content_2251_0:()=>Yw,content_2251_10:()=>pg,content_2251_100:()=>OM,content_2251_1000:()=>vP,content_2251_1002:()=>TP,content_2251_1004:()=>LP,content_2251_1006:()=>NP,content_2251_1008:()=>RP,content_2251_1010:()=>AP,content_2251_1012:()=>PP,content_2251_1014:()=>FP,content_2251_1016:()=>BP,content_2251_1018:()=>OP,content_2251_102:()=>UM,content_2251_1020:()=>UP,content_2251_1022:()=>VP,content_2251_1024:()=>$P,content_2251_1026:()=>YP,content_2251_1028:()=>QP,content_2251_1030:()=>eI,content_2251_1032:()=>oI,content_2251_1034:()=>rI,content_2251_1036:()=>pI,content_2251_1038:()=>cI,content_2251_104:()=>VM,content_2251_1040:()=>uI,content_2251_1042:()=>dI,content_2251_1044:()=>yI,content_2251_1046:()=>kI,content_2251_1048:()=>gI,content_2251_1050:()=>DI,content_2251_1052:()=>XI,content_2251_1054:()=>vI,content_2251_1056:()=>TI,content_2251_1058:()=>LI,content_2251_106:()=>$M,content_2251_1060:()=>NI,content_2251_1062:()=>RI,content_2251_1064:()=>AI,content_2251_1066:()=>PI,content_2251_1068:()=>FI,content_2251_1070:()=>BI,content_2251_1072:()=>OI,content_2251_1074:()=>UI,content_2251_1076:()=>VI,content_2251_1078:()=>$I,content_2251_108:()=>YM,content_2251_1080:()=>YI,content_2251_1082:()=>QI,content_2251_1084:()=>eF,content_2251_1086:()=>oF,content_2251_1088:()=>rF,content_2251_1090:()=>pF,content_2251_1092:()=>cF,content_2251_1094:()=>uF,content_2251_1096:()=>dF,content_2251_1098:()=>yF,content_2251_110:()=>QM,content_2251_1100:()=>kF,content_2251_1102:()=>gF,content_2251_1104:()=>DF,content_2251_1106:()=>XF,content_2251_1108:()=>vF,content_2251_1110:()=>TF,content_2251_1112:()=>LF,content_2251_1114:()=>NF,content_2251_1116:()=>RF,content_2251_1118:()=>AF,content_2251_112:()=>eD,content_2251_1120:()=>PF,content_2251_1122:()=>FF,content_2251_1124:()=>BF,content_2251_1126:()=>OF,content_2251_1128:()=>UF,content_2251_1130:()=>VF,content_2251_1132:()=>$F,content_2251_1134:()=>YF,content_2251_1136:()=>QF,content_2251_1138:()=>eW,content_2251_114:()=>oD,content_2251_1140:()=>oW,content_2251_1142:()=>rW,content_2251_1144:()=>pW,content_2251_1146:()=>cW,content_2251_1148:()=>uW,content_2251_1150:()=>dW,content_2251_1152:()=>yW,content_2251_1154:()=>kW,content_2251_1156:()=>gW,content_2251_1158:()=>DW,content_2251_116:()=>rD,content_2251_1160:()=>XW,content_2251_1162:()=>vW,content_2251_1164:()=>TW,content_2251_1166:()=>LW,content_2251_1168:()=>NW,content_2251_1170:()=>RW,content_2251_1172:()=>AW,content_2251_1174:()=>PW,content_2251_1176:()=>FW,content_2251_1178:()=>BW,content_2251_118:()=>pD,content_2251_1180:()=>OW,content_2251_1182:()=>UW,content_2251_1184:()=>VW,content_2251_1186:()=>$W,content_2251_1188:()=>YW,content_2251_1190:()=>QW,content_2251_1192:()=>eB,content_2251_1194:()=>oB,content_2251_1196:()=>rB,content_2251_1198:()=>pB,content_2251_12:()=>cg,content_2251_120:()=>cD,content_2251_1200:()=>cB,content_2251_1202:()=>uB,content_2251_1204:()=>dB,content_2251_1206:()=>yB,content_2251_1208:()=>kB,content_2251_1210:()=>gB,content_2251_1212:()=>DB,content_2251_1214:()=>XB,content_2251_1216:()=>vB,content_2251_1218:()=>TB,content_2251_122:()=>uD,content_2251_1220:()=>LB,content_2251_1222:()=>NB,content_2251_1224:()=>RB,content_2251_1226:()=>AB,content_2251_1228:()=>PB,content_2251_1230:()=>FB,content_2251_1232:()=>BB,content_2251_1234:()=>OB,content_2251_1236:()=>UB,content_2251_1238:()=>VB,content_2251_124:()=>dD,content_2251_1240:()=>$B,content_2251_1242:()=>YB,content_2251_1244:()=>QB,content_2251_1246:()=>eG,content_2251_1248:()=>oG,content_2251_1250:()=>rG,content_2251_1252:()=>pG,content_2251_1254:()=>cG,content_2251_1256:()=>uG,content_2251_1258:()=>dG,content_2251_126:()=>yD,content_2251_1260:()=>yG,content_2251_1262:()=>kG,content_2251_1264:()=>gG,content_2251_1266:()=>DG,content_2251_1268:()=>XG,content_2251_1270:()=>vG,content_2251_1272:()=>TG,content_2251_1274:()=>LG,content_2251_1276:()=>NG,content_2251_1278:()=>RG,content_2251_128:()=>kD,content_2251_1280:()=>AG,content_2251_1282:()=>PG,content_2251_1284:()=>FG,content_2251_1286:()=>BG,content_2251_1288:()=>OG,content_2251_1290:()=>UG,content_2251_1292:()=>VG,content_2251_1294:()=>$G,content_2251_1296:()=>YG,content_2251_1298:()=>QG,content_2251_130:()=>gD,content_2251_1300:()=>eO,content_2251_1302:()=>oO,content_2251_1304:()=>rO,content_2251_1306:()=>pO,content_2251_1308:()=>cO,content_2251_1310:()=>uO,content_2251_1312:()=>dO,content_2251_1314:()=>yO,content_2251_1316:()=>kO,content_2251_1318:()=>gO,content_2251_132:()=>DD,content_2251_1320:()=>DO,content_2251_1322:()=>XO,content_2251_1324:()=>vO,content_2251_1326:()=>TO,content_2251_1328:()=>LO,content_2251_1330:()=>NO,content_2251_1332:()=>RO,content_2251_1334:()=>AO,content_2251_1336:()=>PO,content_2251_1338:()=>FO,content_2251_134:()=>XD,content_2251_1340:()=>BO,content_2251_1342:()=>OO,content_2251_1344:()=>UO,content_2251_1346:()=>VO,content_2251_1348:()=>$O,content_2251_1350:()=>YO,content_2251_1352:()=>QO,content_2251_1354:()=>ej,content_2251_1356:()=>oj,content_2251_1358:()=>rj,content_2251_136:()=>vD,content_2251_1360:()=>pj,content_2251_1362:()=>cj,content_2251_1364:()=>uj,content_2251_1366:()=>dj,content_2251_1368:()=>yj,content_2251_1370:()=>kj,content_2251_1372:()=>gj,content_2251_1374:()=>Dj,content_2251_1376:()=>Xj,content_2251_1378:()=>vj,content_2251_138:()=>TD,content_2251_1380:()=>Tj,content_2251_1382:()=>Lj,content_2251_1384:()=>Nj,content_2251_1386:()=>Rj,content_2251_1388:()=>Aj,content_2251_1390:()=>Pj,content_2251_1392:()=>Fj,content_2251_1394:()=>Bj,content_2251_1396:()=>Oj,content_2251_1398:()=>Uj,content_2251_14:()=>ug,content_2251_140:()=>LD,content_2251_1400:()=>Vj,content_2251_1402:()=>$j,content_2251_1404:()=>Yj,content_2251_1406:()=>Qj,content_2251_1408:()=>eU,content_2251_1410:()=>oU,content_2251_1412:()=>rU,content_2251_1414:()=>pU,content_2251_1416:()=>cU,content_2251_1418:()=>uU,content_2251_142:()=>ND,content_2251_1420:()=>dU,content_2251_1422:()=>yU,content_2251_1424:()=>kU,content_2251_1426:()=>gU,content_2251_1428:()=>DU,content_2251_1430:()=>XU,content_2251_1432:()=>vU,content_2251_1434:()=>TU,content_2251_1436:()=>LU,content_2251_1438:()=>NU,content_2251_144:()=>RD,content_2251_1440:()=>RU,content_2251_1442:()=>AU,content_2251_1444:()=>PU,content_2251_1446:()=>FU,content_2251_1448:()=>BU,content_2251_1450:()=>OU,content_2251_1452:()=>UU,content_2251_1454:()=>VU,content_2251_1456:()=>$U,content_2251_1458:()=>YU,content_2251_146:()=>AD,content_2251_1460:()=>QU,content_2251_1462:()=>eq,content_2251_1464:()=>oq,content_2251_1466:()=>rq,content_2251_1468:()=>pq,content_2251_1470:()=>cq,content_2251_1472:()=>uq,content_2251_1474:()=>dq,content_2251_1476:()=>yq,content_2251_1478:()=>kq,content_2251_148:()=>PD,content_2251_1480:()=>gq,content_2251_1482:()=>Dq,content_2251_1484:()=>Xq,content_2251_1486:()=>vq,content_2251_1488:()=>Tq,content_2251_1490:()=>Lq,content_2251_1492:()=>Nq,content_2251_1494:()=>Rq,content_2251_1496:()=>Aq,content_2251_1498:()=>Pq,content_2251_150:()=>FD,content_2251_1500:()=>Fq,content_2251_1502:()=>Bq,content_2251_1504:()=>Oq,content_2251_1506:()=>Uq,content_2251_1508:()=>Vq,content_2251_1510:()=>$q,content_2251_1512:()=>Yq,content_2251_1514:()=>Qq,content_2251_1516:()=>eV,content_2251_1518:()=>oV,content_2251_152:()=>BD,content_2251_1520:()=>rV,content_2251_1522:()=>pV,content_2251_1524:()=>cV,content_2251_1526:()=>uV,content_2251_1528:()=>dV,content_2251_1530:()=>yV,content_2251_1532:()=>kV,content_2251_1534:()=>gV,content_2251_1536:()=>DV,content_2251_1538:()=>XV,content_2251_154:()=>OD,content_2251_1540:()=>vV,content_2251_1542:()=>TV,content_2251_1544:()=>LV,content_2251_1546:()=>NV,content_2251_1548:()=>RV,content_2251_1550:()=>AV,content_2251_1552:()=>PV,content_2251_1554:()=>FV,content_2251_1556:()=>BV,content_2251_1558:()=>OV,content_2251_156:()=>UD,content_2251_1560:()=>UV,content_2251_1562:()=>VV,content_2251_1564:()=>$V,content_2251_1566:()=>YV,content_2251_1568:()=>QV,content_2251_1570:()=>eH,content_2251_1572:()=>oH,content_2251_1574:()=>rH,content_2251_1576:()=>pH,content_2251_1578:()=>cH,content_2251_158:()=>VD,content_2251_1580:()=>uH,content_2251_1582:()=>dH,content_2251_1584:()=>yH,content_2251_1586:()=>kH,content_2251_1588:()=>gH,content_2251_1590:()=>DH,content_2251_1592:()=>XH,content_2251_1594:()=>vH,content_2251_1596:()=>TH,content_2251_1598:()=>LH,content_2251_16:()=>dg,content_2251_160:()=>$D,content_2251_1600:()=>NH,content_2251_1602:()=>RH,content_2251_1604:()=>AH,content_2251_1606:()=>PH,content_2251_1608:()=>FH,content_2251_1610:()=>BH,content_2251_1612:()=>OH,content_2251_1614:()=>UH,content_2251_1616:()=>VH,content_2251_1618:()=>$H,content_2251_162:()=>YD,content_2251_1620:()=>YH,content_2251_1622:()=>QH,content_2251_1624:()=>e$,content_2251_1626:()=>o$,content_2251_1628:()=>r$,content_2251_1630:()=>p$,content_2251_1632:()=>c$,content_2251_1634:()=>u$,content_2251_1636:()=>d$,content_2251_1638:()=>y$,content_2251_164:()=>QD,content_2251_1640:()=>k$,content_2251_1642:()=>g$,content_2251_1644:()=>D$,content_2251_1646:()=>X$,content_2251_1648:()=>v$,content_2251_1650:()=>T$,content_2251_1652:()=>L$,content_2251_1654:()=>N$,content_2251_1656:()=>R$,content_2251_1658:()=>A$,content_2251_166:()=>e_,content_2251_1660:()=>P$,content_2251_1662:()=>F$,content_2251_1664:()=>B$,content_2251_1666:()=>O$,content_2251_1668:()=>U$,content_2251_1670:()=>V$,content_2251_1672:()=>$$,content_2251_1674:()=>Y$,content_2251_1676:()=>Q$,content_2251_1678:()=>eJ,content_2251_168:()=>o_,content_2251_1680:()=>oJ,content_2251_1682:()=>rJ,content_2251_1684:()=>pJ,content_2251_1686:()=>cJ,content_2251_1688:()=>uJ,content_2251_1690:()=>dJ,content_2251_1692:()=>yJ,content_2251_1694:()=>kJ,content_2251_1696:()=>gJ,content_2251_1698:()=>DJ,content_2251_170:()=>r_,content_2251_1700:()=>XJ,content_2251_1702:()=>vJ,content_2251_1704:()=>TJ,content_2251_1706:()=>LJ,content_2251_1708:()=>NJ,content_2251_1710:()=>RJ,content_2251_1712:()=>AJ,content_2251_1714:()=>PJ,content_2251_1716:()=>FJ,content_2251_1718:()=>BJ,content_2251_172:()=>p_,content_2251_1720:()=>OJ,content_2251_1722:()=>UJ,content_2251_1724:()=>VJ,content_2251_1726:()=>$J,content_2251_1728:()=>YJ,content_2251_1730:()=>QJ,content_2251_1732:()=>eY,content_2251_1734:()=>oY,content_2251_1736:()=>rY,content_2251_1738:()=>pY,content_2251_174:()=>c_,content_2251_1740:()=>cY,content_2251_1742:()=>uY,content_2251_1744:()=>dY,content_2251_1746:()=>yY,content_2251_1748:()=>kY,content_2251_1750:()=>gY,content_2251_1752:()=>DY,content_2251_1754:()=>XY,content_2251_1756:()=>vY,content_2251_1758:()=>TY,content_2251_176:()=>u_,content_2251_1760:()=>LY,content_2251_1762:()=>NY,content_2251_1764:()=>RY,content_2251_1766:()=>AY,content_2251_1768:()=>PY,content_2251_1770:()=>FY,content_2251_1772:()=>BY,content_2251_1774:()=>OY,content_2251_1776:()=>UY,content_2251_1778:()=>VY,content_2251_178:()=>d_,content_2251_1780:()=>$Y,content_2251_1782:()=>YY,content_2251_1784:()=>QY,content_2251_1786:()=>eK,content_2251_1788:()=>oK,content_2251_1790:()=>rK,content_2251_1792:()=>pK,content_2251_1794:()=>cK,content_2251_1796:()=>uK,content_2251_1798:()=>dK,content_2251_18:()=>yg,content_2251_180:()=>y_,content_2251_1800:()=>yK,content_2251_1802:()=>kK,content_2251_1804:()=>gK,content_2251_1806:()=>DK,content_2251_1808:()=>XK,content_2251_1810:()=>vK,content_2251_1812:()=>TK,content_2251_1814:()=>LK,content_2251_1816:()=>NK,content_2251_1818:()=>RK,content_2251_182:()=>k_,content_2251_1820:()=>AK,content_2251_1822:()=>PK,content_2251_1824:()=>FK,content_2251_1826:()=>BK,content_2251_1828:()=>OK,content_2251_1830:()=>UK,content_2251_1832:()=>VK,content_2251_1834:()=>$K,content_2251_1836:()=>YK,content_2251_1838:()=>QK,content_2251_184:()=>g_,content_2251_1840:()=>eQ,content_2251_1842:()=>oQ,content_2251_1844:()=>rQ,content_2251_1846:()=>pQ,content_2251_1848:()=>cQ,content_2251_1850:()=>uQ,content_2251_1852:()=>dQ,content_2251_1854:()=>yQ,content_2251_1856:()=>kQ,content_2251_1858:()=>gQ,content_2251_186:()=>D_,content_2251_1860:()=>DQ,content_2251_1862:()=>XQ,content_2251_1864:()=>vQ,content_2251_1866:()=>TQ,content_2251_1868:()=>LQ,content_2251_1870:()=>NQ,content_2251_1872:()=>RQ,content_2251_1874:()=>AQ,content_2251_1876:()=>PQ,content_2251_1878:()=>FQ,content_2251_188:()=>X_,content_2251_1880:()=>BQ,content_2251_1882:()=>OQ,content_2251_1884:()=>UQ,content_2251_1886:()=>VQ,content_2251_1888:()=>$Q,content_2251_1890:()=>YQ,content_2251_1892:()=>QQ,content_2251_1894:()=>e0,content_2251_1896:()=>o0,content_2251_1898:()=>r0,content_2251_190:()=>v_,content_2251_1900:()=>p0,content_2251_1902:()=>c0,content_2251_1904:()=>u0,content_2251_1906:()=>d0,content_2251_1908:()=>y0,content_2251_1910:()=>k0,content_2251_1912:()=>g0,content_2251_1914:()=>D0,content_2251_1916:()=>X0,content_2251_1918:()=>v0,content_2251_192:()=>T_,content_2251_1920:()=>T0,content_2251_1922:()=>L0,content_2251_1924:()=>N0,content_2251_1926:()=>R0,content_2251_1928:()=>A0,content_2251_1930:()=>P0,content_2251_1932:()=>F0,content_2251_1934:()=>B0,content_2251_1936:()=>O0,content_2251_1938:()=>U0,content_2251_194:()=>L_,content_2251_1940:()=>V0,content_2251_1942:()=>$0,content_2251_1944:()=>Y0,content_2251_1946:()=>Q0,content_2251_1948:()=>e2,content_2251_1950:()=>o2,content_2251_1952:()=>r2,content_2251_1954:()=>p2,content_2251_1956:()=>c2,content_2251_1958:()=>u2,content_2251_196:()=>N_,content_2251_1960:()=>d2,content_2251_1962:()=>y2,content_2251_1964:()=>k2,content_2251_1966:()=>g2,content_2251_1968:()=>D2,content_2251_1970:()=>X2,content_2251_1972:()=>v2,content_2251_1974:()=>T2,content_2251_1976:()=>L2,content_2251_1978:()=>N2,content_2251_198:()=>R_,content_2251_1980:()=>R2,content_2251_1982:()=>A2,content_2251_1984:()=>P2,content_2251_1986:()=>F2,content_2251_1988:()=>B2,content_2251_1990:()=>O2,content_2251_1992:()=>U2,content_2251_1994:()=>V2,content_2251_1996:()=>$2,content_2251_1998:()=>Y2,content_2251_2:()=>Qw,content_2251_20:()=>kg,content_2251_200:()=>A_,content_2251_2000:()=>Q2,content_2251_2002:()=>e1,content_2251_2004:()=>o1,content_2251_2006:()=>r1,content_2251_2008:()=>p1,content_2251_2010:()=>c1,content_2251_2012:()=>u1,content_2251_2014:()=>d1,content_2251_2016:()=>y1,content_2251_2018:()=>k1,content_2251_202:()=>P_,content_2251_2020:()=>g1,content_2251_2022:()=>D1,content_2251_2024:()=>X1,content_2251_2026:()=>v1,content_2251_2028:()=>T1,content_2251_2030:()=>L1,content_2251_2032:()=>N1,content_2251_2034:()=>R1,content_2251_2036:()=>A1,content_2251_2038:()=>P1,content_2251_204:()=>F_,content_2251_2040:()=>F1,content_2251_2042:()=>B1,content_2251_2044:()=>O1,content_2251_2046:()=>U1,content_2251_2048:()=>V1,content_2251_2050:()=>$1,content_2251_2052:()=>Y1,content_2251_2054:()=>Q1,content_2251_2056:()=>e5,content_2251_2058:()=>o5,content_2251_206:()=>B_,content_2251_2060:()=>r5,content_2251_2062:()=>p5,content_2251_2064:()=>c5,content_2251_2066:()=>u5,content_2251_2068:()=>d5,content_2251_2070:()=>y5,content_2251_2072:()=>k5,content_2251_2074:()=>g5,content_2251_2076:()=>D5,content_2251_2078:()=>X5,content_2251_208:()=>O_,content_2251_2080:()=>v5,content_2251_2082:()=>T5,content_2251_2084:()=>L5,content_2251_2086:()=>N5,content_2251_2088:()=>R5,content_2251_2090:()=>A5,content_2251_2092:()=>P5,content_2251_2094:()=>F5,content_2251_2096:()=>B5,content_2251_2098:()=>O5,content_2251_210:()=>U_,content_2251_2100:()=>U5,content_2251_2102:()=>V5,content_2251_2104:()=>$5,content_2251_2106:()=>Y5,content_2251_2108:()=>Q5,content_2251_2110:()=>e4,content_2251_2112:()=>o4,content_2251_2114:()=>r4,content_2251_2116:()=>p4,content_2251_2118:()=>c4,content_2251_212:()=>V_,content_2251_2120:()=>u4,content_2251_2122:()=>d4,content_2251_2124:()=>y4,content_2251_2126:()=>k4,content_2251_2128:()=>g4,content_2251_2130:()=>D4,content_2251_2132:()=>X4,content_2251_2134:()=>v4,content_2251_2136:()=>T4,content_2251_2138:()=>L4,content_2251_214:()=>$_,content_2251_2140:()=>N4,content_2251_2142:()=>R4,content_2251_2144:()=>A4,content_2251_2146:()=>P4,content_2251_2148:()=>F4,content_2251_2150:()=>B4,content_2251_2152:()=>O4,content_2251_2154:()=>U4,content_2251_2156:()=>V4,content_2251_2158:()=>$4,content_2251_216:()=>Y_,content_2251_2160:()=>Y4,content_2251_2162:()=>Q4,content_2251_2164:()=>e3,content_2251_2166:()=>o3,content_2251_2168:()=>r3,content_2251_2170:()=>p3,content_2251_2172:()=>c3,content_2251_2174:()=>u3,content_2251_2176:()=>d3,content_2251_2178:()=>y3,content_2251_218:()=>Q_,content_2251_2180:()=>k3,content_2251_2182:()=>g3,content_2251_2184:()=>D3,content_2251_2186:()=>X3,content_2251_2188:()=>v3,content_2251_2190:()=>T3,content_2251_2192:()=>L3,content_2251_2194:()=>N3,content_2251_2196:()=>R3,content_2251_2198:()=>A3,content_2251_22:()=>gg,content_2251_220:()=>eX,content_2251_2200:()=>P3,content_2251_2202:()=>F3,content_2251_2204:()=>B3,content_2251_2206:()=>O3,content_2251_2208:()=>U3,content_2251_2210:()=>V3,content_2251_2212:()=>$3,content_2251_2214:()=>Y3,content_2251_2216:()=>Q3,content_2251_2218:()=>e6,content_2251_222:()=>oX,content_2251_2220:()=>o6,content_2251_2222:()=>r6,content_2251_2224:()=>p6,content_2251_2226:()=>c6,content_2251_2228:()=>u6,content_2251_2230:()=>d6,content_2251_2232:()=>y6,content_2251_2234:()=>k6,content_2251_2236:()=>g6,content_2251_2238:()=>D6,content_2251_224:()=>rX,content_2251_2240:()=>X6,content_2251_2242:()=>v6,content_2251_2244:()=>T6,content_2251_2246:()=>L6,content_2251_2248:()=>N6,content_2251_2250:()=>R6,content_2251_2252:()=>A6,content_2251_2254:()=>P6,content_2251_2256:()=>F6,content_2251_2258:()=>B6,content_2251_226:()=>pX,content_2251_2260:()=>O6,content_2251_2262:()=>U6,content_2251_2264:()=>V6,content_2251_2266:()=>$6,content_2251_2268:()=>Y6,content_2251_2270:()=>Q6,content_2251_2272:()=>e8,content_2251_2274:()=>o8,content_2251_2276:()=>r8,content_2251_2278:()=>p8,content_2251_228:()=>cX,content_2251_2280:()=>c8,content_2251_2282:()=>u8,content_2251_2284:()=>d8,content_2251_2286:()=>y8,content_2251_2288:()=>k8,content_2251_2290:()=>g8,content_2251_2292:()=>D8,content_2251_2294:()=>X8,content_2251_2296:()=>v8,content_2251_2298:()=>T8,content_2251_230:()=>uX,content_2251_2300:()=>L8,content_2251_2302:()=>N8,content_2251_2304:()=>R8,content_2251_2306:()=>A8,content_2251_2308:()=>P8,content_2251_2310:()=>F8,content_2251_2312:()=>B8,content_2251_2314:()=>O8,content_2251_2316:()=>U8,content_2251_2318:()=>V8,content_2251_232:()=>dX,content_2251_2320:()=>$8,content_2251_2322:()=>Y8,content_2251_2324:()=>Q8,content_2251_2326:()=>e7,content_2251_2328:()=>o7,content_2251_2330:()=>r7,content_2251_2332:()=>p7,content_2251_2334:()=>c7,content_2251_2336:()=>u7,content_2251_2338:()=>d7,content_2251_234:()=>yX,content_2251_2340:()=>y7,content_2251_2342:()=>k7,content_2251_2344:()=>g7,content_2251_2346:()=>D7,content_2251_2348:()=>X7,content_2251_2350:()=>v7,content_2251_2352:()=>T7,content_2251_2354:()=>L7,content_2251_2356:()=>N7,content_2251_2358:()=>R7,content_2251_236:()=>kX,content_2251_2360:()=>A7,content_2251_2362:()=>P7,content_2251_2364:()=>F7,content_2251_2366:()=>B7,content_2251_2368:()=>O7,content_2251_2370:()=>U7,content_2251_2372:()=>V7,content_2251_2374:()=>$7,content_2251_2376:()=>Y7,content_2251_2378:()=>Q7,content_2251_238:()=>gX,content_2251_2380:()=>e9,content_2251_2382:()=>o9,content_2251_2384:()=>r9,content_2251_2386:()=>p9,content_2251_2388:()=>c9,content_2251_2390:()=>u9,content_2251_2392:()=>d9,content_2251_2394:()=>y9,content_2251_2396:()=>k9,content_2251_2398:()=>g9,content_2251_24:()=>Dg,content_2251_240:()=>DX,content_2251_2400:()=>D9,content_2251_2402:()=>X9,content_2251_2404:()=>v9,content_2251_2406:()=>T9,content_2251_2408:()=>L9,content_2251_2410:()=>N9,content_2251_2412:()=>R9,content_2251_2414:()=>A9,content_2251_2416:()=>P9,content_2251_2418:()=>F9,content_2251_242:()=>XX,content_2251_2420:()=>B9,content_2251_2422:()=>O9,content_2251_2424:()=>U9,content_2251_2426:()=>V9,content_2251_2428:()=>$9,content_2251_2430:()=>Y9,content_2251_2432:()=>Q9,content_2251_2434:()=>ett,content_2251_2436:()=>ott,content_2251_2438:()=>rtt,content_2251_244:()=>vX,content_2251_2440:()=>ptt,content_2251_2442:()=>ctt,content_2251_2444:()=>utt,content_2251_2446:()=>dtt,content_2251_2448:()=>ytt,content_2251_2450:()=>ktt,content_2251_2452:()=>gtt,content_2251_2454:()=>Dtt,content_2251_2456:()=>Xtt,content_2251_2458:()=>vtt,content_2251_246:()=>TX,content_2251_2460:()=>Ttt,content_2251_2462:()=>Ltt,content_2251_2464:()=>Ntt,content_2251_2466:()=>Rtt,content_2251_2468:()=>Att,content_2251_2470:()=>Ptt,content_2251_2472:()=>Ftt,content_2251_2474:()=>Btt,content_2251_2476:()=>Ott,content_2251_2478:()=>Utt,content_2251_248:()=>LX,content_2251_2480:()=>Vtt,content_2251_2482:()=>$tt,content_2251_2484:()=>Ytt,content_2251_2486:()=>Qtt,content_2251_2488:()=>eet,content_2251_2490:()=>oet,content_2251_2492:()=>ret,content_2251_2494:()=>pet,content_2251_2496:()=>cet,content_2251_2498:()=>met,content_2251_250:()=>NX,content_2251_2500:()=>het,content_2251_2502:()=>fet,content_2251_2504:()=>wet,content_2251_2506:()=>Met,content_2251_2508:()=>_et,content_2251_2510:()=>xet,content_2251_2512:()=>Cet,content_2251_2514:()=>bet,content_2251_2516:()=>Zet,content_2251_2518:()=>Set,content_2251_252:()=>RX,content_2251_2520:()=>zet,content_2251_2522:()=>Eet,content_2251_2524:()=>Iet,content_2251_2526:()=>Wet,content_2251_2528:()=>Get,content_2251_2530:()=>jet,content_2251_2532:()=>qet,content_2251_2534:()=>Het,content_2251_2536:()=>Jet,content_2251_2538:()=>Ket,content_2251_254:()=>AX,content_2251_2540:()=>tnt,content_2251_2542:()=>nnt,content_2251_2544:()=>snt,content_2251_2546:()=>int,content_2251_2548:()=>ant,content_2251_2550:()=>lnt,content_2251_2552:()=>mnt,content_2251_2554:()=>hnt,content_2251_2556:()=>fnt,content_2251_2558:()=>wnt,content_2251_256:()=>PX,content_2251_2560:()=>Mnt,content_2251_2562:()=>_nt,content_2251_2564:()=>xnt,content_2251_2566:()=>Cnt,content_2251_2568:()=>bnt,content_2251_2570:()=>Znt,content_2251_2572:()=>Snt,content_2251_2574:()=>znt,content_2251_2576:()=>Ent,content_2251_2578:()=>Int,content_2251_258:()=>FX,content_2251_2580:()=>Wnt,content_2251_2582:()=>Gnt,content_2251_2584:()=>jnt,content_2251_2586:()=>qnt,content_2251_2588:()=>Hnt,content_2251_2590:()=>Jnt,content_2251_2592:()=>Knt,content_2251_2594:()=>tot,content_2251_2596:()=>not,content_2251_2598:()=>sot,content_2251_26:()=>Xg,content_2251_260:()=>BX,content_2251_2600:()=>iot,content_2251_2602:()=>aot,content_2251_2604:()=>lot,content_2251_2606:()=>mot,content_2251_2608:()=>hot,content_2251_2610:()=>fot,content_2251_2612:()=>wot,content_2251_2614:()=>Mot,content_2251_2616:()=>_ot,content_2251_2618:()=>xot,content_2251_262:()=>OX,content_2251_2620:()=>Cot,content_2251_2622:()=>bot,content_2251_2624:()=>Zot,content_2251_2626:()=>Sot,content_2251_2628:()=>zot,content_2251_2630:()=>Eot,content_2251_2632:()=>Iot,content_2251_2634:()=>Wot,content_2251_2636:()=>Got,content_2251_2638:()=>jot,content_2251_264:()=>UX,content_2251_2640:()=>qot,content_2251_2642:()=>Hot,content_2251_2644:()=>Jot,content_2251_2646:()=>Kot,content_2251_2648:()=>tst,content_2251_2650:()=>nst,content_2251_2652:()=>sst,content_2251_2654:()=>ist,content_2251_2656:()=>ast,content_2251_2658:()=>lst,content_2251_266:()=>VX,content_2251_2660:()=>mst,content_2251_2662:()=>hst,content_2251_2664:()=>fst,content_2251_2666:()=>wst,content_2251_2668:()=>Mst,content_2251_2670:()=>_st,content_2251_2672:()=>xst,content_2251_2674:()=>Cst,content_2251_2676:()=>bst,content_2251_2678:()=>Zst,content_2251_268:()=>$X,content_2251_2680:()=>Sst,content_2251_2682:()=>zst,content_2251_2684:()=>Est,content_2251_2686:()=>Ist,content_2251_2688:()=>Wst,content_2251_2690:()=>Gst,content_2251_2692:()=>jst,content_2251_2694:()=>qst,content_2251_2696:()=>Hst,content_2251_2698:()=>Jst,content_2251_270:()=>YX,content_2251_2700:()=>Kst,content_2251_2702:()=>trt,content_2251_2704:()=>nrt,content_2251_2706:()=>srt,content_2251_2708:()=>irt,content_2251_2710:()=>art,content_2251_2712:()=>lrt,content_2251_2714:()=>mrt,content_2251_2716:()=>hrt,content_2251_2718:()=>frt,content_2251_272:()=>QX,content_2251_2720:()=>wrt,content_2251_2722:()=>Mrt,content_2251_2724:()=>_rt,content_2251_2726:()=>xrt,content_2251_2728:()=>Crt,content_2251_2730:()=>brt,content_2251_2732:()=>Zrt,content_2251_2734:()=>Srt,content_2251_2736:()=>zrt,content_2251_2738:()=>Ert,content_2251_274:()=>ex,content_2251_2740:()=>Irt,content_2251_2742:()=>Wrt,content_2251_2744:()=>Grt,content_2251_2746:()=>jrt,content_2251_2748:()=>qrt,content_2251_2750:()=>Hrt,content_2251_2752:()=>Jrt,content_2251_2754:()=>Krt,content_2251_2756:()=>tit,content_2251_2758:()=>nit,content_2251_276:()=>ox,content_2251_2760:()=>sit,content_2251_2762:()=>iit,content_2251_2764:()=>ait,content_2251_2766:()=>lit,content_2251_2768:()=>mit,content_2251_2770:()=>hit,content_2251_2772:()=>fit,content_2251_2774:()=>wit,content_2251_2776:()=>Mit,content_2251_2778:()=>_it,content_2251_278:()=>rx,content_2251_2780:()=>xit,content_2251_2782:()=>Cit,content_2251_2784:()=>bit,content_2251_2786:()=>Zit,content_2251_2788:()=>Sit,content_2251_2790:()=>zit,content_2251_2792:()=>Eit,content_2251_2794:()=>Iit,content_2251_2796:()=>Wit,content_2251_2798:()=>Git,content_2251_28:()=>vg,content_2251_280:()=>px,content_2251_2800:()=>jit,content_2251_2802:()=>qit,content_2251_2804:()=>Hit,content_2251_2806:()=>Jit,content_2251_2808:()=>Kit,content_2251_2810:()=>tpt,content_2251_2812:()=>npt,content_2251_2814:()=>spt,content_2251_2816:()=>ipt,content_2251_2818:()=>apt,content_2251_282:()=>cx,content_2251_2820:()=>lpt,content_2251_2822:()=>mpt,content_2251_2824:()=>hpt,content_2251_2826:()=>fpt,content_2251_2828:()=>wpt,content_2251_2830:()=>Mpt,content_2251_2832:()=>_pt,content_2251_2834:()=>xpt,content_2251_2836:()=>Cpt,content_2251_2838:()=>bpt,content_2251_284:()=>ux,content_2251_2840:()=>Zpt,content_2251_2842:()=>Spt,content_2251_2844:()=>zpt,content_2251_2846:()=>Ept,content_2251_2848:()=>Ipt,content_2251_2850:()=>Wpt,content_2251_2852:()=>Gpt,content_2251_2854:()=>jpt,content_2251_2856:()=>qpt,content_2251_2858:()=>Hpt,content_2251_286:()=>dx,content_2251_2860:()=>Jpt,content_2251_2862:()=>Kpt,content_2251_2864:()=>tat,content_2251_2866:()=>nat,content_2251_2868:()=>sat,content_2251_2870:()=>iat,content_2251_2872:()=>aat,content_2251_2874:()=>lat,content_2251_2876:()=>mat,content_2251_2878:()=>hat,content_2251_288:()=>yx,content_2251_2880:()=>fat,content_2251_2882:()=>wat,content_2251_2884:()=>Mat,content_2251_2886:()=>_at,content_2251_2888:()=>xat,content_2251_2890:()=>Cat,content_2251_2892:()=>bat,content_2251_2894:()=>Zat,content_2251_2896:()=>Sat,content_2251_2898:()=>zat,content_2251_290:()=>kx,content_2251_2900:()=>Eat,content_2251_2902:()=>Iat,content_2251_2904:()=>Wat,content_2251_2906:()=>Gat,content_2251_2908:()=>jat,content_2251_2910:()=>qat,content_2251_2912:()=>Hat,content_2251_2914:()=>Jat,content_2251_2916:()=>Kat,content_2251_2918:()=>tct,content_2251_292:()=>gx,content_2251_2920:()=>nct,content_2251_2922:()=>sct,content_2251_2924:()=>ict,content_2251_2926:()=>act,content_2251_2928:()=>lct,content_2251_2930:()=>mct,content_2251_2932:()=>hct,content_2251_2934:()=>fct,content_2251_2936:()=>wct,content_2251_2938:()=>Mct,content_2251_294:()=>Dx,content_2251_2940:()=>_ct,content_2251_2942:()=>xct,content_2251_2944:()=>Cct,content_2251_2946:()=>bct,content_2251_2948:()=>Zct,content_2251_2950:()=>Sct,content_2251_2952:()=>zct,content_2251_2954:()=>Ect,content_2251_2956:()=>Ict,content_2251_2958:()=>Wct,content_2251_296:()=>Xx,content_2251_2960:()=>Gct,content_2251_2962:()=>jct,content_2251_2964:()=>qct,content_2251_2966:()=>Hct,content_2251_2968:()=>Jct,content_2251_2970:()=>Kct,content_2251_2972:()=>tlt,content_2251_2974:()=>nlt,content_2251_2976:()=>slt,content_2251_2978:()=>ilt,content_2251_298:()=>vx,content_2251_2980:()=>alt,content_2251_2982:()=>llt,content_2251_2984:()=>mlt,content_2251_2986:()=>hlt,content_2251_2988:()=>flt,content_2251_2990:()=>wlt,content_2251_2992:()=>Mlt,content_2251_2994:()=>_lt,content_2251_2996:()=>xlt,content_2251_2998:()=>Clt,content_2251_30:()=>Tg,content_2251_300:()=>Tx,content_2251_3000:()=>blt,content_2251_3002:()=>Zlt,content_2251_3004:()=>Slt,content_2251_3006:()=>zlt,content_2251_3008:()=>Elt,content_2251_3010:()=>Ilt,content_2251_3012:()=>Wlt,content_2251_3014:()=>Glt,content_2251_3016:()=>jlt,content_2251_3018:()=>qlt,content_2251_302:()=>Lx,content_2251_3020:()=>Hlt,content_2251_3022:()=>Jlt,content_2251_3024:()=>Klt,content_2251_3026:()=>tut,content_2251_3028:()=>nut,content_2251_3030:()=>sut,content_2251_3032:()=>iut,content_2251_3034:()=>aut,content_2251_3036:()=>lut,content_2251_3038:()=>mut,content_2251_304:()=>Nx,content_2251_3040:()=>hut,content_2251_3042:()=>fut,content_2251_3044:()=>wut,content_2251_3046:()=>Mut,content_2251_3048:()=>_ut,content_2251_3050:()=>xut,content_2251_3052:()=>Cut,content_2251_3054:()=>but,content_2251_3056:()=>Zut,content_2251_3058:()=>Sut,content_2251_306:()=>Rx,content_2251_3060:()=>zut,content_2251_3062:()=>Eut,content_2251_3064:()=>Iut,content_2251_3066:()=>Wut,content_2251_3068:()=>Gut,content_2251_3070:()=>jut,content_2251_3072:()=>qut,content_2251_3074:()=>Hut,content_2251_3076:()=>Jut,content_2251_3078:()=>Kut,content_2251_308:()=>Ax,content_2251_3080:()=>tmt,content_2251_3082:()=>nmt,content_2251_3084:()=>smt,content_2251_3086:()=>imt,content_2251_3088:()=>amt,content_2251_3090:()=>lmt,content_2251_3092:()=>mmt,content_2251_3094:()=>hmt,content_2251_3096:()=>fmt,content_2251_3098:()=>wmt,content_2251_310:()=>Px,content_2251_3100:()=>Mmt,content_2251_3102:()=>_mt,content_2251_3104:()=>xmt,content_2251_3106:()=>Cmt,content_2251_3108:()=>bmt,content_2251_3110:()=>Zmt,content_2251_3112:()=>Smt,content_2251_3114:()=>zmt,content_2251_3116:()=>Emt,content_2251_3118:()=>Imt,content_2251_312:()=>Fx,content_2251_3120:()=>Wmt,content_2251_3122:()=>Gmt,content_2251_3124:()=>jmt,content_2251_3126:()=>qmt,content_2251_3128:()=>Hmt,content_2251_3130:()=>Jmt,content_2251_3132:()=>Kmt,content_2251_3134:()=>tdt,content_2251_3136:()=>ndt,content_2251_3138:()=>sdt,content_2251_314:()=>Bx,content_2251_3140:()=>idt,content_2251_3142:()=>adt,content_2251_3144:()=>ldt,content_2251_3146:()=>mdt,content_2251_3148:()=>hdt,content_2251_3150:()=>fdt,content_2251_3152:()=>wdt,content_2251_3154:()=>Mdt,content_2251_3156:()=>_dt,content_2251_3158:()=>xdt,content_2251_316:()=>Ox,content_2251_3160:()=>Cdt,content_2251_3162:()=>bdt,content_2251_3164:()=>Zdt,content_2251_3166:()=>Sdt,content_2251_3168:()=>zdt,content_2251_3170:()=>Edt,content_2251_3172:()=>Idt,content_2251_3174:()=>Wdt,content_2251_3176:()=>Gdt,content_2251_3178:()=>jdt,content_2251_318:()=>Ux,content_2251_3180:()=>qdt,content_2251_3182:()=>Hdt,content_2251_3184:()=>Jdt,content_2251_3186:()=>Kdt,content_2251_3188:()=>tht,content_2251_3190:()=>nht,content_2251_3192:()=>sht,content_2251_3194:()=>iht,content_2251_3196:()=>aht,content_2251_3198:()=>lht,content_2251_32:()=>Lg,content_2251_320:()=>Vx,content_2251_3200:()=>mht,content_2251_3202:()=>hht,content_2251_3204:()=>fht,content_2251_3206:()=>wht,content_2251_3208:()=>Mht,content_2251_3210:()=>_ht,content_2251_3212:()=>xht,content_2251_3214:()=>Cht,content_2251_3216:()=>bht,content_2251_3218:()=>Zht,content_2251_322:()=>$x,content_2251_3220:()=>Sht,content_2251_3222:()=>zht,content_2251_3224:()=>Eht,content_2251_3226:()=>Iht,content_2251_3228:()=>Wht,content_2251_3230:()=>Ght,content_2251_3232:()=>jht,content_2251_3234:()=>qht,content_2251_3236:()=>Hht,content_2251_3238:()=>Jht,content_2251_324:()=>Yx,content_2251_3240:()=>Kht,content_2251_3242:()=>tyt,content_2251_3244:()=>nyt,content_2251_3246:()=>syt,content_2251_3248:()=>iyt,content_2251_3250:()=>ayt,content_2251_3252:()=>lyt,content_2251_3254:()=>myt,content_2251_3256:()=>hyt,content_2251_3258:()=>fyt,content_2251_326:()=>Qx,content_2251_3260:()=>wyt,content_2251_3262:()=>Myt,content_2251_3264:()=>_yt,content_2251_3266:()=>xyt,content_2251_3268:()=>Cyt,content_2251_3270:()=>byt,content_2251_3272:()=>Zyt,content_2251_3274:()=>Syt,content_2251_3276:()=>zyt,content_2251_3278:()=>Eyt,content_2251_328:()=>ev,content_2251_3280:()=>Iyt,content_2251_3282:()=>Wyt,content_2251_3284:()=>Gyt,content_2251_3286:()=>jyt,content_2251_3288:()=>qyt,content_2251_3290:()=>Hyt,content_2251_3292:()=>Jyt,content_2251_3294:()=>Kyt,content_2251_3296:()=>tft,content_2251_3298:()=>nft,content_2251_330:()=>ov,content_2251_3300:()=>sft,content_2251_3302:()=>ift,content_2251_3304:()=>aft,content_2251_3306:()=>lft,content_2251_3308:()=>mft,content_2251_3310:()=>hft,content_2251_3312:()=>fft,content_2251_3314:()=>wft,content_2251_3316:()=>Mft,content_2251_3318:()=>_ft,content_2251_332:()=>rv,content_2251_3320:()=>xft,content_2251_3322:()=>Cft,content_2251_3324:()=>bft,content_2251_3326:()=>Zft,content_2251_3328:()=>Sft,content_2251_3330:()=>zft,content_2251_3332:()=>Eft,content_2251_3334:()=>Ift,content_2251_3336:()=>Wft,content_2251_3338:()=>Gft,content_2251_334:()=>pv,content_2251_3340:()=>jft,content_2251_3342:()=>qft,content_2251_3344:()=>Hft,content_2251_3346:()=>Jft,content_2251_3348:()=>Kft,content_2251_3350:()=>tkt,content_2251_3352:()=>nkt,content_2251_3354:()=>skt,content_2251_3356:()=>ikt,content_2251_3358:()=>akt,content_2251_336:()=>cv,content_2251_3360:()=>lkt,content_2251_3362:()=>mkt,content_2251_3364:()=>hkt,content_2251_3366:()=>fkt,content_2251_3368:()=>wkt,content_2251_3370:()=>Mkt,content_2251_3372:()=>_kt,content_2251_3374:()=>xkt,content_2251_3376:()=>Ckt,content_2251_3378:()=>bkt,content_2251_338:()=>uv,content_2251_3380:()=>Zkt,content_2251_3382:()=>Skt,content_2251_3384:()=>zkt,content_2251_3386:()=>Ekt,content_2251_3388:()=>Ikt,content_2251_3390:()=>Wkt,content_2251_3392:()=>Gkt,content_2251_3394:()=>jkt,content_2251_3396:()=>qkt,content_2251_3398:()=>Hkt,content_2251_34:()=>Ng,content_2251_340:()=>dv,content_2251_3400:()=>Jkt,content_2251_3402:()=>Kkt,content_2251_3404:()=>twt,content_2251_3406:()=>nwt,content_2251_3408:()=>swt,content_2251_3410:()=>iwt,content_2251_3412:()=>awt,content_2251_3414:()=>lwt,content_2251_3416:()=>mwt,content_2251_3418:()=>hwt,content_2251_342:()=>yv,content_2251_3420:()=>fwt,content_2251_3422:()=>wwt,content_2251_3424:()=>Mwt,content_2251_3426:()=>_wt,content_2251_3428:()=>xwt,content_2251_3430:()=>Cwt,content_2251_3432:()=>bwt,content_2251_3434:()=>Zwt,content_2251_3436:()=>Swt,content_2251_3438:()=>zwt,content_2251_344:()=>kv,content_2251_3440:()=>Ewt,content_2251_3442:()=>Iwt,content_2251_3444:()=>Wwt,content_2251_3446:()=>Gwt,content_2251_3448:()=>jwt,content_2251_3450:()=>qwt,content_2251_3452:()=>Hwt,content_2251_3454:()=>Jwt,content_2251_3456:()=>Kwt,content_2251_3458:()=>tgt,content_2251_346:()=>gv,content_2251_3460:()=>ngt,content_2251_3462:()=>sgt,content_2251_3464:()=>igt,content_2251_3466:()=>agt,content_2251_3468:()=>lgt,content_2251_3470:()=>mgt,content_2251_3472:()=>hgt,content_2251_3474:()=>fgt,content_2251_3476:()=>wgt,content_2251_3478:()=>Mgt,content_2251_348:()=>Dv,content_2251_3480:()=>_gt,content_2251_3482:()=>xgt,content_2251_3484:()=>Cgt,content_2251_3486:()=>bgt,content_2251_3488:()=>Zgt,content_2251_3490:()=>Sgt,content_2251_3492:()=>zgt,content_2251_3494:()=>Egt,content_2251_3496:()=>Igt,content_2251_3498:()=>Wgt,content_2251_350:()=>Xv,content_2251_3500:()=>Ggt,content_2251_3502:()=>jgt,content_2251_3504:()=>qgt,content_2251_3506:()=>Hgt,content_2251_3508:()=>Jgt,content_2251_3510:()=>Kgt,content_2251_3512:()=>tMt,content_2251_3514:()=>nMt,content_2251_3516:()=>sMt,content_2251_3518:()=>iMt,content_2251_352:()=>vv,content_2251_3520:()=>aMt,content_2251_3522:()=>lMt,content_2251_3524:()=>mMt,content_2251_3526:()=>hMt,content_2251_3528:()=>fMt,content_2251_3530:()=>wMt,content_2251_3532:()=>MMt,content_2251_3534:()=>_Mt,content_2251_3536:()=>xMt,content_2251_3538:()=>CMt,content_2251_354:()=>Tv,content_2251_3540:()=>bMt,content_2251_3542:()=>ZMt,content_2251_3544:()=>SMt,content_2251_3546:()=>zMt,content_2251_3548:()=>EMt,content_2251_3550:()=>IMt,content_2251_3552:()=>WMt,content_2251_3554:()=>GMt,content_2251_3556:()=>jMt,content_2251_3558:()=>qMt,content_2251_356:()=>Lv,content_2251_3560:()=>HMt,content_2251_3562:()=>JMt,content_2251_3564:()=>KMt,content_2251_3566:()=>tDt,content_2251_3568:()=>nDt,content_2251_3570:()=>sDt,content_2251_3572:()=>iDt,content_2251_3574:()=>aDt,content_2251_3576:()=>lDt,content_2251_3578:()=>mDt,content_2251_358:()=>Nv,content_2251_3580:()=>hDt,content_2251_3582:()=>fDt,content_2251_3584:()=>wDt,content_2251_3586:()=>MDt,content_2251_3588:()=>_Dt,content_2251_3590:()=>xDt,content_2251_3592:()=>CDt,content_2251_3594:()=>bDt,content_2251_3596:()=>ZDt,content_2251_3598:()=>SDt,content_2251_36:()=>Rg,content_2251_360:()=>Rv,content_2251_3600:()=>zDt,content_2251_3602:()=>EDt,content_2251_3604:()=>IDt,content_2251_3606:()=>WDt,content_2251_3608:()=>GDt,content_2251_3610:()=>jDt,content_2251_3612:()=>qDt,content_2251_3614:()=>HDt,content_2251_3616:()=>JDt,content_2251_3618:()=>KDt,content_2251_362:()=>Av,content_2251_3620:()=>t_t,content_2251_3622:()=>n_t,content_2251_3624:()=>s_t,content_2251_3626:()=>i_t,content_2251_3628:()=>a_t,content_2251_3630:()=>l_t,content_2251_3632:()=>m_t,content_2251_3634:()=>h_t,content_2251_3636:()=>f_t,content_2251_3638:()=>w_t,content_2251_364:()=>Pv,content_2251_3640:()=>M_t,content_2251_3642:()=>__t,content_2251_3644:()=>x_t,content_2251_3646:()=>C_t,content_2251_3648:()=>b_t,content_2251_3650:()=>Z_t,content_2251_3652:()=>S_t,content_2251_3654:()=>z_t,content_2251_3656:()=>E_t,content_2251_3658:()=>I_t,content_2251_366:()=>Fv,content_2251_3660:()=>W_t,content_2251_3662:()=>G_t,content_2251_3664:()=>j_t,content_2251_3666:()=>q_t,content_2251_3668:()=>H_t,content_2251_3670:()=>J_t,content_2251_3672:()=>K_t,content_2251_3674:()=>tXt,content_2251_3676:()=>nXt,content_2251_3678:()=>sXt,content_2251_368:()=>Bv,content_2251_3680:()=>iXt,content_2251_3682:()=>aXt,content_2251_3684:()=>lXt,content_2251_3686:()=>mXt,content_2251_3688:()=>hXt,content_2251_3690:()=>fXt,content_2251_3692:()=>wXt,content_2251_3694:()=>MXt,content_2251_3696:()=>_Xt,content_2251_3698:()=>xXt,content_2251_370:()=>Ov,content_2251_3700:()=>CXt,content_2251_3702:()=>bXt,content_2251_3704:()=>ZXt,content_2251_3706:()=>SXt,content_2251_3708:()=>zXt,content_2251_3710:()=>EXt,content_2251_3712:()=>IXt,content_2251_3714:()=>WXt,content_2251_3716:()=>GXt,content_2251_3718:()=>jXt,content_2251_372:()=>Uv,content_2251_3720:()=>qXt,content_2251_3722:()=>HXt,content_2251_3724:()=>JXt,content_2251_3726:()=>KXt,content_2251_3728:()=>txt,content_2251_3730:()=>nxt,content_2251_3732:()=>sxt,content_2251_3734:()=>ixt,content_2251_3736:()=>axt,content_2251_3738:()=>lxt,content_2251_374:()=>Vv,content_2251_3740:()=>mxt,content_2251_3742:()=>hxt,content_2251_3744:()=>fxt,content_2251_3746:()=>wxt,content_2251_3748:()=>Mxt,content_2251_3750:()=>_xt,content_2251_3752:()=>xxt,content_2251_3754:()=>Cxt,content_2251_3756:()=>bxt,content_2251_3758:()=>Zxt,content_2251_376:()=>$v,content_2251_3760:()=>Sxt,content_2251_3762:()=>zxt,content_2251_3764:()=>Ext,content_2251_3766:()=>Ixt,content_2251_3768:()=>Wxt,content_2251_3770:()=>Gxt,content_2251_3772:()=>jxt,content_2251_3774:()=>qxt,content_2251_3776:()=>Hxt,content_2251_3778:()=>Jxt,content_2251_378:()=>Yv,content_2251_3780:()=>Kxt,content_2251_3782:()=>tvt,content_2251_3784:()=>nvt,content_2251_3786:()=>svt,content_2251_3788:()=>ivt,content_2251_3790:()=>avt,content_2251_3792:()=>lvt,content_2251_3794:()=>mvt,content_2251_3796:()=>hvt,content_2251_3798:()=>fvt,content_2251_38:()=>Ag,content_2251_380:()=>Qv,content_2251_3800:()=>wvt,content_2251_3802:()=>Mvt,content_2251_3804:()=>_vt,content_2251_3806:()=>xvt,content_2251_3808:()=>Cvt,content_2251_3810:()=>bvt,content_2251_3812:()=>Zvt,content_2251_3814:()=>Svt,content_2251_3816:()=>zvt,content_2251_3818:()=>Evt,content_2251_382:()=>eC,content_2251_3820:()=>Ivt,content_2251_3822:()=>Wvt,content_2251_3824:()=>Gvt,content_2251_3826:()=>jvt,content_2251_3828:()=>qvt,content_2251_3830:()=>Hvt,content_2251_3832:()=>Jvt,content_2251_3834:()=>Kvt,content_2251_3836:()=>tCt,content_2251_3838:()=>nCt,content_2251_384:()=>oC,content_2251_3840:()=>sCt,content_2251_3842:()=>iCt,content_2251_3844:()=>aCt,content_2251_3846:()=>lCt,content_2251_3848:()=>mCt,content_2251_3850:()=>hCt,content_2251_3852:()=>fCt,content_2251_3854:()=>wCt,content_2251_3856:()=>MCt,content_2251_3858:()=>_Ct,content_2251_386:()=>rC,content_2251_3860:()=>xCt,content_2251_3862:()=>CCt,content_2251_3864:()=>bCt,content_2251_3866:()=>ZCt,content_2251_3868:()=>SCt,content_2251_3870:()=>zCt,content_2251_3872:()=>ECt,content_2251_3874:()=>ICt,content_2251_3876:()=>WCt,content_2251_3878:()=>GCt,content_2251_388:()=>pC,content_2251_3880:()=>jCt,content_2251_3882:()=>qCt,content_2251_3884:()=>HCt,content_2251_3886:()=>JCt,content_2251_3888:()=>KCt,content_2251_3890:()=>tTt,content_2251_3892:()=>nTt,content_2251_3894:()=>sTt,content_2251_3896:()=>iTt,content_2251_3898:()=>aTt,content_2251_390:()=>cC,content_2251_3900:()=>lTt,content_2251_3902:()=>mTt,content_2251_3904:()=>hTt,content_2251_3906:()=>fTt,content_2251_3908:()=>wTt,content_2251_3910:()=>MTt,content_2251_3912:()=>_Tt,content_2251_3914:()=>xTt,content_2251_3916:()=>CTt,content_2251_3918:()=>bTt,content_2251_392:()=>uC,content_2251_3920:()=>ZTt,content_2251_3922:()=>STt,content_2251_3924:()=>zTt,content_2251_3926:()=>ETt,content_2251_3928:()=>ITt,content_2251_3930:()=>WTt,content_2251_3932:()=>GTt,content_2251_3934:()=>jTt,content_2251_3936:()=>qTt,content_2251_3938:()=>HTt,content_2251_394:()=>dC,content_2251_3940:()=>JTt,content_2251_3942:()=>KTt,content_2251_3944:()=>tbt,content_2251_3946:()=>nbt,content_2251_3948:()=>sbt,content_2251_3950:()=>ibt,content_2251_3952:()=>abt,content_2251_3954:()=>lbt,content_2251_3956:()=>mbt,content_2251_3958:()=>hbt,content_2251_396:()=>yC,content_2251_3960:()=>fbt,content_2251_3962:()=>wbt,content_2251_3964:()=>Mbt,content_2251_3966:()=>_bt,content_2251_3968:()=>xbt,content_2251_3970:()=>Cbt,content_2251_3972:()=>bbt,content_2251_3974:()=>Zbt,content_2251_3976:()=>Sbt,content_2251_3978:()=>zbt,content_2251_398:()=>kC,content_2251_3980:()=>Ebt,content_2251_3982:()=>Ibt,content_2251_3984:()=>Wbt,content_2251_3986:()=>Gbt,content_2251_3988:()=>jbt,content_2251_3990:()=>qbt,content_2251_3992:()=>Hbt,content_2251_3994:()=>Jbt,content_2251_3996:()=>Kbt,content_2251_3998:()=>tLt,content_2251_4:()=>eg,content_2251_40:()=>Pg,content_2251_400:()=>gC,content_2251_4000:()=>nLt,content_2251_4002:()=>sLt,content_2251_4004:()=>iLt,content_2251_4006:()=>aLt,content_2251_4008:()=>lLt,content_2251_4010:()=>mLt,content_2251_4012:()=>hLt,content_2251_4014:()=>fLt,content_2251_4016:()=>wLt,content_2251_4018:()=>MLt,content_2251_402:()=>DC,content_2251_4020:()=>_Lt,content_2251_4022:()=>xLt,content_2251_4024:()=>CLt,content_2251_4026:()=>bLt,content_2251_4028:()=>ZLt,content_2251_4030:()=>SLt,content_2251_4032:()=>zLt,content_2251_4034:()=>ELt,content_2251_4036:()=>ILt,content_2251_4038:()=>WLt,content_2251_404:()=>XC,content_2251_4040:()=>GLt,content_2251_4042:()=>jLt,content_2251_4044:()=>qLt,content_2251_4046:()=>HLt,content_2251_4048:()=>JLt,content_2251_4050:()=>KLt,content_2251_4052:()=>tZt,content_2251_4054:()=>nZt,content_2251_4056:()=>sZt,content_2251_4058:()=>iZt,content_2251_406:()=>vC,content_2251_4060:()=>aZt,content_2251_4062:()=>lZt,content_2251_4064:()=>mZt,content_2251_4066:()=>hZt,content_2251_4068:()=>fZt,content_2251_4070:()=>wZt,content_2251_4072:()=>MZt,content_2251_4074:()=>_Zt,content_2251_4076:()=>xZt,content_2251_4078:()=>CZt,content_2251_408:()=>TC,content_2251_4080:()=>bZt,content_2251_4082:()=>ZZt,content_2251_4084:()=>SZt,content_2251_4086:()=>zZt,content_2251_4088:()=>EZt,content_2251_4090:()=>IZt,content_2251_4092:()=>WZt,content_2251_4094:()=>GZt,content_2251_4096:()=>jZt,content_2251_4098:()=>qZt,content_2251_410:()=>LC,content_2251_4100:()=>HZt,content_2251_4102:()=>JZt,content_2251_4104:()=>KZt,content_2251_4106:()=>tNt,content_2251_4108:()=>nNt,content_2251_4110:()=>sNt,content_2251_4112:()=>iNt,content_2251_4114:()=>aNt,content_2251_4116:()=>lNt,content_2251_4118:()=>mNt,content_2251_412:()=>NC,content_2251_4120:()=>hNt,content_2251_4122:()=>fNt,content_2251_4124:()=>wNt,content_2251_4126:()=>MNt,content_2251_4128:()=>_Nt,content_2251_4130:()=>xNt,content_2251_4132:()=>CNt,content_2251_4134:()=>bNt,content_2251_4136:()=>ZNt,content_2251_4138:()=>SNt,content_2251_414:()=>RC,content_2251_4140:()=>zNt,content_2251_4142:()=>ENt,content_2251_4144:()=>INt,content_2251_4146:()=>WNt,content_2251_4148:()=>GNt,content_2251_4150:()=>jNt,content_2251_4152:()=>qNt,content_2251_4154:()=>HNt,content_2251_4156:()=>JNt,content_2251_4158:()=>KNt,content_2251_416:()=>AC,content_2251_4160:()=>tSt,content_2251_4162:()=>nSt,content_2251_4164:()=>sSt,content_2251_4166:()=>iSt,content_2251_4168:()=>aSt,content_2251_4170:()=>lSt,content_2251_4172:()=>mSt,content_2251_4174:()=>hSt,content_2251_4176:()=>fSt,content_2251_4178:()=>wSt,content_2251_418:()=>PC,content_2251_4180:()=>MSt,content_2251_4182:()=>_St,content_2251_4184:()=>xSt,content_2251_4186:()=>CSt,content_2251_4188:()=>bSt,content_2251_4190:()=>ZSt,content_2251_4192:()=>SSt,content_2251_4194:()=>zSt,content_2251_4196:()=>ESt,content_2251_4198:()=>ISt,content_2251_42:()=>Fg,content_2251_420:()=>FC,content_2251_4200:()=>WSt,content_2251_4202:()=>GSt,content_2251_4204:()=>jSt,content_2251_4206:()=>qSt,content_2251_4208:()=>HSt,content_2251_4210:()=>JSt,content_2251_4212:()=>KSt,content_2251_4214:()=>tRt,content_2251_4216:()=>nRt,content_2251_4218:()=>sRt,content_2251_422:()=>BC,content_2251_4220:()=>iRt,content_2251_4222:()=>aRt,content_2251_4224:()=>lRt,content_2251_4226:()=>mRt,content_2251_4228:()=>hRt,content_2251_4230:()=>fRt,content_2251_4232:()=>wRt,content_2251_4234:()=>MRt,content_2251_4236:()=>_Rt,content_2251_4238:()=>xRt,content_2251_424:()=>OC,content_2251_4240:()=>CRt,content_2251_4242:()=>bRt,content_2251_4244:()=>ZRt,content_2251_4246:()=>SRt,content_2251_4248:()=>zRt,content_2251_4250:()=>ERt,content_2251_4252:()=>IRt,content_2251_4254:()=>WRt,content_2251_4256:()=>GRt,content_2251_4258:()=>jRt,content_2251_426:()=>UC,content_2251_4260:()=>qRt,content_2251_4262:()=>HRt,content_2251_4264:()=>JRt,content_2251_4266:()=>KRt,content_2251_4268:()=>tzt,content_2251_4270:()=>nzt,content_2251_4272:()=>szt,content_2251_4274:()=>izt,content_2251_4276:()=>azt,content_2251_4278:()=>lzt,content_2251_428:()=>VC,content_2251_4280:()=>mzt,content_2251_4282:()=>hzt,content_2251_4284:()=>fzt,content_2251_4286:()=>wzt,content_2251_4288:()=>Mzt,content_2251_4290:()=>_zt,content_2251_4292:()=>xzt,content_2251_4294:()=>Czt,content_2251_4296:()=>bzt,content_2251_4298:()=>Zzt,content_2251_430:()=>$C,content_2251_4300:()=>Szt,content_2251_4302:()=>zzt,content_2251_4304:()=>Ezt,content_2251_4306:()=>Izt,content_2251_4308:()=>Wzt,content_2251_4310:()=>Gzt,content_2251_4312:()=>jzt,content_2251_4314:()=>qzt,content_2251_4316:()=>Hzt,content_2251_4318:()=>Jzt,content_2251_432:()=>YC,content_2251_4320:()=>Kzt,content_2251_4322:()=>tAt,content_2251_4324:()=>nAt,content_2251_4326:()=>sAt,content_2251_4328:()=>iAt,content_2251_4330:()=>aAt,content_2251_4332:()=>lAt,content_2251_4334:()=>mAt,content_2251_4336:()=>hAt,content_2251_4338:()=>fAt,content_2251_434:()=>QC,content_2251_4340:()=>wAt,content_2251_4342:()=>MAt,content_2251_4344:()=>_At,content_2251_4346:()=>xAt,content_2251_4348:()=>CAt,content_2251_4350:()=>bAt,content_2251_4352:()=>ZAt,content_2251_4354:()=>SAt,content_2251_4356:()=>zAt,content_2251_4358:()=>EAt,content_2251_436:()=>eT,content_2251_4360:()=>IAt,content_2251_4362:()=>WAt,content_2251_4364:()=>GAt,content_2251_4366:()=>jAt,content_2251_4368:()=>qAt,content_2251_4370:()=>HAt,content_2251_4372:()=>JAt,content_2251_4374:()=>KAt,content_2251_4376:()=>tEt,content_2251_4378:()=>nEt,content_2251_438:()=>oT,content_2251_4380:()=>sEt,content_2251_4382:()=>iEt,content_2251_4384:()=>aEt,content_2251_4386:()=>lEt,content_2251_4388:()=>mEt,content_2251_4390:()=>hEt,content_2251_4392:()=>fEt,content_2251_4394:()=>wEt,content_2251_4396:()=>MEt,content_2251_4398:()=>_Et,content_2251_44:()=>Bg,content_2251_440:()=>rT,content_2251_4400:()=>xEt,content_2251_4402:()=>CEt,content_2251_4404:()=>bEt,content_2251_4406:()=>ZEt,content_2251_4408:()=>SEt,content_2251_4410:()=>zEt,content_2251_4412:()=>EEt,content_2251_4414:()=>IEt,content_2251_4416:()=>WEt,content_2251_4418:()=>GEt,content_2251_442:()=>pT,content_2251_4420:()=>jEt,content_2251_4422:()=>qEt,content_2251_4424:()=>HEt,content_2251_4426:()=>JEt,content_2251_4428:()=>KEt,content_2251_4430:()=>tPt,content_2251_4432:()=>nPt,content_2251_4434:()=>sPt,content_2251_4436:()=>iPt,content_2251_4438:()=>aPt,content_2251_444:()=>cT,content_2251_4440:()=>lPt,content_2251_4442:()=>mPt,content_2251_4444:()=>hPt,content_2251_4446:()=>fPt,content_2251_4448:()=>wPt,content_2251_4450:()=>MPt,content_2251_4452:()=>_Pt,content_2251_4454:()=>xPt,content_2251_4456:()=>CPt,content_2251_4458:()=>bPt,content_2251_446:()=>uT,content_2251_4460:()=>ZPt,content_2251_4462:()=>SPt,content_2251_4464:()=>zPt,content_2251_4466:()=>EPt,content_2251_4468:()=>IPt,content_2251_4470:()=>WPt,content_2251_4472:()=>GPt,content_2251_4474:()=>jPt,content_2251_4476:()=>qPt,content_2251_4478:()=>HPt,content_2251_448:()=>dT,content_2251_4480:()=>JPt,content_2251_4482:()=>KPt,content_2251_4484:()=>tIt,content_2251_4486:()=>nIt,content_2251_4488:()=>sIt,content_2251_4490:()=>iIt,content_2251_4492:()=>aIt,content_2251_4494:()=>lIt,content_2251_4496:()=>mIt,content_2251_4498:()=>hIt,content_2251_450:()=>yT,content_2251_4500:()=>fIt,content_2251_4502:()=>wIt,content_2251_4504:()=>MIt,content_2251_4506:()=>_It,content_2251_4508:()=>xIt,content_2251_4510:()=>CIt,content_2251_4512:()=>bIt,content_2251_4514:()=>ZIt,content_2251_4516:()=>SIt,content_2251_4518:()=>zIt,content_2251_452:()=>kT,content_2251_4520:()=>EIt,content_2251_4522:()=>IIt,content_2251_4524:()=>WIt,content_2251_4526:()=>GIt,content_2251_4528:()=>jIt,content_2251_4530:()=>qIt,content_2251_4532:()=>HIt,content_2251_4534:()=>JIt,content_2251_4536:()=>KIt,content_2251_4538:()=>tFt,content_2251_454:()=>gT,content_2251_4540:()=>nFt,content_2251_4542:()=>sFt,content_2251_4544:()=>iFt,content_2251_4546:()=>aFt,content_2251_4548:()=>lFt,content_2251_4550:()=>mFt,content_2251_4552:()=>hFt,content_2251_4554:()=>fFt,content_2251_4556:()=>wFt,content_2251_4558:()=>MFt,content_2251_456:()=>DT,content_2251_4560:()=>_Ft,content_2251_4562:()=>xFt,content_2251_4564:()=>CFt,content_2251_4566:()=>bFt,content_2251_4568:()=>ZFt,content_2251_4570:()=>SFt,content_2251_4572:()=>zFt,content_2251_4574:()=>EFt,content_2251_4576:()=>IFt,content_2251_4578:()=>WFt,content_2251_458:()=>XT,content_2251_4580:()=>GFt,content_2251_4582:()=>jFt,content_2251_4584:()=>qFt,content_2251_4586:()=>HFt,content_2251_4588:()=>JFt,content_2251_4590:()=>KFt,content_2251_4592:()=>tWt,content_2251_4594:()=>nWt,content_2251_4596:()=>sWt,content_2251_4598:()=>iWt,content_2251_46:()=>Og,content_2251_460:()=>vT,content_2251_4600:()=>aWt,content_2251_4602:()=>lWt,content_2251_4604:()=>mWt,content_2251_4606:()=>hWt,content_2251_4608:()=>fWt,content_2251_4610:()=>wWt,content_2251_4612:()=>MWt,content_2251_4614:()=>_Wt,content_2251_4616:()=>xWt,content_2251_4618:()=>CWt,content_2251_462:()=>TT,content_2251_4620:()=>bWt,content_2251_4622:()=>ZWt,content_2251_4624:()=>SWt,content_2251_4626:()=>zWt,content_2251_4628:()=>EWt,content_2251_4630:()=>IWt,content_2251_4632:()=>WWt,content_2251_4634:()=>GWt,content_2251_4636:()=>jWt,content_2251_4638:()=>qWt,content_2251_464:()=>LT,content_2251_4640:()=>HWt,content_2251_4642:()=>JWt,content_2251_4644:()=>KWt,content_2251_4646:()=>tBt,content_2251_4648:()=>nBt,content_2251_4650:()=>sBt,content_2251_4652:()=>iBt,content_2251_4654:()=>aBt,content_2251_4656:()=>lBt,content_2251_4658:()=>mBt,content_2251_466:()=>NT,content_2251_4660:()=>hBt,content_2251_4662:()=>fBt,content_2251_4664:()=>wBt,content_2251_4666:()=>MBt,content_2251_4668:()=>_Bt,content_2251_4670:()=>xBt,content_2251_4672:()=>CBt,content_2251_4674:()=>bBt,content_2251_4676:()=>ZBt,content_2251_4678:()=>SBt,content_2251_468:()=>RT,content_2251_4680:()=>zBt,content_2251_4682:()=>EBt,content_2251_4684:()=>IBt,content_2251_4686:()=>WBt,content_2251_4688:()=>GBt,content_2251_4690:()=>jBt,content_2251_4692:()=>qBt,content_2251_4694:()=>HBt,content_2251_4696:()=>JBt,content_2251_4698:()=>KBt,content_2251_470:()=>AT,content_2251_4700:()=>tGt,content_2251_4702:()=>nGt,content_2251_4704:()=>sGt,content_2251_4706:()=>iGt,content_2251_4708:()=>aGt,content_2251_4710:()=>lGt,content_2251_4712:()=>mGt,content_2251_4714:()=>hGt,content_2251_4716:()=>fGt,content_2251_4718:()=>wGt,content_2251_472:()=>PT,content_2251_4720:()=>MGt,content_2251_4722:()=>_Gt,content_2251_4724:()=>xGt,content_2251_4726:()=>CGt,content_2251_4728:()=>bGt,content_2251_4730:()=>ZGt,content_2251_4732:()=>SGt,content_2251_4734:()=>zGt,content_2251_4736:()=>EGt,content_2251_4738:()=>IGt,content_2251_474:()=>FT,content_2251_4740:()=>WGt,content_2251_4742:()=>GGt,content_2251_4744:()=>jGt,content_2251_4746:()=>qGt,content_2251_4748:()=>HGt,content_2251_4750:()=>JGt,content_2251_4752:()=>KGt,content_2251_4754:()=>tOt,content_2251_4756:()=>nOt,content_2251_4758:()=>sOt,content_2251_476:()=>BT,content_2251_4760:()=>iOt,content_2251_4762:()=>aOt,content_2251_4764:()=>lOt,content_2251_4766:()=>mOt,content_2251_4768:()=>hOt,content_2251_4770:()=>fOt,content_2251_4772:()=>wOt,content_2251_4774:()=>MOt,content_2251_4776:()=>_Ot,content_2251_4778:()=>xOt,content_2251_478:()=>OT,content_2251_4780:()=>COt,content_2251_4782:()=>bOt,content_2251_4784:()=>ZOt,content_2251_4786:()=>SOt,content_2251_4788:()=>zOt,content_2251_4790:()=>EOt,content_2251_4792:()=>IOt,content_2251_4794:()=>WOt,content_2251_4796:()=>GOt,content_2251_4798:()=>jOt,content_2251_48:()=>Ug,content_2251_480:()=>UT,content_2251_4800:()=>qOt,content_2251_4802:()=>HOt,content_2251_4804:()=>JOt,content_2251_4806:()=>KOt,content_2251_4808:()=>tjt,content_2251_4810:()=>njt,content_2251_4812:()=>sjt,content_2251_4814:()=>ijt,content_2251_4816:()=>ajt,content_2251_4818:()=>ljt,content_2251_482:()=>VT,content_2251_4820:()=>mjt,content_2251_4822:()=>hjt,content_2251_4824:()=>fjt,content_2251_4826:()=>wjt,content_2251_484:()=>$T,content_2251_486:()=>YT,content_2251_488:()=>QT,content_2251_490:()=>eb,content_2251_492:()=>ob,content_2251_494:()=>rb,content_2251_496:()=>pb,content_2251_498:()=>cb,content_2251_50:()=>Vg,content_2251_500:()=>ub,content_2251_502:()=>db,content_2251_504:()=>yb,content_2251_506:()=>kb,content_2251_508:()=>gb,content_2251_510:()=>Db,content_2251_512:()=>Xb,content_2251_514:()=>vb,content_2251_516:()=>Tb,content_2251_518:()=>Lb,content_2251_52:()=>$g,content_2251_520:()=>Nb,content_2251_522:()=>Rb,content_2251_524:()=>Ab,content_2251_526:()=>Pb,content_2251_528:()=>Fb,content_2251_530:()=>Bb,content_2251_532:()=>Ob,content_2251_534:()=>Ub,content_2251_536:()=>Vb,content_2251_538:()=>$b,content_2251_54:()=>Yg,content_2251_540:()=>Yb,content_2251_542:()=>Qb,content_2251_544:()=>eL,content_2251_546:()=>oL,content_2251_548:()=>rL,content_2251_550:()=>pL,content_2251_552:()=>cL,content_2251_554:()=>uL,content_2251_556:()=>dL,content_2251_558:()=>yL,content_2251_56:()=>Qg,content_2251_560:()=>kL,content_2251_562:()=>gL,content_2251_564:()=>DL,content_2251_566:()=>XL,content_2251_568:()=>vL,content_2251_570:()=>TL,content_2251_572:()=>LL,content_2251_574:()=>NL,content_2251_576:()=>RL,content_2251_578:()=>AL,content_2251_58:()=>eM,content_2251_580:()=>PL,content_2251_582:()=>FL,content_2251_584:()=>BL,content_2251_586:()=>OL,content_2251_588:()=>UL,content_2251_590:()=>VL,content_2251_592:()=>$L,content_2251_594:()=>YL,content_2251_596:()=>QL,content_2251_598:()=>eZ,content_2251_6:()=>og,content_2251_60:()=>oM,content_2251_600:()=>oZ,content_2251_602:()=>rZ,content_2251_604:()=>pZ,content_2251_606:()=>cZ,content_2251_608:()=>uZ,content_2251_610:()=>dZ,content_2251_612:()=>yZ,content_2251_614:()=>kZ,content_2251_616:()=>gZ,content_2251_618:()=>DZ,content_2251_62:()=>rM,content_2251_620:()=>XZ,content_2251_622:()=>vZ,content_2251_624:()=>TZ,content_2251_626:()=>LZ,content_2251_628:()=>NZ,content_2251_630:()=>RZ,content_2251_632:()=>AZ,content_2251_634:()=>PZ,content_2251_636:()=>FZ,content_2251_638:()=>BZ,content_2251_64:()=>pM,content_2251_640:()=>OZ,content_2251_642:()=>UZ,content_2251_644:()=>VZ,content_2251_646:()=>$Z,content_2251_648:()=>YZ,content_2251_650:()=>QZ,content_2251_652:()=>eN,content_2251_654:()=>oN,content_2251_656:()=>rN,content_2251_658:()=>pN,content_2251_66:()=>cM,content_2251_660:()=>cN,content_2251_662:()=>uN,content_2251_664:()=>dN,content_2251_666:()=>yN,content_2251_668:()=>kN,content_2251_670:()=>gN,content_2251_672:()=>DN,content_2251_674:()=>XN,content_2251_676:()=>vN,content_2251_678:()=>TN,content_2251_68:()=>uM,content_2251_680:()=>LN,content_2251_682:()=>NN,content_2251_684:()=>RN,content_2251_686:()=>AN,content_2251_688:()=>PN,content_2251_690:()=>FN,content_2251_692:()=>BN,content_2251_694:()=>ON,content_2251_696:()=>UN,content_2251_698:()=>VN,content_2251_70:()=>dM,content_2251_700:()=>$N,content_2251_702:()=>YN,content_2251_704:()=>QN,content_2251_706:()=>eS,content_2251_708:()=>oS,content_2251_710:()=>rS,content_2251_712:()=>pS,content_2251_714:()=>cS,content_2251_716:()=>uS,content_2251_718:()=>dS,content_2251_72:()=>yM,content_2251_720:()=>yS,content_2251_722:()=>kS,content_2251_724:()=>gS,content_2251_726:()=>DS,content_2251_728:()=>XS,content_2251_730:()=>vS,content_2251_732:()=>TS,content_2251_734:()=>LS,content_2251_736:()=>NS,content_2251_738:()=>RS,content_2251_74:()=>kM,content_2251_740:()=>AS,content_2251_742:()=>PS,content_2251_744:()=>FS,content_2251_746:()=>BS,content_2251_748:()=>OS,content_2251_750:()=>US,content_2251_752:()=>VS,content_2251_754:()=>$S,content_2251_756:()=>YS,content_2251_758:()=>QS,content_2251_76:()=>gM,content_2251_760:()=>eR,content_2251_762:()=>oR,content_2251_764:()=>rR,content_2251_766:()=>pR,content_2251_768:()=>cR,content_2251_770:()=>uR,content_2251_772:()=>dR,content_2251_774:()=>yR,content_2251_776:()=>kR,content_2251_778:()=>gR,content_2251_78:()=>DM,content_2251_780:()=>DR,content_2251_782:()=>XR,content_2251_784:()=>vR,content_2251_786:()=>TR,content_2251_788:()=>LR,content_2251_790:()=>NR,content_2251_792:()=>RR,content_2251_794:()=>AR,content_2251_796:()=>PR,content_2251_798:()=>FR,content_2251_8:()=>rg,content_2251_80:()=>XM,content_2251_800:()=>BR,content_2251_802:()=>OR,content_2251_804:()=>UR,content_2251_806:()=>VR,content_2251_808:()=>$R,content_2251_810:()=>YR,content_2251_812:()=>QR,content_2251_814:()=>ez,content_2251_816:()=>oz,content_2251_818:()=>rz,content_2251_82:()=>vM,content_2251_820:()=>pz,content_2251_822:()=>cz,content_2251_824:()=>uz,content_2251_826:()=>dz,content_2251_828:()=>yz,content_2251_830:()=>kz,content_2251_832:()=>gz,content_2251_834:()=>Dz,content_2251_836:()=>Xz,content_2251_838:()=>vz,content_2251_84:()=>TM,content_2251_840:()=>Tz,content_2251_842:()=>Lz,content_2251_844:()=>Nz,content_2251_846:()=>Rz,content_2251_848:()=>Az,content_2251_850:()=>Pz,content_2251_852:()=>Fz,content_2251_854:()=>Bz,content_2251_856:()=>Oz,content_2251_858:()=>Uz,content_2251_86:()=>LM,content_2251_860:()=>Vz,content_2251_862:()=>$z,content_2251_864:()=>Yz,content_2251_866:()=>Qz,content_2251_868:()=>eA,content_2251_870:()=>oA,content_2251_872:()=>rA,content_2251_874:()=>pA,content_2251_876:()=>cA,content_2251_878:()=>uA,content_2251_88:()=>NM,content_2251_880:()=>dA,content_2251_882:()=>yA,content_2251_884:()=>kA,content_2251_886:()=>gA,content_2251_888:()=>DA,content_2251_890:()=>XA,content_2251_892:()=>vA,content_2251_894:()=>TA,content_2251_896:()=>LA,content_2251_898:()=>NA,content_2251_90:()=>RM,content_2251_900:()=>RA,content_2251_902:()=>AA,content_2251_904:()=>PA,content_2251_906:()=>FA,content_2251_908:()=>BA,content_2251_910:()=>OA,content_2251_912:()=>UA,content_2251_914:()=>VA,content_2251_916:()=>$A,content_2251_918:()=>YA,content_2251_92:()=>AM,content_2251_920:()=>QA,content_2251_922:()=>eE,content_2251_924:()=>oE,content_2251_926:()=>rE,content_2251_928:()=>pE,content_2251_930:()=>cE,content_2251_932:()=>uE,content_2251_934:()=>dE,content_2251_936:()=>yE,content_2251_938:()=>kE,content_2251_94:()=>PM,content_2251_940:()=>gE,content_2251_942:()=>DE,content_2251_944:()=>XE,content_2251_946:()=>vE,content_2251_948:()=>TE,content_2251_950:()=>LE,content_2251_952:()=>NE,content_2251_954:()=>RE,content_2251_956:()=>AE,content_2251_958:()=>PE,content_2251_96:()=>FM,content_2251_960:()=>FE,content_2251_962:()=>BE,content_2251_964:()=>OE,content_2251_966:()=>UE,content_2251_968:()=>VE,content_2251_970:()=>$E,content_2251_972:()=>YE,content_2251_974:()=>QE,content_2251_976:()=>eP,content_2251_978:()=>oP,content_2251_98:()=>BM,content_2251_980:()=>rP,content_2251_982:()=>pP,content_2251_984:()=>cP,content_2251_986:()=>uP,content_2251_988:()=>dP,content_2251_990:()=>yP,content_2251_992:()=>kP,content_2251_994:()=>gP,content_2251_996:()=>DP,content_2251_998:()=>XP});var s=n(2784),r=n(7896),i=n(30876);const p={toc:[]};function a(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Property decorators."))}a.isMDXComponent=!0;const c={toc:[]};function l(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,i.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a lazy decorator."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A function that returns the value of this property."))}h.isMDXComponent=!0;const y={toc:[]};function f(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},y,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscriptions and triggering of events."))}f.isMDXComponent=!0;const k={toc:[]};function w(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},k,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,i.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}w.isMDXComponent=!0;const g={toc:[]};function M(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}M.isMDXComponent=!0;const D={toc:[]};function _(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},D,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Dispatches an asynchronous ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,i.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}_.isMDXComponent=!0;const X={toc:[]};function x(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},X,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe all subscribers from the event."))}x.isMDXComponent=!0;const v={toc:[]};function C(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},v,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A callback function that cancels the subscription."))}C.isMDXComponent=!0;const T={toc:[]};function b(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},T,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."))}b.isMDXComponent=!0;const L={toc:[]};function Z(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},L,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}Z.isMDXComponent=!0;const N={toc:[]};function S(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},N,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}S.isMDXComponent=!0;const R={toc:[]};function z(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},R,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}z.isMDXComponent=!0;const A={toc:[]};function E(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},A,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the argument passed to subscribers."))}E.isMDXComponent=!0;const P={toc:[]};function I(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},P,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}I.isMDXComponent=!0;const F={toc:[]};function W(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},F,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Dispatches a ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,i.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}W.isMDXComponent=!0;const B={toc:[]};function G(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},B,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe all subscribers from the event."))}G.isMDXComponent=!0;const O={toc:[]};function j(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},O,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A callback function that cancels the subscription."))}j.isMDXComponent=!0;const U={toc:[]};function q(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},U,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."))}q.isMDXComponent=!0;const V={toc:[]};function H(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},V,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}H.isMDXComponent=!0;const $={toc:[]};function J(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}J.isMDXComponent=!0;const Y={toc:[]};function K(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Y,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}K.isMDXComponent=!0;const Q={toc:[]};function tt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Q,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the value argument to subscribers."))}tt.isMDXComponent=!0;const et={toc:[]};function nt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},et,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A base for dispatching ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,i.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}nt.isMDXComponent=!0;const ot={toc:[]};function st(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe all subscribers from the event."))}st.isMDXComponent=!0;const rt={toc:[]};function it(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A callback function that cancels the subscription."))}it.isMDXComponent=!0;const pt={toc:[]};function at(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."))}at.isMDXComponent=!0;const ct={toc:[]};function lt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}ht.isMDXComponent=!0;const yt={toc:[]};function ft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the argument passed to subscribers."))}ft.isMDXComponent=!0;const kt={toc:[]};function wt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the callback function."))}wt.isMDXComponent=!0;const gt={toc:[]};function Mt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,i.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,i.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}Mt.isMDXComponent=!0;const Dt={toc:[]};function _t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}_t.isMDXComponent=!0;const Xt={toc:[]};function xt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Dispatches a ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,i.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}xt.isMDXComponent=!0;const vt={toc:[]};function Ct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe all subscribers from the event."))}Ct.isMDXComponent=!0;const Tt={toc:[]};function bt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Are subscribers being notified?"))}bt.isMDXComponent=!0;const Lt={toc:[]};function Zt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Notify all current and future subscribers."))}Zt.isMDXComponent=!0;const Nt={toc:[]};function St(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Stop notifying future subscribers."))}St.isMDXComponent=!0;const Rt={toc:[]};function zt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A callback function that cancels the subscription."))}zt.isMDXComponent=!0;const At={toc:[]};function Et(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},At,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."))}Et.isMDXComponent=!0;const Pt={toc:[]};function It(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}It.isMDXComponent=!0;const Ft={toc:[]};function Wt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}Wt.isMDXComponent=!0;const Bt={toc:[]};function Gt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}Gt.isMDXComponent=!0;const Ot={toc:[]};function jt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}jt.isMDXComponent=!0;const Ut={toc:[]};function qt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provides safe access to the public interface of ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,i.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}qt.isMDXComponent=!0;const Vt={toc:[]};function Ht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A callback function that cancels the subscription."))}Ht.isMDXComponent=!0;const $t={toc:[]};function Jt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."))}Jt.isMDXComponent=!0;const Yt={toc:[]};function Kt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}Kt.isMDXComponent=!0;const Qt={toc:[]};function te(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}te.isMDXComponent=!0;const ee={toc:[]};function ne(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ee,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}ne.isMDXComponent=!0;const oe={toc:[]};function se(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the argument passed to subscribers."))}se.isMDXComponent=!0;const re={toc:[]};function ie(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},re,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the callback function."))}ie.isMDXComponent=!0;const pe={toc:[]};function ae(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ae.isMDXComponent=!0;const ce={toc:[]};function le(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ce,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provides safe access to the public interface of ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,i.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}le.isMDXComponent=!0;const ue={toc:[]};function me(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ue,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the most recent value of this dispatcher."))}me.isMDXComponent=!0;const de={toc:[]};function he(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},de,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Callback function that cancels the subscription."))}he.isMDXComponent=!0;const ye={toc:[]};function fe(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ye,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."),(0,i.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}fe.isMDXComponent=!0;const ke={toc:[]};function we(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ke,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}we.isMDXComponent=!0;const ge={toc:[]};function Me(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ge,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Me.isMDXComponent=!0;const De={toc:[]};function _e(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},De,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Callback function that cancels the subscription."))}_e.isMDXComponent=!0;const Xe={toc:[]};function xe(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."),(0,i.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}xe.isMDXComponent=!0;const ve={toc:[]};function Ce(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ve,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}Ce.isMDXComponent=!0;const Te={toc:[]};function be(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Te,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}be.isMDXComponent=!0;const Le={toc:[]};function Ze(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Le,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the value passed to subscribers."))}Ze.isMDXComponent=!0;const Ne={toc:[]};function Se(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ne,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}Se.isMDXComponent=!0;const Re={toc:[]};function ze(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Re,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}ze.isMDXComponent=!0;const Ae={toc:[]};function Ee(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ae,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Dispatches a ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,i.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Ee.isMDXComponent=!0;const Pe={toc:[]};function Ie(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The initial value."))}Ie.isMDXComponent=!0;const Fe={toc:[]};function We(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the most recent value of this dispatcher."))}We.isMDXComponent=!0;const Be={toc:[]};function Ge(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Be,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Setting the value will immediately notify all subscribers."))}Ge.isMDXComponent=!0;const Oe={toc:[]};function je(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Set the current value of this dispatcher."))}je.isMDXComponent=!0;const Ue={toc:[]};function qe(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ue,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new value."))}qe.isMDXComponent=!0;const Ve={toc:[]};function He(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ve,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe all subscribers from the event."))}He.isMDXComponent=!0;const $e={toc:[]};function Je(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$e,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Callback function that cancels the subscription."))}Je.isMDXComponent=!0;const Ye={toc:[]};function Ke(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ye,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subscribe to the event."),(0,i.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ke.isMDXComponent=!0;const Qe={toc:[]};function tn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qe,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to invoke when the event occurs."))}tn.isMDXComponent=!0;const en={toc:[]};function nn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},en,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}nn.isMDXComponent=!0;const on={toc:[]};function sn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},on,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unsubscribe from the event."))}sn.isMDXComponent=!0;const rn={toc:[]};function pn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The handler to unsubscribe."))}pn.isMDXComponent=!0;const an={toc:[]};function cn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},an,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the value passed to subscribers."))}cn.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ln,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provides safe access to the public interface of ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,i.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}dn.isMDXComponent=!0;const hn={toc:[]};function yn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the argument passed to subscribers."))}yn.isMDXComponent=!0;const fn={toc:[]};function kn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}kn.isMDXComponent=!0;const wn={toc:[]};function gn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provides safe access to the public interface of ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,i.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}gn.isMDXComponent=!0;const Mn={toc:[]};function Dn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the argument passed to subscribers."))}Dn.isMDXComponent=!0;const _n={toc:[]};function Xn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_n,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Xn.isMDXComponent=!0;const xn={toc:[]};function vn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provides safe access to the public interface of ",(0,i.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,i.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}vn.isMDXComponent=!0;const Cn={toc:[]};function Tn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}Tn.isMDXComponent=!0;const bn={toc:[]};function Ln(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The amount of times the timer has ticked."))}Ln.isMDXComponent=!0;const Zn={toc:[]};function Nn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The generator responsible for running this timer."))}Nn.isMDXComponent=!0;const Sn={toc:[]};function Rn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait until the timer ticks."))}Rn.isMDXComponent=!0;const zn={toc:[]};function An(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The current iteration index."))}An.isMDXComponent=!0;const En={toc:[]};function Pn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},En,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Pn.isMDXComponent=!0;const In={toc:[]};function Fn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},In,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Fn.isMDXComponent=!0;const Wn={toc:[]};function Bn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to run."))}Bn.isMDXComponent=!0;const Gn={toc:[]};function On(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}On.isMDXComponent=!0;const jn={toc:[]};function Un(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Un.isMDXComponent=!0;const qn={toc:[]};function Vn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to run."))}Vn.isMDXComponent=!0;const Hn={toc:[]};function $n(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,i.kt)("p",null,"Note that the same animation can be written as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,i.kt)("p",null,"The reason ",(0,i.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}$n.isMDXComponent=!0;const Jn={toc:[]};function Yn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Run tasks one after another."))}Yn.isMDXComponent=!0;const Kn={toc:[]};function Qn(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kn,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to run."))}Qn.isMDXComponent=!0;const to={toc:[]};function eo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},to,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,i.kt)("p",null,"Note that the same animation can be written as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,i.kt)("p",null,"The reason ",(0,i.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}eo.isMDXComponent=!0;const no={toc:[]};function oo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},no,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}oo.isMDXComponent=!0;const so={toc:[]};function ro(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},so,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The delay in seconds"))}ro.isMDXComponent=!0;const io={toc:[]};function po(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},io,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The task or callback to run after the delay."))}po.isMDXComponent=!0;const ao={toc:[]};function co(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ao,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}co.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Call the given callback every N seconds."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The interval between subsequent calls."))}ho.isMDXComponent=!0;const yo={toc:[]};function fo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The callback to be called."))}fo.isMDXComponent=!0;const ko={toc:[]};function wo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ko,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Each time iteration waits until the previous one is completed."))}wo.isMDXComponent=!0;const go={toc:[]};function Mo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},go,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n});\n")))}Mo.isMDXComponent=!0;const Do={toc:[]};function _o(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Do,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Run the given generator N times."))}_o.isMDXComponent=!0;const Xo={toc:[]};function xo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The number of iterations."))}xo.isMDXComponent=!0;const vo={toc:[]};function Co(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each iteration."))}Co.isMDXComponent=!0;const To={toc:[]};function bo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},To,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Do nothing."))}bo.isMDXComponent=!0;const Lo={toc:[]};function Zo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Zo.isMDXComponent=!0;const No={toc:[]};function So(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},No,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Turn the given generator function into a threadable generator."))}So.isMDXComponent=!0;const Ro={toc:[]};function zo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ro,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A generator function or a factory that creates the generator."))}zo.isMDXComponent=!0;const Ao={toc:[]};function Eo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ao,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Eo.isMDXComponent=!0;const Po={toc:[]};function Io(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Po,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Turn the given generator function into a threadable generator."))}Io.isMDXComponent=!0;const Fo={toc:[]};function Wo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An optional name used when displaying this generator in the UI."))}Wo.isMDXComponent=!0;const Bo={toc:[]};function Go(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A generator function or a factory that creates the generator."))}Go.isMDXComponent=!0;const Oo={toc:[]};function jo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}jo.isMDXComponent=!0;const Uo={toc:[]};function qo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}qo.isMDXComponent=!0;const Vo={toc:[]};function Ho(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Start all tasks one after another with a constant delay between."))}Ho.isMDXComponent=!0;const $o={toc:[]};function Jo(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$o,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The delay between each of the tasks."))}Jo.isMDXComponent=!0;const Yo={toc:[]};function Ko(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to be run in a sequence."))}Ko.isMDXComponent=!0;const Qo={toc:[]};function ts(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qo,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}ts.isMDXComponent=!0;const es={toc:[]};function ns(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},es,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for the given amount of time."))}ns.isMDXComponent=!0;const os={toc:[]};function ss(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},os,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The relative time in seconds."))}ss.isMDXComponent=!0;const rs={toc:[]};function is(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An optional task to be run after the function completes."))}is.isMDXComponent=!0;const ps={toc:[]};function as(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ps,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}as.isMDXComponent=!0;const cs={toc:[]};function ls(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},us,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait until the given time event."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ds,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The name of the time event."))}hs.isMDXComponent=!0;const ys={toc:[]};function fs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ys,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An optional task to be run after the function completes."))}fs.isMDXComponent=!0;const ks={toc:[]};function ws(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ks,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Multi-media management."))}ws.isMDXComponent=!0;const gs={toc:[]};function Ms(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Ms.isMDXComponent=!0;const Ds={toc:[]};function _s(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ds,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Pause/resume the audio."))}_s.isMDXComponent=!0;const Xs={toc:[]};function xs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the audio should be paused or resumed."))}xs.isMDXComponent=!0;const vs={toc:[]};function Cs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The absolute biggest value from the peaks array."))}Cs.isMDXComponent=!0;const Ts={toc:[]};function bs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ts,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The amount of samples taken."))}bs.isMDXComponent=!0;const Ls={toc:[]};function Zs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ls,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Zs.isMDXComponent=!0;const Ns={toc:[]};function Ss(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ns,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Samples per seconds."))}Ss.isMDXComponent=!0;const Rs={toc:[]};function zs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Abstract scene representations and related utilities."))}zs.isMDXComponent=!0;const As={toc:[]};function Es(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},As,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Signifies the various stages of a ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,i.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}Es.isMDXComponent=!0;const Ps={toc:[]};function Is(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ps,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Occurs after a render ends."))}Is.isMDXComponent=!0;const Fs={toc:[]};function Ws(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}Ws.isMDXComponent=!0;const Bs={toc:[]};function Gs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,i.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}Gs.isMDXComponent=!0;const Os={toc:[]};function js(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Os,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,i.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}js.isMDXComponent=!0;const Us={toc:[]};function qs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Us,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Describes the state of a scene."))}qs.isMDXComponent=!0;const Vs={toc:[]};function Hs(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}Hs.isMDXComponent=!0;const $s={toc:[]};function Js(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$s,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene has finished transitioning in."))}Js.isMDXComponent=!0;const Ys={toc:[]};function Ks(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ys,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,i.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,i.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}Ks.isMDXComponent=!0;const Qs={toc:[]};function tr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qs,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene is ready to transition out."))}tr.isMDXComponent=!0;const er={toc:[]};function nr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},er,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Invoking ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,i.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}nr.isMDXComponent=!0;const or={toc:[]};function sr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},or,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene has finished."))}sr.isMDXComponent=!0;const rr={toc:[]};function ir(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene has just been created/reset."))}ir.isMDXComponent=!0;const pr={toc:[]};function ar(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The default implementation of the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,i.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,i.kt)("p",null,"Uses generators to control the animation."))}ar.isMDXComponent=!0;const cr={toc:[]};function lr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will be passed as the second argument to the constructor."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ur,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Name of the scene."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reference to the project."))}hr.isMDXComponent=!0;const yr={toc:[]};function fr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,i.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}fr.isMDXComponent=!0;const kr={toc:[]};function wr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,i.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}wr.isMDXComponent=!0;const gr={toc:[]};function Mr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The frame at which this scene starts."))}Mr.isMDXComponent=!0;const Dr={toc:[]};function _r(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The frame at which this scene ends."))}_r.isMDXComponent=!0;const Xr={toc:[]};function xr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the cached data changes."))}xr.isMDXComponent=!0;const vr={toc:[]};function Cr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered after scene is recalculated."))}Cr.isMDXComponent=!0;const Tr={toc:[]};function br(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the scene is reloaded."))}br.isMDXComponent=!0;const Lr={toc:[]};function Zr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Zr.isMDXComponent=!0;const Nr={toc:[]};function Sr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the scene is reset."))}Sr.isMDXComponent=!0;const Rr={toc:[]};function zr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the main thread changes."))}zr.isMDXComponent=!0;const Ar={toc:[]};function Er(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ar,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Er.isMDXComponent=!0;const Pr={toc:[]};function Ir(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,i.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Ir.isMDXComponent=!0;const Fr={toc:[]};function Wr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,i.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Wr.isMDXComponent=!0;const Br={toc:[]};function Gr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Br,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,i.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}Gr.isMDXComponent=!0;const Or={toc:[]};function jr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Or,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,i.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}jr.isMDXComponent=!0;const Ur={toc:[]};function qr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ur,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}qr.isMDXComponent=!0;const Vr={toc:[]};function Hr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Invoke the given callback in the context of this scene."))}Hr.isMDXComponent=!0;const $r={toc:[]};function Jr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$r,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The callback to invoke."))}Jr.isMDXComponent=!0;const Yr={toc:[]};function Kr(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the size of this scene."),(0,i.kt)("p",null,"Usually return ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}Kr.isMDXComponent=!0;const Qr={toc:[]};function ti(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qr,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,i.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}ti.isMDXComponent=!0;const ei={toc:[]};function ni(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ei,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene cached?"),(0,i.kt)("p",null,"Used only by ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,i.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,i.kt)("p",null,"Should always return ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}ni.isMDXComponent=!0;const oi={toc:[]};function si(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,i.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}si.isMDXComponent=!0;const ri={toc:[]};function ii(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ri,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Progress this scene one frame forward."))}ii.isMDXComponent=!0;const pi={toc:[]};function ai(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,i.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,i.kt)("p",null,"At the end of execution, this method should set ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,i.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,i.kt)("p",null,"Should trigger ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,i.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}ai.isMDXComponent=!0;const ci={toc:[]};function li(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ci,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Recalculate the scene."))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ui,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,i.kt)("p",null,"Should trigger ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,i.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},di,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reload the scene."))}hi.isMDXComponent=!0;const yi={toc:[]};function fi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If present, an updated version of the description."))}fi.isMDXComponent=!0;const ki={toc:[]};function wi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ki,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render the scene onto a canvas."))}wi.isMDXComponent=!0;const gi={toc:[]};function Mi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to used when rendering."))}Mi.isMDXComponent=!0;const Di={toc:[]};function _i(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Di,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset this scene to its initial state."))}_i.isMDXComponent=!0;const Xi={toc:[]};function xi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If present, the previous scene."))}xi.isMDXComponent=!0;const vi={toc:[]};function Ci(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the view."),(0,i.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,i.kt)("p",null,"Can modify the state of the view."))}Ci.isMDXComponent=!0;const Ti={toc:[]};function bi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ti,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Lifecycle events for ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,i.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}bi.isMDXComponent=!0;const Li={toc:[]};function Zi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Li,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A random number generator based on\n",(0,i.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,i.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Zi.isMDXComponent=!0;const Ni={toc:[]};function Si(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ni,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get an array filled with random floats in the given range."))}Si.isMDXComponent=!0;const Ri={toc:[]};function zi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ri,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The size of the array."))}zi.isMDXComponent=!0;const Ai={toc:[]};function Ei(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ai,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."))}Ei.isMDXComponent=!0;const Pi={toc:[]};function Ii(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range."))}Ii.isMDXComponent=!0;const Fi={toc:[]};function Wi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get an array filled with random integers in the given range."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"}),(0,i.kt)("li",{parentName:"ul"})))}Wi.isMDXComponent=!0;const Bi={toc:[]};function Gi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The size of the array."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"})))}Gi.isMDXComponent=!0;const Oi={toc:[]};function ji(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"})))}ji.isMDXComponent=!0;const Ui={toc:[]};function qi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ui,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range. Exclusive."))}qi.isMDXComponent=!0;const Vi={toc:[]};function Hi(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the next random float in the given range."))}Hi.isMDXComponent=!0;const $i={toc:[]};function Ji(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$i,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."))}Ji.isMDXComponent=!0;const Yi={toc:[]};function Ki(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range."))}Ki.isMDXComponent=!0;const Qi={toc:[]};function tp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qi,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the next random integer in the given range."))}tp.isMDXComponent=!0;const ep={toc:[]};function np(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ep,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."))}np.isMDXComponent=!0;const op={toc:[]};function sp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},op,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range. Exclusive."))}sp.isMDXComponent=!0;const rp={toc:[]};function ip(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a new independent generator."))}ip.isMDXComponent=!0;const pp={toc:[]};function ap(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get variable signal if exists or create signal if not"))}ap.isMDXComponent=!0;const cp={toc:[]};function lp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The name of the variable."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},up,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get variable signal if exists or create signal if not"))}hp.isMDXComponent=!0;const yp={toc:[]};function fp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset all stored signals."))}fp.isMDXComponent=!0;const kp={toc:[]};function wp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update all signals with new project variable values."))}wp.isMDXComponent=!0;const gp={toc:[]};function Mp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Describes cached information about the timing of a scene."))}Mp.isMDXComponent=!0;const Dp={toc:[]};function _p(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Describes a complete scene together with the meta file."))}_p.isMDXComponent=!0;const Xp={toc:[]};function xp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Configuration object."))}xp.isMDXComponent=!0;const vp={toc:[]};function Cp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The class used to instantiate the scene."))}Cp.isMDXComponent=!0;const Tp={toc:[]};function bp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The stack trace at the moment of creation."))}bp.isMDXComponent=!0;const Lp={toc:[]};function Zp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the configuration object."))}Zp.isMDXComponent=!0;const Np={toc:[]};function Sp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Np,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Sp.isMDXComponent=!0;const Rp={toc:[]};function zp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}zp.isMDXComponent=!0;const Ap={toc:[]};function Ep(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ap,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for the inspected element."))}Ep.isMDXComponent=!0;const Pp={toc:[]};function Ip(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The element for which to draw an overlay."))}Ip.isMDXComponent=!0;const Fp={toc:[]};function Wp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}Wp.isMDXComponent=!0;const Bp={toc:[]};function Gp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Gp.isMDXComponent=!0;const Op={toc:[]};function jp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Op,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}jp.isMDXComponent=!0;const Up={toc:[]};function qp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Up,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the attributes of the inspected element."))}qp.isMDXComponent=!0;const Vp={toc:[]};function Hp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The element to inspect."))}Hp.isMDXComponent=!0;const $p={toc:[]};function Jp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$p,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a possible element to inspect at a given position."))}Jp.isMDXComponent=!0;const Yp={toc:[]};function Kp(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The x coordinate."))}Kp.isMDXComponent=!0;const Qp={toc:[]};function ta(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qp,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The y coordinate."))}ta.isMDXComponent=!0;const ea={toc:[]};function na(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ea,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}na.isMDXComponent=!0;const oa={toc:[]};function sa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the inspected element is still valid."))}sa.isMDXComponent=!0;const ra={toc:[]};function ia(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ra,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The element to validate."))}ia.isMDXComponent=!0;const pa={toc:[]};function aa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,i.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}aa.isMDXComponent=!0;const ca={toc:[]};function la(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ca,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The main interface for scenes."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ua,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will be passed as the second argument to the constructor."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},da,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Name of the scene."))}ha.isMDXComponent=!0;const ya={toc:[]};function fa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ya,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reference to the project."))}fa.isMDXComponent=!0;const ka={toc:[]};function wa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ka,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,i.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}wa.isMDXComponent=!0;const ga={toc:[]};function Ma(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ga,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,i.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Ma.isMDXComponent=!0;const Da={toc:[]};function _a(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Da,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The frame at which this scene starts."))}_a.isMDXComponent=!0;const Xa={toc:[]};function xa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The frame at which this scene ends."))}xa.isMDXComponent=!0;const va={toc:[]};function Ca(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},va,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,i.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Ca.isMDXComponent=!0;const Ta={toc:[]};function ba(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ta,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the cached data changes."))}ba.isMDXComponent=!0;const La={toc:[]};function Za(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},La,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered after scene is recalculated."))}Za.isMDXComponent=!0;const Na={toc:[]};function Sa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Na,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the scene is reloaded."))}Sa.isMDXComponent=!0;const Ra={toc:[]};function za(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ra,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}za.isMDXComponent=!0;const Aa={toc:[]};function Ea(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Aa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the scene is reset."))}Ea.isMDXComponent=!0;const Pa={toc:[]};function Ia(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Ia.isMDXComponent=!0;const Fa={toc:[]};function Wa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,i.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Wa.isMDXComponent=!0;const Ba={toc:[]};function Ga(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ba,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,i.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Ga.isMDXComponent=!0;const Oa={toc:[]};function ja(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,i.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}ja.isMDXComponent=!0;const Ua={toc:[]};function qa(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ua,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Enter the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,i.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}qa.isMDXComponent=!0;const Va={toc:[]};function Ha(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Va,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the size of this scene."),(0,i.kt)("p",null,"Usually return ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}Ha.isMDXComponent=!0;const $a={toc:[]};function Ja(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$a,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,i.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}Ja.isMDXComponent=!0;const Ya={toc:[]};function Ka(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ya,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene cached?"),(0,i.kt)("p",null,"Used only by ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,i.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,i.kt)("p",null,"Should always return ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}Ka.isMDXComponent=!0;const Qa={toc:[]};function tc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qa,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Is this scene in the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,i.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}tc.isMDXComponent=!0;const ec={toc:[]};function nc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ec,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Progress this scene one frame forward."))}nc.isMDXComponent=!0;const oc={toc:[]};function sc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,i.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,i.kt)("p",null,"At the end of execution, this method should set ",(0,i.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,i.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,i.kt)("p",null,"Should trigger ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,i.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}sc.isMDXComponent=!0;const rc={toc:[]};function ic(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Recalculate the scene."))}ic.isMDXComponent=!0;const pc={toc:[]};function ac(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,i.kt)("p",null,"Should trigger ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,i.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}ac.isMDXComponent=!0;const cc={toc:[]};function lc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reload the scene."))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If present, an updated version of the description."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render the scene onto a canvas."))}hc.isMDXComponent=!0;const yc={toc:[]};function fc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to used when rendering."))}fc.isMDXComponent=!0;const kc={toc:[]};function wc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset this scene to its initial state."))}wc.isMDXComponent=!0;const gc={toc:[]};function Mc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If present, the previous scene."))}Mc.isMDXComponent=!0;const Dc={toc:[]};function _c(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the configuration object."))}_c.isMDXComponent=!0;const Xc={toc:[]};function xc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Each class implementing the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,i.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}xc.isMDXComponent=!0;const vc={toc:[]};function Cc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constructor used when creating new scenes."))}Cc.isMDXComponent=!0;const Tc={toc:[]};function bc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,i.kt)("inlineCode",{parentName:"a"},"config")),"."))}bc.isMDXComponent=!0;const Lc={toc:[]};function Zc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Describes a scene exposed by scene files."))}Zc.isMDXComponent=!0;const Nc={toc:[]};function Sc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Configuration object."))}Sc.isMDXComponent=!0;const Rc={toc:[]};function zc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The class used to instantiate the scene."))}zc.isMDXComponent=!0;const Ac={toc:[]};function Ec(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ac,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The stack trace at the moment of creation."))}Ec.isMDXComponent=!0;const Pc={toc:[]};function Ic(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the configuration object."))}Ic.isMDXComponent=!0;const Fc={toc:[]};function Wc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A part of the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,i.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}Wc.isMDXComponent=!0;const Bc={toc:[]};function Gc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type of the configuration object."))}Gc.isMDXComponent=!0;const Oc={toc:[]};function jc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}jc.isMDXComponent=!0;const Uc={toc:[]};function qc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}qc.isMDXComponent=!0;const Vc={toc:[]};function Hc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triggered when the main thread changes."))}Hc.isMDXComponent=!0;const $c={toc:[]};function Jc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$c,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents attributes of an inspected element."))}Jc.isMDXComponent=!0;const Yc={toc:[]};function Kc(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}Kc.isMDXComponent=!0;const Qc={toc:[]};function tl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qc,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents an element to inspect."))}tl.isMDXComponent=!0;const el={toc:[]};function nl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},el,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A runtime representation of the scene metadata."))}nl.isMDXComponent=!0;const ol={toc:[]};function sl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ol,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a runtime representation of the scene metadata."))}sl.isMDXComponent=!0;const rl={toc:[]};function il(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}il.isMDXComponent=!0;const pl={toc:[]};function al(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}al.isMDXComponent=!0;const cl={toc:[]};function ll(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the signal is currently using its initial value."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ul,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,i.kt)("p",null,"This method can be used to create copies of signals."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}hl.isMDXComponent=!0;const yl={toc:[]};function fl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the raw value of this signal."))}fl.isMDXComponent=!0;const kl={toc:[]};function wl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}wl.isMDXComponent=!0;const gl={toc:[]};function Ml(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Ml.isMDXComponent=!0;const Dl={toc:[]};function _l(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}_l.isMDXComponent=!0;const Xl={toc:[]};function xl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}xl.isMDXComponent=!0;const vl={toc:[]};function Cl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Cl.isMDXComponent=!0;const Tl={toc:[]};function bl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}bl.isMDXComponent=!0;const Ll={toc:[]};function Zl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ll,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the signal is currently using its initial value."))}Zl.isMDXComponent=!0;const Nl={toc:[]};function Sl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,i.kt)("p",null,"This method can be used to create copies of signals."))}Sl.isMDXComponent=!0;const Rl={toc:[]};function zl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}zl.isMDXComponent=!0;const Al={toc:[]};function El(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Al,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the raw value of this signal."))}El.isMDXComponent=!0;const Pl={toc:[]};function Il(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Il.isMDXComponent=!0;const Fl={toc:[]};function Wl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Wl.isMDXComponent=!0;const Bl={toc:[]};function Gl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Gl.isMDXComponent=!0;const Ol={toc:[]};function jl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ol,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}jl.isMDXComponent=!0;const Ul={toc:[]};function ql(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ul,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Compute the current value of the signal and immediately set it."))}ql.isMDXComponent=!0;const Vl={toc:[]};function Hl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the signal is currently using its initial value."))}Hl.isMDXComponent=!0;const $l={toc:[]};function Jl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$l,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Jl.isMDXComponent=!0;const Yl={toc:[]};function Kl(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yl,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Kl.isMDXComponent=!0;const Ql={toc:[]};function tu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ql,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Compute the current value of the signal and immediately set it."))}tu.isMDXComponent=!0;const eu={toc:[]};function nu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Thread management."))}nu.isMDXComponent=!0;const ou={toc:[]};function su(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ou,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,i.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}su.isMDXComponent=!0;const ru={toc:[]};function iu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ru,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A class representing an individual thread."))}iu.isMDXComponent=!0;const pu={toc:[]};function au(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The generator wrapped by this thread."))}au.isMDXComponent=!0;const cu={toc:[]};function lu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The generator wrapped by this thread."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Used by ",(0,i.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,i.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},du,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The current time of this thread."))}hu.isMDXComponent=!0;const yu={toc:[]};function fu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The next value to be passed to the wrapped generator."))}fu.isMDXComponent=!0;const ku={toc:[]};function wu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ku,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}wu.isMDXComponent=!0;const gu={toc:[]};function Mu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,i.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,i.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}Mu.isMDXComponent=!0;const Du={toc:[]};function _u(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Du,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The fixed time of this thread."))}_u.isMDXComponent=!0;const Xu={toc:[]};function xu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Progress the wrapped generator once."))}xu.isMDXComponent=!0;const vu={toc:[]};function Cu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the thread for the next update cycle."))}Cu.isMDXComponent=!0;const Tu={toc:[]};function bu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The delta time of the next cycle."))}bu.isMDXComponent=!0;const Lu={toc:[]};function Zu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A generator function or a normal function that returns a generator."))}Zu.isMDXComponent=!0;const Nu={toc:[]};function Su(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,i.kt)("p",null,"Progress to the next frame:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,i.kt)("p",null,"Run another generator synchronously:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,i.kt)("p",null,"Run another generator concurrently:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,i.kt)("p",null,"Await a Promise:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}Su.isMDXComponent=!0;const Ru={toc:[]};function zu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ru,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}zu.isMDXComponent=!0;const Au={toc:[]};function Eu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Au,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Cancel all listed tasks."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Eu.isMDXComponent=!0;const Pu={toc:[]};function Iu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to cancel."))}Iu.isMDXComponent=!0;const Fu={toc:[]};function Wu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}Wu.isMDXComponent=!0;const Bu={toc:[]};function Gu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A possible ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}Gu.isMDXComponent=!0;const Ou={toc:[]};function ju(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ou,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the given value is a ",(0,i.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,i.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}ju.isMDXComponent=!0;const Uu={toc:[]};function qu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A possible thread ",(0,i.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,i.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}qu.isMDXComponent=!0;const Vu={toc:[]};function Hu(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}Hu.isMDXComponent=!0;const $u={toc:[]};function Ju(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$u,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}Ju.isMDXComponent=!0;const Yu={toc:[]};function Ku(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to join."))}Ku.isMDXComponent=!0;const Qu={toc:[]};function tm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qu,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}tm.isMDXComponent=!0;const em={toc:[]};function nm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},em,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Pause the current generator until listed tasks are finished."))}nm.isMDXComponent=!0;const om={toc:[]};function sm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},om,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}sm.isMDXComponent=!0;const rm={toc:[]};function im(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A list of tasks to join."))}im.isMDXComponent=!0;const pm={toc:[]};function am(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"From the perspective of the external generator, ",(0,i.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,i.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}am.isMDXComponent=!0;const cm={toc:[]};function lm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},um,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a context in which generators can be run concurrently."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A function that returns the generator to run."))}hm.isMDXComponent=!0;const ym={toc:[]};function fm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ym,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}fm.isMDXComponent=!0;const km={toc:[]};function wm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},km,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Transitions between scenes."))}wm.isMDXComponent=!0;const gm={toc:[]};function Mm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Perform a transition that fades between the scenes."))}Mm.isMDXComponent=!0;const Dm={toc:[]};function _m(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition."))}_m.isMDXComponent=!0;const Xm={toc:[]};function xm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}xm.isMDXComponent=!0;const vm={toc:[]};function Cm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The direction in which to slide."))}Cm.isMDXComponent=!0;const Tm={toc:[]};function bm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition."))}bm.isMDXComponent=!0;const Lm={toc:[]};function Zm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}Zm.isMDXComponent=!0;const Nm={toc:[]};function Sm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The callback to use before the current scene is rendered."))}Sm.isMDXComponent=!0;const Rm={toc:[]};function zm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The callback to use before the previous scene is rendered."))}zm.isMDXComponent=!0;const Am={toc:[]};function Em(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Am,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}Em.isMDXComponent=!0;const Pm={toc:[]};function Im(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The area on which to zoom in."))}Im.isMDXComponent=!0;const Fm={toc:[]};function Wm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition."))}Wm.isMDXComponent=!0;const Bm={toc:[]};function Gm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}Gm.isMDXComponent=!0;const Om={toc:[]};function jm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Om,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The area from which to zoom out."))}jm.isMDXComponent=!0;const Um={toc:[]};function qm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Um,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition."))}qm.isMDXComponent=!0;const Vm={toc:[]};function Hm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Interpolation and timing of tweens."))}Hm.isMDXComponent=!0;const $m={toc:[]};function Jm(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$m,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Any old key that is missing in ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"})))}Jm.isMDXComponent=!0;const Ym={toc:[]};function Km(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ym,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A value matching the structure of from and to."))}Km.isMDXComponent=!0;const Qm={toc:[]};function td(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qm,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}td.isMDXComponent=!0;const ed={toc:[]};function nd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ed,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The input to favor when value is 0."))}nd.isMDXComponent=!0;const od={toc:[]};function sd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},od,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The input to favor when value is 1."))}sd.isMDXComponent=!0;const rd={toc:[]};function id(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}id.isMDXComponent=!0;const pd={toc:[]};function ad(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A value matching the structure of from and to."))}ad.isMDXComponent=!0;const cd={toc:[]};function ld(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ud,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The input to favor when value is 0."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The input to favor when value is 1."))}hd.isMDXComponent=!0;const yd={toc:[]};function fd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}fd.isMDXComponent=!0;const kd={toc:[]};function wd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Complex types used in animations."))}wd.isMDXComponent=!0;const gd={toc:[]};function Md(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,i.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,i.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,i.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,i.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,i.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,i.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}Md.isMDXComponent=!0;const Dd={toc:[]};function _d(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the determinant of the matrix."))}_d.isMDXComponent=!0;const Xd={toc:[]};function xd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}xd.isMDXComponent=!0;const vd={toc:[]};function Cd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}Cd.isMDXComponent=!0;const Td={toc:[]};function bd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Td,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the inverse of the matrix."))}bd.isMDXComponent=!0;const Ld={toc:[]};function Zd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ld,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Zd.isMDXComponent=!0;const Nd={toc:[]};function Sd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}Sd.isMDXComponent=!0;const Rd={toc:[]};function zd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the provided matrix to this matrix."))}zd.isMDXComponent=!0;const Ad={toc:[]};function Ed(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ad,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The matrix to add"))}Ed.isMDXComponent=!0;const Pd={toc:[]};function Id(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}Id.isMDXComponent=!0;const Fd={toc:[]};function Wd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}Wd.isMDXComponent=!0;const Bd={toc:[]};function Gd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index of the component vector to retrieve."))}Gd.isMDXComponent=!0;const Od={toc:[]};function jd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Od,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}jd.isMDXComponent=!0;const Ud={toc:[]};function qd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ud,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}qd.isMDXComponent=!0;const Vd={toc:[]};function Hd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}Hd.isMDXComponent=!0;const $d={toc:[]};function Jd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$d,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The matrix to multiply with"))}Jd.isMDXComponent=!0;const Yd={toc:[]};function Kd(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}Kd.isMDXComponent=!0;const Qd={toc:[]};function th(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qd,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"})))}th.isMDXComponent=!0;const eh={toc:[]};function nh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value by which to scale each term"))}nh.isMDXComponent=!0;const oh={toc:[]};function sh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}sh.isMDXComponent=!0;const rh={toc:[]};function ih(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}ih.isMDXComponent=!0;const ph={toc:[]};function ah(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ph,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}ah.isMDXComponent=!0;const ch={toc:[]};function lh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ch,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The angle by which to rotate the matrix"))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}hh.isMDXComponent=!0;const yh={toc:[]};function fh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index of the row to retrieve."))}fh.isMDXComponent=!0;const kh={toc:[]};function wh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}wh.isMDXComponent=!0;const gh={toc:[]};function Mh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}Mh.isMDXComponent=!0;const Dh={toc:[]};function _h(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Scale the x and y component vectors of the matrix."))}_h.isMDXComponent=!0;const Xh={toc:[]};function xh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The factor by which to scale the matrix"))}xh.isMDXComponent=!0;const vh={toc:[]};function Ch(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Ch.isMDXComponent=!0;const Th={toc:[]};function bh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Th,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}bh.isMDXComponent=!0;const Lh={toc:[]};function Zh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Subtract the provided matrix from this matrix."))}Zh.isMDXComponent=!0;const Nh={toc:[]};function Sh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The matrix to subract"))}Sh.isMDXComponent=!0;const Rh={toc:[]};function zh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,i.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}zh.isMDXComponent=!0;const Ah={toc:[]};function Eh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ah,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}Eh.isMDXComponent=!0;const Ph={toc:[]};function Ih(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ph,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}Ih.isMDXComponent=!0;const Fh={toc:[]};function Wh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The vector by which to translate the matrix"))}Wh.isMDXComponent=!0;const Bh={toc:[]};function Gh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents a two-dimensional vector."))}Gh.isMDXComponent=!0;const Oh={toc:[]};function jh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}jh.isMDXComponent=!0;const Uh={toc:[]};function qh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}qh.isMDXComponent=!0;const Vh={toc:[]};function Hh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}Hh.isMDXComponent=!0;const $h={toc:[]};function Jh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$h,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,i.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}Jh.isMDXComponent=!0;const Yh={toc:[]};function Kh(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if two vectors are equal to each other."))}Kh.isMDXComponent=!0;const Qh={toc:[]};function ty(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qh,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The vector to compare."))}ty.isMDXComponent=!0;const ey={toc:[]};function ny(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ey,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The allowed error threshold when comparing the vectors."))}ny.isMDXComponent=!0;const oy={toc:[]};function sy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,i.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}sy.isMDXComponent=!0;const ry={toc:[]};function iy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ry,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if two vectors are exactly equal to each other."))}iy.isMDXComponent=!0;const py={toc:[]};function ay(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},py,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The vector to compare."))}ay.isMDXComponent=!0;const cy={toc:[]};function ly(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}ly.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The x component of the vector."))}hy.isMDXComponent=!0;const yy={toc:[]};function fy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The y component of the vector."))}fy.isMDXComponent=!0;const ky={toc:[]};function wy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ky,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}wy.isMDXComponent=!0;const gy={toc:[]};function My(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The x component of the vector."))}My.isMDXComponent=!0;const Dy={toc:[]};function _y(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The y component of the vector."))}_y.isMDXComponent=!0;const Xy={toc:[]};function xy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}xy.isMDXComponent=!0;const vy={toc:[]};function Cy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The unclipped RGB components."))}Cy.isMDXComponent=!0;const Ty={toc:[]};function by(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ty,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}by.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ly,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}Zy.isMDXComponent=!0;const Ny={toc:[]};function Sy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ny,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Sy.isMDXComponent=!0;const Ry={toc:[]};function zy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ry,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}zy.isMDXComponent=!0;const Ay={toc:[]};function Ey(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ay,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}Ey.isMDXComponent=!0;const Py={toc:[]};function Iy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Py,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}Iy.isMDXComponent=!0;const Fy={toc:[]};function Wy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}Wy.isMDXComponent=!0;const By={toc:[]};function Gy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},By,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Alias of ",(0,i.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}Gy.isMDXComponent=!0;const Oy={toc:[]};function jy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}jy.isMDXComponent=!0;const Uy={toc:[]};function qy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the ",(0,i.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}qy.isMDXComponent=!0;const Vy={toc:[]};function Hy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}Hy.isMDXComponent=!0;const $y={toc:[]};function Jy(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$y,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the ",(0,i.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,i.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,i.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}Jy.isMDXComponent=!0;const Yy={toc:[]};function Ky(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}Ky.isMDXComponent=!0;const Qy={toc:[]};function tf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qy,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the ",(0,i.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,i.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,i.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}tf.isMDXComponent=!0;const ef={toc:[]};function nf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ef,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}nf.isMDXComponent=!0;const of={toc:[]};function sf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},of,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the ",(0,i.kt)("strong",{parentName:"p"},"L"),", ",(0,i.kt)("strong",{parentName:"p"},"a"),", and ",(0,i.kt)("strong",{parentName:"p"},"b")," components."))}sf.isMDXComponent=!0;const rf={toc:[]};function pf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}pf.isMDXComponent=!0;const af={toc:[]};function cf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},af,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the ",(0,i.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,i.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,i.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}cf.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}df.isMDXComponent=!0;const hf={toc:[]};function yf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}yf.isMDXComponent=!0;const ff={toc:[]};function kf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ff,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}kf.isMDXComponent=!0;const wf={toc:[]};function gf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get and set the color opacity."))}gf.isMDXComponent=!0;const Mf={toc:[]};function Df(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,i.kt)("code",null,"'rgb'")))}Df.isMDXComponent=!0;const _f={toc:[]};function Xf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_f,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Similar to saturate, but the opposite direction."))}Xf.isMDXComponent=!0;const xf={toc:[]};function vf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"set"))}vf.isMDXComponent=!0;const Cf={toc:[]};function Tf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns a single channel value.\nAlso"))}Tf.isMDXComponent=!0;const bf={toc:[]};function Lf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}Lf.isMDXComponent=!0;const Zf={toc:[]};function Nf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color as hexadecimal string."))}Nf.isMDXComponent=!0;const Sf={toc:[]};function Rf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,i.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,i.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}Rf.isMDXComponent=!0;const zf={toc:[]};function Af(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,i.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}Af.isMDXComponent=!0;const Ef={toc:[]};function Pf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ef,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}Pf.isMDXComponent=!0;const If={toc:[]};function Ff(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},If,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}Ff.isMDXComponent=!0;const Wf={toc:[]};function Bf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}Bf.isMDXComponent=!0;const Gf={toc:[]};function Of(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}Of.isMDXComponent=!0;const jf={toc:[]};function Uf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}Uf.isMDXComponent=!0;const qf={toc:[]};function Vf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}Vf.isMDXComponent=!0;const Hf={toc:[]};function $f(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}$f.isMDXComponent=!0;const Jf={toc:[]};function Yf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}Yf.isMDXComponent=!0;const Kf={toc:[]};function Qf(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kf,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}Qf.isMDXComponent=!0;const tk={toc:[]};function ek(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}ek.isMDXComponent=!0;const nk={toc:[]};function ok(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Convert the given origin to a vector representing its offset."))}ok.isMDXComponent=!0;const sk={toc:[]};function rk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The origin to convert."))}rk.isMDXComponent=!0;const ik={toc:[]};function pk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ik,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"General utilities and helper functions."))}pk.isMDXComponent=!0;const ak={toc:[]};function ck(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ak,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}ck.isMDXComponent=!0;const lk={toc:[]};function uk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Optional override for formatting stack traces"))}uk.isMDXComponent=!0;const mk={toc:[]};function dk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create .stack property on a target object"))}dk.isMDXComponent=!0;const hk={toc:[]};function yk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is a shortcut for calling ",(0,i.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}yk.isMDXComponent=!0;const fk={toc:[]};function kk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}kk.isMDXComponent=!0;const wk={toc:[]};function gk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Logs a debug message with an arbitrary payload."))}gk.isMDXComponent=!0;const Mk={toc:[]};function Dk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The payload to log"))}Dk.isMDXComponent=!0;const _k={toc:[]};function Xk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_k,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Mark the given function as deprecated."))}Xk.isMDXComponent=!0;const xk={toc:[]};function vk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The function to deprecate."))}vk.isMDXComponent=!0;const Ck={toc:[]};function Tk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ck,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The log message."))}Tk.isMDXComponent=!0;const bk={toc:[]};function Lk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The optional log remarks."))}Lk.isMDXComponent=!0;const Zk={toc:[]};function Nk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}Nk.isMDXComponent=!0;const Sk={toc:[]};function Rk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Mark the current scene as ready to transition out."))}Rk.isMDXComponent=!0;const zk={toc:[]};function Ak(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}Ak.isMDXComponent=!0;const Ek={toc:[]};function Pk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ek,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,i.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}Pk.isMDXComponent=!0;const Ik={toc:[]};function Fk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ik,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}Fk.isMDXComponent=!0;const Wk={toc:[]};function Bk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an array containing a range of numbers."))}Bk.isMDXComponent=!0;const Gk={toc:[]};function Ok(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The length of the array."))}Ok.isMDXComponent=!0;const jk={toc:[]};function Uk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}Uk.isMDXComponent=!0;const qk={toc:[]};function Vk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an array containing a range of numbers."))}Vk.isMDXComponent=!0;const Hk={toc:[]};function $k(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."))}$k.isMDXComponent=!0;const Jk={toc:[]};function Yk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range. ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}Yk.isMDXComponent=!0;const Kk={toc:[]};function Qk(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kk,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}Qk.isMDXComponent=!0;const tw={toc:[]};function ew(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an array containing a range of numbers."))}ew.isMDXComponent=!0;const nw={toc:[]};function ow(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start of the range."))}ow.isMDXComponent=!0;const sw={toc:[]};function rw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end of the range. ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}rw.isMDXComponent=!0;const iw={toc:[]};function pw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value by which to increment or decrement."))}pw.isMDXComponent=!0;const aw={toc:[]};function cw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}cw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The function that will be provided the context before render."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}dw.isMDXComponent=!0;const hw={toc:[]};function yw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The function that will be provided the context after render."))}yw.isMDXComponent=!0;const fw={toc:[]};function kw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}kw.isMDXComponent=!0;const ww={toc:[]};function gw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ww,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}gw.isMDXComponent=!0;const Mw={toc:[]};function Dw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the event in seconds."))}Dw.isMDXComponent=!0;const _w={toc:[]};function Xw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_w,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Register a time event and get its duration in seconds."))}Xw.isMDXComponent=!0;const xw={toc:[]};function vw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The name of the event."))}vw.isMDXComponent=!0;const Cw={toc:[]};function Tw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a reference to the playback status."))}Tw.isMDXComponent=!0;const bw={toc:[]};function Lw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the random number generator for the current scene."))}Lw.isMDXComponent=!0;const Zw={toc:[]};function Nw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the random number generator for the given seed."))}Nw.isMDXComponent=!0;const Sw={toc:[]};function Rw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The seed for the generator."))}Rw.isMDXComponent=!0;const zw={toc:[]};function Aw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}Aw.isMDXComponent=!0;const Ew={toc:[]};function Pw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ew,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a reference to the current scene."))}Pw.isMDXComponent=!0;const Iw={toc:[]};function Fw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a reference to the current thread."))}Fw.isMDXComponent=!0;const Ww={toc:[]};function Bw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ww,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,i.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}Bw.isMDXComponent=!0;const Gw={toc:[]};function Ow(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}Ow.isMDXComponent=!0;const jw={toc:[]};function Uw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the real time since the start of the animation."))}Uw.isMDXComponent=!0;const qw={toc:[]};function Vw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This rewrites a remote url like ",(0,i.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,i.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}Vw.isMDXComponent=!0;const Hw={toc:[]};function $w(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Route the given url through a local proxy."))}$w.isMDXComponent=!0;const Jw={toc:[]};function Yw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}Yw.isMDXComponent=!0;const Kw={toc:[]};function Qw(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kw,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n")))}Qw.isMDXComponent=!0;const tg={toc:[]};function eg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node for drawing circular shapes."))}eg.isMDXComponent=!0;const ng={toc:[]};function og(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ng,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}og.isMDXComponent=!0;const sg={toc:[]};function rg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}rg.isMDXComponent=!0;const ig={toc:[]};function pg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ig,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}pg.isMDXComponent=!0;const ag={toc:[]};function cg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ag,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}cg.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}dg.isMDXComponent=!0;const hg={toc:[]};function yg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}yg.isMDXComponent=!0;const fg={toc:[]};function kg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A closed circle will look like a pie chart:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,i.kt)("p",null,"An open one will look like an arc:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}kg.isMDXComponent=!0;const wg={toc:[]};function gg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"false"))}gg.isMDXComponent=!0;const Mg={toc:[]};function Dg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the path of this circle should be closed."))}Dg.isMDXComponent=!0;const _g={toc:[]};function Xg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_g,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property can be used together with ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,i.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Xg.isMDXComponent=!0;const xg={toc:[]};function vg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"360"))}vg.isMDXComponent=!0;const Cg={toc:[]};function Tg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ending angle in degrees for the circle sector."))}Tg.isMDXComponent=!0;const bg={toc:[]};function Lg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Lg.isMDXComponent=!0;const Zg={toc:[]};function Ng(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}Ng.isMDXComponent=!0;const Sg={toc:[]};function Rg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Rg.isMDXComponent=!0;const zg={toc:[]};function Ag(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}Ag.isMDXComponent=!0;const Eg={toc:[]};function Pg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Eg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Pg.isMDXComponent=!0;const Ig={toc:[]};function Fg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ig,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Fg.isMDXComponent=!0;const Wg={toc:[]};function Bg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Bg.isMDXComponent=!0;const Gg={toc:[]};function Og(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Og.isMDXComponent=!0;const jg={toc:[]};function Ug(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Ug.isMDXComponent=!0;const qg={toc:[]};function Vg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}Vg.isMDXComponent=!0;const Hg={toc:[]};function $g(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property can be used together with ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,i.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}$g.isMDXComponent=!0;const Jg={toc:[]};function Yg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"0"))}Yg.isMDXComponent=!0;const Kg={toc:[]};function Qg(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kg,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The starting angle in degrees for the circle sector."))}Qg.isMDXComponent=!0;const tM={toc:[]};function eM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}eM.isMDXComponent=!0;const nM={toc:[]};function oM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}oM.isMDXComponent=!0;const sM={toc:[]};function rM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}rM.isMDXComponent=!0;const iM={toc:[]};function pM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}pM.isMDXComponent=!0;const aM={toc:[]};function cM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}cM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}dM.isMDXComponent=!0;const hM={toc:[]};function yM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}yM.isMDXComponent=!0;const fM={toc:[]};function kM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}kM.isMDXComponent=!0;const wM={toc:[]};function gM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}gM.isMDXComponent=!0;const MM={toc:[]};function DM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}DM.isMDXComponent=!0;const _M={toc:[]};function XM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_M,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}XM.isMDXComponent=!0;const xM={toc:[]};function vM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}vM.isMDXComponent=!0;const CM={toc:[]};function TM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}TM.isMDXComponent=!0;const bM={toc:[]};function LM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}LM.isMDXComponent=!0;const ZM={toc:[]};function NM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}NM.isMDXComponent=!0;const SM={toc:[]};function RM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}RM.isMDXComponent=!0;const zM={toc:[]};function AM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}AM.isMDXComponent=!0;const EM={toc:[]};function PM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}PM.isMDXComponent=!0;const IM={toc:[]};function FM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}FM.isMDXComponent=!0;const WM={toc:[]};function BM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}BM.isMDXComponent=!0;const GM={toc:[]};function OM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}OM.isMDXComponent=!0;const jM={toc:[]};function UM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}UM.isMDXComponent=!0;const qM={toc:[]};function VM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}VM.isMDXComponent=!0;const HM={toc:[]};function $M(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}$M.isMDXComponent=!0;const JM={toc:[]};function YM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}YM.isMDXComponent=!0;const KM={toc:[]};function QM(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KM,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}QM.isMDXComponent=!0;const tD={toc:[]};function eD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}eD.isMDXComponent=!0;const nD={toc:[]};function oD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}oD.isMDXComponent=!0;const sD={toc:[]};function rD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}rD.isMDXComponent=!0;const iD={toc:[]};function pD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}pD.isMDXComponent=!0;const aD={toc:[]};function cD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}cD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}dD.isMDXComponent=!0;const hD={toc:[]};function yD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}yD.isMDXComponent=!0;const fD={toc:[]};function kD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}kD.isMDXComponent=!0;const wD={toc:[]};function gD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}gD.isMDXComponent=!0;const MD={toc:[]};function DD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}DD.isMDXComponent=!0;const _D={toc:[]};function XD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_D,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}XD.isMDXComponent=!0;const xD={toc:[]};function vD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}vD.isMDXComponent=!0;const CD={toc:[]};function TD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}TD.isMDXComponent=!0;const bD={toc:[]};function LD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}LD.isMDXComponent=!0;const ZD={toc:[]};function ND(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}ND.isMDXComponent=!0;const SD={toc:[]};function RD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}RD.isMDXComponent=!0;const zD={toc:[]};function AD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}AD.isMDXComponent=!0;const ED={toc:[]};function PD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ED,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}PD.isMDXComponent=!0;const ID={toc:[]};function FD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ID,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}FD.isMDXComponent=!0;const WD={toc:[]};function BD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}BD.isMDXComponent=!0;const GD={toc:[]};function OD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}OD.isMDXComponent=!0;const jD={toc:[]};function UD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}UD.isMDXComponent=!0;const qD={toc:[]};function VD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}VD.isMDXComponent=!0;const HD={toc:[]};function $D(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}$D.isMDXComponent=!0;const JD={toc:[]};function YD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}YD.isMDXComponent=!0;const KD={toc:[]};function QD(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KD,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}QD.isMDXComponent=!0;const t_={toc:[]};function e_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}e_.isMDXComponent=!0;const n_={toc:[]};function o_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}o_.isMDXComponent=!0;const s_={toc:[]};function r_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}r_.isMDXComponent=!0;const i_={toc:[]};function p_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}p_.isMDXComponent=!0;const a_={toc:[]};function c_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}c_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}d_.isMDXComponent=!0;const h_={toc:[]};function y_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}y_.isMDXComponent=!0;const f_={toc:[]};function k_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}k_.isMDXComponent=!0;const w_={toc:[]};function g_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}g_.isMDXComponent=!0;const M_={toc:[]};function D_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}D_.isMDXComponent=!0;const __={toc:[]};function X_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},__,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}X_.isMDXComponent=!0;const x_={toc:[]};function v_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}v_.isMDXComponent=!0;const C_={toc:[]};function T_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}T_.isMDXComponent=!0;const b_={toc:[]};function L_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}L_.isMDXComponent=!0;const Z_={toc:[]};function N_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}N_.isMDXComponent=!0;const S_={toc:[]};function R_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}R_.isMDXComponent=!0;const z_={toc:[]};function A_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}A_.isMDXComponent=!0;const E_={toc:[]};function P_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}P_.isMDXComponent=!0;const I_={toc:[]};function F_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}F_.isMDXComponent=!0;const W_={toc:[]};function B_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}B_.isMDXComponent=!0;const G_={toc:[]};function O_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}O_.isMDXComponent=!0;const j_={toc:[]};function U_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}U_.isMDXComponent=!0;const q_={toc:[]};function V_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}V_.isMDXComponent=!0;const H_={toc:[]};function $_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}$_.isMDXComponent=!0;const J_={toc:[]};function Y_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Y_.isMDXComponent=!0;const K_={toc:[]};function Q_(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K_,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Q_.isMDXComponent=!0;const tX={toc:[]};function eX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}eX.isMDXComponent=!0;const nX={toc:[]};function oX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}oX.isMDXComponent=!0;const sX={toc:[]};function rX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}rX.isMDXComponent=!0;const iX={toc:[]};function pX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}pX.isMDXComponent=!0;const aX={toc:[]};function cX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}cX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}dX.isMDXComponent=!0;const hX={toc:[]};function yX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}yX.isMDXComponent=!0;const fX={toc:[]};function kX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}kX.isMDXComponent=!0;const wX={toc:[]};function gX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}gX.isMDXComponent=!0;const MX={toc:[]};function DX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}DX.isMDXComponent=!0;const _X={toc:[]};function XX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_X,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}XX.isMDXComponent=!0;const xX={toc:[]};function vX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}vX.isMDXComponent=!0;const CX={toc:[]};function TX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}TX.isMDXComponent=!0;const bX={toc:[]};function LX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}LX.isMDXComponent=!0;const ZX={toc:[]};function NX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}NX.isMDXComponent=!0;const SX={toc:[]};function RX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}RX.isMDXComponent=!0;const zX={toc:[]};function AX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}AX.isMDXComponent=!0;const EX={toc:[]};function PX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}PX.isMDXComponent=!0;const IX={toc:[]};function FX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}FX.isMDXComponent=!0;const WX={toc:[]};function BX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}BX.isMDXComponent=!0;const GX={toc:[]};function OX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}OX.isMDXComponent=!0;const jX={toc:[]};function UX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}UX.isMDXComponent=!0;const qX={toc:[]};function VX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}VX.isMDXComponent=!0;const HX={toc:[]};function $X(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Defining a cubic B\xe9zier curve using ",(0,i.kt)("inlineCode",{parentName:"p"},"points")," property."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  <CubicBezier\n    lineWidth={4}\n    stroke={'lightseagreen'}\n    p0={[-200, -200]}\n    p1={[100, -200]}\n    p2={[-100, 200]}\n    p3={[200, 200]}\n    end={0}\n  />\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}$X.isMDXComponent=!0;const JX={toc:[]};function YX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node for drawing a cubic B\xe9zier curve."))}YX.isMDXComponent=!0;const KX={toc:[]};function QX(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KX,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}QX.isMDXComponent=!0;const tx={toc:[]};function ex(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}ex.isMDXComponent=!0;const nx={toc:[]};function ox(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ox.isMDXComponent=!0;const sx={toc:[]};function rx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}rx.isMDXComponent=!0;const ix={toc:[]};function px(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ix,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}px.isMDXComponent=!0;const ax={toc:[]};function cx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ax,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}cx.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}dx.isMDXComponent=!0;const hx={toc:[]};function yx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start point of the B\xe9zier curve."))}yx.isMDXComponent=!0;const fx={toc:[]};function kx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The first control point of the B\xe9zier curve."))}kx.isMDXComponent=!0;const wx={toc:[]};function gx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The second control point of the B\xe9zier curve."))}gx.isMDXComponent=!0;const Mx={toc:[]};function Dx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end point of the B\xe9zier curve."))}Dx.isMDXComponent=!0;const _x={toc:[]};function Xx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_x,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Xx.isMDXComponent=!0;const xx={toc:[]};function vx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}vx.isMDXComponent=!0;const Cx={toc:[]};function Tx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Tx.isMDXComponent=!0;const bx={toc:[]};function Lx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Lx.isMDXComponent=!0;const Zx={toc:[]};function Nx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Nx.isMDXComponent=!0;const Sx={toc:[]};function Rx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Rx.isMDXComponent=!0;const zx={toc:[]};function Ax(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Ax.isMDXComponent=!0;const Ex={toc:[]};function Px(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ex,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}Px.isMDXComponent=!0;const Ix={toc:[]};function Fx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ix,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}Fx.isMDXComponent=!0;const Wx={toc:[]};function Bx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Bx.isMDXComponent=!0;const Gx={toc:[]};function Ox(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}Ox.isMDXComponent=!0;const jx={toc:[]};function Ux(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}Ux.isMDXComponent=!0;const qx={toc:[]};function Vx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Vx.isMDXComponent=!0;const Hx={toc:[]};function $x(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}$x.isMDXComponent=!0;const Jx={toc:[]};function Yx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Yx.isMDXComponent=!0;const Kx={toc:[]};function Qx(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kx,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Qx.isMDXComponent=!0;const tv={toc:[]};function ev(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}ev.isMDXComponent=!0;const nv={toc:[]};function ov(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}ov.isMDXComponent=!0;const sv={toc:[]};function rv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}rv.isMDXComponent=!0;const iv={toc:[]};function pv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}pv.isMDXComponent=!0;const av={toc:[]};function cv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},av,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}cv.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}dv.isMDXComponent=!0;const hv={toc:[]};function yv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}yv.isMDXComponent=!0;const fv={toc:[]};function kv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}kv.isMDXComponent=!0;const wv={toc:[]};function gv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}gv.isMDXComponent=!0;const Mv={toc:[]};function Dv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Dv.isMDXComponent=!0;const _v={toc:[]};function Xv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_v,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}Xv.isMDXComponent=!0;const xv={toc:[]};function vv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}vv.isMDXComponent=!0;const Cv={toc:[]};function Tv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}Tv.isMDXComponent=!0;const bv={toc:[]};function Lv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}Lv.isMDXComponent=!0;const Zv={toc:[]};function Nv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Nv.isMDXComponent=!0;const Sv={toc:[]};function Rv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}Rv.isMDXComponent=!0;const zv={toc:[]};function Av(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Av.isMDXComponent=!0;const Ev={toc:[]};function Pv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ev,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Pv.isMDXComponent=!0;const Iv={toc:[]};function Fv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}Fv.isMDXComponent=!0;const Wv={toc:[]};function Bv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Bv.isMDXComponent=!0;const Gv={toc:[]};function Ov(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}Ov.isMDXComponent=!0;const jv={toc:[]};function Uv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}Uv.isMDXComponent=!0;const qv={toc:[]};function Vv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Vv.isMDXComponent=!0;const Hv={toc:[]};function $v(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}$v.isMDXComponent=!0;const Jv={toc:[]};function Yv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Yv.isMDXComponent=!0;const Kv={toc:[]};function Qv(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kv,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Qv.isMDXComponent=!0;const tC={toc:[]};function eC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}eC.isMDXComponent=!0;const nC={toc:[]};function oC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}oC.isMDXComponent=!0;const sC={toc:[]};function rC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}rC.isMDXComponent=!0;const iC={toc:[]};function pC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}pC.isMDXComponent=!0;const aC={toc:[]};function cC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}cC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dC.isMDXComponent=!0;const hC={toc:[]};function yC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}yC.isMDXComponent=!0;const fC={toc:[]};function kC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}kC.isMDXComponent=!0;const wC={toc:[]};function gC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}gC.isMDXComponent=!0;const MC={toc:[]};function DC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}DC.isMDXComponent=!0;const _C={toc:[]};function XC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_C,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}XC.isMDXComponent=!0;const xC={toc:[]};function vC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}vC.isMDXComponent=!0;const CC={toc:[]};function TC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}TC.isMDXComponent=!0;const bC={toc:[]};function LC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}LC.isMDXComponent=!0;const ZC={toc:[]};function NC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}NC.isMDXComponent=!0;const SC={toc:[]};function RC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}RC.isMDXComponent=!0;const zC={toc:[]};function AC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}AC.isMDXComponent=!0;const EC={toc:[]};function PC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}PC.isMDXComponent=!0;const IC={toc:[]};function FC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}FC.isMDXComponent=!0;const WC={toc:[]};function BC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}BC.isMDXComponent=!0;const GC={toc:[]};function OC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}OC.isMDXComponent=!0;const jC={toc:[]};function UC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}UC.isMDXComponent=!0;const qC={toc:[]};function VC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}VC.isMDXComponent=!0;const HC={toc:[]};function $C(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}$C.isMDXComponent=!0;const JC={toc:[]};function YC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}YC.isMDXComponent=!0;const KC={toc:[]};function QC(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KC,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}QC.isMDXComponent=!0;const tT={toc:[]};function eT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}eT.isMDXComponent=!0;const nT={toc:[]};function oT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}oT.isMDXComponent=!0;const sT={toc:[]};function rT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}rT.isMDXComponent=!0;const iT={toc:[]};function pT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pT.isMDXComponent=!0;const aT={toc:[]};function cT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}dT.isMDXComponent=!0;const hT={toc:[]};function yT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}yT.isMDXComponent=!0;const fT={toc:[]};function kT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}kT.isMDXComponent=!0;const wT={toc:[]};function gT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}gT.isMDXComponent=!0;const MT={toc:[]};function DT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}DT.isMDXComponent=!0;const _T={toc:[]};function XT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_T,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}XT.isMDXComponent=!0;const xT={toc:[]};function vT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}vT.isMDXComponent=!0;const CT={toc:[]};function TT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}TT.isMDXComponent=!0;const bT={toc:[]};function LT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}LT.isMDXComponent=!0;const ZT={toc:[]};function NT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}NT.isMDXComponent=!0;const ST={toc:[]};function RT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ST,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}RT.isMDXComponent=!0;const zT={toc:[]};function AT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}AT.isMDXComponent=!0;const ET={toc:[]};function PT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ET,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}PT.isMDXComponent=!0;const IT={toc:[]};function FT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}FT.isMDXComponent=!0;const WT={toc:[]};function BT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}BT.isMDXComponent=!0;const GT={toc:[]};function OT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}OT.isMDXComponent=!0;const jT={toc:[]};function UT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}UT.isMDXComponent=!0;const qT={toc:[]};function VT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}VT.isMDXComponent=!0;const HT={toc:[]};function $T(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}$T.isMDXComponent=!0;const JT={toc:[]};function YT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}YT.isMDXComponent=!0;const KT={toc:[]};function QT(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KT,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}QT.isMDXComponent=!0;const tb={toc:[]};function eb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}eb.isMDXComponent=!0;const nb={toc:[]};function ob(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ob.isMDXComponent=!0;const sb={toc:[]};function rb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}rb.isMDXComponent=!0;const ib={toc:[]};function pb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ib,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}pb.isMDXComponent=!0;const ab={toc:[]};function cb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ab,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}cb.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}db.isMDXComponent=!0;const hb={toc:[]};function yb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}yb.isMDXComponent=!0;const fb={toc:[]};function kb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}kb.isMDXComponent=!0;const wb={toc:[]};function gb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}gb.isMDXComponent=!0;const Mb={toc:[]};function Db(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Db.isMDXComponent=!0;const _b={toc:[]};function Xb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_b,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Xb.isMDXComponent=!0;const xb={toc:[]};function vb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}vb.isMDXComponent=!0;const Cb={toc:[]};function Tb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Tb.isMDXComponent=!0;const bb={toc:[]};function Lb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}Lb.isMDXComponent=!0;const Zb={toc:[]};function Nb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}Nb.isMDXComponent=!0;const Sb={toc:[]};function Rb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Rb.isMDXComponent=!0;const zb={toc:[]};function Ab(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}Ab.isMDXComponent=!0;const Eb={toc:[]};function Pb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Eb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}Pb.isMDXComponent=!0;const Ib={toc:[]};function Fb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ib,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Fb.isMDXComponent=!0;const Wb={toc:[]};function Bb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}Bb.isMDXComponent=!0;const Gb={toc:[]};function Ob(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Ob.isMDXComponent=!0;const jb={toc:[]};function Ub(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Ub.isMDXComponent=!0;const qb={toc:[]};function Vb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}Vb.isMDXComponent=!0;const Hb={toc:[]};function $b(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}$b.isMDXComponent=!0;const Jb={toc:[]};function Yb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}Yb.isMDXComponent=!0;const Kb={toc:[]};function Qb(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kb,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Qb.isMDXComponent=!0;const tL={toc:[]};function eL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}eL.isMDXComponent=!0;const nL={toc:[]};function oL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}oL.isMDXComponent=!0;const sL={toc:[]};function rL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}rL.isMDXComponent=!0;const iL={toc:[]};function pL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}pL.isMDXComponent=!0;const aL={toc:[]};function cL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}cL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}dL.isMDXComponent=!0;const hL={toc:[]};function yL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}yL.isMDXComponent=!0;const fL={toc:[]};function kL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}kL.isMDXComponent=!0;const wL={toc:[]};function gL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}gL.isMDXComponent=!0;const ML={toc:[]};function DL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ML,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}DL.isMDXComponent=!0;const _L={toc:[]};function XL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_L,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}XL.isMDXComponent=!0;const xL={toc:[]};function vL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}vL.isMDXComponent=!0;const CL={toc:[]};function TL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}TL.isMDXComponent=!0;const bL={toc:[]};function LL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}LL.isMDXComponent=!0;const ZL={toc:[]};function NL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}NL.isMDXComponent=!0;const SL={toc:[]};function RL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}RL.isMDXComponent=!0;const zL={toc:[]};function AL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}AL.isMDXComponent=!0;const EL={toc:[]};function PL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}PL.isMDXComponent=!0;const IL={toc:[]};function FL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}FL.isMDXComponent=!0;const WL={toc:[]};function BL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}BL.isMDXComponent=!0;const GL={toc:[]};function OL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}OL.isMDXComponent=!0;const jL={toc:[]};function UL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}UL.isMDXComponent=!0;const qL={toc:[]};function VL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}VL.isMDXComponent=!0;const HL={toc:[]};function $L(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}$L.isMDXComponent=!0;const JL={toc:[]};function YL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}YL.isMDXComponent=!0;const KL={toc:[]};function QL(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KL,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}QL.isMDXComponent=!0;const tZ={toc:[]};function eZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}eZ.isMDXComponent=!0;const nZ={toc:[]};function oZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}oZ.isMDXComponent=!0;const sZ={toc:[]};function rZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}rZ.isMDXComponent=!0;const iZ={toc:[]};function pZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}pZ.isMDXComponent=!0;const aZ={toc:[]};function cZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}cZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function yZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}yZ.isMDXComponent=!0;const fZ={toc:[]};function kZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}kZ.isMDXComponent=!0;const wZ={toc:[]};function gZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}gZ.isMDXComponent=!0;const MZ={toc:[]};function DZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}DZ.isMDXComponent=!0;const _Z={toc:[]};function XZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_Z,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}XZ.isMDXComponent=!0;const xZ={toc:[]};function vZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}vZ.isMDXComponent=!0;const CZ={toc:[]};function TZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}TZ.isMDXComponent=!0;const bZ={toc:[]};function LZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}LZ.isMDXComponent=!0;const ZZ={toc:[]};function NZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}NZ.isMDXComponent=!0;const SZ={toc:[]};function RZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}RZ.isMDXComponent=!0;const zZ={toc:[]};function AZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}AZ.isMDXComponent=!0;const EZ={toc:[]};function PZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}PZ.isMDXComponent=!0;const IZ={toc:[]};function FZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}FZ.isMDXComponent=!0;const WZ={toc:[]};function BZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}BZ.isMDXComponent=!0;const GZ={toc:[]};function OZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}OZ.isMDXComponent=!0;const jZ={toc:[]};function UZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}UZ.isMDXComponent=!0;const qZ={toc:[]};function VZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}VZ.isMDXComponent=!0;const HZ={toc:[]};function $Z(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}$Z.isMDXComponent=!0;const JZ={toc:[]};function YZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}YZ.isMDXComponent=!0;const KZ={toc:[]};function QZ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KZ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}QZ.isMDXComponent=!0;const tN={toc:[]};function eN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}eN.isMDXComponent=!0;const nN={toc:[]};function oN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}oN.isMDXComponent=!0;const sN={toc:[]};function rN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}rN.isMDXComponent=!0;const iN={toc:[]};function pN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}pN.isMDXComponent=!0;const aN={toc:[]};function cN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}cN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}dN.isMDXComponent=!0;const hN={toc:[]};function yN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}yN.isMDXComponent=!0;const fN={toc:[]};function kN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}kN.isMDXComponent=!0;const wN={toc:[]};function gN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}gN.isMDXComponent=!0;const MN={toc:[]};function DN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}DN.isMDXComponent=!0;const _N={toc:[]};function XN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_N,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}XN.isMDXComponent=!0;const xN={toc:[]};function vN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}vN.isMDXComponent=!0;const CN={toc:[]};function TN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}TN.isMDXComponent=!0;const bN={toc:[]};function LN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}LN.isMDXComponent=!0;const ZN={toc:[]};function NN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}NN.isMDXComponent=!0;const SN={toc:[]};function RN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}RN.isMDXComponent=!0;const zN={toc:[]};function AN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}AN.isMDXComponent=!0;const EN={toc:[]};function PN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}PN.isMDXComponent=!0;const IN={toc:[]};function FN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}FN.isMDXComponent=!0;const WN={toc:[]};function BN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}BN.isMDXComponent=!0;const GN={toc:[]};function ON(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}ON.isMDXComponent=!0;const jN={toc:[]};function UN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}UN.isMDXComponent=!0;const qN={toc:[]};function VN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}VN.isMDXComponent=!0;const HN={toc:[]};function $N(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}$N.isMDXComponent=!0;const JN={toc:[]};function YN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}YN.isMDXComponent=!0;const KN={toc:[]};function QN(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KN,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}QN.isMDXComponent=!0;const tS={toc:[]};function eS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}eS.isMDXComponent=!0;const nS={toc:[]};function oS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}oS.isMDXComponent=!0;const sS={toc:[]};function rS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}rS.isMDXComponent=!0;const iS={toc:[]};function pS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}pS.isMDXComponent=!0;const aS={toc:[]};function cS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}cS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}dS.isMDXComponent=!0;const hS={toc:[]};function yS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}yS.isMDXComponent=!0;const fS={toc:[]};function kS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}kS.isMDXComponent=!0;const wS={toc:[]};function gS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}gS.isMDXComponent=!0;const MS={toc:[]};function DS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}DS.isMDXComponent=!0;const _S={toc:[]};function XS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_S,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}XS.isMDXComponent=!0;const xS={toc:[]};function vS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An Icon Component that provides an easy access to over 150k icons.\nSee ",(0,i.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}vS.isMDXComponent=!0;const CS={toc:[]};function TS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}TS.isMDXComponent=!0;const bS={toc:[]};function LS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}LS.isMDXComponent=!0;const ZS={toc:[]};function NS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}NS.isMDXComponent=!0;const SS={toc:[]};function RS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}RS.isMDXComponent=!0;const zS={toc:[]};function AS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}AS.isMDXComponent=!0;const ES={toc:[]};function PS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ES,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}PS.isMDXComponent=!0;const IS={toc:[]};function FS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}FS.isMDXComponent=!0;const WS={toc:[]};function BS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The alpha value of this image."))}BS.isMDXComponent=!0;const GS={toc:[]};function OS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provide the color in one of the following formats:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"named color like ",(0,i.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,i.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}OS.isMDXComponent=!0;const jS={toc:[]};function US(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"'white'"))}US.isMDXComponent=!0;const qS={toc:[]};function VS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The color of the icon"))}VS.isMDXComponent=!0;const HS={toc:[]};function $S(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}$S.isMDXComponent=!0;const JS={toc:[]};function YS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}YS.isMDXComponent=!0;const KS={toc:[]};function QS(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KS,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}QS.isMDXComponent=!0;const tR={toc:[]};function eR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"You can find identifiers on ",(0,i.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}eR.isMDXComponent=!0;const nR={toc:[]};function oR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The identifier of the icon."))}oR.isMDXComponent=!0;const sR={toc:[]};function rR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}rR.isMDXComponent=!0;const iR={toc:[]};function pR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}pR.isMDXComponent=!0;const aR={toc:[]};function cR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}cR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}dR.isMDXComponent=!0;const hR={toc:[]};function yR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}yR.isMDXComponent=!0;const fR={toc:[]};function kR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}kR.isMDXComponent=!0;const wR={toc:[]};function gR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}gR.isMDXComponent=!0;const MR={toc:[]};function DR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}DR.isMDXComponent=!0;const _R={toc:[]};function XR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_R,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}XR.isMDXComponent=!0;const xR={toc:[]};function vR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}vR.isMDXComponent=!0;const CR={toc:[]};function TR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}TR.isMDXComponent=!0;const bR={toc:[]};function LR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}LR.isMDXComponent=!0;const ZR={toc:[]};function NR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}NR.isMDXComponent=!0;const SR={toc:[]};function RR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"true"))}RR.isMDXComponent=!0;const zR={toc:[]};function AR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the image should be smoothed."))}AR.isMDXComponent=!0;const ER={toc:[]};function PR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ER,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Using a local image:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,i.kt)("p",null,"Loading an image from the internet:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}PR.isMDXComponent=!0;const IR={toc:[]};function FR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The source of this image."))}FR.isMDXComponent=!0;const WR={toc:[]};function BR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}BR.isMDXComponent=!0;const GR={toc:[]};function OR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}OR.isMDXComponent=!0;const jR={toc:[]};function UR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}UR.isMDXComponent=!0;const qR={toc:[]};function VR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}VR.isMDXComponent=!0;const HR={toc:[]};function $R(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}$R.isMDXComponent=!0;const JR={toc:[]};function YR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}YR.isMDXComponent=!0;const KR={toc:[]};function QR(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KR,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}QR.isMDXComponent=!0;const tz={toc:[]};function ez(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}ez.isMDXComponent=!0;const nz={toc:[]};function oz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}oz.isMDXComponent=!0;const sz={toc:[]};function rz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}rz.isMDXComponent=!0;const iz={toc:[]};function pz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}pz.isMDXComponent=!0;const az={toc:[]};function cz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},az,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}cz.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}dz.isMDXComponent=!0;const hz={toc:[]};function yz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}yz.isMDXComponent=!0;const fz={toc:[]};function kz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}kz.isMDXComponent=!0;const wz={toc:[]};function gz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}gz.isMDXComponent=!0;const Mz={toc:[]};function Dz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Dz.isMDXComponent=!0;const _z={toc:[]};function Xz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_z,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}Xz.isMDXComponent=!0;const xz={toc:[]};function vz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}vz.isMDXComponent=!0;const Cz={toc:[]};function Tz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Tz.isMDXComponent=!0;const bz={toc:[]};function Lz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}Lz.isMDXComponent=!0;const Zz={toc:[]};function Nz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Nz.isMDXComponent=!0;const Sz={toc:[]};function Rz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}Rz.isMDXComponent=!0;const zz={toc:[]};function Az(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Az.isMDXComponent=!0;const Ez={toc:[]};function Pz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ez,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Pz.isMDXComponent=!0;const Iz={toc:[]};function Fz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Fz.isMDXComponent=!0;const Wz={toc:[]};function Bz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Bz.isMDXComponent=!0;const Gz={toc:[]};function Oz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given position."))}Oz.isMDXComponent=!0;const jz={toc:[]};function Uz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The position in local space at which to sample the color."))}Uz.isMDXComponent=!0;const qz={toc:[]};function Vz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given pixel."))}Vz.isMDXComponent=!0;const Hz={toc:[]};function $z(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The pixel's position."))}$z.isMDXComponent=!0;const Jz={toc:[]};function Yz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"overrides ",(0,i.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}Yz.isMDXComponent=!0;const Kz={toc:[]};function Qz(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kz,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Qz.isMDXComponent=!0;const tA={toc:[]};function eA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}eA.isMDXComponent=!0;const nA={toc:[]};function oA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}oA.isMDXComponent=!0;const sA={toc:[]};function rA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}rA.isMDXComponent=!0;const iA={toc:[]};function pA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}pA.isMDXComponent=!0;const aA={toc:[]};function cA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}cA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}dA.isMDXComponent=!0;const hA={toc:[]};function yA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}yA.isMDXComponent=!0;const fA={toc:[]};function kA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}kA.isMDXComponent=!0;const wA={toc:[]};function gA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}gA.isMDXComponent=!0;const MA={toc:[]};function DA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}DA.isMDXComponent=!0;const _A={toc:[]};function XA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_A,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}XA.isMDXComponent=!0;const xA={toc:[]};function vA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}vA.isMDXComponent=!0;const CA={toc:[]};function TA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}TA.isMDXComponent=!0;const bA={toc:[]};function LA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}LA.isMDXComponent=!0;const ZA={toc:[]};function NA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}NA.isMDXComponent=!0;const SA={toc:[]};function RA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}RA.isMDXComponent=!0;const zA={toc:[]};function AA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}AA.isMDXComponent=!0;const EA={toc:[]};function PA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}PA.isMDXComponent=!0;const IA={toc:[]};function FA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}FA.isMDXComponent=!0;const WA={toc:[]};function BA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}BA.isMDXComponent=!0;const GA={toc:[]};function OA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}OA.isMDXComponent=!0;const jA={toc:[]};function UA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}UA.isMDXComponent=!0;const qA={toc:[]};function VA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}VA.isMDXComponent=!0;const HA={toc:[]};function $A(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}$A.isMDXComponent=!0;const JA={toc:[]};function YA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}YA.isMDXComponent=!0;const KA={toc:[]};function QA(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KA,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}QA.isMDXComponent=!0;const tE={toc:[]};function eE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}eE.isMDXComponent=!0;const nE={toc:[]};function oE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}oE.isMDXComponent=!0;const sE={toc:[]};function rE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}rE.isMDXComponent=!0;const iE={toc:[]};function pE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}pE.isMDXComponent=!0;const aE={toc:[]};function cE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}cE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}dE.isMDXComponent=!0;const hE={toc:[]};function yE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}yE.isMDXComponent=!0;const fE={toc:[]};function kE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}kE.isMDXComponent=!0;const wE={toc:[]};function gE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}gE.isMDXComponent=!0;const ME={toc:[]};function DE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ME,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}DE.isMDXComponent=!0;const _E={toc:[]};function XE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_E,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}XE.isMDXComponent=!0;const xE={toc:[]};function vE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}vE.isMDXComponent=!0;const CE={toc:[]};function TE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}TE.isMDXComponent=!0;const bE={toc:[]};function LE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The natural size of this image."))}LE.isMDXComponent=!0;const ZE={toc:[]};function NE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}NE.isMDXComponent=!0;const SE={toc:[]};function RE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}RE.isMDXComponent=!0;const zE={toc:[]};function AE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}AE.isMDXComponent=!0;const EE={toc:[]};function PE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}PE.isMDXComponent=!0;const IE={toc:[]};function FE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}FE.isMDXComponent=!0;const WE={toc:[]};function BE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}BE.isMDXComponent=!0;const GE={toc:[]};function OE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}OE.isMDXComponent=!0;const jE={toc:[]};function UE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}UE.isMDXComponent=!0;const qE={toc:[]};function VE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}VE.isMDXComponent=!0;const HE={toc:[]};function $E(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}$E.isMDXComponent=!0;const JE={toc:[]};function YE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}YE.isMDXComponent=!0;const KE={toc:[]};function QE(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KE,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}QE.isMDXComponent=!0;const tP={toc:[]};function eP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}eP.isMDXComponent=!0;const nP={toc:[]};function oP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}oP.isMDXComponent=!0;const sP={toc:[]};function rP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}rP.isMDXComponent=!0;const iP={toc:[]};function pP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}pP.isMDXComponent=!0;const aP={toc:[]};function cP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}cP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}dP.isMDXComponent=!0;const hP={toc:[]};function yP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}yP.isMDXComponent=!0;const fP={toc:[]};function kP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"overrides ",(0,i.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}kP.isMDXComponent=!0;const wP={toc:[]};function gP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}gP.isMDXComponent=!0;const MP={toc:[]};function DP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}DP.isMDXComponent=!0;const _P={toc:[]};function XP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_P,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}XP.isMDXComponent=!0;const xP={toc:[]};function vP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}vP.isMDXComponent=!0;const CP={toc:[]};function TP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}TP.isMDXComponent=!0;const bP={toc:[]};function LP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}LP.isMDXComponent=!0;const ZP={toc:[]};function NP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Address to Iconify API for the requested Icon."))}NP.isMDXComponent=!0;const SP={toc:[]};function RP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create the URL that will be used as the Image source"))}RP.isMDXComponent=!0;const zP={toc:[]};function AP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}AP.isMDXComponent=!0;const EP={toc:[]};function PP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}PP.isMDXComponent=!0;const IP={toc:[]};function FP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}FP.isMDXComponent=!0;const WP={toc:[]};function BP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}BP.isMDXComponent=!0;const GP={toc:[]};function OP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}OP.isMDXComponent=!0;const jP={toc:[]};function UP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}UP.isMDXComponent=!0;const qP={toc:[]};function VP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}VP.isMDXComponent=!0;const HP={toc:[]};function $P(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}$P.isMDXComponent=!0;const JP={toc:[]};function YP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}YP.isMDXComponent=!0;const KP={toc:[]};function QP(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KP,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}QP.isMDXComponent=!0;const tI={toc:[]};function eI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}eI.isMDXComponent=!0;const nI={toc:[]};function oI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node for displaying images."))}oI.isMDXComponent=!0;const sI={toc:[]};function rI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}rI.isMDXComponent=!0;const iI={toc:[]};function pI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}pI.isMDXComponent=!0;const aI={toc:[]};function cI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}cI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}dI.isMDXComponent=!0;const hI={toc:[]};function yI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}yI.isMDXComponent=!0;const fI={toc:[]};function kI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}kI.isMDXComponent=!0;const wI={toc:[]};function gI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The alpha value of this image."))}gI.isMDXComponent=!0;const MI={toc:[]};function DI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}DI.isMDXComponent=!0;const _I={toc:[]};function XI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_I,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}XI.isMDXComponent=!0;const xI={toc:[]};function vI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}vI.isMDXComponent=!0;const CI={toc:[]};function TI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}TI.isMDXComponent=!0;const bI={toc:[]};function LI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}LI.isMDXComponent=!0;const ZI={toc:[]};function NI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}NI.isMDXComponent=!0;const SI={toc:[]};function RI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}RI.isMDXComponent=!0;const zI={toc:[]};function AI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}AI.isMDXComponent=!0;const EI={toc:[]};function PI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}PI.isMDXComponent=!0;const II={toc:[]};function FI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},II,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}FI.isMDXComponent=!0;const WI={toc:[]};function BI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}BI.isMDXComponent=!0;const GI={toc:[]};function OI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}OI.isMDXComponent=!0;const jI={toc:[]};function UI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}UI.isMDXComponent=!0;const qI={toc:[]};function VI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}VI.isMDXComponent=!0;const HI={toc:[]};function $I(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}$I.isMDXComponent=!0;const JI={toc:[]};function YI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}YI.isMDXComponent=!0;const KI={toc:[]};function QI(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KI,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}QI.isMDXComponent=!0;const tF={toc:[]};function eF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"true"))}eF.isMDXComponent=!0;const nF={toc:[]};function oF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the image should be smoothed."))}oF.isMDXComponent=!0;const sF={toc:[]};function rF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Using a local image:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,i.kt)("p",null,"Loading an image from the internet:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}rF.isMDXComponent=!0;const iF={toc:[]};function pF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The source of this image."))}pF.isMDXComponent=!0;const aF={toc:[]};function cF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}cF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}dF.isMDXComponent=!0;const hF={toc:[]};function yF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}yF.isMDXComponent=!0;const fF={toc:[]};function kF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}kF.isMDXComponent=!0;const wF={toc:[]};function gF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}gF.isMDXComponent=!0;const MF={toc:[]};function DF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}DF.isMDXComponent=!0;const _F={toc:[]};function XF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_F,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}XF.isMDXComponent=!0;const xF={toc:[]};function vF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}vF.isMDXComponent=!0;const CF={toc:[]};function TF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}TF.isMDXComponent=!0;const bF={toc:[]};function LF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}LF.isMDXComponent=!0;const ZF={toc:[]};function NF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}NF.isMDXComponent=!0;const SF={toc:[]};function RF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}RF.isMDXComponent=!0;const zF={toc:[]};function AF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}AF.isMDXComponent=!0;const EF={toc:[]};function PF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}PF.isMDXComponent=!0;const IF={toc:[]};function FF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}FF.isMDXComponent=!0;const WF={toc:[]};function BF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}BF.isMDXComponent=!0;const GF={toc:[]};function OF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}OF.isMDXComponent=!0;const jF={toc:[]};function UF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}UF.isMDXComponent=!0;const qF={toc:[]};function VF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}VF.isMDXComponent=!0;const HF={toc:[]};function $F(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}$F.isMDXComponent=!0;const JF={toc:[]};function YF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}YF.isMDXComponent=!0;const KF={toc:[]};function QF(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KF,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}QF.isMDXComponent=!0;const tW={toc:[]};function eW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}eW.isMDXComponent=!0;const nW={toc:[]};function oW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}oW.isMDXComponent=!0;const sW={toc:[]};function rW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}rW.isMDXComponent=!0;const iW={toc:[]};function pW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}pW.isMDXComponent=!0;const aW={toc:[]};function cW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}cW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given position."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The position in local space at which to sample the color."))}dW.isMDXComponent=!0;const hW={toc:[]};function yW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given pixel."))}yW.isMDXComponent=!0;const fW={toc:[]};function kW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The pixel's position."))}kW.isMDXComponent=!0;const wW={toc:[]};function gW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}gW.isMDXComponent=!0;const MW={toc:[]};function DW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}DW.isMDXComponent=!0;const _W={toc:[]};function XW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_W,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}XW.isMDXComponent=!0;const xW={toc:[]};function vW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}vW.isMDXComponent=!0;const CW={toc:[]};function TW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}TW.isMDXComponent=!0;const bW={toc:[]};function LW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}LW.isMDXComponent=!0;const ZW={toc:[]};function NW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}NW.isMDXComponent=!0;const SW={toc:[]};function RW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}RW.isMDXComponent=!0;const zW={toc:[]};function AW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}AW.isMDXComponent=!0;const EW={toc:[]};function PW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}PW.isMDXComponent=!0;const IW={toc:[]};function FW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}FW.isMDXComponent=!0;const WW={toc:[]};function BW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}BW.isMDXComponent=!0;const GW={toc:[]};function OW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}OW.isMDXComponent=!0;const jW={toc:[]};function UW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}UW.isMDXComponent=!0;const qW={toc:[]};function VW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}VW.isMDXComponent=!0;const HW={toc:[]};function $W(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}$W.isMDXComponent=!0;const JW={toc:[]};function YW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}YW.isMDXComponent=!0;const KW={toc:[]};function QW(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KW,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}QW.isMDXComponent=!0;const tB={toc:[]};function eB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}eB.isMDXComponent=!0;const nB={toc:[]};function oB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}oB.isMDXComponent=!0;const sB={toc:[]};function rB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}rB.isMDXComponent=!0;const iB={toc:[]};function pB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}pB.isMDXComponent=!0;const aB={toc:[]};function cB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}cB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}dB.isMDXComponent=!0;const hB={toc:[]};function yB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}yB.isMDXComponent=!0;const fB={toc:[]};function kB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}kB.isMDXComponent=!0;const wB={toc:[]};function gB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}gB.isMDXComponent=!0;const MB={toc:[]};function DB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}DB.isMDXComponent=!0;const _B={toc:[]};function XB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_B,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}XB.isMDXComponent=!0;const xB={toc:[]};function vB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}vB.isMDXComponent=!0;const CB={toc:[]};function TB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}TB.isMDXComponent=!0;const bB={toc:[]};function LB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}LB.isMDXComponent=!0;const ZB={toc:[]};function NB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}NB.isMDXComponent=!0;const SB={toc:[]};function RB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}RB.isMDXComponent=!0;const zB={toc:[]};function AB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}AB.isMDXComponent=!0;const EB={toc:[]};function PB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}PB.isMDXComponent=!0;const IB={toc:[]};function FB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}FB.isMDXComponent=!0;const WB={toc:[]};function BB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}BB.isMDXComponent=!0;const GB={toc:[]};function OB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}OB.isMDXComponent=!0;const jB={toc:[]};function UB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}UB.isMDXComponent=!0;const qB={toc:[]};function VB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}VB.isMDXComponent=!0;const HB={toc:[]};function $B(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The natural size of this image."))}$B.isMDXComponent=!0;const JB={toc:[]};function YB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}YB.isMDXComponent=!0;const KB={toc:[]};function QB(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KB,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}QB.isMDXComponent=!0;const tG={toc:[]};function eG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}eG.isMDXComponent=!0;const nG={toc:[]};function oG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}oG.isMDXComponent=!0;const sG={toc:[]};function rG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}rG.isMDXComponent=!0;const iG={toc:[]};function pG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}pG.isMDXComponent=!0;const aG={toc:[]};function cG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}cG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}dG.isMDXComponent=!0;const hG={toc:[]};function yG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}yG.isMDXComponent=!0;const fG={toc:[]};function kG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}kG.isMDXComponent=!0;const wG={toc:[]};function gG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}gG.isMDXComponent=!0;const MG={toc:[]};function DG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}DG.isMDXComponent=!0;const _G={toc:[]};function XG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_G,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}XG.isMDXComponent=!0;const xG={toc:[]};function vG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}vG.isMDXComponent=!0;const CG={toc:[]};function TG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}TG.isMDXComponent=!0;const bG={toc:[]};function LG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}LG.isMDXComponent=!0;const ZG={toc:[]};function NG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}NG.isMDXComponent=!0;const SG={toc:[]};function RG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}RG.isMDXComponent=!0;const zG={toc:[]};function AG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}AG.isMDXComponent=!0;const EG={toc:[]};function PG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}PG.isMDXComponent=!0;const IG={toc:[]};function FG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}FG.isMDXComponent=!0;const WG={toc:[]};function BG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}BG.isMDXComponent=!0;const GG={toc:[]};function OG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}OG.isMDXComponent=!0;const jG={toc:[]};function UG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}UG.isMDXComponent=!0;const qG={toc:[]};function VG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}VG.isMDXComponent=!0;const HG={toc:[]};function $G(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}$G.isMDXComponent=!0;const JG={toc:[]};function YG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}YG.isMDXComponent=!0;const KG={toc:[]};function QG(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KG,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}QG.isMDXComponent=!0;const tO={toc:[]};function eO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}eO.isMDXComponent=!0;const nO={toc:[]};function oO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}oO.isMDXComponent=!0;const sO={toc:[]};function rO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}rO.isMDXComponent=!0;const iO={toc:[]};function pO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}pO.isMDXComponent=!0;const aO={toc:[]};function cO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}cO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}dO.isMDXComponent=!0;const hO={toc:[]};function yO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node representing a knot of a ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,i.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}yO.isMDXComponent=!0;const fO={toc:[]};function kO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}kO.isMDXComponent=!0;const wO={toc:[]};function gO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}gO.isMDXComponent=!0;const MO={toc:[]};function DO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}DO.isMDXComponent=!0;const _O={toc:[]};function XO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_O,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}XO.isMDXComponent=!0;const xO={toc:[]};function vO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}vO.isMDXComponent=!0;const CO={toc:[]};function TO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}TO.isMDXComponent=!0;const bO={toc:[]};function LO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}LO.isMDXComponent=!0;const ZO={toc:[]};function NO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"0"))}NO.isMDXComponent=!0;const SO={toc:[]};function RO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}RO.isMDXComponent=!0;const zO={toc:[]};function AO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,i.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,i.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,i.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,i.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}AO.isMDXComponent=!0;const EO={toc:[]};function PO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Mirrored position of the startHandle."))}PO.isMDXComponent=!0;const IO={toc:[]};function FO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}FO.isMDXComponent=!0;const WO={toc:[]};function BO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}BO.isMDXComponent=!0;const GO={toc:[]};function OO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}OO.isMDXComponent=!0;const jO={toc:[]};function UO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}UO.isMDXComponent=!0;const qO={toc:[]};function VO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}VO.isMDXComponent=!0;const HO={toc:[]};function $O(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}$O.isMDXComponent=!0;const JO={toc:[]};function YO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,i.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,i.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,i.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,i.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}YO.isMDXComponent=!0;const KO={toc:[]};function QO(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KO,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Mirrored position of the endHandle."))}QO.isMDXComponent=!0;const tj={toc:[]};function ej(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}ej.isMDXComponent=!0;const nj={toc:[]};function oj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}oj.isMDXComponent=!0;const sj={toc:[]};function rj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}rj.isMDXComponent=!0;const ij={toc:[]};function pj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ij,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}pj.isMDXComponent=!0;const aj={toc:[]};function cj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}cj.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}dj.isMDXComponent=!0;const hj={toc:[]};function yj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}yj.isMDXComponent=!0;const fj={toc:[]};function kj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}kj.isMDXComponent=!0;const wj={toc:[]};function gj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}gj.isMDXComponent=!0;const Mj={toc:[]};function Dj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Dj.isMDXComponent=!0;const _j={toc:[]};function Xj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_j,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}Xj.isMDXComponent=!0;const xj={toc:[]};function vj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}vj.isMDXComponent=!0;const Cj={toc:[]};function Tj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}Tj.isMDXComponent=!0;const bj={toc:[]};function Lj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Lj.isMDXComponent=!0;const Zj={toc:[]};function Nj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}Nj.isMDXComponent=!0;const Sj={toc:[]};function Rj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Rj.isMDXComponent=!0;const zj={toc:[]};function Aj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}Aj.isMDXComponent=!0;const Ej={toc:[]};function Pj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ej,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Pj.isMDXComponent=!0;const Ij={toc:[]};function Fj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ij,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Fj.isMDXComponent=!0;const Wj={toc:[]};function Bj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}Bj.isMDXComponent=!0;const Gj={toc:[]};function Oj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Oj.isMDXComponent=!0;const jj={toc:[]};function Uj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}Uj.isMDXComponent=!0;const qj={toc:[]};function Vj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Vj.isMDXComponent=!0;const Hj={toc:[]};function $j(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}$j.isMDXComponent=!0;const Jj={toc:[]};function Yj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Yj.isMDXComponent=!0;const Kj={toc:[]};function Qj(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kj,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Qj.isMDXComponent=!0;const tU={toc:[]};function eU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}eU.isMDXComponent=!0;const nU={toc:[]};function oU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}oU.isMDXComponent=!0;const sU={toc:[]};function rU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}rU.isMDXComponent=!0;const iU={toc:[]};function pU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}pU.isMDXComponent=!0;const aU={toc:[]};function cU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}cU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}dU.isMDXComponent=!0;const hU={toc:[]};function yU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}yU.isMDXComponent=!0;const fU={toc:[]};function kU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}kU.isMDXComponent=!0;const wU={toc:[]};function gU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}gU.isMDXComponent=!0;const MU={toc:[]};function DU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}DU.isMDXComponent=!0;const _U={toc:[]};function XU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_U,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}XU.isMDXComponent=!0;const xU={toc:[]};function vU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}vU.isMDXComponent=!0;const CU={toc:[]};function TU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}TU.isMDXComponent=!0;const bU={toc:[]};function LU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}LU.isMDXComponent=!0;const ZU={toc:[]};function NU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}NU.isMDXComponent=!0;const SU={toc:[]};function RU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}RU.isMDXComponent=!0;const zU={toc:[]};function AU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}AU.isMDXComponent=!0;const EU={toc:[]};function PU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}PU.isMDXComponent=!0;const IU={toc:[]};function FU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}FU.isMDXComponent=!0;const WU={toc:[]};function BU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}BU.isMDXComponent=!0;const GU={toc:[]};function OU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}OU.isMDXComponent=!0;const jU={toc:[]};function UU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}UU.isMDXComponent=!0;const qU={toc:[]};function VU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}VU.isMDXComponent=!0;const HU={toc:[]};function $U(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}$U.isMDXComponent=!0;const JU={toc:[]};function YU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}YU.isMDXComponent=!0;const KU={toc:[]};function QU(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KU,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}QU.isMDXComponent=!0;const tq={toc:[]};function eq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}eq.isMDXComponent=!0;const nq={toc:[]};function oq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}oq.isMDXComponent=!0;const sq={toc:[]};function rq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}rq.isMDXComponent=!0;const iq={toc:[]};function pq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}pq.isMDXComponent=!0;const aq={toc:[]};function cq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}cq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}dq.isMDXComponent=!0;const hq={toc:[]};function yq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}yq.isMDXComponent=!0;const fq={toc:[]};function kq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}kq.isMDXComponent=!0;const wq={toc:[]};function gq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}gq.isMDXComponent=!0;const Mq={toc:[]};function Dq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Dq.isMDXComponent=!0;const _q={toc:[]};function Xq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_q,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}Xq.isMDXComponent=!0;const xq={toc:[]};function vq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}vq.isMDXComponent=!0;const Cq={toc:[]};function Tq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Cq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}Tq.isMDXComponent=!0;const bq={toc:[]};function Lq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}Lq.isMDXComponent=!0;const Zq={toc:[]};function Nq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Zq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}Nq.isMDXComponent=!0;const Sq={toc:[]};function Rq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Sq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Rq.isMDXComponent=!0;const zq={toc:[]};function Aq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Aq.isMDXComponent=!0;const Eq={toc:[]};function Pq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Eq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Pq.isMDXComponent=!0;const Iq={toc:[]};function Fq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Iq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}Fq.isMDXComponent=!0;const Wq={toc:[]};function Bq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}Bq.isMDXComponent=!0;const Gq={toc:[]};function Oq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Oq.isMDXComponent=!0;const jq={toc:[]};function Uq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Uq.isMDXComponent=!0;const qq={toc:[]};function Vq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}Vq.isMDXComponent=!0;const Hq={toc:[]};function $q(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Hq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}$q.isMDXComponent=!0;const Jq={toc:[]};function Yq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}Yq.isMDXComponent=!0;const Kq={toc:[]};function Qq(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Kq,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Qq.isMDXComponent=!0;const tV={toc:[]};function eV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}eV.isMDXComponent=!0;const nV={toc:[]};function oV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}oV.isMDXComponent=!0;const sV={toc:[]};function rV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}rV.isMDXComponent=!0;const iV={toc:[]};function pV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}pV.isMDXComponent=!0;const aV={toc:[]};function cV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}cV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}dV.isMDXComponent=!0;const hV={toc:[]};function yV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}yV.isMDXComponent=!0;const fV={toc:[]};function kV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}kV.isMDXComponent=!0;const wV={toc:[]};function gV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}gV.isMDXComponent=!0;const MV={toc:[]};function DV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}DV.isMDXComponent=!0;const _V={toc:[]};function XV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_V,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}XV.isMDXComponent=!0;const xV={toc:[]};function vV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}vV.isMDXComponent=!0;const CV={toc:[]};function TV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}TV.isMDXComponent=!0;const bV={toc:[]};function LV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}LV.isMDXComponent=!0;const ZV={toc:[]};function NV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}NV.isMDXComponent=!0;const SV={toc:[]};function RV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}RV.isMDXComponent=!0;const zV={toc:[]};function AV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node for displaying images."))}AV.isMDXComponent=!0;const EV={toc:[]};function PV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}PV.isMDXComponent=!0;const IV={toc:[]};function FV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}FV.isMDXComponent=!0;const WV={toc:[]};function BV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}BV.isMDXComponent=!0;const GV={toc:[]};function OV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}OV.isMDXComponent=!0;const jV={toc:[]};function UV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}UV.isMDXComponent=!0;const qV={toc:[]};function VV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}VV.isMDXComponent=!0;const HV={toc:[]};function $V(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}$V.isMDXComponent=!0;const JV={toc:[]};function YV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The alpha value of this image."))}YV.isMDXComponent=!0;const KV={toc:[]};function QV(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KV,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}QV.isMDXComponent=!0;const tH={toc:[]};function eH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}eH.isMDXComponent=!0;const nH={toc:[]};function oH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}oH.isMDXComponent=!0;const sH={toc:[]};function rH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}rH.isMDXComponent=!0;const iH={toc:[]};function pH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}pH.isMDXComponent=!0;const aH={toc:[]};function cH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}cH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}dH.isMDXComponent=!0;const hH={toc:[]};function yH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}yH.isMDXComponent=!0;const fH={toc:[]};function kH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}kH.isMDXComponent=!0;const wH={toc:[]};function gH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}gH.isMDXComponent=!0;const MH={toc:[]};function DH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}DH.isMDXComponent=!0;const _H={toc:[]};function XH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_H,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}XH.isMDXComponent=!0;const xH={toc:[]};function vH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}vH.isMDXComponent=!0;const CH={toc:[]};function TH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}TH.isMDXComponent=!0;const bH={toc:[]};function LH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}LH.isMDXComponent=!0;const ZH={toc:[]};function NH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}NH.isMDXComponent=!0;const SH={toc:[]};function RH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"true"))}RH.isMDXComponent=!0;const zH={toc:[]};function AH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the image should be smoothed."))}AH.isMDXComponent=!0;const EH={toc:[]};function PH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Using a local image:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,i.kt)("p",null,"Loading an image from the internet:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}PH.isMDXComponent=!0;const IH={toc:[]};function FH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The source of this image."))}FH.isMDXComponent=!0;const WH={toc:[]};function BH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}BH.isMDXComponent=!0;const GH={toc:[]};function OH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}OH.isMDXComponent=!0;const jH={toc:[]};function UH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}UH.isMDXComponent=!0;const qH={toc:[]};function VH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}VH.isMDXComponent=!0;const HH={toc:[]};function $H(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}$H.isMDXComponent=!0;const JH={toc:[]};function YH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}YH.isMDXComponent=!0;const KH={toc:[]};function QH(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KH,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}QH.isMDXComponent=!0;const t$={toc:[]};function e$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}e$.isMDXComponent=!0;const n$={toc:[]};function o$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}o$.isMDXComponent=!0;const s$={toc:[]};function r$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}r$.isMDXComponent=!0;const i$={toc:[]};function p$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}p$.isMDXComponent=!0;const a$={toc:[]};function c$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}c$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}d$.isMDXComponent=!0;const h$={toc:[]};function y$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}y$.isMDXComponent=!0;const f$={toc:[]};function k$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}k$.isMDXComponent=!0;const w$={toc:[]};function g$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}g$.isMDXComponent=!0;const M$={toc:[]};function D$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}D$.isMDXComponent=!0;const _$={toc:[]};function X$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}X$.isMDXComponent=!0;const x$={toc:[]};function v$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}v$.isMDXComponent=!0;const C$={toc:[]};function T$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}T$.isMDXComponent=!0;const b$={toc:[]};function L$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}L$.isMDXComponent=!0;const Z$={toc:[]};function N$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}N$.isMDXComponent=!0;const S$={toc:[]};function R$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}R$.isMDXComponent=!0;const z$={toc:[]};function A$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}A$.isMDXComponent=!0;const E$={toc:[]};function P$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}P$.isMDXComponent=!0;const I$={toc:[]};function F$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}F$.isMDXComponent=!0;const W$={toc:[]};function B$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}B$.isMDXComponent=!0;const G$={toc:[]};function O$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given position."))}O$.isMDXComponent=!0;const j$={toc:[]};function U$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The position in local space at which to sample the color."))}U$.isMDXComponent=!0;const q$={toc:[]};function V$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get color of the image at the given pixel."))}V$.isMDXComponent=!0;const H$={toc:[]};function $$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The pixel's position."))}$$.isMDXComponent=!0;const J$={toc:[]};function Y$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Y$.isMDXComponent=!0;const K$={toc:[]};function Q$(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K$,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}Q$.isMDXComponent=!0;const tJ={toc:[]};function eJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}eJ.isMDXComponent=!0;const nJ={toc:[]};function oJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}oJ.isMDXComponent=!0;const sJ={toc:[]};function rJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}rJ.isMDXComponent=!0;const iJ={toc:[]};function pJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}pJ.isMDXComponent=!0;const aJ={toc:[]};function cJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}cJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function yJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}yJ.isMDXComponent=!0;const fJ={toc:[]};function kJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}kJ.isMDXComponent=!0;const wJ={toc:[]};function gJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}gJ.isMDXComponent=!0;const MJ={toc:[]};function DJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}DJ.isMDXComponent=!0;const _J={toc:[]};function XJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_J,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}XJ.isMDXComponent=!0;const xJ={toc:[]};function vJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}vJ.isMDXComponent=!0;const CJ={toc:[]};function TJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}TJ.isMDXComponent=!0;const bJ={toc:[]};function LJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}LJ.isMDXComponent=!0;const ZJ={toc:[]};function NJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}NJ.isMDXComponent=!0;const SJ={toc:[]};function RJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}RJ.isMDXComponent=!0;const zJ={toc:[]};function AJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}AJ.isMDXComponent=!0;const EJ={toc:[]};function PJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}PJ.isMDXComponent=!0;const IJ={toc:[]};function FJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}FJ.isMDXComponent=!0;const WJ={toc:[]};function BJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}BJ.isMDXComponent=!0;const GJ={toc:[]};function OJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}OJ.isMDXComponent=!0;const jJ={toc:[]};function UJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}UJ.isMDXComponent=!0;const qJ={toc:[]};function VJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}VJ.isMDXComponent=!0;const HJ={toc:[]};function $J(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}$J.isMDXComponent=!0;const JJ={toc:[]};function YJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}YJ.isMDXComponent=!0;const KJ={toc:[]};function QJ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KJ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}QJ.isMDXComponent=!0;const tY={toc:[]};function eY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}eY.isMDXComponent=!0;const nY={toc:[]};function oY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}oY.isMDXComponent=!0;const sY={toc:[]};function rY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}rY.isMDXComponent=!0;const iY={toc:[]};function pY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}pY.isMDXComponent=!0;const aY={toc:[]};function cY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}cY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}dY.isMDXComponent=!0;const hY={toc:[]};function yY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}yY.isMDXComponent=!0;const fY={toc:[]};function kY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}kY.isMDXComponent=!0;const wY={toc:[]};function gY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}gY.isMDXComponent=!0;const MY={toc:[]};function DY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}DY.isMDXComponent=!0;const _Y={toc:[]};function XY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_Y,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}XY.isMDXComponent=!0;const xY={toc:[]};function vY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}vY.isMDXComponent=!0;const CY={toc:[]};function TY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The natural size of this image."))}TY.isMDXComponent=!0;const bY={toc:[]};function LY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}LY.isMDXComponent=!0;const ZY={toc:[]};function NY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}NY.isMDXComponent=!0;const SY={toc:[]};function RY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}RY.isMDXComponent=!0;const zY={toc:[]};function AY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}AY.isMDXComponent=!0;const EY={toc:[]};function PY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}PY.isMDXComponent=!0;const IY={toc:[]};function FY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}FY.isMDXComponent=!0;const WY={toc:[]};function BY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}BY.isMDXComponent=!0;const GY={toc:[]};function OY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}OY.isMDXComponent=!0;const jY={toc:[]};function UY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}UY.isMDXComponent=!0;const qY={toc:[]};function VY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}VY.isMDXComponent=!0;const HY={toc:[]};function $Y(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}$Y.isMDXComponent=!0;const JY={toc:[]};function YY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}YY.isMDXComponent=!0;const KY={toc:[]};function QY(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KY,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}QY.isMDXComponent=!0;const tK={toc:[]};function eK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}eK.isMDXComponent=!0;const nK={toc:[]};function oK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}oK.isMDXComponent=!0;const sK={toc:[]};function rK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}rK.isMDXComponent=!0;const iK={toc:[]};function pK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}pK.isMDXComponent=!0;const aK={toc:[]};function cK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}cK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}dK.isMDXComponent=!0;const hK={toc:[]};function yK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}yK.isMDXComponent=!0;const fK={toc:[]};function kK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}kK.isMDXComponent=!0;const wK={toc:[]};function gK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}gK.isMDXComponent=!0;const MK={toc:[]};function DK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}DK.isMDXComponent=!0;const _K={toc:[]};function XK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_K,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}XK.isMDXComponent=!0;const xK={toc:[]};function vK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}vK.isMDXComponent=!0;const CK={toc:[]};function TK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}TK.isMDXComponent=!0;const bK={toc:[]};function LK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}LK.isMDXComponent=!0;const ZK={toc:[]};function NK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}NK.isMDXComponent=!0;const SK={toc:[]};function RK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}RK.isMDXComponent=!0;const zK={toc:[]};function AK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}AK.isMDXComponent=!0;const EK={toc:[]};function PK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}PK.isMDXComponent=!0;const IK={toc:[]};function FK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}FK.isMDXComponent=!0;const WK={toc:[]};function BK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}BK.isMDXComponent=!0;const GK={toc:[]};function OK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}OK.isMDXComponent=!0;const jK={toc:[]};function UK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}UK.isMDXComponent=!0;const qK={toc:[]};function VK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}VK.isMDXComponent=!0;const HK={toc:[]};function $K(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}$K.isMDXComponent=!0;const JK={toc:[]};function YK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}YK.isMDXComponent=!0;const KK={toc:[]};function QK(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KK,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}QK.isMDXComponent=!0;const tQ={toc:[]};function eQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}eQ.isMDXComponent=!0;const nQ={toc:[]};function oQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},nQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}oQ.isMDXComponent=!0;const sQ={toc:[]};function rQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},sQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}rQ.isMDXComponent=!0;const iQ={toc:[]};function pQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}pQ.isMDXComponent=!0;const aQ={toc:[]};function cQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}cQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},lQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function yQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},hQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}yQ.isMDXComponent=!0;const fQ={toc:[]};function kQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},fQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}kQ.isMDXComponent=!0;const wQ={toc:[]};function gQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}gQ.isMDXComponent=!0;const MQ={toc:[]};function DQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},MQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}DQ.isMDXComponent=!0;const _Q={toc:[]};function XQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_Q,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}XQ.isMDXComponent=!0;const xQ={toc:[]};function vQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}vQ.isMDXComponent=!0;const CQ={toc:[]};function TQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},CQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}TQ.isMDXComponent=!0;const bQ={toc:[]};function LQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},bQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}LQ.isMDXComponent=!0;const ZQ={toc:[]};function NQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ZQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}NQ.isMDXComponent=!0;const SQ={toc:[]};function RQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},SQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}RQ.isMDXComponent=!0;const zQ={toc:[]};function AQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},zQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}AQ.isMDXComponent=!0;const EQ={toc:[]};function PQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},EQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}PQ.isMDXComponent=!0;const IQ={toc:[]};function FQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},IQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}FQ.isMDXComponent=!0;const WQ={toc:[]};function BQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},WQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}BQ.isMDXComponent=!0;const GQ={toc:[]};function OQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},GQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}OQ.isMDXComponent=!0;const jQ={toc:[]};function UQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}UQ.isMDXComponent=!0;const qQ={toc:[]};function VQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}VQ.isMDXComponent=!0;const HQ={toc:[]};function $Q(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},HQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}$Q.isMDXComponent=!0;const JQ={toc:[]};function YQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},JQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}YQ.isMDXComponent=!0;const KQ={toc:[]};function QQ(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},KQ,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}QQ.isMDXComponent=!0;const t0={toc:[]};function e0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}e0.isMDXComponent=!0;const n0={toc:[]};function o0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}o0.isMDXComponent=!0;const s0={toc:[]};function r0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}r0.isMDXComponent=!0;const i0={toc:[]};function p0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}p0.isMDXComponent=!0;const a0={toc:[]};function c0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}c0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}d0.isMDXComponent=!0;const h0={toc:[]};function y0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}y0.isMDXComponent=!0;const f0={toc:[]};function k0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}k0.isMDXComponent=!0;const w0={toc:[]};function g0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}g0.isMDXComponent=!0;const M0={toc:[]};function D0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}D0.isMDXComponent=!0;const _0={toc:[]};function X0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}X0.isMDXComponent=!0;const x0={toc:[]};function v0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}v0.isMDXComponent=!0;const C0={toc:[]};function T0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}T0.isMDXComponent=!0;const b0={toc:[]};function L0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}L0.isMDXComponent=!0;const Z0={toc:[]};function N0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}N0.isMDXComponent=!0;const S0={toc:[]};function R0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}R0.isMDXComponent=!0;const z0={toc:[]};function A0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}A0.isMDXComponent=!0;const E0={toc:[]};function P0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}P0.isMDXComponent=!0;const I0={toc:[]};function F0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}F0.isMDXComponent=!0;const W0={toc:[]};function B0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}B0.isMDXComponent=!0;const G0={toc:[]};function O0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}O0.isMDXComponent=!0;const j0={toc:[]};function U0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}U0.isMDXComponent=!0;const q0={toc:[]};function V0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}V0.isMDXComponent=!0;const H0={toc:[]};function $0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}$0.isMDXComponent=!0;const J0={toc:[]};function Y0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Y0.isMDXComponent=!0;const K0={toc:[]};function Q0(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K0,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}Q0.isMDXComponent=!0;const t2={toc:[]};function e2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}e2.isMDXComponent=!0;const n2={toc:[]};function o2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}o2.isMDXComponent=!0;const s2={toc:[]};function r2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}r2.isMDXComponent=!0;const i2={toc:[]};function p2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}p2.isMDXComponent=!0;const a2={toc:[]};function c2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}c2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}d2.isMDXComponent=!0;const h2={toc:[]};function y2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}y2.isMDXComponent=!0;const f2={toc:[]};function k2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}k2.isMDXComponent=!0;const w2={toc:[]};function g2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}g2.isMDXComponent=!0;const M2={toc:[]};function D2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}D2.isMDXComponent=!0;const _2={toc:[]};function X2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}X2.isMDXComponent=!0;const x2={toc:[]};function v2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}v2.isMDXComponent=!0;const C2={toc:[]};function T2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}T2.isMDXComponent=!0;const b2={toc:[]};function L2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}L2.isMDXComponent=!0;const Z2={toc:[]};function N2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}N2.isMDXComponent=!0;const S2={toc:[]};function R2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}R2.isMDXComponent=!0;const z2={toc:[]};function A2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}A2.isMDXComponent=!0;const E2={toc:[]};function P2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}P2.isMDXComponent=!0;const I2={toc:[]};function F2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}F2.isMDXComponent=!0;const W2={toc:[]};function B2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}B2.isMDXComponent=!0;const G2={toc:[]};function O2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}O2.isMDXComponent=!0;const j2={toc:[]};function U2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}U2.isMDXComponent=!0;const q2={toc:[]};function V2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}V2.isMDXComponent=!0;const H2={toc:[]};function $2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}$2.isMDXComponent=!0;const J2={toc:[]};function Y2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Y2.isMDXComponent=!0;const K2={toc:[]};function Q2(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K2,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}Q2.isMDXComponent=!0;const t1={toc:[]};function e1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}e1.isMDXComponent=!0;const n1={toc:[]};function o1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}o1.isMDXComponent=!0;const s1={toc:[]};function r1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}r1.isMDXComponent=!0;const i1={toc:[]};function p1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}p1.isMDXComponent=!0;const a1={toc:[]};function c1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}c1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}d1.isMDXComponent=!0;const h1={toc:[]};function y1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}y1.isMDXComponent=!0;const f1={toc:[]};function k1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}k1.isMDXComponent=!0;const w1={toc:[]};function g1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}g1.isMDXComponent=!0;const M1={toc:[]};function D1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}D1.isMDXComponent=!0;const _1={toc:[]};function X1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}X1.isMDXComponent=!0;const x1={toc:[]};function v1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}v1.isMDXComponent=!0;const C1={toc:[]};function T1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}T1.isMDXComponent=!0;const b1={toc:[]};function L1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}L1.isMDXComponent=!0;const Z1={toc:[]};function N1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}N1.isMDXComponent=!0;const S1={toc:[]};function R1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}R1.isMDXComponent=!0;const z1={toc:[]};function A1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}A1.isMDXComponent=!0;const E1={toc:[]};function P1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}P1.isMDXComponent=!0;const I1={toc:[]};function F1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}F1.isMDXComponent=!0;const W1={toc:[]};function B1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}B1.isMDXComponent=!0;const G1={toc:[]};function O1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}O1.isMDXComponent=!0;const j1={toc:[]};function U1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}U1.isMDXComponent=!0;const q1={toc:[]};function V1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}V1.isMDXComponent=!0;const H1={toc:[]};function $1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}$1.isMDXComponent=!0;const J1={toc:[]};function Y1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Y1.isMDXComponent=!0;const K1={toc:[]};function Q1(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K1,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Q1.isMDXComponent=!0;const t5={toc:[]};function e5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}e5.isMDXComponent=!0;const n5={toc:[]};function o5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}o5.isMDXComponent=!0;const s5={toc:[]};function r5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}r5.isMDXComponent=!0;const i5={toc:[]};function p5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}p5.isMDXComponent=!0;const a5={toc:[]};function c5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}c5.isMDXComponent=!0;const l5={toc:[]};function u5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}u5.isMDXComponent=!0;const m5={toc:[]};function d5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}d5.isMDXComponent=!0;const h5={toc:[]};function y5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}y5.isMDXComponent=!0;const f5={toc:[]};function k5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}k5.isMDXComponent=!0;const w5={toc:[]};function g5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}g5.isMDXComponent=!0;const M5={toc:[]};function D5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}D5.isMDXComponent=!0;const _5={toc:[]};function X5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}X5.isMDXComponent=!0;const x5={toc:[]};function v5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}v5.isMDXComponent=!0;const C5={toc:[]};function T5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}T5.isMDXComponent=!0;const b5={toc:[]};function L5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}L5.isMDXComponent=!0;const Z5={toc:[]};function N5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}N5.isMDXComponent=!0;const S5={toc:[]};function R5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}R5.isMDXComponent=!0;const z5={toc:[]};function A5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}A5.isMDXComponent=!0;const E5={toc:[]};function P5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}P5.isMDXComponent=!0;const I5={toc:[]};function F5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}F5.isMDXComponent=!0;const W5={toc:[]};function B5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}B5.isMDXComponent=!0;const G5={toc:[]};function O5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}O5.isMDXComponent=!0;const j5={toc:[]};function U5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}U5.isMDXComponent=!0;const q5={toc:[]};function V5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}V5.isMDXComponent=!0;const H5={toc:[]};function $5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}$5.isMDXComponent=!0;const J5={toc:[]};function Y5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}Y5.isMDXComponent=!0;const K5={toc:[]};function Q5(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K5,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Q5.isMDXComponent=!0;const t4={toc:[]};function e4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}e4.isMDXComponent=!0;const n4={toc:[]};function o4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}o4.isMDXComponent=!0;const s4={toc:[]};function r4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}r4.isMDXComponent=!0;const i4={toc:[]};function p4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}p4.isMDXComponent=!0;const a4={toc:[]};function c4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}c4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}d4.isMDXComponent=!0;const h4={toc:[]};function y4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}y4.isMDXComponent=!0;const f4={toc:[]};function k4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}k4.isMDXComponent=!0;const w4={toc:[]};function g4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}g4.isMDXComponent=!0;const M4={toc:[]};function D4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}D4.isMDXComponent=!0;const _4={toc:[]};function X4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}X4.isMDXComponent=!0;const x4={toc:[]};function v4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}v4.isMDXComponent=!0;const C4={toc:[]};function T4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}T4.isMDXComponent=!0;const b4={toc:[]};function L4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}L4.isMDXComponent=!0;const Z4={toc:[]};function N4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}N4.isMDXComponent=!0;const S4={toc:[]};function R4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}R4.isMDXComponent=!0;const z4={toc:[]};function A4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}A4.isMDXComponent=!0;const E4={toc:[]};function P4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}P4.isMDXComponent=!0;const I4={toc:[]};function F4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}F4.isMDXComponent=!0;const W4={toc:[]};function B4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}B4.isMDXComponent=!0;const G4={toc:[]};function O4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}O4.isMDXComponent=!0;const j4={toc:[]};function U4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}U4.isMDXComponent=!0;const q4={toc:[]};function V4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}V4.isMDXComponent=!0;const H4={toc:[]};function $4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}$4.isMDXComponent=!0;const J4={toc:[]};function Y4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}Y4.isMDXComponent=!0;const K4={toc:[]};function Q4(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K4,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Q4.isMDXComponent=!0;const t3={toc:[]};function e3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}e3.isMDXComponent=!0;const n3={toc:[]};function o3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}o3.isMDXComponent=!0;const s3={toc:[]};function r3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}r3.isMDXComponent=!0;const i3={toc:[]};function p3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}p3.isMDXComponent=!0;const a3={toc:[]};function c3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}c3.isMDXComponent=!0;const l3={toc:[]};function u3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}d3.isMDXComponent=!0;const h3={toc:[]};function y3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}y3.isMDXComponent=!0;const f3={toc:[]};function k3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}k3.isMDXComponent=!0;const w3={toc:[]};function g3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}g3.isMDXComponent=!0;const M3={toc:[]};function D3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}D3.isMDXComponent=!0;const _3={toc:[]};function X3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}X3.isMDXComponent=!0;const x3={toc:[]};function v3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}v3.isMDXComponent=!0;const C3={toc:[]};function T3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}T3.isMDXComponent=!0;const b3={toc:[]};function L3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}L3.isMDXComponent=!0;const Z3={toc:[]};function N3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}N3.isMDXComponent=!0;const S3={toc:[]};function R3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}R3.isMDXComponent=!0;const z3={toc:[]};function A3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}A3.isMDXComponent=!0;const E3={toc:[]};function P3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}P3.isMDXComponent=!0;const I3={toc:[]};function F3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}F3.isMDXComponent=!0;const W3={toc:[]};function B3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}B3.isMDXComponent=!0;const G3={toc:[]};function O3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}O3.isMDXComponent=!0;const j3={toc:[]};function U3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}U3.isMDXComponent=!0;const q3={toc:[]};function V3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}V3.isMDXComponent=!0;const H3={toc:[]};function $3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}$3.isMDXComponent=!0;const J3={toc:[]};function Y3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Y3.isMDXComponent=!0;const K3={toc:[]};function Q3(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K3,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}Q3.isMDXComponent=!0;const t6={toc:[]};function e6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}e6.isMDXComponent=!0;const n6={toc:[]};function o6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}o6.isMDXComponent=!0;const s6={toc:[]};function r6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}r6.isMDXComponent=!0;const i6={toc:[]};function p6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}p6.isMDXComponent=!0;const a6={toc:[]};function c6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}c6.isMDXComponent=!0;const l6={toc:[]};function u6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}u6.isMDXComponent=!0;const m6={toc:[]};function d6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}d6.isMDXComponent=!0;const h6={toc:[]};function y6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}y6.isMDXComponent=!0;const f6={toc:[]};function k6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}k6.isMDXComponent=!0;const w6={toc:[]};function g6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}g6.isMDXComponent=!0;const M6={toc:[]};function D6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}D6.isMDXComponent=!0;const _6={toc:[]};function X6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}X6.isMDXComponent=!0;const x6={toc:[]};function v6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}v6.isMDXComponent=!0;const C6={toc:[]};function T6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}T6.isMDXComponent=!0;const b6={toc:[]};function L6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}L6.isMDXComponent=!0;const Z6={toc:[]};function N6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}N6.isMDXComponent=!0;const S6={toc:[]};function R6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}R6.isMDXComponent=!0;const z6={toc:[]};function A6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}A6.isMDXComponent=!0;const E6={toc:[]};function P6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}P6.isMDXComponent=!0;const I6={toc:[]};function F6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}F6.isMDXComponent=!0;const W6={toc:[]};function B6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}B6.isMDXComponent=!0;const G6={toc:[]};function O6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}O6.isMDXComponent=!0;const j6={toc:[]};function U6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}U6.isMDXComponent=!0;const q6={toc:[]};function V6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}V6.isMDXComponent=!0;const H6={toc:[]};function $6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}$6.isMDXComponent=!0;const J6={toc:[]};function Y6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Y6.isMDXComponent=!0;const K6={toc:[]};function Q6(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K6,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Q6.isMDXComponent=!0;const t8={toc:[]};function e8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}e8.isMDXComponent=!0;const n8={toc:[]};function o8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}o8.isMDXComponent=!0;const s8={toc:[]};function r8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}r8.isMDXComponent=!0;const i8={toc:[]};function p8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}p8.isMDXComponent=!0;const a8={toc:[]};function c8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}c8.isMDXComponent=!0;const l8={toc:[]};function u8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}u8.isMDXComponent=!0;const m8={toc:[]};function d8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}d8.isMDXComponent=!0;const h8={toc:[]};function y8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}y8.isMDXComponent=!0;const f8={toc:[]};function k8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}k8.isMDXComponent=!0;const w8={toc:[]};function g8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}g8.isMDXComponent=!0;const M8={toc:[]};function D8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}D8.isMDXComponent=!0;const _8={toc:[]};function X8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}X8.isMDXComponent=!0;const x8={toc:[]};function v8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}v8.isMDXComponent=!0;const C8={toc:[]};function T8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}T8.isMDXComponent=!0;const b8={toc:[]};function L8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}L8.isMDXComponent=!0;const Z8={toc:[]};function N8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}N8.isMDXComponent=!0;const S8={toc:[]};function R8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}R8.isMDXComponent=!0;const z8={toc:[]};function A8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}A8.isMDXComponent=!0;const E8={toc:[]};function P8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}P8.isMDXComponent=!0;const I8={toc:[]};function F8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}F8.isMDXComponent=!0;const W8={toc:[]};function B8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}B8.isMDXComponent=!0;const G8={toc:[]};function O8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}O8.isMDXComponent=!0;const j8={toc:[]};function U8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}U8.isMDXComponent=!0;const q8={toc:[]};function V8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}V8.isMDXComponent=!0;const H8={toc:[]};function $8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}$8.isMDXComponent=!0;const J8={toc:[]};function Y8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Y8.isMDXComponent=!0;const K8={toc:[]};function Q8(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K8,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}Q8.isMDXComponent=!0;const t7={toc:[]};function e7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}e7.isMDXComponent=!0;const n7={toc:[]};function o7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}o7.isMDXComponent=!0;const s7={toc:[]};function r7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}r7.isMDXComponent=!0;const i7={toc:[]};function p7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}p7.isMDXComponent=!0;const a7={toc:[]};function c7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}c7.isMDXComponent=!0;const l7={toc:[]};function u7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}u7.isMDXComponent=!0;const m7={toc:[]};function d7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}d7.isMDXComponent=!0;const h7={toc:[]};function y7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}y7.isMDXComponent=!0;const f7={toc:[]};function k7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}k7.isMDXComponent=!0;const w7={toc:[]};function g7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}g7.isMDXComponent=!0;const M7={toc:[]};function D7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}D7.isMDXComponent=!0;const _7={toc:[]};function X7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}X7.isMDXComponent=!0;const x7={toc:[]};function v7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}v7.isMDXComponent=!0;const C7={toc:[]};function T7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}T7.isMDXComponent=!0;const b7={toc:[]};function L7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}L7.isMDXComponent=!0;const Z7={toc:[]};function N7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}N7.isMDXComponent=!0;const S7={toc:[]};function R7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}R7.isMDXComponent=!0;const z7={toc:[]};function A7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}A7.isMDXComponent=!0;const E7={toc:[]};function P7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}P7.isMDXComponent=!0;const I7={toc:[]};function F7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}F7.isMDXComponent=!0;const W7={toc:[]};function B7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}B7.isMDXComponent=!0;const G7={toc:[]};function O7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}O7.isMDXComponent=!0;const j7={toc:[]};function U7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}U7.isMDXComponent=!0;const q7={toc:[]};function V7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}V7.isMDXComponent=!0;const H7={toc:[]};function $7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}$7.isMDXComponent=!0;const J7={toc:[]};function Y7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Y7.isMDXComponent=!0;const K7={toc:[]};function Q7(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K7,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}Q7.isMDXComponent=!0;const t9={toc:[]};function e9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},t9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}e9.isMDXComponent=!0;const n9={toc:[]};function o9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},n9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}o9.isMDXComponent=!0;const s9={toc:[]};function r9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},s9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}r9.isMDXComponent=!0;const i9={toc:[]};function p9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},i9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}p9.isMDXComponent=!0;const a9={toc:[]};function c9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},a9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}c9.isMDXComponent=!0;const l9={toc:[]};function u9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},l9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}u9.isMDXComponent=!0;const m9={toc:[]};function d9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},m9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}d9.isMDXComponent=!0;const h9={toc:[]};function y9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},h9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}y9.isMDXComponent=!0;const f9={toc:[]};function k9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},f9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}k9.isMDXComponent=!0;const w9={toc:[]};function g9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},w9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}g9.isMDXComponent=!0;const M9={toc:[]};function D9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},M9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}D9.isMDXComponent=!0;const _9={toc:[]};function X9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}X9.isMDXComponent=!0;const x9={toc:[]};function v9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},x9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}v9.isMDXComponent=!0;const C9={toc:[]};function T9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},C9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}T9.isMDXComponent=!0;const b9={toc:[]};function L9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},b9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}L9.isMDXComponent=!0;const Z9={toc:[]};function N9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Z9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}N9.isMDXComponent=!0;const S9={toc:[]};function R9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},S9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}R9.isMDXComponent=!0;const z9={toc:[]};function A9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},z9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}A9.isMDXComponent=!0;const E9={toc:[]};function P9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},E9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}P9.isMDXComponent=!0;const I9={toc:[]};function F9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},I9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}F9.isMDXComponent=!0;const W9={toc:[]};function B9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},W9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}B9.isMDXComponent=!0;const G9={toc:[]};function O9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},G9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}O9.isMDXComponent=!0;const j9={toc:[]};function U9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},j9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}U9.isMDXComponent=!0;const q9={toc:[]};function V9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},q9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}V9.isMDXComponent=!0;const H9={toc:[]};function $9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},H9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}$9.isMDXComponent=!0;const J9={toc:[]};function Y9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},J9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Y9.isMDXComponent=!0;const K9={toc:[]};function Q9(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},K9,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}Q9.isMDXComponent=!0;const ttt={toc:[]};function ett(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ttt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}ett.isMDXComponent=!0;const ntt={toc:[]};function ott(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ntt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}ott.isMDXComponent=!0;const stt={toc:[]};function rtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},stt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}rtt.isMDXComponent=!0;const itt={toc:[]};function ptt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},itt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}ptt.isMDXComponent=!0;const att={toc:[]};function ctt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},att,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}ctt.isMDXComponent=!0;const ltt={toc:[]};function utt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ltt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}utt.isMDXComponent=!0;const mtt={toc:[]};function dtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},mtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}dtt.isMDXComponent=!0;const htt={toc:[]};function ytt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},htt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}ytt.isMDXComponent=!0;const ftt={toc:[]};function ktt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ftt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}ktt.isMDXComponent=!0;const wtt={toc:[]};function gtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},wtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}gtt.isMDXComponent=!0;const Mtt={toc:[]};function Dtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Mtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Dtt.isMDXComponent=!0;const _tt={toc:[]};function Xtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},_tt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}Xtt.isMDXComponent=!0;const xtt={toc:[]};function vtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},xtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}vtt.isMDXComponent=!0;const Ctt={toc:[]};function Ttt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ctt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}Ttt.isMDXComponent=!0;const btt={toc:[]};function Ltt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},btt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Ltt.isMDXComponent=!0;const Ztt={toc:[]};function Ntt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ztt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Ntt.isMDXComponent=!0;const Stt={toc:[]};function Rtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Stt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Rtt.isMDXComponent=!0;const ztt={toc:[]};function Att(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ztt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Att.isMDXComponent=!0;const Ett={toc:[]};function Ptt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ett,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}Ptt.isMDXComponent=!0;const Itt={toc:[]};function Ftt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Itt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Ftt.isMDXComponent=!0;const Wtt={toc:[]};function Btt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Wtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}Btt.isMDXComponent=!0;const Gtt={toc:[]};function Ott(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Gtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Ott.isMDXComponent=!0;const jtt={toc:[]};function Utt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},jtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Utt.isMDXComponent=!0;const qtt={toc:[]};function Vtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},qtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Vtt.isMDXComponent=!0;const Htt={toc:[]};function $tt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Htt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}$tt.isMDXComponent=!0;const Jtt={toc:[]};function Ytt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Jtt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Ytt.isMDXComponent=!0;const Ktt={toc:[]};function Qtt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ktt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Qtt.isMDXComponent=!0;const tet={toc:[]};function eet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},tet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}eet.isMDXComponent=!0;const net={toc:[]};function oet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},net,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}oet.isMDXComponent=!0;const set={toc:[]};function ret(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},set,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}ret.isMDXComponent=!0;const iet={toc:[]};function pet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},iet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}pet.isMDXComponent=!0;const aet={toc:[]};function cet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},aet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,i.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,i.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticable if the number of sides is low, e.g. for a\ntriangle."))}cet.isMDXComponent=!0;const uet={toc:[]};function met(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}met.isMDXComponent=!0;const det={toc:[]};function het(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},det,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node for drawing regular polygons."))}het.isMDXComponent=!0;const yet={toc:[]};function fet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}fet.isMDXComponent=!0;const ket={toc:[]};function wet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ket,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}wet.isMDXComponent=!0;const get={toc:[]};function Met(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},get,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Met.isMDXComponent=!0;const Det={toc:[]};function _et(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Det,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}_et.isMDXComponent=!0;const Xet={toc:[]};function xet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}xet.isMDXComponent=!0;const vet={toc:[]};function Cet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}Cet.isMDXComponent=!0;const Tet={toc:[]};function bet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}bet.isMDXComponent=!0;const Let={toc:[]};function Zet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Let,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}Zet.isMDXComponent=!0;const Net={toc:[]};function Set(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Net,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Set.isMDXComponent=!0;const Ret={toc:[]};function zet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ret,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}zet.isMDXComponent=!0;const Aet={toc:[]};function Eet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Aet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Eet.isMDXComponent=!0;const Pet={toc:[]};function Iet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Iet.isMDXComponent=!0;const Fet={toc:[]};function Wet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Wet.isMDXComponent=!0;const Bet={toc:[]};function Get(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"For example, a value of 6 creates a hexagon."))}Get.isMDXComponent=!0;const Oet={toc:[]};function jet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}jet.isMDXComponent=!0;const Uet={toc:[]};function qet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Sets the number of sides of the polygon."))}qet.isMDXComponent=!0;const Vet={toc:[]};function Het(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Het.isMDXComponent=!0;const $et={toc:[]};function Jet(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$et,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Jet.isMDXComponent=!0;const Yet={toc:[]};function Ket(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}Ket.isMDXComponent=!0;const Qet={toc:[]};function tnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qet,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}tnt.isMDXComponent=!0;const ent={toc:[]};function nnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ent,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}nnt.isMDXComponent=!0;const ont={toc:[]};function snt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ont,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}snt.isMDXComponent=!0;const rnt={toc:[]};function int(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}int.isMDXComponent=!0;const pnt={toc:[]};function ant(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}ant.isMDXComponent=!0;const cnt={toc:[]};function lnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}lnt.isMDXComponent=!0;const unt={toc:[]};function mnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},unt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}mnt.isMDXComponent=!0;const dnt={toc:[]};function hnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}hnt.isMDXComponent=!0;const ynt={toc:[]};function fnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ynt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}fnt.isMDXComponent=!0;const knt={toc:[]};function wnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},knt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}wnt.isMDXComponent=!0;const gnt={toc:[]};function Mnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}Mnt.isMDXComponent=!0;const Dnt={toc:[]};function _nt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}_nt.isMDXComponent=!0;const Xnt={toc:[]};function xnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}xnt.isMDXComponent=!0;const vnt={toc:[]};function Cnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Cnt.isMDXComponent=!0;const Tnt={toc:[]};function bnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}bnt.isMDXComponent=!0;const Lnt={toc:[]};function Znt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Znt.isMDXComponent=!0;const Nnt={toc:[]};function Snt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}Snt.isMDXComponent=!0;const Rnt={toc:[]};function znt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}znt.isMDXComponent=!0;const Ant={toc:[]};function Ent(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ant,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}Ent.isMDXComponent=!0;const Pnt={toc:[]};function Int(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Int.isMDXComponent=!0;const Fnt={toc:[]};function Wnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Wnt.isMDXComponent=!0;const Bnt={toc:[]};function Gnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}Gnt.isMDXComponent=!0;const Ont={toc:[]};function jnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ont,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}jnt.isMDXComponent=!0;const Unt={toc:[]};function qnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Unt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}qnt.isMDXComponent=!0;const Vnt={toc:[]};function Hnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Hnt.isMDXComponent=!0;const $nt={toc:[]};function Jnt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$nt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Jnt.isMDXComponent=!0;const Ynt={toc:[]};function Knt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ynt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Knt.isMDXComponent=!0;const Qnt={toc:[]};function tot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qnt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}tot.isMDXComponent=!0;const eot={toc:[]};function not(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}not.isMDXComponent=!0;const oot={toc:[]};function sot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}sot.isMDXComponent=!0;const rot={toc:[]};function iot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}iot.isMDXComponent=!0;const pot={toc:[]};function aot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}aot.isMDXComponent=!0;const cot={toc:[]};function lot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}lot.isMDXComponent=!0;const uot={toc:[]};function mot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}mot.isMDXComponent=!0;const dot={toc:[]};function hot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}hot.isMDXComponent=!0;const yot={toc:[]};function fot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}fot.isMDXComponent=!0;const kot={toc:[]};function wot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}wot.isMDXComponent=!0;const got={toc:[]};function Mot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},got,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}Mot.isMDXComponent=!0;const Dot={toc:[]};function _ot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}_ot.isMDXComponent=!0;const Xot={toc:[]};function xot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}xot.isMDXComponent=!0;const vot={toc:[]};function Cot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Cot.isMDXComponent=!0;const Tot={toc:[]};function bot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}bot.isMDXComponent=!0;const Lot={toc:[]};function Zot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Zot.isMDXComponent=!0;const Not={toc:[]};function Sot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Not,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Sot.isMDXComponent=!0;const Rot={toc:[]};function zot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}zot.isMDXComponent=!0;const Aot={toc:[]};function Eot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Aot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Eot.isMDXComponent=!0;const Pot={toc:[]};function Iot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}Iot.isMDXComponent=!0;const Fot={toc:[]};function Wot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}Wot.isMDXComponent=!0;const Bot={toc:[]};function Got(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Got.isMDXComponent=!0;const Oot={toc:[]};function jot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}jot.isMDXComponent=!0;const Uot={toc:[]};function qot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}qot.isMDXComponent=!0;const Vot={toc:[]};function Hot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Hot.isMDXComponent=!0;const $ot={toc:[]};function Jot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$ot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Jot.isMDXComponent=!0;const Yot={toc:[]};function Kot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Kot.isMDXComponent=!0;const Qot={toc:[]};function tst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}tst.isMDXComponent=!0;const est={toc:[]};function nst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},est,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}nst.isMDXComponent=!0;const ost={toc:[]};function sst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ost,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}sst.isMDXComponent=!0;const rst={toc:[]};function ist(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}ist.isMDXComponent=!0;const pst={toc:[]};function ast(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ast.isMDXComponent=!0;const cst={toc:[]};function lst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}lst.isMDXComponent=!0;const ust={toc:[]};function mst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ust,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}mst.isMDXComponent=!0;const dst={toc:[]};function hst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}hst.isMDXComponent=!0;const yst={toc:[]};function fst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}fst.isMDXComponent=!0;const kst={toc:[]};function wst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}wst.isMDXComponent=!0;const gst={toc:[]};function Mst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Mst.isMDXComponent=!0;const Dst={toc:[]};function _st(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}_st.isMDXComponent=!0;const Xst={toc:[]};function xst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}xst.isMDXComponent=!0;const vst={toc:[]};function Cst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Cst.isMDXComponent=!0;const Tst={toc:[]};function bst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}bst.isMDXComponent=!0;const Lst={toc:[]};function Zst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Zst.isMDXComponent=!0;const Nst={toc:[]};function Sst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}Sst.isMDXComponent=!0;const Rst={toc:[]};function zst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}zst.isMDXComponent=!0;const Ast={toc:[]};function Est(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ast,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}Est.isMDXComponent=!0;const Pst={toc:[]};function Ist(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}Ist.isMDXComponent=!0;const Fst={toc:[]};function Wst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}Wst.isMDXComponent=!0;const Bst={toc:[]};function Gst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Gst.isMDXComponent=!0;const Ost={toc:[]};function jst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ost,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}jst.isMDXComponent=!0;const Ust={toc:[]};function qst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ust,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}qst.isMDXComponent=!0;const Vst={toc:[]};function Hst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}Hst.isMDXComponent=!0;const $st={toc:[]};function Jst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$st,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Jst.isMDXComponent=!0;const Yst={toc:[]};function Kst(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Kst.isMDXComponent=!0;const Qst={toc:[]};function trt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qst,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}trt.isMDXComponent=!0;const ert={toc:[]};function nrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ert,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}nrt.isMDXComponent=!0;const ort={toc:[]};function srt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ort,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}srt.isMDXComponent=!0;const rrt={toc:[]};function irt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}irt.isMDXComponent=!0;const prt={toc:[]};function art(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},prt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}art.isMDXComponent=!0;const crt={toc:[]};function lrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},crt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}lrt.isMDXComponent=!0;const urt={toc:[]};function mrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},urt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}mrt.isMDXComponent=!0;const drt={toc:[]};function hrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},drt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}hrt.isMDXComponent=!0;const yrt={toc:[]};function frt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}frt.isMDXComponent=!0;const krt={toc:[]};function wrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},krt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}wrt.isMDXComponent=!0;const grt={toc:[]};function Mrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},grt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}Mrt.isMDXComponent=!0;const Drt={toc:[]};function _rt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Drt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}_rt.isMDXComponent=!0;const Xrt={toc:[]};function xrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}xrt.isMDXComponent=!0;const vrt={toc:[]};function Crt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Crt.isMDXComponent=!0;const Trt={toc:[]};function brt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Trt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}brt.isMDXComponent=!0;const Lrt={toc:[]};function Zrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Zrt.isMDXComponent=!0;const Nrt={toc:[]};function Srt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}Srt.isMDXComponent=!0;const Rrt={toc:[]};function zrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}zrt.isMDXComponent=!0;const Art={toc:[]};function Ert(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Art,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Ert.isMDXComponent=!0;const Prt={toc:[]};function Irt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Prt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Irt.isMDXComponent=!0;const Frt={toc:[]};function Wrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Frt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Wrt.isMDXComponent=!0;const Brt={toc:[]};function Grt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Brt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}Grt.isMDXComponent=!0;const Ort={toc:[]};function jrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ort,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}jrt.isMDXComponent=!0;const Urt={toc:[]};function qrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Urt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}qrt.isMDXComponent=!0;const Vrt={toc:[]};function Hrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}Hrt.isMDXComponent=!0;const $rt={toc:[]};function Jrt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$rt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}Jrt.isMDXComponent=!0;const Yrt={toc:[]};function Krt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}Krt.isMDXComponent=!0;const Qrt={toc:[]};function tit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qrt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}tit.isMDXComponent=!0;const eit={toc:[]};function nit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}nit.isMDXComponent=!0;const oit={toc:[]};function sit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}sit.isMDXComponent=!0;const rit={toc:[]};function iit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}iit.isMDXComponent=!0;const pit={toc:[]};function ait(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}ait.isMDXComponent=!0;const cit={toc:[]};function lit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}lit.isMDXComponent=!0;const uit={toc:[]};function mit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}mit.isMDXComponent=!0;const dit={toc:[]};function hit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The start point of the B\xe9zier curve."))}hit.isMDXComponent=!0;const yit={toc:[]};function fit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The control point of the B\xe9zier curve."))}fit.isMDXComponent=!0;const kit={toc:[]};function wit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The end point of the B\xe9zier curve."))}wit.isMDXComponent=!0;const git={toc:[]};function Mit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},git,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Mit.isMDXComponent=!0;const Dit={toc:[]};function _it(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}_it.isMDXComponent=!0;const Xit={toc:[]};function xit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}xit.isMDXComponent=!0;const vit={toc:[]};function Cit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Cit.isMDXComponent=!0;const Tit={toc:[]};function bit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}bit.isMDXComponent=!0;const Lit={toc:[]};function Zit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Zit.isMDXComponent=!0;const Nit={toc:[]};function Sit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Sit.isMDXComponent=!0;const Rit={toc:[]};function zit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}zit.isMDXComponent=!0;const Ait={toc:[]};function Eit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ait,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}Eit.isMDXComponent=!0;const Pit={toc:[]};function Iit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Iit.isMDXComponent=!0;const Fit={toc:[]};function Wit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}Wit.isMDXComponent=!0;const Bit={toc:[]};function Git(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}Git.isMDXComponent=!0;const Oit={toc:[]};function jit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}jit.isMDXComponent=!0;const Uit={toc:[]};function qit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}qit.isMDXComponent=!0;const Vit={toc:[]};function Hit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Hit.isMDXComponent=!0;const $it={toc:[]};function Jit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$it,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Jit.isMDXComponent=!0;const Yit={toc:[]};function Kit(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}Kit.isMDXComponent=!0;const Qit={toc:[]};function tpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qit,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}tpt.isMDXComponent=!0;const ept={toc:[]};function npt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ept,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}npt.isMDXComponent=!0;const opt={toc:[]};function spt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},opt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}spt.isMDXComponent=!0;const rpt={toc:[]};function ipt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}ipt.isMDXComponent=!0;const ppt={toc:[]};function apt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ppt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}apt.isMDXComponent=!0;const cpt={toc:[]};function lpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}lpt.isMDXComponent=!0;const upt={toc:[]};function mpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},upt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}mpt.isMDXComponent=!0;const dpt={toc:[]};function hpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}hpt.isMDXComponent=!0;const ypt={toc:[]};function fpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ypt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}fpt.isMDXComponent=!0;const kpt={toc:[]};function wpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}wpt.isMDXComponent=!0;const gpt={toc:[]};function Mpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}Mpt.isMDXComponent=!0;const Dpt={toc:[]};function _pt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}_pt.isMDXComponent=!0;const Xpt={toc:[]};function xpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}xpt.isMDXComponent=!0;const vpt={toc:[]};function Cpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}Cpt.isMDXComponent=!0;const Tpt={toc:[]};function bpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}bpt.isMDXComponent=!0;const Lpt={toc:[]};function Zpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}Zpt.isMDXComponent=!0;const Npt={toc:[]};function Spt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Npt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Spt.isMDXComponent=!0;const Rpt={toc:[]};function zpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}zpt.isMDXComponent=!0;const Apt={toc:[]};function Ept(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Apt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}Ept.isMDXComponent=!0;const Ppt={toc:[]};function Ipt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ppt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Ipt.isMDXComponent=!0;const Fpt={toc:[]};function Wpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}Wpt.isMDXComponent=!0;const Bpt={toc:[]};function Gpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}Gpt.isMDXComponent=!0;const Opt={toc:[]};function jpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Opt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}jpt.isMDXComponent=!0;const Upt={toc:[]};function qpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Upt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}qpt.isMDXComponent=!0;const Vpt={toc:[]};function Hpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Hpt.isMDXComponent=!0;const $pt={toc:[]};function Jpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$pt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Jpt.isMDXComponent=!0;const Ypt={toc:[]};function Kpt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ypt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Kpt.isMDXComponent=!0;const Qpt={toc:[]};function tat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qpt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}tat.isMDXComponent=!0;const eat={toc:[]};function nat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}nat.isMDXComponent=!0;const oat={toc:[]};function sat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}sat.isMDXComponent=!0;const rat={toc:[]};function iat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}iat.isMDXComponent=!0;const pat={toc:[]};function aat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}aat.isMDXComponent=!0;const cat={toc:[]};function lat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}lat.isMDXComponent=!0;const uat={toc:[]};function mat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}mat.isMDXComponent=!0;const dat={toc:[]};function hat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}hat.isMDXComponent=!0;const yat={toc:[]};function fat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}fat.isMDXComponent=!0;const kat={toc:[]};function wat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}wat.isMDXComponent=!0;const gat={toc:[]};function Mat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Mat.isMDXComponent=!0;const Dat={toc:[]};function _at(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}_at.isMDXComponent=!0;const Xat={toc:[]};function xat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}xat.isMDXComponent=!0;const vat={toc:[]};function Cat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}Cat.isMDXComponent=!0;const Tat={toc:[]};function bat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}bat.isMDXComponent=!0;const Lat={toc:[]};function Zat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}Zat.isMDXComponent=!0;const Nat={toc:[]};function Sat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Sat.isMDXComponent=!0;const Rat={toc:[]};function zat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}zat.isMDXComponent=!0;const Aat={toc:[]};function Eat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Aat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Eat.isMDXComponent=!0;const Pat={toc:[]};function Iat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}Iat.isMDXComponent=!0;const Fat={toc:[]};function Wat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}Wat.isMDXComponent=!0;const Bat={toc:[]};function Gat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}Gat.isMDXComponent=!0;const Oat={toc:[]};function jat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}jat.isMDXComponent=!0;const Uat={toc:[]};function qat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}qat.isMDXComponent=!0;const Vat={toc:[]};function Hat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Hat.isMDXComponent=!0;const $at={toc:[]};function Jat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$at,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}Jat.isMDXComponent=!0;const Yat={toc:[]};function Kat(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Kat.isMDXComponent=!0;const Qat={toc:[]};function tct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qat,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}tct.isMDXComponent=!0;const ect={toc:[]};function nct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ect,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}nct.isMDXComponent=!0;const oct={toc:[]};function sct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}sct.isMDXComponent=!0;const rct={toc:[]};function ict(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}ict.isMDXComponent=!0;const pct={toc:[]};function act(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}act.isMDXComponent=!0;const cct={toc:[]};function lct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}lct.isMDXComponent=!0;const uct={toc:[]};function mct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}mct.isMDXComponent=!0;const dct={toc:[]};function hct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}hct.isMDXComponent=!0;const yct={toc:[]};function fct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}fct.isMDXComponent=!0;const kct={toc:[]};function wct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wct.isMDXComponent=!0;const gct={toc:[]};function Mct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Mct.isMDXComponent=!0;const Dct={toc:[]};function _ct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}_ct.isMDXComponent=!0;const Xct={toc:[]};function xct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}xct.isMDXComponent=!0;const vct={toc:[]};function Cct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}Cct.isMDXComponent=!0;const Tct={toc:[]};function bct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}bct.isMDXComponent=!0;const Lct={toc:[]};function Zct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Zct.isMDXComponent=!0;const Nct={toc:[]};function Sct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Sct.isMDXComponent=!0;const Rct={toc:[]};function zct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}zct.isMDXComponent=!0;const Act={toc:[]};function Ect(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Act,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Ect.isMDXComponent=!0;const Pct={toc:[]};function Ict(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Ict.isMDXComponent=!0;const Fct={toc:[]};function Wct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Wct.isMDXComponent=!0;const Bct={toc:[]};function Gct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Gct.isMDXComponent=!0;const Oct={toc:[]};function jct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}jct.isMDXComponent=!0;const Uct={toc:[]};function qct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}qct.isMDXComponent=!0;const Vct={toc:[]};function Hct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}Hct.isMDXComponent=!0;const $ct={toc:[]};function Jct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$ct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}Jct.isMDXComponent=!0;const Yct={toc:[]};function Kct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}Kct.isMDXComponent=!0;const Qct={toc:[]};function tlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}tlt.isMDXComponent=!0;const elt={toc:[]};function nlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},elt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}nlt.isMDXComponent=!0;const olt={toc:[]};function slt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},olt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}slt.isMDXComponent=!0;const rlt={toc:[]};function ilt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}ilt.isMDXComponent=!0;const plt={toc:[]};function alt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},plt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}alt.isMDXComponent=!0;const clt={toc:[]};function llt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},clt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}llt.isMDXComponent=!0;const ult={toc:[]};function mlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ult,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}mlt.isMDXComponent=!0;const dlt={toc:[]};function hlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}hlt.isMDXComponent=!0;const ylt={toc:[]};function flt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ylt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}flt.isMDXComponent=!0;const klt={toc:[]};function wlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},klt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}wlt.isMDXComponent=!0;const glt={toc:[]};function Mlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},glt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}Mlt.isMDXComponent=!0;const Dlt={toc:[]};function _lt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}_lt.isMDXComponent=!0;const Xlt={toc:[]};function xlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}xlt.isMDXComponent=!0;const vlt={toc:[]};function Clt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Clt.isMDXComponent=!0;const Tlt={toc:[]};function blt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}blt.isMDXComponent=!0;const Llt={toc:[]};function Zlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Llt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Zlt.isMDXComponent=!0;const Nlt={toc:[]};function Slt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}Slt.isMDXComponent=!0;const Rlt={toc:[]};function zlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}zlt.isMDXComponent=!0;const Alt={toc:[]};function Elt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Alt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Elt.isMDXComponent=!0;const Plt={toc:[]};function Ilt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Plt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Ilt.isMDXComponent=!0;const Flt={toc:[]};function Wlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Flt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}Wlt.isMDXComponent=!0;const Blt={toc:[]};function Glt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Blt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Glt.isMDXComponent=!0;const Olt={toc:[]};function jlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Olt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}jlt.isMDXComponent=!0;const Ult={toc:[]};function qlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ult,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}qlt.isMDXComponent=!0;const Vlt={toc:[]};function Hlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Hlt.isMDXComponent=!0;const $lt={toc:[]};function Jlt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$lt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}Jlt.isMDXComponent=!0;const Ylt={toc:[]};function Klt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ylt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Klt.isMDXComponent=!0;const Qlt={toc:[]};function tut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qlt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}tut.isMDXComponent=!0;const eut={toc:[]};function nut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}nut.isMDXComponent=!0;const out={toc:[]};function sut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},out,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}sut.isMDXComponent=!0;const rut={toc:[]};function iut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}iut.isMDXComponent=!0;const put={toc:[]};function aut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},put,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}aut.isMDXComponent=!0;const cut={toc:[]};function lut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}lut.isMDXComponent=!0;const uut={toc:[]};function mut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}mut.isMDXComponent=!0;const dut={toc:[]};function hut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}hut.isMDXComponent=!0;const yut={toc:[]};function fut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}fut.isMDXComponent=!0;const kut={toc:[]};function wut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}wut.isMDXComponent=!0;const gut={toc:[]};function Mut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Mut.isMDXComponent=!0;const Dut={toc:[]};function _ut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}_ut.isMDXComponent=!0;const Xut={toc:[]};function xut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}xut.isMDXComponent=!0;const vut={toc:[]};function Cut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Cut.isMDXComponent=!0;const Tut={toc:[]};function but(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}but.isMDXComponent=!0;const Lut={toc:[]};function Zut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Zut.isMDXComponent=!0;const Nut={toc:[]};function Sut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}Sut.isMDXComponent=!0;const Rut={toc:[]};function zut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}zut.isMDXComponent=!0;const Aut={toc:[]};function Eut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Aut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Eut.isMDXComponent=!0;const Put={toc:[]};function Iut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Put,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Iut.isMDXComponent=!0;const Fut={toc:[]};function Wut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Wut.isMDXComponent=!0;const But={toc:[]};function Gut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},But,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Gut.isMDXComponent=!0;const Out={toc:[]};function jut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Out,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}jut.isMDXComponent=!0;const Uut={toc:[]};function qut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}qut.isMDXComponent=!0;const Vut={toc:[]};function Hut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}Hut.isMDXComponent=!0;const $ut={toc:[]};function Jut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$ut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Jut.isMDXComponent=!0;const Yut={toc:[]};function Kut(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Kut.isMDXComponent=!0;const Qut={toc:[]};function tmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qut,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}tmt.isMDXComponent=!0;const emt={toc:[]};function nmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},emt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}nmt.isMDXComponent=!0;const omt={toc:[]};function smt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},omt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}smt.isMDXComponent=!0;const rmt={toc:[]};function imt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}imt.isMDXComponent=!0;const pmt={toc:[]};function amt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}amt.isMDXComponent=!0;const cmt={toc:[]};function lmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}lmt.isMDXComponent=!0;const umt={toc:[]};function mmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},umt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}mmt.isMDXComponent=!0;const dmt={toc:[]};function hmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}hmt.isMDXComponent=!0;const ymt={toc:[]};function fmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ymt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}fmt.isMDXComponent=!0;const kmt={toc:[]};function wmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}wmt.isMDXComponent=!0;const gmt={toc:[]};function Mmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}Mmt.isMDXComponent=!0;const Dmt={toc:[]};function _mt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}_mt.isMDXComponent=!0;const Xmt={toc:[]};function xmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}xmt.isMDXComponent=!0;const vmt={toc:[]};function Cmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}Cmt.isMDXComponent=!0;const Tmt={toc:[]};function bmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}bmt.isMDXComponent=!0;const Lmt={toc:[]};function Zmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Zmt.isMDXComponent=!0;const Nmt={toc:[]};function Smt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Smt.isMDXComponent=!0;const Rmt={toc:[]};function zmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}zmt.isMDXComponent=!0;const Amt={toc:[]};function Emt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Amt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Emt.isMDXComponent=!0;const Pmt={toc:[]};function Imt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Imt.isMDXComponent=!0;const Fmt={toc:[]};function Wmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Wmt.isMDXComponent=!0;const Bmt={toc:[]};function Gmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Gmt.isMDXComponent=!0;const Omt={toc:[]};function jmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Omt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}jmt.isMDXComponent=!0;const Umt={toc:[]};function qmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Umt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}qmt.isMDXComponent=!0;const Vmt={toc:[]};function Hmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Hmt.isMDXComponent=!0;const $mt={toc:[]};function Jmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$mt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}Jmt.isMDXComponent=!0;const Ymt={toc:[]};function Kmt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ymt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Kmt.isMDXComponent=!0;const Qmt={toc:[]};function tdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qmt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}tdt.isMDXComponent=!0;const edt={toc:[]};function ndt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},edt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}ndt.isMDXComponent=!0;const odt={toc:[]};function sdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},odt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}sdt.isMDXComponent=!0;const rdt={toc:[]};function idt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}idt.isMDXComponent=!0;const pdt={toc:[]};function adt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}adt.isMDXComponent=!0;const cdt={toc:[]};function ldt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}ldt.isMDXComponent=!0;const udt={toc:[]};function mdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},udt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}mdt.isMDXComponent=!0;const ddt={toc:[]};function hdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ddt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}hdt.isMDXComponent=!0;const ydt={toc:[]};function fdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ydt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}fdt.isMDXComponent=!0;const kdt={toc:[]};function wdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}wdt.isMDXComponent=!0;const gdt={toc:[]};function Mdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Mdt.isMDXComponent=!0;const Ddt={toc:[]};function _dt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ddt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}_dt.isMDXComponent=!0;const Xdt={toc:[]};function xdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}xdt.isMDXComponent=!0;const vdt={toc:[]};function Cdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}Cdt.isMDXComponent=!0;const Tdt={toc:[]};function bdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}bdt.isMDXComponent=!0;const Ldt={toc:[]};function Zdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ldt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Zdt.isMDXComponent=!0;const Ndt={toc:[]};function Sdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ndt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Sdt.isMDXComponent=!0;const Rdt={toc:[]};function zdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}zdt.isMDXComponent=!0;const Adt={toc:[]};function Edt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Adt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Edt.isMDXComponent=!0;const Pdt={toc:[]};function Idt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Idt.isMDXComponent=!0;const Fdt={toc:[]};function Wdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}Wdt.isMDXComponent=!0;const Bdt={toc:[]};function Gdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Gdt.isMDXComponent=!0;const Odt={toc:[]};function jdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Odt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}jdt.isMDXComponent=!0;const Udt={toc:[]};function qdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Udt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}qdt.isMDXComponent=!0;const Vdt={toc:[]};function Hdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}Hdt.isMDXComponent=!0;const $dt={toc:[]};function Jdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$dt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}Jdt.isMDXComponent=!0;const Ydt={toc:[]};function Kdt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ydt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Kdt.isMDXComponent=!0;const Qdt={toc:[]};function tht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qdt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}tht.isMDXComponent=!0;const eht={toc:[]};function nht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}nht.isMDXComponent=!0;const oht={toc:[]};function sht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}sht.isMDXComponent=!0;const rht={toc:[]};function iht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}iht.isMDXComponent=!0;const pht={toc:[]};function aht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}aht.isMDXComponent=!0;const cht={toc:[]};function lht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}lht.isMDXComponent=!0;const uht={toc:[]};function mht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}mht.isMDXComponent=!0;const dht={toc:[]};function hht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}hht.isMDXComponent=!0;const yht={toc:[]};function fht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}fht.isMDXComponent=!0;const kht={toc:[]};function wht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}wht.isMDXComponent=!0;const ght={toc:[]};function Mht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ght,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Mht.isMDXComponent=!0;const Dht={toc:[]};function _ht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}_ht.isMDXComponent=!0;const Xht={toc:[]};function xht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}xht.isMDXComponent=!0;const vht={toc:[]};function Cht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Cht.isMDXComponent=!0;const Tht={toc:[]};function bht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}bht.isMDXComponent=!0;const Lht={toc:[]};function Zht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Zht.isMDXComponent=!0;const Nht={toc:[]};function Sht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}Sht.isMDXComponent=!0;const Rht={toc:[]};function zht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}zht.isMDXComponent=!0;const Aht={toc:[]};function Eht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Aht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}Eht.isMDXComponent=!0;const Pht={toc:[]};function Iht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Iht.isMDXComponent=!0;const Fht={toc:[]};function Wht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Wht.isMDXComponent=!0;const Bht={toc:[]};function Ght(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}Ght.isMDXComponent=!0;const Oht={toc:[]};function jht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}jht.isMDXComponent=!0;const Uht={toc:[]};function qht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}qht.isMDXComponent=!0;const Vht={toc:[]};function Hht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}Hht.isMDXComponent=!0;const $ht={toc:[]};function Jht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$ht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Jht.isMDXComponent=!0;const Yht={toc:[]};function Kht(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}Kht.isMDXComponent=!0;const Qht={toc:[]};function tyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qht,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}tyt.isMDXComponent=!0;const eyt={toc:[]};function nyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}nyt.isMDXComponent=!0;const oyt={toc:[]};function syt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}syt.isMDXComponent=!0;const ryt={toc:[]};function iyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ryt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}iyt.isMDXComponent=!0;const pyt={toc:[]};function ayt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ayt.isMDXComponent=!0;const cyt={toc:[]};function lyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}lyt.isMDXComponent=!0;const uyt={toc:[]};function myt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}myt.isMDXComponent=!0;const dyt={toc:[]};function hyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}hyt.isMDXComponent=!0;const yyt={toc:[]};function fyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}fyt.isMDXComponent=!0;const kyt={toc:[]};function wyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}wyt.isMDXComponent=!0;const gyt={toc:[]};function Myt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Myt.isMDXComponent=!0;const Dyt={toc:[]};function _yt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}_yt.isMDXComponent=!0;const Xyt={toc:[]};function xyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}xyt.isMDXComponent=!0;const vyt={toc:[]};function Cyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Cyt.isMDXComponent=!0;const Tyt={toc:[]};function byt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}byt.isMDXComponent=!0;const Lyt={toc:[]};function Zyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Zyt.isMDXComponent=!0;const Nyt={toc:[]};function Syt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}Syt.isMDXComponent=!0;const Ryt={toc:[]};function zyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ryt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}zyt.isMDXComponent=!0;const Ayt={toc:[]};function Eyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ayt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}Eyt.isMDXComponent=!0;const Pyt={toc:[]};function Iyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Iyt.isMDXComponent=!0;const Fyt={toc:[]};function Wyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}Wyt.isMDXComponent=!0;const Byt={toc:[]};function Gyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Byt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Gyt.isMDXComponent=!0;const Oyt={toc:[]};function jyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}jyt.isMDXComponent=!0;const Uyt={toc:[]};function qyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}qyt.isMDXComponent=!0;const Vyt={toc:[]};function Hyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}Hyt.isMDXComponent=!0;const $yt={toc:[]};function Jyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$yt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Jyt.isMDXComponent=!0;const Yyt={toc:[]};function Kyt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Kyt.isMDXComponent=!0;const Qyt={toc:[]};function tft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qyt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}tft.isMDXComponent=!0;const eft={toc:[]};function nft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}nft.isMDXComponent=!0;const oft={toc:[]};function sft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}sft.isMDXComponent=!0;const rft={toc:[]};function ift(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}ift.isMDXComponent=!0;const pft={toc:[]};function aft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}aft.isMDXComponent=!0;const cft={toc:[]};function lft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}lft.isMDXComponent=!0;const uft={toc:[]};function mft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}mft.isMDXComponent=!0;const dft={toc:[]};function hft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}hft.isMDXComponent=!0;const yft={toc:[]};function fft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}fft.isMDXComponent=!0;const kft={toc:[]};function wft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}wft.isMDXComponent=!0;const gft={toc:[]};function Mft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}Mft.isMDXComponent=!0;const Dft={toc:[]};function _ft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}_ft.isMDXComponent=!0;const Xft={toc:[]};function xft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}xft.isMDXComponent=!0;const vft={toc:[]};function Cft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}Cft.isMDXComponent=!0;const Tft={toc:[]};function bft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}bft.isMDXComponent=!0;const Lft={toc:[]};function Zft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}Zft.isMDXComponent=!0;const Nft={toc:[]};function Sft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}Sft.isMDXComponent=!0;const Rft={toc:[]};function zft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}zft.isMDXComponent=!0;const Aft={toc:[]};function Eft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Aft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}Eft.isMDXComponent=!0;const Pft={toc:[]};function Ift(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Ift.isMDXComponent=!0;const Fft={toc:[]};function Wft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}Wft.isMDXComponent=!0;const Bft={toc:[]};function Gft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Gft.isMDXComponent=!0;const Oft={toc:[]};function jft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}jft.isMDXComponent=!0;const Uft={toc:[]};function qft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}qft.isMDXComponent=!0;const Vft={toc:[]};function Hft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Hft.isMDXComponent=!0;const $ft={toc:[]};function Jft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$ft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}Jft.isMDXComponent=!0;const Yft={toc:[]};function Kft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}Kft.isMDXComponent=!0;const Qft={toc:[]};function tkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}tkt.isMDXComponent=!0;const ekt={toc:[]};function nkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ekt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}nkt.isMDXComponent=!0;const okt={toc:[]};function skt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},okt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}skt.isMDXComponent=!0;const rkt={toc:[]};function ikt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}ikt.isMDXComponent=!0;const pkt={toc:[]};function akt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}akt.isMDXComponent=!0;const ckt={toc:[]};function lkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ckt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}lkt.isMDXComponent=!0;const ukt={toc:[]};function mkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ukt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}mkt.isMDXComponent=!0;const dkt={toc:[]};function hkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}hkt.isMDXComponent=!0;const ykt={toc:[]};function fkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ykt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}fkt.isMDXComponent=!0;const kkt={toc:[]};function wkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}wkt.isMDXComponent=!0;const gkt={toc:[]};function Mkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Mkt.isMDXComponent=!0;const Dkt={toc:[]};function _kt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}_kt.isMDXComponent=!0;const Xkt={toc:[]};function xkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}xkt.isMDXComponent=!0;const vkt={toc:[]};function Ckt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Ckt.isMDXComponent=!0;const Tkt={toc:[]};function bkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}bkt.isMDXComponent=!0;const Lkt={toc:[]};function Zkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Zkt.isMDXComponent=!0;const Nkt={toc:[]};function Skt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Skt.isMDXComponent=!0;const Rkt={toc:[]};function zkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}zkt.isMDXComponent=!0;const Akt={toc:[]};function Ekt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Akt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}Ekt.isMDXComponent=!0;const Pkt={toc:[]};function Ikt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Ikt.isMDXComponent=!0;const Fkt={toc:[]};function Wkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}Wkt.isMDXComponent=!0;const Bkt={toc:[]};function Gkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Gkt.isMDXComponent=!0;const Okt={toc:[]};function jkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Okt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}jkt.isMDXComponent=!0;const Ukt={toc:[]};function qkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ukt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}qkt.isMDXComponent=!0;const Vkt={toc:[]};function Hkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}Hkt.isMDXComponent=!0;const $kt={toc:[]};function Jkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$kt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}Jkt.isMDXComponent=!0;const Ykt={toc:[]};function Kkt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ykt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}Kkt.isMDXComponent=!0;const Qkt={toc:[]};function twt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qkt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}twt.isMDXComponent=!0;const ewt={toc:[]};function nwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ewt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}nwt.isMDXComponent=!0;const owt={toc:[]};function swt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},owt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}swt.isMDXComponent=!0;const rwt={toc:[]};function iwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}iwt.isMDXComponent=!0;const pwt={toc:[]};function awt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}awt.isMDXComponent=!0;const cwt={toc:[]};function lwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}lwt.isMDXComponent=!0;const uwt={toc:[]};function mwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}mwt.isMDXComponent=!0;const dwt={toc:[]};function hwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}hwt.isMDXComponent=!0;const ywt={toc:[]};function fwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ywt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}fwt.isMDXComponent=!0;const kwt={toc:[]};function wwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}wwt.isMDXComponent=!0;const gwt={toc:[]};function Mwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}Mwt.isMDXComponent=!0;const Dwt={toc:[]};function _wt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}_wt.isMDXComponent=!0;const Xwt={toc:[]};function xwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}xwt.isMDXComponent=!0;const vwt={toc:[]};function Cwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Cwt.isMDXComponent=!0;const Twt={toc:[]};function bwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Twt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}bwt.isMDXComponent=!0;const Lwt={toc:[]};function Zwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Zwt.isMDXComponent=!0;const Nwt={toc:[]};function Swt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}Swt.isMDXComponent=!0;const Rwt={toc:[]};function zwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}zwt.isMDXComponent=!0;const Awt={toc:[]};function Ewt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Awt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}Ewt.isMDXComponent=!0;const Pwt={toc:[]};function Iwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}Iwt.isMDXComponent=!0;const Fwt={toc:[]};function Wwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Wwt.isMDXComponent=!0;const Bwt={toc:[]};function Gwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Gwt.isMDXComponent=!0;const Owt={toc:[]};function jwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Owt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}jwt.isMDXComponent=!0;const Uwt={toc:[]};function qwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qwt.isMDXComponent=!0;const Vwt={toc:[]};function Hwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Hwt.isMDXComponent=!0;const $wt={toc:[]};function Jwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$wt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Jwt.isMDXComponent=!0;const Ywt={toc:[]};function Kwt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ywt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Kwt.isMDXComponent=!0;const Qwt={toc:[]};function tgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qwt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}tgt.isMDXComponent=!0;const egt={toc:[]};function ngt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},egt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}ngt.isMDXComponent=!0;const ogt={toc:[]};function sgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ogt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}sgt.isMDXComponent=!0;const rgt={toc:[]};function igt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}igt.isMDXComponent=!0;const pgt={toc:[]};function agt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Defining knots using the ",(0,i.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,i.kt)("p",null,"Defining knots with ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,i.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}agt.isMDXComponent=!0;const cgt={toc:[]};function lgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node for drawing a smooth line through a number of points."))}lgt.isMDXComponent=!0;const ugt={toc:[]};function mgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ugt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}mgt.isMDXComponent=!0;const dgt={toc:[]};function hgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}hgt.isMDXComponent=!0;const ygt={toc:[]};function fgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ygt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}fgt.isMDXComponent=!0;const kgt={toc:[]};function wgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}wgt.isMDXComponent=!0;const ggt={toc:[]};function Mgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ggt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}Mgt.isMDXComponent=!0;const Dgt={toc:[]};function _gt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}_gt.isMDXComponent=!0;const Xgt={toc:[]};function xgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}xgt.isMDXComponent=!0;const vgt={toc:[]};function Cgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}Cgt.isMDXComponent=!0;const Tgt={toc:[]};function bgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}bgt.isMDXComponent=!0;const Lgt={toc:[]};function Zgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}Zgt.isMDXComponent=!0;const Ngt={toc:[]};function Sgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ngt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Sgt.isMDXComponent=!0;const Rgt={toc:[]};function zgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}zgt.isMDXComponent=!0;const Agt={toc:[]};function Egt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Agt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Egt.isMDXComponent=!0;const Pgt={toc:[]};function Igt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Igt.isMDXComponent=!0;const Fgt={toc:[]};function Wgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Wgt.isMDXComponent=!0;const Bgt={toc:[]};function Ggt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}Ggt.isMDXComponent=!0;const Ogt={toc:[]};function jgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ogt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}jgt.isMDXComponent=!0;const Ugt={toc:[]};function qgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ugt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"0.4"))}qgt.isMDXComponent=!0;const Vgt={toc:[]};function Hgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}Hgt.isMDXComponent=!0;const $gt={toc:[]};function Jgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$gt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}Jgt.isMDXComponent=!0;const Ygt={toc:[]};function Kgt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ygt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Kgt.isMDXComponent=!0;const Qgt={toc:[]};function tMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qgt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}tMt.isMDXComponent=!0;const eMt={toc:[]};function nMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}nMt.isMDXComponent=!0;const oMt={toc:[]};function sMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}sMt.isMDXComponent=!0;const rMt={toc:[]};function iMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}iMt.isMDXComponent=!0;const pMt={toc:[]};function aMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}aMt.isMDXComponent=!0;const cMt={toc:[]};function lMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lMt.isMDXComponent=!0;const uMt={toc:[]};function mMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}mMt.isMDXComponent=!0;const dMt={toc:[]};function hMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}hMt.isMDXComponent=!0;const yMt={toc:[]};function fMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}fMt.isMDXComponent=!0;const kMt={toc:[]};function wMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}wMt.isMDXComponent=!0;const gMt={toc:[]};function MMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}MMt.isMDXComponent=!0;const DMt={toc:[]};function _Mt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}_Mt.isMDXComponent=!0;const XMt={toc:[]};function xMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}xMt.isMDXComponent=!0;const vMt={toc:[]};function CMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}CMt.isMDXComponent=!0;const TMt={toc:[]};function bMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}bMt.isMDXComponent=!0;const LMt={toc:[]};function ZMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}ZMt.isMDXComponent=!0;const NMt={toc:[]};function SMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}SMt.isMDXComponent=!0;const RMt={toc:[]};function zMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}zMt.isMDXComponent=!0;const AMt={toc:[]};function EMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}EMt.isMDXComponent=!0;const PMt={toc:[]};function IMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}IMt.isMDXComponent=!0;const FMt={toc:[]};function WMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}WMt.isMDXComponent=!0;const BMt={toc:[]};function GMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}GMt.isMDXComponent=!0;const OMt={toc:[]};function jMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}jMt.isMDXComponent=!0;const UMt={toc:[]};function qMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}qMt.isMDXComponent=!0;const VMt={toc:[]};function HMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}HMt.isMDXComponent=!0;const $Mt={toc:[]};function JMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Mt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}JMt.isMDXComponent=!0;const YMt={toc:[]};function KMt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}KMt.isMDXComponent=!0;const QMt={toc:[]};function tDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QMt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}tDt.isMDXComponent=!0;const eDt={toc:[]};function nDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}nDt.isMDXComponent=!0;const oDt={toc:[]};function sDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}sDt.isMDXComponent=!0;const rDt={toc:[]};function iDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}iDt.isMDXComponent=!0;const pDt={toc:[]};function aDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}aDt.isMDXComponent=!0;const cDt={toc:[]};function lDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}lDt.isMDXComponent=!0;const uDt={toc:[]};function mDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}mDt.isMDXComponent=!0;const dDt={toc:[]};function hDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}hDt.isMDXComponent=!0;const yDt={toc:[]};function fDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}fDt.isMDXComponent=!0;const kDt={toc:[]};function wDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}wDt.isMDXComponent=!0;const gDt={toc:[]};function MDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}MDt.isMDXComponent=!0;const DDt={toc:[]};function _Dt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}_Dt.isMDXComponent=!0;const XDt={toc:[]};function xDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}xDt.isMDXComponent=!0;const vDt={toc:[]};function CDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}CDt.isMDXComponent=!0;const TDt={toc:[]};function bDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}bDt.isMDXComponent=!0;const LDt={toc:[]};function ZDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}ZDt.isMDXComponent=!0;const NDt={toc:[]};function SDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}SDt.isMDXComponent=!0;const RDt={toc:[]};function zDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}zDt.isMDXComponent=!0;const ADt={toc:[]};function EDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ADt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}EDt.isMDXComponent=!0;const PDt={toc:[]};function IDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}IDt.isMDXComponent=!0;const FDt={toc:[]};function WDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}WDt.isMDXComponent=!0;const BDt={toc:[]};function GDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}GDt.isMDXComponent=!0;const ODt={toc:[]};function jDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ODt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}jDt.isMDXComponent=!0;const UDt={toc:[]};function qDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}qDt.isMDXComponent=!0;const VDt={toc:[]};function HDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}HDt.isMDXComponent=!0;const $Dt={toc:[]};function JDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Dt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}JDt.isMDXComponent=!0;const YDt={toc:[]};function KDt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}KDt.isMDXComponent=!0;const QDt={toc:[]};function t_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QDt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}t_t.isMDXComponent=!0;const e_t={toc:[]};function n_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},e_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}n_t.isMDXComponent=!0;const o_t={toc:[]};function s_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},o_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}s_t.isMDXComponent=!0;const r_t={toc:[]};function i_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},r_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}i_t.isMDXComponent=!0;const p_t={toc:[]};function a_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},p_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}a_t.isMDXComponent=!0;const c_t={toc:[]};function l_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},c_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}l_t.isMDXComponent=!0;const u_t={toc:[]};function m_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},u_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}m_t.isMDXComponent=!0;const d_t={toc:[]};function h_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},d_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}h_t.isMDXComponent=!0;const y_t={toc:[]};function f_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},y_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}f_t.isMDXComponent=!0;const k_t={toc:[]};function w_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},k_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}w_t.isMDXComponent=!0;const g_t={toc:[]};function M_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},g_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}M_t.isMDXComponent=!0;const D_t={toc:[]};function __t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},D_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}__t.isMDXComponent=!0;const X_t={toc:[]};function x_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},X_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}x_t.isMDXComponent=!0;const v_t={toc:[]};function C_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},v_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}C_t.isMDXComponent=!0;const T_t={toc:[]};function b_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},T_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}b_t.isMDXComponent=!0;const L_t={toc:[]};function Z_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},L_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Z_t.isMDXComponent=!0;const N_t={toc:[]};function S_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},N_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}S_t.isMDXComponent=!0;const R_t={toc:[]};function z_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},R_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}z_t.isMDXComponent=!0;const A_t={toc:[]};function E_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},A_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}E_t.isMDXComponent=!0;const P_t={toc:[]};function I_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},P_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}I_t.isMDXComponent=!0;const F_t={toc:[]};function W_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},F_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}W_t.isMDXComponent=!0;const B_t={toc:[]};function G_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},B_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}G_t.isMDXComponent=!0;const O_t={toc:[]};function j_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},O_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}j_t.isMDXComponent=!0;const U_t={toc:[]};function q_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},U_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}q_t.isMDXComponent=!0;const V_t={toc:[]};function H_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},V_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}H_t.isMDXComponent=!0;const $_t={toc:[]};function J_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}J_t.isMDXComponent=!0;const Y_t={toc:[]};function K_t(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Y_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}K_t.isMDXComponent=!0;const Q_t={toc:[]};function tXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Q_t,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}tXt.isMDXComponent=!0;const eXt={toc:[]};function nXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}nXt.isMDXComponent=!0;const oXt={toc:[]};function sXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}sXt.isMDXComponent=!0;const rXt={toc:[]};function iXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}iXt.isMDXComponent=!0;const pXt={toc:[]};function aXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}aXt.isMDXComponent=!0;const cXt={toc:[]};function lXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}lXt.isMDXComponent=!0;const uXt={toc:[]};function mXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}mXt.isMDXComponent=!0;const dXt={toc:[]};function hXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}hXt.isMDXComponent=!0;const yXt={toc:[]};function fXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}fXt.isMDXComponent=!0;const kXt={toc:[]};function wXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}wXt.isMDXComponent=!0;const gXt={toc:[]};function MXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}MXt.isMDXComponent=!0;const DXt={toc:[]};function _Xt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}_Xt.isMDXComponent=!0;const XXt={toc:[]};function xXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}xXt.isMDXComponent=!0;const vXt={toc:[]};function CXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}CXt.isMDXComponent=!0;const TXt={toc:[]};function bXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}bXt.isMDXComponent=!0;const LXt={toc:[]};function ZXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}ZXt.isMDXComponent=!0;const NXt={toc:[]};function SXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}SXt.isMDXComponent=!0;const RXt={toc:[]};function zXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}zXt.isMDXComponent=!0;const AXt={toc:[]};function EXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}EXt.isMDXComponent=!0;const PXt={toc:[]};function IXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}IXt.isMDXComponent=!0;const FXt={toc:[]};function WXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}WXt.isMDXComponent=!0;const BXt={toc:[]};function GXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}GXt.isMDXComponent=!0;const OXt={toc:[]};function jXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}jXt.isMDXComponent=!0;const UXt={toc:[]};function qXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}qXt.isMDXComponent=!0;const VXt={toc:[]};function HXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}HXt.isMDXComponent=!0;const $Xt={toc:[]};function JXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Xt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}JXt.isMDXComponent=!0;const YXt={toc:[]};function KXt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}KXt.isMDXComponent=!0;const QXt={toc:[]};function txt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QXt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}txt.isMDXComponent=!0;const ext={toc:[]};function nxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ext,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nxt.isMDXComponent=!0;const oxt={toc:[]};function sxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}sxt.isMDXComponent=!0;const rxt={toc:[]};function ixt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}ixt.isMDXComponent=!0;const pxt={toc:[]};function axt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}axt.isMDXComponent=!0;const cxt={toc:[]};function lxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}lxt.isMDXComponent=!0;const uxt={toc:[]};function mxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}mxt.isMDXComponent=!0;const dxt={toc:[]};function hxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}hxt.isMDXComponent=!0;const yxt={toc:[]};function fxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}fxt.isMDXComponent=!0;const kxt={toc:[]};function wxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}wxt.isMDXComponent=!0;const gxt={toc:[]};function Mxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}Mxt.isMDXComponent=!0;const Dxt={toc:[]};function _xt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}_xt.isMDXComponent=!0;const Xxt={toc:[]};function xxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}xxt.isMDXComponent=!0;const vxt={toc:[]};function Cxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Cxt.isMDXComponent=!0;const Txt={toc:[]};function bxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Txt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}bxt.isMDXComponent=!0;const Lxt={toc:[]};function Zxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}Zxt.isMDXComponent=!0;const Nxt={toc:[]};function Sxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}Sxt.isMDXComponent=!0;const Rxt={toc:[]};function zxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}zxt.isMDXComponent=!0;const Axt={toc:[]};function Ext(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Axt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Ext.isMDXComponent=!0;const Pxt={toc:[]};function Ixt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Ixt.isMDXComponent=!0;const Fxt={toc:[]};function Wxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Wxt.isMDXComponent=!0;const Bxt={toc:[]};function Gxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Gxt.isMDXComponent=!0;const Oxt={toc:[]};function jxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Oxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}jxt.isMDXComponent=!0;const Uxt={toc:[]};function qxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}qxt.isMDXComponent=!0;const Vxt={toc:[]};function Hxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}Hxt.isMDXComponent=!0;const $xt={toc:[]};function Jxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$xt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}Jxt.isMDXComponent=!0;const Yxt={toc:[]};function Kxt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Kxt.isMDXComponent=!0;const Qxt={toc:[]};function tvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qxt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}tvt.isMDXComponent=!0;const evt={toc:[]};function nvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},evt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}nvt.isMDXComponent=!0;const ovt={toc:[]};function svt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ovt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}svt.isMDXComponent=!0;const rvt={toc:[]};function ivt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}ivt.isMDXComponent=!0;const pvt={toc:[]};function avt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}avt.isMDXComponent=!0;const cvt={toc:[]};function lvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}lvt.isMDXComponent=!0;const uvt={toc:[]};function mvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}mvt.isMDXComponent=!0;const dvt={toc:[]};function hvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}hvt.isMDXComponent=!0;const yvt={toc:[]};function fvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}fvt.isMDXComponent=!0;const kvt={toc:[]};function wvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wvt.isMDXComponent=!0;const gvt={toc:[]};function Mvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Mvt.isMDXComponent=!0;const Dvt={toc:[]};function _vt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}_vt.isMDXComponent=!0;const Xvt={toc:[]};function xvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}xvt.isMDXComponent=!0;const vvt={toc:[]};function Cvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}Cvt.isMDXComponent=!0;const Tvt={toc:[]};function bvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}bvt.isMDXComponent=!0;const Lvt={toc:[]};function Zvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Zvt.isMDXComponent=!0;const Nvt={toc:[]};function Svt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Svt.isMDXComponent=!0;const Rvt={toc:[]};function zvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}zvt.isMDXComponent=!0;const Avt={toc:[]};function Evt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Avt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Evt.isMDXComponent=!0;const Pvt={toc:[]};function Ivt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Ivt.isMDXComponent=!0;const Fvt={toc:[]};function Wvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Wvt.isMDXComponent=!0;const Bvt={toc:[]};function Gvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}Gvt.isMDXComponent=!0;const Ovt={toc:[]};function jvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ovt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}jvt.isMDXComponent=!0;const Uvt={toc:[]};function qvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qvt.isMDXComponent=!0;const Vvt={toc:[]};function Hvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}Hvt.isMDXComponent=!0;const $vt={toc:[]};function Jvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$vt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Jvt.isMDXComponent=!0;const Yvt={toc:[]};function Kvt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}Kvt.isMDXComponent=!0;const Qvt={toc:[]};function tCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qvt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}tCt.isMDXComponent=!0;const eCt={toc:[]};function nCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}nCt.isMDXComponent=!0;const oCt={toc:[]};function sCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}sCt.isMDXComponent=!0;const rCt={toc:[]};function iCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}iCt.isMDXComponent=!0;const pCt={toc:[]};function aCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}aCt.isMDXComponent=!0;const cCt={toc:[]};function lCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}lCt.isMDXComponent=!0;const uCt={toc:[]};function mCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}mCt.isMDXComponent=!0;const dCt={toc:[]};function hCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}hCt.isMDXComponent=!0;const yCt={toc:[]};function fCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}fCt.isMDXComponent=!0;const kCt={toc:[]};function wCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}wCt.isMDXComponent=!0;const gCt={toc:[]};function MCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}MCt.isMDXComponent=!0;const DCt={toc:[]};function _Ct(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}_Ct.isMDXComponent=!0;const XCt={toc:[]};function xCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}xCt.isMDXComponent=!0;const vCt={toc:[]};function CCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}CCt.isMDXComponent=!0;const TCt={toc:[]};function bCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}bCt.isMDXComponent=!0;const LCt={toc:[]};function ZCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}ZCt.isMDXComponent=!0;const NCt={toc:[]};function SCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}SCt.isMDXComponent=!0;const RCt={toc:[]};function zCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}zCt.isMDXComponent=!0;const ACt={toc:[]};function ECt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ACt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}ECt.isMDXComponent=!0;const PCt={toc:[]};function ICt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}ICt.isMDXComponent=!0;const FCt={toc:[]};function WCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}WCt.isMDXComponent=!0;const BCt={toc:[]};function GCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}GCt.isMDXComponent=!0;const OCt={toc:[]};function jCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}jCt.isMDXComponent=!0;const UCt={toc:[]};function qCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qCt.isMDXComponent=!0;const VCt={toc:[]};function HCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}HCt.isMDXComponent=!0;const $Ct={toc:[]};function JCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Ct,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}JCt.isMDXComponent=!0;const YCt={toc:[]};function KCt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}KCt.isMDXComponent=!0;const QCt={toc:[]};function tTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QCt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}tTt.isMDXComponent=!0;const eTt={toc:[]};function nTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}nTt.isMDXComponent=!0;const oTt={toc:[]};function sTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}sTt.isMDXComponent=!0;const rTt={toc:[]};function iTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}iTt.isMDXComponent=!0;const pTt={toc:[]};function aTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}aTt.isMDXComponent=!0;const cTt={toc:[]};function lTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lTt.isMDXComponent=!0;const uTt={toc:[]};function mTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}mTt.isMDXComponent=!0;const dTt={toc:[]};function hTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}hTt.isMDXComponent=!0;const yTt={toc:[]};function fTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}fTt.isMDXComponent=!0;const kTt={toc:[]};function wTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}wTt.isMDXComponent=!0;const gTt={toc:[]};function MTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}MTt.isMDXComponent=!0;const DTt={toc:[]};function _Tt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}_Tt.isMDXComponent=!0;const XTt={toc:[]};function xTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}xTt.isMDXComponent=!0;const vTt={toc:[]};function CTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}CTt.isMDXComponent=!0;const TTt={toc:[]};function bTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}bTt.isMDXComponent=!0;const LTt={toc:[]};function ZTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}ZTt.isMDXComponent=!0;const NTt={toc:[]};function STt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}STt.isMDXComponent=!0;const RTt={toc:[]};function zTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}zTt.isMDXComponent=!0;const ATt={toc:[]};function ETt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ATt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}ETt.isMDXComponent=!0;const PTt={toc:[]};function ITt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}ITt.isMDXComponent=!0;const FTt={toc:[]};function WTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}WTt.isMDXComponent=!0;const BTt={toc:[]};function GTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}GTt.isMDXComponent=!0;const OTt={toc:[]};function jTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}jTt.isMDXComponent=!0;const UTt={toc:[]};function qTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}qTt.isMDXComponent=!0;const VTt={toc:[]};function HTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}HTt.isMDXComponent=!0;const $Tt={toc:[]};function JTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Tt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The alpha value of this video."))}JTt.isMDXComponent=!0;const YTt={toc:[]};function KTt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}KTt.isMDXComponent=!0;const QTt={toc:[]};function tbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QTt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}tbt.isMDXComponent=!0;const ebt={toc:[]};function nbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ebt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}nbt.isMDXComponent=!0;const obt={toc:[]};function sbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},obt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this video should loop upon reaching the end."))}sbt.isMDXComponent=!0;const rbt={toc:[]};function ibt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}ibt.isMDXComponent=!0;const pbt={toc:[]};function abt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}abt.isMDXComponent=!0;const cbt={toc:[]};function lbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lbt.isMDXComponent=!0;const ubt={toc:[]};function mbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ubt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}mbt.isMDXComponent=!0;const dbt={toc:[]};function hbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}hbt.isMDXComponent=!0;const ybt={toc:[]};function fbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ybt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}fbt.isMDXComponent=!0;const kbt={toc:[]};function wbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}wbt.isMDXComponent=!0;const gbt={toc:[]};function Mbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Mbt.isMDXComponent=!0;const Dbt={toc:[]};function _bt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}_bt.isMDXComponent=!0;const Xbt={toc:[]};function xbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}xbt.isMDXComponent=!0;const vbt={toc:[]};function Cbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Cbt.isMDXComponent=!0;const Tbt={toc:[]};function bbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}bbt.isMDXComponent=!0;const Lbt={toc:[]};function Zbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Zbt.isMDXComponent=!0;const Nbt={toc:[]};function Sbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}Sbt.isMDXComponent=!0;const Rbt={toc:[]};function zbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"true"))}zbt.isMDXComponent=!0;const Abt={toc:[]};function Ebt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Abt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the video should be smoothed."))}Ebt.isMDXComponent=!0;const Pbt={toc:[]};function Ibt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Using a local video:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import video from './example.mp4';\n// ...\nview.add(<Video src={video} />)\n")),(0,i.kt)("p",null,"Loading an image from the internet:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Video src="https://example.com/video.mp4" />)\n')))}Ibt.isMDXComponent=!0;const Fbt={toc:[]};function Wbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The source of this video."))}Wbt.isMDXComponent=!0;const Bbt={toc:[]};function Gbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}Gbt.isMDXComponent=!0;const Obt={toc:[]};function jbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Obt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}jbt.isMDXComponent=!0;const Ubt={toc:[]};function qbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ubt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}qbt.isMDXComponent=!0;const Vbt={toc:[]};function Hbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}Hbt.isMDXComponent=!0;const $bt={toc:[]};function Jbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$bt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Jbt.isMDXComponent=!0;const Ybt={toc:[]};function Kbt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ybt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}Kbt.isMDXComponent=!0;const Qbt={toc:[]};function tLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qbt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}tLt.isMDXComponent=!0;const eLt={toc:[]};function nLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nLt.isMDXComponent=!0;const oLt={toc:[]};function sLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}sLt.isMDXComponent=!0;const rLt={toc:[]};function iLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}iLt.isMDXComponent=!0;const pLt={toc:[]};function aLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}aLt.isMDXComponent=!0;const cLt={toc:[]};function lLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}lLt.isMDXComponent=!0;const uLt={toc:[]};function mLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}mLt.isMDXComponent=!0;const dLt={toc:[]};function hLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}hLt.isMDXComponent=!0;const yLt={toc:[]};function fLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}fLt.isMDXComponent=!0;const kLt={toc:[]};function wLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}wLt.isMDXComponent=!0;const gLt={toc:[]};function MLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}MLt.isMDXComponent=!0;const DLt={toc:[]};function _Lt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}_Lt.isMDXComponent=!0;const XLt={toc:[]};function xLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}xLt.isMDXComponent=!0;const vLt={toc:[]};function CLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}CLt.isMDXComponent=!0;const TLt={toc:[]};function bLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}bLt.isMDXComponent=!0;const LLt={toc:[]};function ZLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}ZLt.isMDXComponent=!0;const NLt={toc:[]};function SLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}SLt.isMDXComponent=!0;const RLt={toc:[]};function zLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}zLt.isMDXComponent=!0;const ALt={toc:[]};function ELt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ALt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}ELt.isMDXComponent=!0;const PLt={toc:[]};function ILt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}ILt.isMDXComponent=!0;const FLt={toc:[]};function WLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}WLt.isMDXComponent=!0;const BLt={toc:[]};function GLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}GLt.isMDXComponent=!0;const OLt={toc:[]};function jLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}jLt.isMDXComponent=!0;const ULt={toc:[]};function qLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ULt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}qLt.isMDXComponent=!0;const VLt={toc:[]};function HLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}HLt.isMDXComponent=!0;const $Lt={toc:[]};function JLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Lt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}JLt.isMDXComponent=!0;const YLt={toc:[]};function KLt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}KLt.isMDXComponent=!0;const QLt={toc:[]};function tZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QLt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}tZt.isMDXComponent=!0;const eZt={toc:[]};function nZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}nZt.isMDXComponent=!0;const oZt={toc:[]};function sZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}sZt.isMDXComponent=!0;const rZt={toc:[]};function iZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}iZt.isMDXComponent=!0;const pZt={toc:[]};function aZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}aZt.isMDXComponent=!0;const cZt={toc:[]};function lZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}lZt.isMDXComponent=!0;const uZt={toc:[]};function mZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}mZt.isMDXComponent=!0;const dZt={toc:[]};function hZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}hZt.isMDXComponent=!0;const yZt={toc:[]};function fZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}fZt.isMDXComponent=!0;const kZt={toc:[]};function wZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wZt.isMDXComponent=!0;const gZt={toc:[]};function MZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}MZt.isMDXComponent=!0;const DZt={toc:[]};function _Zt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}_Zt.isMDXComponent=!0;const XZt={toc:[]};function xZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}xZt.isMDXComponent=!0;const vZt={toc:[]};function CZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}CZt.isMDXComponent=!0;const TZt={toc:[]};function bZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}bZt.isMDXComponent=!0;const LZt={toc:[]};function ZZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}ZZt.isMDXComponent=!0;const NZt={toc:[]};function SZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}SZt.isMDXComponent=!0;const RZt={toc:[]};function zZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}zZt.isMDXComponent=!0;const AZt={toc:[]};function EZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}EZt.isMDXComponent=!0;const PZt={toc:[]};function IZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}IZt.isMDXComponent=!0;const FZt={toc:[]};function WZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}WZt.isMDXComponent=!0;const BZt={toc:[]};function GZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}GZt.isMDXComponent=!0;const OZt={toc:[]};function jZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}jZt.isMDXComponent=!0;const UZt={toc:[]};function qZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qZt.isMDXComponent=!0;const VZt={toc:[]};function HZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}HZt.isMDXComponent=!0;const $Zt={toc:[]};function JZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Zt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}JZt.isMDXComponent=!0;const YZt={toc:[]};function KZt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}KZt.isMDXComponent=!0;const QZt={toc:[]};function tNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QZt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}tNt.isMDXComponent=!0;const eNt={toc:[]};function nNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}nNt.isMDXComponent=!0;const oNt={toc:[]};function sNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}sNt.isMDXComponent=!0;const rNt={toc:[]};function iNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}iNt.isMDXComponent=!0;const pNt={toc:[]};function aNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}aNt.isMDXComponent=!0;const cNt={toc:[]};function lNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}lNt.isMDXComponent=!0;const uNt={toc:[]};function mNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}mNt.isMDXComponent=!0;const dNt={toc:[]};function hNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}hNt.isMDXComponent=!0;const yNt={toc:[]};function fNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}fNt.isMDXComponent=!0;const kNt={toc:[]};function wNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}wNt.isMDXComponent=!0;const gNt={toc:[]};function MNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}MNt.isMDXComponent=!0;const DNt={toc:[]};function _Nt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}_Nt.isMDXComponent=!0;const XNt={toc:[]};function xNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}xNt.isMDXComponent=!0;const vNt={toc:[]};function CNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}CNt.isMDXComponent=!0;const TNt={toc:[]};function bNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}bNt.isMDXComponent=!0;const LNt={toc:[]};function ZNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}ZNt.isMDXComponent=!0;const NNt={toc:[]};function SNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}SNt.isMDXComponent=!0;const RNt={toc:[]};function zNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}zNt.isMDXComponent=!0;const ANt={toc:[]};function ENt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ANt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}ENt.isMDXComponent=!0;const PNt={toc:[]};function INt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}INt.isMDXComponent=!0;const FNt={toc:[]};function WNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}WNt.isMDXComponent=!0;const BNt={toc:[]};function GNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}GNt.isMDXComponent=!0;const ONt={toc:[]};function jNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ONt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}jNt.isMDXComponent=!0;const UNt={toc:[]};function qNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qNt.isMDXComponent=!0;const VNt={toc:[]};function HNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}HNt.isMDXComponent=!0;const $Nt={toc:[]};function JNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Nt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}JNt.isMDXComponent=!0;const YNt={toc:[]};function KNt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}KNt.isMDXComponent=!0;const QNt={toc:[]};function tSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QNt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}tSt.isMDXComponent=!0;const eSt={toc:[]};function nSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}nSt.isMDXComponent=!0;const oSt={toc:[]};function sSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}sSt.isMDXComponent=!0;const rSt={toc:[]};function iSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}iSt.isMDXComponent=!0;const pSt={toc:[]};function aSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}aSt.isMDXComponent=!0;const cSt={toc:[]};function lSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lSt.isMDXComponent=!0;const uSt={toc:[]};function mSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}mSt.isMDXComponent=!0;const dSt={toc:[]};function hSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}hSt.isMDXComponent=!0;const ySt={toc:[]};function fSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ySt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}fSt.isMDXComponent=!0;const kSt={toc:[]};function wSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}wSt.isMDXComponent=!0;const gSt={toc:[]};function MSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}MSt.isMDXComponent=!0;const DSt={toc:[]};function _St(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}_St.isMDXComponent=!0;const XSt={toc:[]};function xSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}xSt.isMDXComponent=!0;const vSt={toc:[]};function CSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}CSt.isMDXComponent=!0;const TSt={toc:[]};function bSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}bSt.isMDXComponent=!0;const LSt={toc:[]};function ZSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}ZSt.isMDXComponent=!0;const NSt={toc:[]};function SSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}SSt.isMDXComponent=!0;const RSt={toc:[]};function zSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}zSt.isMDXComponent=!0;const ASt={toc:[]};function ESt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ASt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,i.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}ESt.isMDXComponent=!0;const PSt={toc:[]};function ISt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the position in world space."))}ISt.isMDXComponent=!0;const FSt={toc:[]};function WSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,i.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}WSt.isMDXComponent=!0;const BSt={toc:[]};function GSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the rotation in world space."))}GSt.isMDXComponent=!0;const OSt={toc:[]};function jSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,i.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,i.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," components."))}jSt.isMDXComponent=!0;const USt={toc:[]};function qSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},USt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A helper signal for operating on the scale in world space."))}qSt.isMDXComponent=!0;const VSt={toc:[]};function HSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}HSt.isMDXComponent=!0;const $St={toc:[]};function JSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$St,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}JSt.isMDXComponent=!0;const YSt={toc:[]};function KSt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}KSt.isMDXComponent=!0;const QSt={toc:[]};function tRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QSt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,i.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}tRt.isMDXComponent=!0;const eRt={toc:[]};function nRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the offset of this node's origin."))}nRt.isMDXComponent=!0;const oRt={toc:[]};function sRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,i.kt)("p",null,"Accessing the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,i.kt)("p",null,"Setting the position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}sRt.isMDXComponent=!0;const rRt={toc:[]};function iRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the position of this node in local space of its parent."))}iRt.isMDXComponent=!0;const pRt={toc:[]};function aRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}aRt.isMDXComponent=!0;const cRt={toc:[]};function lRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,i.kt)("p",null,"Accessing the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,i.kt)("p",null,"Setting the scale:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}lRt.isMDXComponent=!0;const uRt={toc:[]};function mRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the scale of this node in local space of its parent."))}mRt.isMDXComponent=!0;const dRt={toc:[]};function hRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A size is a two-dimensional vector, where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,i.kt)("p",null,"The value of both x and y is of type ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,i.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,i.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,i.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,i.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,i.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}hRt.isMDXComponent=!0;const yRt={toc:[]};function fRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initializing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,i.kt)("p",null,"Accessing the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,i.kt)("p",null,"Setting the size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}fRt.isMDXComponent=!0;const kRt={toc:[]};function wRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents the size of this node."))}wRt.isMDXComponent=!0;const gRt={toc:[]};function MRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}MRt.isMDXComponent=!0;const DRt={toc:[]};function _Rt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}_Rt.isMDXComponent=!0;const XRt={toc:[]};function xRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}xRt.isMDXComponent=!0;const vRt={toc:[]};function CRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The nodes will be appended at the end of the children list."))}CRt.isMDXComponent=!0;const TRt={toc:[]};function bRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}bRt.isMDXComponent=!0;const LRt={toc:[]};function ZRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Add the given node(s) as the children of this node."))}ZRt.isMDXComponent=!0;const NRt={toc:[]};function SRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to append."))}SRt.isMDXComponent=!0;const RRt={toc:[]};function zRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}zRt.isMDXComponent=!0;const ARt={toc:[]};function ERt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ARt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The state to apply to the node."))}ERt.isMDXComponent=!0;const PRt={toc:[]};function IRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}IRt.isMDXComponent=!0;const FRt={toc:[]};function WRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}WRt.isMDXComponent=!0;const BRt={toc:[]};function GRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}GRt.isMDXComponent=!0;const ORt={toc:[]};function jRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ORt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}jRt.isMDXComponent=!0;const URt={toc:[]};function qRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},URt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Collect all asynchronous resources used by this node."))}qRt.isMDXComponent=!0;const VRt={toc:[]};function HRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}HRt.isMDXComponent=!0;const $Rt={toc:[]};function JRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Rt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A matrix mapping composite space to world space."))}JRt.isMDXComponent=!0;const YRt={toc:[]};function KRt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}KRt.isMDXComponent=!0;const QRt={toc:[]};function tzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QRt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the desired size of this node."))}tzt.isMDXComponent=!0;const ezt={toc:[]};function nzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ezt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,i.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}nzt.isMDXComponent=!0;const ozt={toc:[]};function szt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ozt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare this node to be disposed of."))}szt.isMDXComponent=!0;const rzt={toc:[]};function izt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}izt.isMDXComponent=!0;const pzt={toc:[]};function azt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw this node onto the canvas."))}azt.isMDXComponent=!0;const czt={toc:[]};function lzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},czt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}lzt.isMDXComponent=!0;const uzt={toc:[]};function mzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,i.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}mzt.isMDXComponent=!0;const dzt={toc:[]};function hzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Draw an overlay for this node."))}hzt.isMDXComponent=!0;const yzt={toc:[]};function fzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}fzt.isMDXComponent=!0;const kzt={toc:[]};function wzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A local-to-screen matrix."))}wzt.isMDXComponent=!0;const gzt={toc:[]};function Mzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}Mzt.isMDXComponent=!0;const Dzt={toc:[]};function _zt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Dzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}_zt.isMDXComponent=!0;const Xzt={toc:[]};function xzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Xzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The returned bounding box should be in local space."))}xzt.isMDXComponent=!0;const vzt={toc:[]};function Czt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Czt.isMDXComponent=!0;const Tzt={toc:[]};function bzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Tzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}bzt.isMDXComponent=!0;const Lzt={toc:[]};function Zzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Lzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return a snapshot of the node's current signal values."))}Zzt.isMDXComponent=!0;const Nzt={toc:[]};function Szt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Nzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Try to find a node intersecting the given position."))}Szt.isMDXComponent=!0;const Rzt={toc:[]};function zzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Rzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The searched position."))}zzt.isMDXComponent=!0;const Azt={toc:[]};function Ezt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Azt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Ezt.isMDXComponent=!0;const Pzt={toc:[]};function Izt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Pzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Izt.isMDXComponent=!0;const Fzt={toc:[]};function Wzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Fzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A node or an array of nodes to insert."))}Wzt.isMDXComponent=!0;const Bzt={toc:[]};function Gzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Bzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An index at which to insert the node(s)."))}Gzt.isMDXComponent=!0;const Ozt={toc:[]};function jzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Ozt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an instance of this node's class."))}jzt.isMDXComponent=!0;const Uzt={toc:[]};function qzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Uzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to pass to the constructor."))}qzt.isMDXComponent=!0;const Vzt={toc:[]};function Hzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Vzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the mode is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,i.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Hzt.isMDXComponent=!0;const $zt={toc:[]};function Jzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$zt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the resolved layout mode of this node."))}Jzt.isMDXComponent=!0;const Yzt={toc:[]};function Kzt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Yzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Kzt.isMDXComponent=!0;const Qzt={toc:[]};function tAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},Qzt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-parent matrix for this node."))}tAt.isMDXComponent=!0;const eAt={toc:[]};function nAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}nAt.isMDXComponent=!0;const oAt={toc:[]};function sAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}sAt.isMDXComponent=!0;const rAt={toc:[]};function iAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the local-to-world matrix for this node."))}iAt.isMDXComponent=!0;const pAt={toc:[]};function aAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,i.kt)("p",null,"A positive ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}aAt.isMDXComponent=!0;const cAt={toc:[]};function lAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rearrange this node in relation to its siblings."))}lAt.isMDXComponent=!0;const uAt={toc:[]};function mAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Number of places by which the node should be moved."))}mAt.isMDXComponent=!0;const dAt={toc:[]};function hAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}hAt.isMDXComponent=!0;const yAt={toc:[]};function fAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node above the provided node in the parent's layout."))}fAt.isMDXComponent=!0;const kAt={toc:[]};function wAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}wAt.isMDXComponent=!0;const gAt={toc:[]};function MAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}MAt.isMDXComponent=!0;const DAt={toc:[]};function _At(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}_At.isMDXComponent=!0;const XAt={toc:[]};function xAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node below the provided node in the parent's layout."))}xAt.isMDXComponent=!0;const vAt={toc:[]};function CAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The sibling node below which to move."))}CAt.isMDXComponent=!0;const TAt={toc:[]};function bAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}bAt.isMDXComponent=!0;const LAt={toc:[]};function ZAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}ZAt.isMDXComponent=!0;const NAt={toc:[]};function SAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node down in relation to its siblings."))}SAt.isMDXComponent=!0;const RAt={toc:[]};function zAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}zAt.isMDXComponent=!0;const AAt={toc:[]};function EAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new offset."))}EAt.isMDXComponent=!0;const PAt={toc:[]};function IAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}IAt.isMDXComponent=!0;const FAt={toc:[]};function WAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the provided position relative to its siblings."))}WAt.isMDXComponent=!0;const BAt={toc:[]};function GAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The index to move the node to."))}GAt.isMDXComponent=!0;const OAt={toc:[]};function jAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}jAt.isMDXComponent=!0;const UAt={toc:[]};function qAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}qAt.isMDXComponent=!0;const VAt={toc:[]};function HAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}HAt.isMDXComponent=!0;const $At={toc:[]};function JAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$At,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node to the top in relation to its siblings."))}JAt.isMDXComponent=!0;const YAt={toc:[]};function KAt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}KAt.isMDXComponent=!0;const QAt={toc:[]};function tEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QAt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Move the node up in relation to its siblings."))}tEt.isMDXComponent=!0;const eEt={toc:[]};function nEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}nEt.isMDXComponent=!0;const oEt={toc:[]};function sEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a reactive copy of this node."))}sEt.isMDXComponent=!0;const rEt={toc:[]};function iEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}iEt.isMDXComponent=!0;const pEt={toc:[]};function aEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove this node from the tree."))}aEt.isMDXComponent=!0;const cEt={toc:[]};function lEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Remove all children of this node."))}lEt.isMDXComponent=!0;const uEt={toc:[]};function mEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Render this node onto the given canvas."))}mEt.isMDXComponent=!0;const dEt={toc:[]};function hEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context to draw with."))}hEt.isMDXComponent=!0;const yEt={toc:[]};function fEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}fEt.isMDXComponent=!0;const kEt={toc:[]};function wEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}wEt.isMDXComponent=!0;const gEt={toc:[]};function MEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The new parent of this node."))}MEt.isMDXComponent=!0;const DEt={toc:[]};function _Et(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}_Et.isMDXComponent=!0;const XEt={toc:[]};function xEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}xEt.isMDXComponent=!0;const vEt={toc:[]};function CEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this node should be cached or not."))}CEt.isMDXComponent=!0;const TEt={toc:[]};function bEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,i.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}bEt.isMDXComponent=!0;const LEt={toc:[]};function ZEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}ZEt.isMDXComponent=!0;const NEt={toc:[]};function SEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Restore the node to its last saved state."))}SEt.isMDXComponent=!0;const REt={toc:[]};function zEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},REt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The duration of the transition"))}zEt.isMDXComponent=!0;const AEt={toc:[]};function EEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The timing function to use for the transition"))}EEt.isMDXComponent=!0;const PEt={toc:[]};function IEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used together with the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,i.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}IEt.isMDXComponent=!0;const FEt={toc:[]};function WEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}WEt.isMDXComponent=!0;const BEt={toc:[]};function GEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,i.kt)("p",null,"Whether the node is cached is decided by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,i.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}GEt.isMDXComponent=!0;const OEt={toc:[]};function jEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}jEt.isMDXComponent=!0;const UEt={toc:[]};function qEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The context using which the cache will be drawn."))}qEt.isMDXComponent=!0;const VEt={toc:[]};function HEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,i.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}HEt.isMDXComponent=!0;const $Et={toc:[]};function JEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Et,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a copy of this node."))}JEt.isMDXComponent=!0;const YEt={toc:[]};function KEt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Properties to override."))}KEt.isMDXComponent=!0;const QEt={toc:[]};function tPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QEt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}tPt.isMDXComponent=!0;const ePt={toc:[]};function nPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ePt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}nPt.isMDXComponent=!0;const oPt={toc:[]};function sPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Apply any new layout changes to this node and its children."))}sPt.isMDXComponent=!0;const rPt={toc:[]};function iPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is the same the bounding box returned by ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,i.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}iPt.isMDXComponent=!0;const pPt={toc:[]};function aPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}aPt.isMDXComponent=!0;const cPt={toc:[]};function lPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}lPt.isMDXComponent=!0;const uPt={toc:[]};function mPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}mPt.isMDXComponent=!0;const dPt={toc:[]};function hPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-local matrix for this node."))}hPt.isMDXComponent=!0;const yPt={toc:[]};function fPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}fPt.isMDXComponent=!0;const kPt={toc:[]};function wPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the world-to-parent matrix for this node."))}wPt.isMDXComponent=!0;const gPt={toc:[]};function MPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}MPt.isMDXComponent=!0;const DPt={toc:[]};function _Pt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the path of this circle should be closed."))}_Pt.isMDXComponent=!0;const XPt={toc:[]};function xPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property can be used together with ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,i.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}xPt.isMDXComponent=!0;const vPt={toc:[]};function CPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The ending angle in degrees for the circle sector."))}CPt.isMDXComponent=!0;const TPt={toc:[]};function bPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property can be used together with ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,i.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}bPt.isMDXComponent=!0;const LPt={toc:[]};function ZPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The starting angle in degrees for the circle sector."))}ZPt.isMDXComponent=!0;const NPt={toc:[]};function SPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}SPt.isMDXComponent=!0;const RPt={toc:[]};function zPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The alpha value of this image."))}zPt.isMDXComponent=!0;const APt={toc:[]};function EPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},APt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Provide the color in one of the following formats:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"named color like ",(0,i.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,i.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}EPt.isMDXComponent=!0;const PPt={toc:[]};function IPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The color of the icon"))}IPt.isMDXComponent=!0;const FPt={toc:[]};function WPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}WPt.isMDXComponent=!0;const BPt={toc:[]};function GPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}GPt.isMDXComponent=!0;const OPt={toc:[]};function jPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"You can find identifiers on ",(0,i.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}jPt.isMDXComponent=!0;const UPt={toc:[]};function qPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The identifier of the icon."))}qPt.isMDXComponent=!0;const VPt={toc:[]};function HPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}HPt.isMDXComponent=!0;const $Pt={toc:[]};function JPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Pt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}JPt.isMDXComponent=!0;const YPt={toc:[]};function KPt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}KPt.isMDXComponent=!0;const QPt={toc:[]};function tIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QPt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the image should be smoothed."))}tIt.isMDXComponent=!0;const eIt={toc:[]};function nIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The source of this image."))}nIt.isMDXComponent=!0;const oIt={toc:[]};function sIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}sIt.isMDXComponent=!0;const rIt={toc:[]};function iIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The alpha value of this image."))}iIt.isMDXComponent=!0;const pIt={toc:[]};function aIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}aIt.isMDXComponent=!0;const cIt={toc:[]};function lIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}lIt.isMDXComponent=!0;const uIt={toc:[]};function mIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}mIt.isMDXComponent=!0;const dIt={toc:[]};function hIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}hIt.isMDXComponent=!0;const yIt={toc:[]};function fIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}fIt.isMDXComponent=!0;const kIt={toc:[]};function wIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the image should be smoothed."))}wIt.isMDXComponent=!0;const gIt={toc:[]};function MIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The source of this image."))}MIt.isMDXComponent=!0;const DIt={toc:[]};function _It(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}_It.isMDXComponent=!0;const XIt={toc:[]};function xIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}xIt.isMDXComponent=!0;const vIt={toc:[]};function CIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,i.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,i.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,i.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,i.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}CIt.isMDXComponent=!0;const TIt={toc:[]};function bIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}bIt.isMDXComponent=!0;const LIt={toc:[]};function ZIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,i.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,i.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,i.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,i.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}ZIt.isMDXComponent=!0;const NIt={toc:[]};function SIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}SIt.isMDXComponent=!0;const RIt={toc:[]};function zIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}zIt.isMDXComponent=!0;const AIt={toc:[]};function EIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The alpha value of this image."))}EIt.isMDXComponent=!0;const PIt={toc:[]};function IIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}IIt.isMDXComponent=!0;const FIt={toc:[]};function WIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}WIt.isMDXComponent=!0;const BIt={toc:[]};function GIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}GIt.isMDXComponent=!0;const OIt={toc:[]};function jIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}jIt.isMDXComponent=!0;const UIt={toc:[]};function qIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}qIt.isMDXComponent=!0;const VIt={toc:[]};function HIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the image should be smoothed."))}HIt.isMDXComponent=!0;const $It={toc:[]};function JIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$It,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The source of this image."))}JIt.isMDXComponent=!0;const YIt={toc:[]};function KIt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"For example, a value of 6 creates a hexagon."))}KIt.isMDXComponent=!0;const QIt={toc:[]};function tFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QIt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Sets the number of sides of the polygon."))}tFt.isMDXComponent=!0;const eFt={toc:[]};function nFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}nFt.isMDXComponent=!0;const oFt={toc:[]};function sFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}sFt.isMDXComponent=!0;const rFt={toc:[]};function iFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}iFt.isMDXComponent=!0;const pFt={toc:[]};function aFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}aFt.isMDXComponent=!0;const cFt={toc:[]};function lFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Spline.points"))}lFt.isMDXComponent=!0;const uFt={toc:[]};function mFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}mFt.isMDXComponent=!0;const dFt={toc:[]};function hFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}hFt.isMDXComponent=!0;const yFt={toc:[]};function fFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}fFt.isMDXComponent=!0;const kFt={toc:[]};function wFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The alpha value of this video."))}wFt.isMDXComponent=!0;const gFt={toc:[]};function MFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By default the ",(0,i.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}MFt.isMDXComponent=!0;const DFt={toc:[]};function _Ft(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Controls the sharpness of the corners. ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,i.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))}_Ft.isMDXComponent=!0;const XFt={toc:[]};function xFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether this video should loop upon reaching the end."))}xFt.isMDXComponent=!0;const vFt={toc:[]};function CFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,i.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}CFt.isMDXComponent=!0;const TFt={toc:[]};function bFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Will set the corner drawing method to smooth corners."))}bFt.isMDXComponent=!0;const LFt={toc:[]};function ZFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}ZFt.isMDXComponent=!0;const NFt={toc:[]};function SFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the video should be smoothed."))}SFt.isMDXComponent=!0;const RFt={toc:[]};function zFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The source of this video."))}zFt.isMDXComponent=!0;const AFt={toc:[]};function EFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The starting time for this video in seconds."))}EFt.isMDXComponent=!0;const PFt={toc:[]};function IFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}IFt.isMDXComponent=!0;const FFt={toc:[]};function WFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Evaluate the polynomial at the given t value."))}WFt.isMDXComponent=!0;const BFt={toc:[]};function GFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The t value at which to evaluate the curve."))}GFt.isMDXComponent=!0;const OFt={toc:[]};function jFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}jFt.isMDXComponent=!0;const UFt={toc:[]};function qFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The t value at which to evaluate the curve."))}qFt.isMDXComponent=!0;const VFt={toc:[]};function HFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,i.kt)("p",null,"Source code liberally taken from:\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}HFt.isMDXComponent=!0;const $Ft={toc:[]};function JFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Ft,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constant coefficient"))}JFt.isMDXComponent=!0;const YFt={toc:[]};function KFt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constant coefficient"))}KFt.isMDXComponent=!0;const QFt={toc:[]};function tWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QFt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The linear coefficient"))}tWt.isMDXComponent=!0;const eWt={toc:[]};function nWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constant coefficient"))}nWt.isMDXComponent=!0;const oWt={toc:[]};function sWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The linear coefficient"))}sWt.isMDXComponent=!0;const rWt={toc:[]};function iWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The quadratic coefficient"))}iWt.isMDXComponent=!0;const pWt={toc:[]};function aWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constant coefficient"))}aWt.isMDXComponent=!0;const cWt={toc:[]};function lWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The linear coefficient"))}lWt.isMDXComponent=!0;const uWt={toc:[]};function mWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The quadratic coefficient"))}mWt.isMDXComponent=!0;const dWt={toc:[]};function hWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The cubic coefficient"))}hWt.isMDXComponent=!0;const yWt={toc:[]};function fWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The degree of the polynomial"))}fWt.isMDXComponent=!0;const kWt={toc:[]};function wWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the nth derivative of the polynomial."))}wWt.isMDXComponent=!0;const gWt={toc:[]};function MWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The number of times to differentiate the polynomial."))}MWt.isMDXComponent=!0;const DWt={toc:[]};function _Wt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Evaluate the polynomial at the given value t."))}_Wt.isMDXComponent=!0;const XWt={toc:[]};function xWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value to sample at"))}xWt.isMDXComponent=!0;const vWt={toc:[]};function CWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}CWt.isMDXComponent=!0;const TWt={toc:[]};function bWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value to sample at"))}bWt.isMDXComponent=!0;const LWt={toc:[]};function ZWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The derivative of the polynomial to sample from"))}ZWt.isMDXComponent=!0;const NWt={toc:[]};function SWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the local extrema of the polynomial."))}SWt.isMDXComponent=!0;const RWt={toc:[]};function zWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}zWt.isMDXComponent=!0;const AWt={toc:[]};function EWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the output value range within the unit interval."))}EWt.isMDXComponent=!0;const PWt={toc:[]};function IWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}IWt.isMDXComponent=!0;const FWt={toc:[]};function WWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}WWt.isMDXComponent=!0;const BWt={toc:[]};function GWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}GWt.isMDXComponent=!0;const OWt={toc:[]};function jWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The point at which to split the polynomial."))}jWt.isMDXComponent=!0;const UWt={toc:[]};function qWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Constructs a constant polynomial"))}qWt.isMDXComponent=!0;const VWt={toc:[]};function HWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constant coefficient"))}HWt.isMDXComponent=!0;const $Wt={toc:[]};function JWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Wt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Constructs a cubic polynomial"))}JWt.isMDXComponent=!0;const YWt={toc:[]};function KWt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constant coefficient"))}KWt.isMDXComponent=!0;const QWt={toc:[]};function tBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QWt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The linear coefficient"))}tBt.isMDXComponent=!0;const eBt={toc:[]};function nBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The quadratic coefficient"))}nBt.isMDXComponent=!0;const oBt={toc:[]};function sBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The cubic coefficient"))}sBt.isMDXComponent=!0;const rBt={toc:[]};function iBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Constructs a linear polynomial"))}iBt.isMDXComponent=!0;const pBt={toc:[]};function aBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constant coefficient"))}aBt.isMDXComponent=!0;const cBt={toc:[]};function lBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The linear coefficient"))}lBt.isMDXComponent=!0;const uBt={toc:[]};function mBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Constructs a quadratic polynomial"))}mBt.isMDXComponent=!0;const dBt={toc:[]};function hBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The constant coefficient"))}hBt.isMDXComponent=!0;const yBt={toc:[]};function fBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The linear coefficient"))}fBt.isMDXComponent=!0;const kBt={toc:[]};function wBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The quadratic coefficient"))}wBt.isMDXComponent=!0;const gBt={toc:[]};function MBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}MBt.isMDXComponent=!0;const DBt={toc:[]};function _Bt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}_Bt.isMDXComponent=!0;const XBt={toc:[]};function xBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Evaluate the polynomial at the given t value."))}xBt.isMDXComponent=!0;const vBt={toc:[]};function CBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The t value at which to evaluate the curve."))}CBt.isMDXComponent=!0;const TBt={toc:[]};function bBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}bBt.isMDXComponent=!0;const LBt={toc:[]};function ZBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The t value at which to evaluate the curve."))}ZBt.isMDXComponent=!0;const NBt={toc:[]};function SBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,i.kt)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}SBt.isMDXComponent=!0;const RBt={toc:[]};function zBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RBt,n,{components:e,mdxType:"MDXLayout"}))}zBt.isMDXComponent=!0;const ABt={toc:[]};function EBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ABt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}EBt.isMDXComponent=!0;const PBt={toc:[]};function IBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The knots defining the spline"))}IBt.isMDXComponent=!0;const FBt={toc:[]};function WBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the spline should be closed or not"))}WBt.isMDXComponent=!0;const BBt={toc:[]};function GBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}GBt.isMDXComponent=!0;const OBt={toc:[]};function jBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}jBt.isMDXComponent=!0;const UBt={toc:[]};function qBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Check if the signal is currently using its initial value."))}qBt.isMDXComponent=!0;const VBt={toc:[]};function HBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,i.kt)("p",null,"This method can be used to create copies of signals."))}HBt.isMDXComponent=!0;const $Bt={toc:[]};function JBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Bt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}JBt.isMDXComponent=!0;const YBt={toc:[]};function KBt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Get the raw value of this signal."))}KBt.isMDXComponent=!0;const QBt={toc:[]};function tGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QBt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}tGt.isMDXComponent=!0;const eGt={toc:[]};function nGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}nGt.isMDXComponent=!0;const oGt={toc:[]};function sGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}sGt.isMDXComponent=!0;const rGt={toc:[]};function iGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}iGt.isMDXComponent=!0;const pGt={toc:[]};function aGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Compute the current value of the signal and immediately set it."))}aGt.isMDXComponent=!0;const cGt={toc:[]};function lGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,i.kt)("p",null,"By default, any property is cloneable."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}lGt.isMDXComponent=!0;const uGt={toc:[]};function mGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}mGt.isMDXComponent=!0;const dGt={toc:[]};function hGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a cloneable property decorator."))}hGt.isMDXComponent=!0;const yGt={toc:[]};function fGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the property should be cloneable."))}fGt.isMDXComponent=!0;const kGt={toc:[]};function wGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}wGt.isMDXComponent=!0;const gGt={toc:[]};function MGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}MGt.isMDXComponent=!0;const DGt={toc:[]};function _Gt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a compound property decorator."))}_Gt.isMDXComponent=!0;const XGt={toc:[]};function xGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}xGt.isMDXComponent=!0;const vGt={toc:[]};function CGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,i.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,i.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}CGt.isMDXComponent=!0;const TGt={toc:[]};function bGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a computed method decorator."))}bGt.isMDXComponent=!0;const LGt={toc:[]};function ZGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator specifies the initial value of a property."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}ZGt.isMDXComponent=!0;const NGt={toc:[]};function SGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}SGt.isMDXComponent=!0;const RGt={toc:[]};function zGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},RGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an initial signal value decorator."))}zGt.isMDXComponent=!0;const AGt={toc:[]};function EGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The initial value of the property."))}EGt.isMDXComponent=!0;const PGt={toc:[]};function IGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},PGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,i.kt)("p",null,"By default, any property is inspectable."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}IGt.isMDXComponent=!0;const FGt={toc:[]};function WGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}WGt.isMDXComponent=!0;const BGt={toc:[]};function GGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an inspectable property decorator."))}GGt.isMDXComponent=!0;const OGt={toc:[]};function jGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Whether the property should be inspectable."))}jGt.isMDXComponent=!0;const UGt={toc:[]};function qGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}qGt.isMDXComponent=!0;const VGt={toc:[]};function HGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}HGt.isMDXComponent=!0;const $Gt={toc:[]};function JGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Gt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a signal interpolation function decorator."))}JGt.isMDXComponent=!0;const YGt={toc:[]};function KGt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The interpolation function for the property."))}KGt.isMDXComponent=!0;const QGt={toc:[]};function tOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QGt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,i.kt)("p",null,"If the wrapper class has a method called ",(0,i.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}tOt.isMDXComponent=!0;const eOt={toc:[]};function nOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},eOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}nOt.isMDXComponent=!0;const oOt={toc:[]};function sOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},oOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a signal parser decorator."))}sOt.isMDXComponent=!0;const rOt={toc:[]};function iOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The wrapper class for the property."))}iOt.isMDXComponent=!0;const pOt={toc:[]};function aOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This decorator turns the given property into a signal."),(0,i.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}aOt.isMDXComponent=!0;const cOt={toc:[]};function lOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}lOt.isMDXComponent=!0;const uOt={toc:[]};function mOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},uOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a signal decorator."))}mOt.isMDXComponent=!0;const dOt={toc:[]};function hOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},dOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,i.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,i.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,i.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,i.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,i.kt)("p",null,"Must be specified before the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,i.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}hOt.isMDXComponent=!0;const yOt={toc:[]};function fOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}fOt.isMDXComponent=!0;const kOt={toc:[]};function wOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a signal wrapper decorator."))}wOt.isMDXComponent=!0;const gOt={toc:[]};function MOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},gOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The wrapper class for the property."))}MOt.isMDXComponent=!0;const DOt={toc:[]};function _Ot(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},DOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A unified abstraction for all CSS filters."))}_Ot.isMDXComponent=!0;const XOt={toc:[]};function xOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},XOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When the desired length is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}xOt.isMDXComponent=!0;const vOt={toc:[]};function COt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},vOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}COt.isMDXComponent=!0;const TOt={toc:[]};function bOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},TOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value can be either:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,i.kt)("inlineCode",{parentName:"li"},"'50%'"))))}bOt.isMDXComponent=!0;const LOt={toc:[]};function ZOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},LOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents a length used by most layout properties."))}ZOt.isMDXComponent=!0;const NOt={toc:[]};function SOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},NOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,i.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}SOt.isMDXComponent=!0;const ROt={toc:[]};function zOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ROt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,i.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}zOt.isMDXComponent=!0;const AOt={toc:[]};function EOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},AOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter in pixels."))}EOt.isMDXComponent=!0;const POt={toc:[]};function IOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},POt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,i.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}IOt.isMDXComponent=!0;const FOt={toc:[]};function WOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},FOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}WOt.isMDXComponent=!0;const BOt={toc:[]};function GOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},BOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,i.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}GOt.isMDXComponent=!0;const OOt={toc:[]};function jOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},OOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}jOt.isMDXComponent=!0;const UOt={toc:[]};function qOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},UOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,i.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}qOt.isMDXComponent=!0;const VOt={toc:[]};function HOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},VOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}HOt.isMDXComponent=!0;const $Ot={toc:[]};function JOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},$Ot,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,i.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}JOt.isMDXComponent=!0;const YOt={toc:[]};function KOt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},YOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter in degrees."))}KOt.isMDXComponent=!0;const QOt={toc:[]};function tjt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},QOt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create an ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,i.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}tjt.isMDXComponent=!0;const ejt={toc:[]};function njt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ejt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}njt.isMDXComponent=!0;const ojt={toc:[]};function sjt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ojt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,i.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}sjt.isMDXComponent=!0;const rjt={toc:[]};function ijt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},rjt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}ijt.isMDXComponent=!0;const pjt={toc:[]};function ajt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},pjt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Create a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,i.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}ajt.isMDXComponent=!0;const cjt={toc:[]};function ljt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},cjt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The value of the filter."))}ljt.isMDXComponent=!0;const ujt={toc:[]};function mjt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},ujt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}mjt.isMDXComponent=!0;const djt={toc:[]};function hjt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},djt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Invoke the given callback in the context of this scene."))}hjt.isMDXComponent=!0;const yjt={toc:[]};function fjt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},yjt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The callback to invoke."))}fjt.isMDXComponent=!0;const kjt={toc:[]};function wjt(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,r.Z)({},kjt,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Update the view."),(0,i.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,i.kt)("p",null,"Can modify the state of the view."))}function gjt(t){let{id:e}=t;const n=o[e]??s.Fragment;return s.createElement(n,null)}wjt.isMDXComponent=!0},79322:(t,e,n)=>{"use strict";n.d(e,{Z:()=>m});var o=n(2784),s=n(24983),r=n(28698);const i="toggle_S_IX",p="collapsed_wdUB",a="collapse_TjTN",c="inverse_g6vW",l="clearFix_HQ1T";var u=n(6277);function m(t){let{comment:e,full:n=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@remarks"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(s.Z,{id:null==e?void 0:e.summaryId}),o.createElement(s.Z,{id:null==r?void 0:r.contentId}),n&&o.createElement(d,{comment:e}))}function d(t){let{comment:e}=t;const[n,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@preview"===e}))}),[e]),h=(0,o.useMemo)((()=>{var t;return(null==e||null==(t=e.blockTags)?void 0:t.filter((t=>{let{tag:e}=t;return"@example"===e})))??[]}),[e]),y=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@defaultValue"===e}))}),[e]),f=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@deprecated"===e}))}),[e]),k=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@see"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(s.Z,{id:null==d?void 0:d.contentId}),h.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(i,n&&p),onClick:t=>{t.preventDefault(),m(!n)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:n},o.createElement("div",{className:a},h.map((t=>o.createElement(s.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,c)})),y&&o.createElement(o.Fragment,null,"Default Value:"," ",o.createElement("code",null,y.content.map((t=>t.text)).join(""))),f&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(s.Z,{id:f.contentId})),k&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(s.Z,{id:k.contentId})))}},31930:(t,e,n)=>{"use strict";n.d(e,{Z:()=>Gt});var o=n(2784),s=n(37390),r=n(66835),i=n(80068),p=n(6277),a=n(68569);const c={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=n(7896);function u(t){let{width:e=24,height:n=24,...s}=t;return o.createElement("svg",(0,l.Z)({width:e,height:n,"aria-hidden":"true",viewBox:"0 0 24 24"},s),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:e,highlight:n,onClick:s,link:l}=t;const m=(0,r.F)(),d=(0,i.s2)();return o.createElement("div",{className:(0,p.Z)(a.Z.codeBlockContent,c.codeBlock,n&&c.highlight,s&&c.pointer)},o.createElement("pre",{onClick:s,onKeyDown:t=>{"Enter"===t.key&&(null==s||s())},tabIndex:0,ref:m.codeBlockRef,className:(0,p.Z)(a.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:a.Z.codeBlockLines,style:d},e)),l&&o.createElement("div",{className:a.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=n(39318);function h(t){let{children:e}=t;return o.createElement(d.Z,{as:"div",className:(0,p.Z)(c.codeBlockContainer,"language-typescript")},e)}var y=n(89817);function f(t){let{children:e,type:n,to:s,id:r,tooltip:p}=t;const a=(0,i.Ld)(n);return s?o.createElement(y.Z,(0,l.Z)({id:r,to:s,"data-tooltip":p},a),e):o.createElement("span",(0,l.Z)({id:r},a),e)}let k,w;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(k||(k={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(w||(w={}));const g={[k.None]:c.none,[k.Angle]:c.angle,[k.Curly]:c.curly,[k.Square]:c.square,[k.Parentheses]:c.parentheses};function M(t){let{children:e,type:n,separator:s=w.Comma}=t;return o.createElement("span",{className:(0,p.Z)(c.list,g[n??k.None])},o.createElement("span",{className:(0,p.Z)(c.elements,s!==w.Comma&&c.left)},(Array.isArray(e)?e:[e]).flatMap(((t,e)=>o.createElement("span",{"data-separator":s,key:e,className:c.element},t)))))}var D=n(88617);function _(t){var e;let{type:n}=t;const s=(0,D.RU)(n.project),r=null==s?void 0:s[n.id],i=n.externalUrl??(0,D.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(f,{to:i,type:i?"class-name":"constant",tooltip:!0},n.name),!(null==(e=n.typeArguments)||!e.length)&&o.createElement(M,{type:k.Angle},n.typeArguments.map(((t,e)=>o.createElement(F,{key:e,type:t})))))}function X(t){let{type:e}=t;return o.createElement(f,{type:"keyword"},e.name)}function x(t){let{type:e}=t;return e.elements?o.createElement(M,{type:k.Square},e.elements.map(((t,e)=>o.createElement(F,{key:e,type:t})))):o.createElement(o.Fragment,null,"[]")}function v(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(F,{type:e.elementType}),"[]")}function C(t){let{type:e}=t;return o.createElement(M,{type:k.Parentheses,separator:w.Pipe},e.types.map(((t,e)=>o.createElement(F,{key:e,type:t}))))}function T(t){let{type:e}=t;const[n,s]=(0,o.useMemo)((()=>{if(null===e.value)return["null","keyword"];switch(typeof e.value){case"object":return[(e.value.negative?"-":"")+e.value.value,"number"];case"boolean":return[e.value,"keyword"];case"number":return[e.value,"number"];case"string":return[`'${e.value}'`,"string"];default:return[e.value,"constant"]}}),[e.value]);return o.createElement(f,{type:s},n)}function b(t){let{type:e}=t;return e.asserts?o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"asserts "),o.createElement(f,null,e.name," ")):o.createElement(o.Fragment,null,o.createElement(f,null,e.name," "),o.createElement(f,{type:"keyword"},"is "),o.createElement(F,{type:e.targetType}))}function L(t){let{type:e}=t;const n=(0,D.in)();return o.createElement(J,{reflection:n(e.declaration)})}function Z(t){let{type:e}=t;return o.createElement(M,{type:k.Parentheses,separator:w.Ampersand},e.types.map(((t,e)=>o.createElement(F,{key:e,type:t}))))}function N(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(f,{type:"string"},"`",e.head),e.tail.map(((t,e)=>{let[n,s]=t;return o.createElement(o.Fragment,null,"${",o.createElement(F,{key:e,type:n}),"}",o.createElement(f,{type:"string"},s))})),o.createElement(f,{type:"string"},"`"))}function S(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"typeof "),o.createElement(F,{type:e.queryType}))}function R(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(F,{type:e.checkType}),o.createElement(f,{type:"keyword"}," extends "),o.createElement(F,{type:e.extendsType})," ? ",o.createElement(F,{type:e.trueType})," : ",o.createElement(F,{type:e.falseType}))}function z(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"infer "),o.createElement(f,{type:"constant"},e.name))}function A(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(F,{type:e.objectType}),"[",o.createElement(F,{type:e.indexType}),"]")}function E(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},e.operator," "),o.createElement(F,{type:e.target}))}function P(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(M,{type:k.Curly},o.createElement(o.Fragment,null,"[",o.createElement(f,{type:"class"},e.parameter),o.createElement(f,{type:"keyword"}," in "),o.createElement(F,{type:e.parameterType}),"]: ",o.createElement(F,{type:e.templateType}))))}function I(t){let{type:e}=t;return o.createElement(o.Fragment,null,e.name,": ",o.createElement(F,{type:e.element}))}function F(t){const e=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return E;case"conditional":return R;case"reflection":return L;case"query":return S;case"named-tuple-member":return I;case"union":return C;case"intrinsic":return X;case"literal":return T;case"reference":return _;case"predicate":return b;case"tuple":return x;case"array":return v;case"intersection":return Z;case"inferred":return z;case"mapped":return P;case"template-literal":return N;case"indexedAccess":return A}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(e,t)}function W(t){let{flags:e,explicitAccessModifier:n}=t;const s=[];return null!=e&&e.isAbstract&&s.push("abstract"),null!=e&&e.isStatic&&s.push("static"),null!=e&&e.isConst&&s.push("const"),null!=e&&e.isReadonly&&s.push("readonly"),null!=e&&e.isPrivate&&s.push("private"),null!=e&&e.isProtected&&s.push("protected"),(null==e||!e.isPublic)&&(!n||null!=e&&e.isProtected||null!=e&&e.isPrivate)||s.push("public"),o.createElement(o.Fragment,null,s.map((t=>o.createElement(f,{key:t,type:"keyword"},t," "))))}function B(t){let{reflection:e}=t;const n="__namedParameters"===e.name?"{...}":e.name;return o.createElement(o.Fragment,null,o.createElement(W,{flags:e.flags}),e.flags.isRest&&"...",o.createElement(f,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"plain"},n),e.flags.isOptional&&"?",": ",e.type&&o.createElement(F,{type:e.type}),e.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(f,{type:"plain"},e.defaultValue)))}function G(t){let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(W,{flags:e.flags}),e.varianceModifier&&o.createElement(f,{type:"keyword"},e.varianceModifier," "),o.createElement(f,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"class-name"},e.name),e.type&&o.createElement(o.Fragment,null," extends ",o.createElement(F,{type:e.type})),e.default&&o.createElement(o.Fragment,null," = ",o.createElement(F,{type:e.default})))}function O(t){var e,n;let{reflection:r,flags:i}=t;const p=(0,D.in)(),a="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(W,{flags:i??r.flags,explicitAccessModifier:!a}),r.kind===s.W.GetSignature&&o.createElement(f,{type:"keyword"},"get "),r.kind===s.W.SetSignature&&o.createElement(f,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(f,{to:r.overwrites.externalUrl??(0,D.Gr)(p(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===s.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(f,{to:"#",type:"keyword"},"new")," ",o.createElement(f,{type:"plain"},r.type.name)):a?"":o.createElement(f,{type:"function"},r.name),!(null==(e=r.typeParameter)||!e.length)&&o.createElement(M,{type:k.Angle},r.typeParameter.map((t=>o.createElement(G,{key:t.id,reflection:p(t)})))),null!=(n=r.parameters)&&n.length?o.createElement(M,{type:k.Parentheses},r.parameters.map((t=>o.createElement(B,{key:t,reflection:p(t)})))):"()",r.type&&o.createElement(o.Fragment,null,a?" => ":": ",o.createElement(F,{type:r.type})))}function j(t){let{reflection:e}=t;return o.createElement(B,{reflection:e})}const U={[s.W.Namespace]:"namespace",[s.W.Enum]:"enum",[s.W.Class]:"class",[s.W.Interface]:"interface"};function q(t){var e,n,s;let{reflection:r}=t;const i=(0,D.in)();return o.createElement(o.Fragment,null,o.createElement(W,{flags:r.flags}),o.createElement(f,{type:"keyword"},U[r.kind]," "),o.createElement(f,{type:"class-name"},r.name),!(null==(e=r.typeParameters)||!e.length)&&o.createElement(M,{type:k.Angle},r.typeParameters.map((t=>o.createElement(G,{key:t.id,reflection:i(t)}))))," ",!(null==(n=r.extendedTypes)||!n.length)&&o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"extends "),o.createElement(M,null,r.extendedTypes.map(((t,e)=>o.createElement(F,{key:e,type:t}))))),!(null==(s=r.implementedTypes)||!s.length)&&o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"implements "),o.createElement(M,null,r.implementedTypes.map(((t,e)=>o.createElement(F,{key:e,type:t}))))))}function V(t){let{reflection:e}=t;const n=(0,D.in)();return o.createElement(o.Fragment,null,o.createElement(W,{flags:e.flags}),o.createElement(f,{type:"keyword"},"type "),o.createElement(f,{type:"class-name"},e.name),e.typeParameters&&o.createElement(M,{type:k.Angle},e.typeParameters.map((t=>o.createElement(G,{key:t.id,reflection:n(t)}))))," = ",o.createElement(F,{type:e.type}))}function H(t){let{reflection:e}=t;const n=(0,D.in)();return e.signatures?o.createElement(O,{reflection:e.signatures[0]}):e.children?o.createElement(M,{type:k.Curly},e.children.map((t=>o.createElement(J,{key:t.id,reflection:n(t)})))):o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"unknown"))}function $(t){var e;let{reflection:n}=t;const s=(null==(e=n.signatures)?void 0:e[0])??n.getSignature??n.setSignature??n.indexSignature;return o.createElement(O,{reflection:s})}function J(t){let{reflection:e}=t;const n=(0,o.useMemo)((()=>{switch(e.kind){case s.W.Project:case s.W.Module:case s.W.EnumMember:case s.W.Variable:case s.W.Function:break;case s.W.Namespace:case s.W.Enum:case s.W.Class:case s.W.Interface:return q;case s.W.Constructor:return O;case s.W.Property:return j;case s.W.Method:return $;case s.W.CallSignature:case s.W.IndexSignature:case s.W.ConstructorSignature:case s.W.Parameter:break;case s.W.TypeLiteral:return H;case s.W.TypeParameter:return G;case s.W.Accessor:case s.W.GetSignature:case s.W.SetSignature:case s.W.ObjectLiteral:break;case s.W.TypeAlias:return V;case s.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.id]);return o.createElement(n,{reflection:e})}function Y(t){let{children:e}=t;const n=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!n.current)return;const t=n.current.closest("pre");if(t.scrollWidth>t.clientWidth){const e=Array.from(n.current.querySelectorAll(`.${c.elements}`)).sort(((t,e)=>function(t,e){return t>e?1:t<e?-1:0}(e.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&e.length>0;)e.shift().classList.add(c.wrap)}})),o.createElement(o.Fragment,null,e&&o.createElement("span",{ref:n,className:(0,p.Z)(c.line,"token-line")},e),o.createElement("br",null))}var K=n(79322),Q=n(24983);function tt(t){let{parameters:e}=t;const n=(0,D.in)(),s=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=s&&s.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,s.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(G,{reflection:t})),o.createElement(Q.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{parameters:e}=t;const n=(0,D.in)(),s=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=s&&s.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,s.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(B,{reflection:t})),o.createElement(Q.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{signatures:e,flags:n,source:s}=t;const r=(0,D.in)(),i=(0,o.useMemo)((()=>e.map(r)),[e]),[p,a]=(0,o.useState)(i[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,i.map((t=>o.createElement(m,{link:null==s?void 0:s.url,key:t.id,highlight:e.length>1&&t.id===p.id,onClick:e.length>1?()=>a(t):void 0},o.createElement(Y,null,o.createElement(O,{reflection:t,flags:n})))))),o.createElement(K.Z,{comment:p.comment}),o.createElement(tt,{parameters:p.typeParameter}),o.createElement(et,{parameters:p.parameters}))}var ot=n(57708);function st(t){let{width:e=24,height:n=24,...s}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},s),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",it="filters_z1iC",pt="icon_ROIU";function at(){const t=(0,o.useRef)(null),[e,n]=(0,o.useState)(!1),[s,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const e=e=>{t.current&&!t.current.contains(e.target)&&n(!1)};return document.addEventListener("mousedown",e),document.addEventListener("touchstart",e),()=>{document.removeEventListener("mousedown",e),document.removeEventListener("touchstart",e)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,p.Z)("dropdown dropdown--right margin-bottom--md",e&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),n(!e)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),n(!e))}},"Filters",o.createElement(st,{className:pt})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,p.Z)("dropdown__link",s.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:s.private,onChange:t=>{r({...s,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&n(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,p.Z)("dropdown__link",s.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:s.inherited,onChange:t=>{r({...s,inherited:t.target.checked})}}),"Inherited members")))))}function ct(t){let{children:e,kind:n}=t;return n===s.W.Class||n===s.W.Interface?o.createElement("div",{className:(0,p.Z)("row",rt)},o.createElement("div",{className:(0,p.Z)("col",it)},o.createElement(at,null)),o.createElement("div",{className:"col"},e)):o.createElement(o.Fragment,null,e)}var lt=n(53181),ut=n(83851),mt=n(24126),dt=n(32424),ht=n(42244),yt=n(24155);function ft(t){return function(t){return o.Children.map(t,(t=>{if((0,o.isValidElement)(t)&&"value"in t.props)return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(t).map((t=>{let{props:{value:e,label:n,attributes:o,default:s}}=t;return{value:e,label:n,attributes:o,default:s}}))}function kt(t){const{values:e,children:n}=t;return(0,o.useMemo)((()=>{const t=e??ft(n);return function(t){const e=(0,ht.l)(t,((t,e)=>t.value===e.value));if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[e,n])}function wt(t){let{value:e,tabValues:n}=t;return n.some((t=>t.value===e))}function gt(t){let{queryString:e=!1,groupId:n}=t;const s=(0,lt.k6)(),r=function(t){let{queryString:e=!1,groupId:n}=t;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,dt._X)(r),(0,o.useCallback)((t=>{if(!r)return;const e=new URLSearchParams(s.location.search);e.set(r,t),s.replace({...s.location,search:e.toString()})}),[r,s])]}function Mt(t){const{defaultValue:e,queryString:n=!1,groupId:s}=t,r=kt(t),[i,p]=(0,o.useState)((()=>function(t){let{defaultValue:e,tabValues:n}=t;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!wt({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const o=n.find((t=>t.default))??n[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:e,tabValues:r}))),[a,c]=gt({queryString:n,groupId:s}),[l,u]=function(t){let{groupId:e}=t;const n=function(t){return t?`docusaurus.tab.${t}`:null}(e),[s,r]=(0,yt.Nk)(n);return[s,(0,o.useCallback)((t=>{n&&r.set(t)}),[n,r])]}({groupId:s}),m=(()=>{const t=a??l;return wt({value:t,tabValues:r})?t:null})();(0,o.useLayoutEffect)((()=>{m&&p(m)}),[m]);return{selectedValue:i,selectValue:(0,o.useCallback)((t=>{if(!wt({value:t,tabValues:r}))throw new Error(`Can't select invalid tab value=${t}`);p(t),c(t),u(t)}),[c,u,r]),tabValues:r}}var Dt=n(89741);const _t="tabList_M0Dn",Xt="tabItem_ysIP";function xt(t){let{className:e,block:n,selectedValue:s,selectValue:r,tabValues:i}=t;const a=[],{blockElementScrollPositionUntilNextRender:c}=(0,mt.o5)(),u=t=>{const e=t.currentTarget,n=a.indexOf(e),o=i[n].value;o!==s&&(c(e),r(o))},m=t=>{var e;let n=null;switch(t.key){case"Enter":u(t);break;case"ArrowRight":{const e=a.indexOf(t.currentTarget)+1;n=a[e]??a[0];break}case"ArrowLeft":{const e=a.indexOf(t.currentTarget)-1;n=a[e]??a[a.length-1];break}}null==(e=n)||e.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,p.Z)("tabs",{"tabs--block":n},e)},i.map((t=>{let{value:e,label:n,attributes:r}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:s===e?0:-1,"aria-selected":s===e,key:e,ref:t=>a.push(t),onKeyDown:m,onClick:u},r,{className:(0,p.Z)("tabs__item",Xt,null==r?void 0:r.className,{"tabs__item--active":s===e})}),n??e)})))}function vt(t){let{lazy:e,children:n,selectedValue:s}=t;if(n=Array.isArray(n)?n:[n],e){const t=n.find((t=>t.props.value===s));return t?(0,o.cloneElement)(t,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},n.map(((t,e)=>(0,o.cloneElement)(t,{key:e,hidden:t.props.value!==s}))))}function Ct(t){const e=Mt(t);return o.createElement("div",{className:(0,p.Z)("tabs-container",_t)},o.createElement(xt,(0,l.Z)({},t,e)),o.createElement(vt,(0,l.Z)({},t,e)))}function Tt(t){const e=(0,Dt.Z)();return o.createElement(Ct,(0,l.Z)({key:String(e)},t))}const bt="tabItem_OMyP";function Lt(t){let{children:e,hidden:n,className:s}=t;return o.createElement("div",{role:"tabpanel",className:(0,p.Z)(bt,s),hidden:n},e)}function Zt(t){let{group:e}=t;return"Constructors"===e.title&&0===e.external.length&&1===e.nested.length?o.createElement(Gt,{reflection:e.nested[0]}):o.createElement(o.Fragment,null,e.external.length>0&&o.createElement("ul",null,e.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(_,{type:t})))))),e.nested.length>0&&e.nested.map(((t,e)=>o.createElement(o.Fragment,{key:t.id},e>0&&o.createElement("hr",null),o.createElement(Gt,{reflection:t})))))}function Nt(t){let{group:e,project:n}=t;const s=(0,lt.TH)(),r=(0,D.RU)(n),i=s.hash.split("-")[0].slice(1),[p]=(0,ot.mN)(),a=(0,o.useMemo)((()=>(e.categories??[e]).map((t=>function(t,e,n){const o=[],s=[],r=[];for(const i of t.children){const t=e[i];t&&(0,ot.It)(n,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):s.push(t))}if(o.length>0||s.length>0)return{title:t.title,external:o,nested:s,anchors:r}}(t,r,p))).filter((t=>!!t))),[e,r,p]);return(0,o.useEffect)((()=>{if(1===a.length)return;const t=s.hash.split("-")[0].slice(1);for(const e of a)if(e.anchors.includes(t))return}),[s.hash,a]),0===a.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h2",id:e.title},e.title),a.length>1?o.createElement(Tt,{groupId:e.title},a.map((t=>o.createElement(Lt,{default:t.anchors.includes(i),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(Zt,{group:t}))))):o.createElement(Zt,{group:a[0]}))}function St(t){var e,n,s,r,i;let{reflection:p}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(e=p.sources)||null==(n=e[0])?void 0:n.url},o.createElement(Y,null,o.createElement(J,{reflection:p})))),o.createElement(ct,{kind:p.kind},o.createElement(K.Z,{comment:p.comment})),o.createElement(tt,{parameters:p.typeParameters}),(null==(s=p.implementedBy)?void 0:s.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,p.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(_,{type:t}))))))),(null==(r=p.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,p.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(_,{type:t}))))))),p.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:p.signatures})),null==(i=p.groups)?void 0:i.map((t=>o.createElement(Nt,{group:t,key:t.title,project:p.project}))))}function Rt(t){var e;let{reflection:n,headless:s}=t;const r=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!s&&(n.hasOwnPage?o.createElement("h1",null,n.name):o.createElement(ut.Z,{as:"h3",id:n.anchor},o.createElement("code",null,n.name))),o.createElement(nt,{signatures:r,flags:n.flags,source:null==(e=n.sources)?void 0:e[0]}),n.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(_,{type:n.inheritedFrom}))),n.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(_,{type:n.overwrites}))))}function zt(t){var e,n;let{reflection:s,headless:r}=t;return o.createElement(o.Fragment,null,!r&&(s.hasOwnPage?o.createElement("h1",null,s.name):o.createElement(ut.Z,{as:"h3",id:s.anchor},o.createElement("code",null,s.name))),o.createElement(h,null,o.createElement(m,{link:null==(e=s.sources)||null==(n=e[0])?void 0:n.url},o.createElement(Y,null,o.createElement(j,{reflection:s})))),o.createElement(K.Z,{comment:s.comment}),s.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(_,{type:s.inheritedFrom}))))}function At(t){var e,n,s;let{reflection:r}=t;const i=(0,D.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(e=r.sources)||null==(n=e[0])?void 0:n.url},o.createElement(Y,null,o.createElement(J,{reflection:r})))),o.createElement(K.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:r.signatures})),null==(s=r.groups)?void 0:s.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>i[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Gt,{key:t.id,reflection:t})))))))}var Et=n(78128);function Pt(t){var e;let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(Et.Z,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),o.createElement(ct,{kind:n.kind},o.createElement(K.Z,{comment:n.comment})),null==(e=n.groups)?void 0:e.map((t=>o.createElement(Nt,{group:t,key:t.title,project:n.project}))))}const It="cardContainer_ybwo",Ft="cardTitle_Ehd1",Wt="cardDescription_b6wr";function Bt(t){let{reflection:e}=t;const n=(0,D.RU)(e.project),s=e.groups[0].children.map((t=>n[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,p.Z)("row")},s.map((t=>{var e;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(y.Z,{href:t.href,className:(0,p.Z)("card padding--lg",It)},o.createElement("h2",{className:(0,p.Z)("text--truncate",Ft)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,p.Z)("text--truncate",Wt)},(null==(e=t.comment)?void 0:e.summaryText)??"\xa0")))}))))}function Gt(t){let{reflection:e,headless:n=!1}=t;const r=(0,o.useMemo)((()=>{switch(e.kind){case s.W.Project:return Bt;case s.W.Module:return Pt;case s.W.Namespace:case s.W.Enum:case s.W.Class:case s.W.Interface:return St;case s.W.Function:case s.W.Accessor:case s.W.Constructor:case s.W.Method:return Rt;case s.W.Variable:case s.W.Property:case s.W.EnumMember:return zt;case s.W.CallSignature:case s.W.IndexSignature:case s.W.ConstructorSignature:case s.W.Parameter:case s.W.TypeLiteral:case s.W.TypeParameter:case s.W.GetSignature:case s.W.SetSignature:case s.W.ObjectLiteral:break;case s.W.TypeAlias:return At;case s.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.kind]);return o.createElement(r,{reflection:e,headless:n})}},37390:(t,e,n)=>{"use strict";let o;n.d(e,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},26773:(t,e,n)=>{"use strict";n.d(e,{Z:()=>kt});var o=n(2784),s=n(18888),r=n(35565),i=n(1727),p=n(99387),a=n(77120),c=n(53947),l=n(86253);const u=a.Qf.define([{tag:l.pJ.comment,color:"var(--hl-comment)"},{tag:l.pJ.docComment,color:"var(--hl-comment)"},{tag:l.pJ.blockComment,color:"var(--hl-comment)"},{tag:l.pJ.keyword,color:"var(--hl-keyword)"},{tag:l.pJ.number,color:"var(--hl-number)"},{tag:l.pJ.inserted,color:"var(--hl-number)"},{tag:l.pJ.constant(l.pJ.propertyName),color:"var(--hl-constant)"},{tag:l.pJ.attributeName,color:"var(--hl-variable)"},{tag:l.pJ.variableName,color:"var(--hl-variable)"},{tag:l.pJ.propertyName,color:"var(--hl-variable)"},{tag:l.pJ.deleted,color:"var(--hl-string)"},{tag:l.pJ.string,color:"var(--hl-string)"},{tag:l.pJ.attributeValue,color:"var(--hl-string)"},{tag:l.pJ.tagName,color:"var(--hl-tag)"},{tag:l.pJ.typeName,color:"var(--hl-tag)"},{tag:l.pJ.punctuation,color:"var(--hl-punctuation)"},{tag:l.pJ.operator,color:"var(--hl-punctuation)"},{tag:l.pJ.function(l.pJ.variableName),color:"var(--hl-function)"},{tag:l.pJ.function(l.pJ.propertyName),color:"var(--hl-function)"},{tag:l.pJ.className,color:"var(--hl-class)"},{tag:l.pJ.character,color:"var(--hl-char)"}]),m=r.tk.theme({"&":{fontSize:"var(--ifm-code-font-size)",lineHeight:"21.04px",fontFamily:"var(--ifm-font-family-monospace)",color:"var(--hl-color)",backgroundColor:"var(--hl-background)"},"&.cm-focused .cm-cursor":{borderLeftColor:"var(--hl-color)"},"&.cm-focused":{outline:"none"},".cm-gutters":{backgroundColor:"var(--hl-background)",color:"var(--ifm-color-secondary-darkest)",borderRight:"1px solid var(--ifm-background-color)"},"& .cm-lineNumbers .cm-gutterElement":{paddingLeft:"var(--ifm-pre-padding)"},".cm-activeLineGutter":{backgroundColor:"var(--ifm-code-active-color)"},".cm-scroller":{fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",paddingTop:"var(--ifm-pre-padding)",paddingBottom:"var(--ifm-pre-padding)"},".cm-content":{padding:"0"},"& .cm-line":{paddingRight:"var(--ifm-pre-padding)"},"& .cm-selectionBackground, &.cm-focused .cm-selectionBackground, ::selection":{backgroundColor:"var(--ifm-code-selection-color)"},".cm-activeLine":{backgroundColor:"var(--ifm-code-active-color)"},".cm-selectionMatch":{backgroundColor:"var(--ifm-code-selection-color)"},".cm-foldPlaceholder":{backgroundColor:"var(--ifm-code-selection-color)",borderColor:"var(--ifm-color-emphasis-300)"},".cm-tooltip":{backgroundColor:"var(--ifm-background-surface-color)"}});var d=n(78128);function h(t){const[e,n]=(0,o.useState)(null==t?void 0:t.current);return(0,o.useEffect)((()=>t&&t.subscribe(n)),[t]),e}function y(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M6 6h2v12H6zm3.5 6l8.5 6V6z"}))}function f(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"}))}function k(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M8 5v14l11-7z"}))}function w(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M6 19h4V5H6v14zm8-14v14h4V5h-4z"}))}var g=n(16491);const M=Object.entries(g.Z).map((t=>{let[e,n]=t;return{label:e,type:"function"==typeof n?(o=n,o.prototype&&o.prototype.constructor.name?"class":"function"):"variable"};var o}));var D,_=n(96881);!function(t){t.Error="error",t.Warn="warn",t.Info="info",t.Http="http",t.Verbose="verbose",t.Debug="debug",t.Silly="silly"}(D||(D={}));class X{constructor(){this.logged=new _.p,this.history=[],this.profilers={}}get onLogged(){return this.logged.subscribable}log(t){this.logged.dispatch(t),this.history.push(t)}error(t){this.logLevel(D.Error,t)}warn(t){this.logLevel(D.Warn,t)}info(t){this.logLevel(D.Info,t)}http(t){this.logLevel(D.Http,t)}verbose(t){this.logLevel(D.Verbose,t)}debug(t){this.logLevel(D.Debug,t)}silly(t){this.logLevel(D.Silly,t)}logLevel(t,e){const n="string"==typeof e?{message:e}:e;n.level=t,this.log(n)}profile(t,e){const n=performance.now();if(this.profilers[t]){const o=this.profilers[t];delete this.profilers[t];const s=e??{message:t};return s.level??(s.level=D.Debug),s.durationMs=n-o,void this.log(s)}this.profilers[t]=n}}var x=n(82344),v=n(92673),C=n(30204);class T extends x.C{constructor(){super(...arguments),this.type=C.I.symbol}parse(t){return null===t?null:new C.I(t)}serialize(){var t;return(null==(t=this.value.current)?void 0:t.serialize())??null}}var b=n(57292),L=n(13170);class Z extends x.C{constructor(){super(...arguments),this.type=Z.symbol}parse(t){return this.parseRange(1/0,t[0],t[1]??1/0)}update(t,e,n,o){this.value.current=this.parseRange(n/o-b.I,t/o-b.I,e/o-b.I)}parseRange(t,e,n){return void 0===e&&(e=this.value.current[0]),void 0===n&&(n=this.value.current[1]),(e=(0,L.uZ)(0,t,e))>(n=(0,L.uZ)(0,t,n??1/0))&&([e,n]=[n,e]),n>=t&&(n=1/0),[e,n]}}Z.symbol=Symbol.for("@motion-canvas/core/meta/RangeMetaField");var N=n(29797);class S extends x.C{constructor(){super(...arguments),this.type=N.F.symbol}parse(t){return new N.F(t)}serialize(){return this.value.current.serialize()}}class R extends x.C{constructor(){super(...arguments),this.type=Number,this.presets=[]}parse(t){let e=parseFloat(t);return void 0!==this.min&&e<this.min&&(e=this.min),void 0!==this.max&&e>this.max&&(e=this.max),e}getPresets(){return this.presets}setPresets(t){return this.presets=t,this}setRange(t,e){return this.min=t,this.max=e,this}}class z extends x.C{constructor(t,e,n){void 0===n&&(n=e[0].value),super(t,n),this.options=e,this.type=z.symbol}set(t){super.set(this.getOption(t).value)}parse(t){return this.getOption(t).value}getOption(t){return this.options.find((e=>e.value===t))??this.options[0]}}z.symbol=Symbol.for("@motion-canvas/core/meta/EnumMetaField");var A=n(1323);class E extends x.C{get onFieldsChanged(){return this.fields.subscribable}get options(){return this.optionFields[this.current]}get exporter(){return this.exporters[this.current]}constructor(t,e,n){void 0===n&&(n=0);const o=e.map((t=>t.meta())),s=new z("exporter",e.map((t=>({value:t.name,text:t.name}))),e[n].name);super(t,{name:s.get(),options:o[n].get()}),this.exporters=e,this.current=n,this.type=Object,this.handleChange=()=>{const t=this.exporterField.get(),e=Math.max(this.exporters.findIndex((e=>e.name===t)),0);this.current!==e&&(this.options.onChanged.unsubscribe(this.handleChange),this.current=e,this.options.onChanged.subscribe(this.handleChange,!1),this.fields.current=[this.exporterField,this.options]),this.value.current={name:this.exporterField.get(),options:this.options.get()}},this.exporterField=s,this.exporterField.onChanged.subscribe(this.handleChange,!1),this.exporterField.disable(o.length<2).space(),this.optionFields=o,this.optionFields[n].onChanged.subscribe(this.handleChange,!1),this.fields=new A.G([this.exporterField,this.options])}set(t){this.exporterField.set(t.name),this.options.set(t.options)}serialize(){return{name:this.exporterField.serialize(),options:this.options.serialize()}}clone(){return new this.constructor(this.name,this.exporters,this.current)}}const P=[{value:.25,text:"0.25x (Quarter)"},{value:.5,text:"0.5x (Half)"},{value:1,text:"1.0x (Full)"},{value:2,text:"2.0x (Double)"}],I=[{value:"srgb",text:"sRGB"},{value:"display-p3",text:"DCI-P3"}],F=[{value:"image/png",text:"png"},{value:"image/jpeg",text:"jpeg"},{value:"image/webp",text:"webp"}],W=[{value:30,text:"30 FPS"},{value:60,text:"60 FPS"}];class B extends v.v{constructor(t){super("project",function(t){const e={version:new x.C("version",1),shared:new v.v("General",{background:new T("background",null),range:new Z("range",[0,1/0]),size:new S("resolution",new N.F(1920,1080)),audioOffset:new R("audio offset",0)}),preview:new v.v("Preview",{fps:new R("frame rate",30).setPresets(W),resolutionScale:new z("scale",P,1)}),rendering:new v.v("Rendering",{fps:new R("frame rate",60).setPresets(W),resolutionScale:new z("scale",P,1),colorSpace:new z("color space",I),exporter:new E("exporter",t.plugins.flatMap((e=>(null==e.exporters?void 0:e.exporters(t))??[])))})};return e.shared.audioOffset.disable(!t.audio),e}(t))}getFullPreviewSettings(){return{...this.shared.get(),...this.preview.get()}}getFullRenderingSettings(){return{...this.shared.get(),...this.rendering.get()}}}var G=n(2672),O=n(9989),j=n(15914);class U extends x.C{constructor(){super(...arguments),this.type=Boolean}parse(t){return!!t}}class q{constructor(t){this.logger=t,this.name="image sequence",this.frameLookup=new Map,this.frameCounter=0,this.projectName="unknown",this.quality=1,this.fileType="image/png",this.groupByScene=!1}meta(){const t=new v.v(this.name,{fileType:new z("file type",F),quality:new R("quality",100).setRange(0,100),groupByScene:new U("group by scene",!1)});return t.fileType.onChanged.subscribe((e=>{t.quality.disable("image/png"===e)})),t}async configure(t){const e=t.exporter.options;this.projectName=t.name,this.quality=(0,L.uZ)(0,1,e.quality/100),this.fileType=e.fileType,this.groupByScene=e.groupByScene}async start(){this.frameLookup.clear()}async handleFrame(t,e,n,o,s){this.frameLookup.has(e)&&this.logger.warn(`Frame no. ${e} is already being exported.`)}async stop(){for(;this.frameCounter>0;)await new Promise((t=>setTimeout(t,1e3)))}}const V={name:"mc-default-plugin",exporters:t=>[new q(t.logger)]};let H=null,$=null,J=null,Y=null,K=null,Q=null;function tt(t,e){var n;if(t!==K)return H||(window.mc={...g.Z,makeScene2D:t=>($.config=t,$.onReplaced.current=$,$)},$=(0,j.r)((function*(){yield})),$.onReplaced=new A.G($),H={name:"fiddle",logger:new X,plugins:[V],scenes:[$]},H.meta=new B(H),H.meta.shared.size.set([960,240]),J=new G.J(H,{size:H.meta.shared.size.get()}),Y=new O.H,Y.configure({size:H.meta.shared.size.get()}),J.onRender.subscribe((async()=>{await Y.render(J.playback.currentScene,J.playback.previousScene)})),J.onRecalculated.subscribe((()=>{var t;Y.finalBuffer.parentElement!==Q&&(null==(t=Q)||t.append(Y.finalBuffer),K(J))}))),null==(n=Q)||n.removeChild(Y.finalBuffer),null==K||K(null),K=t,Q=e,J.activate(),J.requestReset(),J}const et="root_icgl",nt="progress_HsLC",ot="controls_R4ai",st="section_UscS",rt="icon_brRG",it="error_N64d",pt="editor_xQGp",at="source_Dq6N",ct="preview_C9cZ",lt="button_ESGX",ut="picker_Whdf";var mt=n(53487);const dt=/ *\/\/ ?(\S+) ?(.*)/,ht=["highlight-next-line","highlight-start","highlight-end"];var yt=n(6277);function ft(t){var e;let{options:n,value:s,className:r,onChange:i}=t;const p=(0,o.useRef)(),a=(0,o.useRef)(),[c,l]=(0,o.useState)(!1);return(0,o.useEffect)((()=>{const t=t=>{p.current&&!p.current.contains(t.target)&&l(!1)};return document.addEventListener("mousedown",t),document.addEventListener("touchstart",t),()=>{document.removeEventListener("mousedown",t),document.removeEventListener("touchstart",t)}}),[p]),o.createElement("div",{ref:p,className:(0,yt.Z)("dropdown dropdown--right",c&&"dropdown--show",r)},o.createElement("a",{ref:a,className:"navbar__link",href:"#",onClick:t=>{t.preventDefault(),l(!c)}},(null==(e=n.find((t=>t.value===s)))?void 0:e.name)??s),o.createElement("ul",{className:"dropdown__menu"},n.map(((t,e)=>o.createElement("li",{key:t.value},o.createElement("a",{href:"#",className:(0,yt.Z)("dropdown__link",s===t.value&&"dropdown__link--active"),onClick:e=>{e.preventDefault(),i(t.value),l(!1),a.current.focus()},onKeyDown:t=>{e!==n.length-1||"Tab"!==t.key||t.shiftKey||(t.preventDefault(),l(!1),a.current.focus())}},t.name))))))}function kt(t){let{children:e,className:n}=t;const[l,g]=(0,o.useState)(null),D=(0,o.useRef)(null),_=(0,o.useRef)(),X=(0,o.useRef)(),[x,v]=(0,o.useState)(null),C=h(null==l?void 0:l.onDurationChanged),T=h(null==l?void 0:l.onFrameChanged),b=h(null==l?void 0:l.onStateChanged),[L,Z]=(0,o.useState)(null),[N,S]=(0,o.useState)(null),R=function(t,e){void 0===e&&(e=!0),tt(g,X.current);const n=(0,mt.v)(t.sliceString(0));var o;v(n),n||(S(t),!e||null!=N&&N.eq(t)||X.current.animate((void 0===o&&(o=4),[{boxShadow:"0 0 0px 0 #ccc inset",easing:"cubic-bezier(0.33, 1, 0.68, 1)"},{boxShadow:`0 0 0px ${o}px #ccc inset`,easing:"cubic-bezier(0.32, 0, 0.67, 0)"},{boxShadow:"0 0 0px 0 #ccc inset"}]),{duration:300}))},[z,A]=(0,o.useState)(0),E=(0,o.useMemo)((()=>function(t){let e={name:"Default",lines:[]};const n=[e];for(const o of t.split("\n")){const t=dt.exec(o);if(!t){e.lines.push(o);continue}const[,s,r]=t;ht.includes(s)||("snippet"===s?e.lines.length>0?(e={name:r,lines:[]},n.push(e)):e.name=r:e.lines.push(o))}return n}(e).map((t=>({name:t.name,state:i.yy.create({doc:i.xv.of(t.lines),extensions:[s.Xy,r.$f.of([c.oc,{key:"Mod-s",preventDefault:!0,run:t=>(R(t.state.doc),!0)}]),r.tk.updateListener.of((t=>{Z(t.state.doc),v(null)})),p.Lz.data.of({autocomplete:t=>{if("String"===(0,a.qz)(t.state).resolveInner(t.pos,-1).name)return;const e=t.matchBefore(/\w*/);return e.from!=e.to||t.explicit?{from:e.from,options:M}:null}}),(0,p.eJ)({jsx:!0,typescript:!0}),(0,a.nF)(u),m]})})))),[e]);(0,o.useEffect)((()=>{D.current=new r.tk({parent:_.current,state:E[z].state});var t,e;return(t=g,e=X.current,K?null:tt(t,e))&&R(E[z].state.doc,!1),()=>{!function(t){K===t&&H&&(J.deactivate(),K=null,Q=null,Y.finalBuffer.remove())}(g),D.current.destroy()}}),[]);const P=N&&L&&!L.eq(N),I=L&&!L.eq(E[z].state.doc)||P;return o.createElement("div",{className:(0,yt.Z)(et,n)},o.createElement("div",{className:ct,ref:X},!l&&o.createElement("div",null,"Press play to preview the animation")),C>0&&o.createElement("div",{className:nt,style:{width:l?T/C*100+"%":0}}),o.createElement("div",{className:ot},o.createElement("div",{className:st},P&&o.createElement("button",{onClick:()=>R(D.current.state.doc),className:lt},o.createElement("kbd",null,"CTRL"),o.createElement("kbd",null,"S"),o.createElement("small",null,"Update preview"))),o.createElement("div",{className:st},o.createElement("button",{className:rt,onClick:()=>null==l?void 0:l.requestPreviousFrame()},o.createElement(y,null)),o.createElement("button",{className:rt,onClick:()=>{if(l)N||R(D.current.state.doc),l.togglePlayback();else{const t=tt(g,X.current);R(D.current.state.doc),t.togglePlayback(!0)}}},!l||((null==b?void 0:b.paused)??1)?o.createElement(k,null):o.createElement(w,null)),o.createElement("button",{className:rt,onClick:()=>null==l?void 0:l.requestNextFrame()},o.createElement(f,null))),o.createElement("div",{className:st},0===E.length&&I&&o.createElement("button",{className:lt,onClick:()=>{D.current.setState(E[z].state),R(E[z].state.doc),Z(E[z].state.doc)}},o.createElement("small",null,"Reset example")),E.length>1&&o.createElement(ft,{className:ut,value:I?-1:z,onChange:t=>{A(t),D.current.setState(E[t].state),R(E[t].state.doc)},options:E.map(((t,e)=>({value:e,name:t.name}))).concat(I?{value:-1,name:"Custom"}:[])}))),x&&o.createElement("pre",{className:it},x.message),o.createElement("div",{className:pt,ref:_},o.createElement(d.Z,{className:at,language:"tsx"},E[0].state.doc.toString()+"\n")))}},16491:(t,e,n)=>{"use strict";n.d(e,{Z:()=>Ue});var o={};n.r(o),n.d(o,{Circle:()=>f,CubicBezier:()=>P,Grid:()=>Y,Icon:()=>$,Img:()=>q,Knot:()=>et,Latex:()=>ut,Layout:()=>mt.A,Line:()=>kt,Node:()=>K.N,Polygon:()=>gt,QuadBezier:()=>Xt,Rect:()=>F.U,Shape:()=>d.b,Spline:()=>Lt,Txt:()=>St,Video:()=>Et,View2D:()=>Zt.h});var s={};n.r(s),n.d(s,{all:()=>Pt.$,any:()=>Bt,chain:()=>Ot,delay:()=>Ht,every:()=>$t,loop:()=>Jt,noop:()=>Yt,run:()=>Kt.K,sequence:()=>Qt,waitFor:()=>Vt,waitUntil:()=>qt});var r={};n.r(r),n.d(r,{DetailedError:()=>re.t,Semaphore:()=>ce.L,beginSlide:()=>te,capitalize:()=>ee.k,createRef:()=>me,debug:()=>oe,deprecate:()=>se,endPlayback:()=>Ut.Mh,endScene:()=>B.ug,endThread:()=>Rt.kw,errorToLog:()=>ie.d,finishScene:()=>B.vl,getContext:()=>pe.f,isProxyEnabled:()=>O,makeRef:()=>de,makeRefs:()=>he,range:()=>ae.w,startPlayback:()=>Ut.wA,startScene:()=>B.DO,startThread:()=>Rt.h$,useContext:()=>fe,useContextAfter:()=>ke,useDuration:()=>jt,useLogger:()=>B.wL,usePlayback:()=>Ut.te,useRandom:()=>ue,useScene:()=>B.$r,useThread:()=>Rt.nn,useTime:()=>ye,viaProxy:()=>G});var i={};n.r(i),n.d(i,{CompoundSignalContext:()=>we.N,ComputedContext:()=>ge.h,DEFAULT:()=>xe.T,DependencyContext:()=>W.k,SignalContext:()=>Xe.V,createComputed:()=>Me.D,createComputedAsync:()=>_e,createSignal:()=>De.g,isReactive:()=>dt.P});var p={};n.r(p),n.d(p,{BBox:()=>X.b,Center:()=>be.M5,Color:()=>I.I,Direction:()=>be.Nm,EPSILON:()=>Ce.I,Matrix2D:()=>Te,Origin:()=>be.aP,Spacing:()=>Le.K,Vector2:()=>k.F,flipOrigin:()=>be.lk,isType:()=>Ce.P,originToOffset:()=>be.WS,transformAngle:()=>ve.$,transformScalar:()=>ve.X});var a={};n.r(a),n.d(a,{BeatSpring:()=>ze,BounceSpring:()=>Ee,JumpSpring:()=>Ie,PlopSpring:()=>Ae,SmoothSpring:()=>We,StrikeSpring:()=>Fe,SwingSpring:()=>Pe,arcLerp:()=>M.Vz,clamp:()=>M.uZ,clampRemap:()=>M.vl,cos:()=>Ze.mC,createEaseInBack:()=>Ze.j$,createEaseInBounce:()=>Ze.jv,createEaseInElastic:()=>Ze.qS,createEaseInOutBack:()=>Ze.Bl,createEaseInOutBounce:()=>Ze.Ij,createEaseInOutElastic:()=>Ze.du,createEaseOutBack:()=>Ze.lj,createEaseOutBounce:()=>Ze.zk,createEaseOutElastic:()=>Ze.Kx,deepLerp:()=>M.o0,easeInBack:()=>Ze.Yw,easeInBounce:()=>Ze.SJ,easeInCirc:()=>Ze.Mg,easeInCubic:()=>Ze.Q9,easeInElastic:()=>Ze.eE,easeInExpo:()=>Ze.e_,easeInOutBack:()=>Ze.BH,easeInOutBounce:()=>Ze.en,easeInOutCirc:()=>Ze.Ge,easeInOutCubic:()=>Ze.qb,easeInOutElastic:()=>Ze.cv,easeInOutExpo:()=>Ze.hN,easeInOutQuad:()=>Ze.to,easeInOutQuart:()=>Ze.J7,easeInOutQuint:()=>Ze.rz,easeInOutSine:()=>Ze.Fs,easeInQuad:()=>Ze.FG,easeInQuart:()=>Ze.g4,easeInQuint:()=>Ze.n5,easeInSine:()=>Ze.N1,easeOutBack:()=>Ze.UE,easeOutBounce:()=>Ze.C6,easeOutCirc:()=>Ze.ei,easeOutCubic:()=>Ze.w2,easeOutElastic:()=>Ze.sK,easeOutExpo:()=>Ze.ad,easeOutQuad:()=>Ze.hl,easeOutQuart:()=>Ze.Y3,easeOutQuint:()=>Ze.pl,easeOutSine:()=>Ze.vh,linear:()=>Ze.GE,makeSpring:()=>Re,map:()=>M.UI,remap:()=>M.a2,sin:()=>Ze.O$,spring:()=>Se,textLerp:()=>M.JC,tween:()=>Ne.i});var c={};n.r(c),n.d(c,{Thread:()=>Oe.j,cancel:()=>Be,getTaskName:()=>Ge.z,isPromisable:()=>Gt.x,isPromise:()=>je.t,isThreadGenerator:()=>Gt.R,join:()=>It.v,setTaskName:()=>Ge.i,threads:()=>je.C});var l=n(15914);const u=Symbol.for("@motion-canvas/2d/fragment");function m(t,e){const{ref:n,children:o,...s}=e,r=Array.isArray(o)?o.flat():o;if(t===u)return r;if(null!=(i=t.prototype)&&i.isClass){const e=new t({...s,children:r});return null==n||n(e),e}return t({...s,ref:n,children:r});var i}var d=n(13730),h=n(93091),y=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class f extends d.b{constructor(t){super(t)}getPath(){return this.createPath()}getRipplePath(){return this.createPath(this.rippleSize())}createPath(t){void 0===t&&(t=0);const e=new Path2D,n=this.startAngle()/180*Math.PI,o=this.endAngle()/180*Math.PI,s=this.size().scale(.5),r=this.closed();return r&&e.moveTo(0,0),e.ellipse(0,0,s.x+t,s.y+t,0,n,o),r&&e.closePath(),e}}y([(0,h.nn)(0),(0,h.td)()],f.prototype,"startAngle",void 0),y([(0,h.nn)(360),(0,h.td)()],f.prototype,"endAngle",void 0),y([(0,h.nn)(!1),(0,h.td)()],f.prototype,"closed",void 0);var k=n(29797),w=n(11258);class g{}var M=n(13170);class D{constructor(t,e){void 0===e&&(e=20),this.curve=t,this.sampledDistances=[],this.resample(e)}resample(t){this.sampledDistances=[0];let e=0,n=this.curve.eval(0).position;for(let o=1;o<t;o++){const s=o/(t-1),r=this.curve.eval(s);e+=n.sub(r.position).magnitude,this.sampledDistances.push(e),n=r.position}this.sampledDistances[this.sampledDistances.length-1]=this.curve.arcLength}pointAtDistance(t){return this.curve.eval(this.distanceToT(t))}distanceToT(t){const e=this.sampledDistances.length;t=(0,M.uZ)(0,this.curve.arcLength,t);for(let n=0;n<e;n++){const o=this.sampledDistances[n],s=this.sampledDistances[n+1];if(t>=o&&t<=s)return(0,M.a2)(o,s,n/(e-1),(n+1)/(e-1),t)}return 1}}class _ extends g{get arcLength(){return this.length}constructor(t,e){super(),this.curve=t,this.length=e,this.pointSampler=new D(this)}getBBox(){return this.curve.getBounds()}eval(t){const e=this.tangent(t);return{position:this.curve.eval(t),tangent:e,normal:e.perpendicular}}getPoint(t){const e=this.pointSampler.pointAtDistance(this.arcLength*t);return{position:e.position,tangent:e.tangent,normal:e.tangent.perpendicular}}transformPoints(t){return this.points.map((e=>e.transformAsPoint(t)))}tangent(t){return this.curve.evalDerivative(t).normalized}draw(t,e,n,o){void 0===e&&(e=0),void 0===n&&(n=1),void 0===o&&(o=!0);let s=null,r=e,i=n,p=this.points;if(0!==e||1!==n){const t=this.length*e,o=this.length*n;r=this.pointSampler.distanceToT(t),i=this.pointSampler.distanceToT(o),i=(i-r)/(1-r);const[,a]=this.split(r);[s]=a.split(i),p=s.points}o&&(0,w.Ao)(t,p[0]),(s??this).doDraw(t);const a=this.tangent(r),c=this.tangent(i);return[{position:p[0],tangent:a,normal:a.perpendicular},{position:p.at(-1),tangent:c,normal:c.perpendicular}]}}var X=n(23357);class x{static constant(t){return new x(t)}static linear(t,e){return new x(t,e)}static quadratic(t,e,n){return new x(t,e,n)}static cubic(t,e,n,o){return new x(t,e,n,o)}get degree(){return 0!==this.c3?3:0!==this.c2?2:0!==this.c1?1:0}constructor(t,e,n,o){this.c0=t,this.c1=e??0,this.c2=n??0,this.c3=o??0}differentiate(t){switch(void 0===t&&(t=1),t){case 0:return this;case 1:return new x(this.c1,2*this.c2,3*this.c3,0);case 2:return new x(2*this.c2,6*this.c3,0,0);case 3:return new x(6*this.c3,0,0,0);default:throw new Error("Unsupported derivative")}}eval(t,e){return void 0===e&&(e=0),0!==e?this.differentiate(e).eval(t):this.c3*(t*t*t)+this.c2*(t*t)+this.c1*t+this.c0}split(t){const e=1-t;return[new x(this.c0,this.c1*t,this.c2*t*t,this.c3*t*t*t),new x(this.eval(0),e*this.differentiate(1).eval(t),e*e/2*this.differentiate(2).eval(t),e*e*e/6*this.differentiate(3).eval(t))]}roots(){switch(this.degree){case 3:return this.solveCubicRoots();case 2:return this.solveQuadraticRoots();case 1:return this.solveLinearRoot();case 0:return[];default:throw new Error(`Unsupported polynomial degree: ${this.degree}`)}}localExtrema(){return this.differentiate().roots()}localExtrema01(){const t=this.localExtrema(),e=[];for(let n=0;n<t.length;n++){const o=t[n];o>=0&&o<=1&&e.push(t[n])}return e}outputRange01(){let t=[this.eval(0),this.eval(1)];return this.localExtrema01().forEach((e=>{return n=this.eval(e),void(t=t[1]>t[0]?[Math.min(t[0],n),Math.max(t[1],n)]:[Math.min(t[1],n),Math.max(t[0],n)]);var n})),t}solveCubicRoots(){const t=this.c0,e=this.c1,n=this.c2,o=this.c3,s=t*t,r=t*n,i=e*e,p=(3*r-i)/(3*s),a=(2*i*e-9*r*e+27*s*o)/(27*s*t),c=this.solveDepressedCubicRoots(p,a),l=n=>n-e/(3*t);switch(c.length){case 1:return[l(c[0])];case 2:return[l(c[0]),l(c[1])];case 3:return[l(c[0]),l(c[1]),l(c[2])];default:return[]}}solveDepressedCubicRoots(t,e){if(this.almostZero(t))return[Math.cbrt(-e)];const n=2*Math.PI,o=4*t*t*t+27*e*e;if(o<1e-5){const o=2*Math.sqrt(-t/3),s=3*e/(2*t)*Math.sqrt(-3/t),r=t=>o*Math.cos(1/3*Math.acos((0,M.uZ)(-1,1,s))-n/3*t);return s>=.9999?[r(0),r(2)]:s<=-.9999?[r(1),r(2)]:[r(0),r(1),r(2)]}if(o>0&&t<0){const n=1/3*Math.acosh(-3*Math.abs(e)/(2*t)*Math.sqrt(-3/t));return[-2*Math.sign(e)*Math.sqrt(-t/3)*Math.cosh(n)]}if(t>0){const n=1/3*Math.asinh(3*e/(2*t)*Math.sqrt(3/t));return[-2*Math.sqrt(t/3)*Math.sinh(n)]}return[]}solveQuadraticRoots(){const t=this.c2,e=this.c1,n=e*e-4*t*this.c0;if(this.almostZero(n))return[-e/(2*t)];if(n>=0){const o=Math.sqrt(n),s=(-e-o)/(2*t),r=(-e+o)/(2*t);return[Math.min(s,r),Math.max(s,r)]}return[]}solveLinearRoot(){return[-this.c0/this.c1]}almostZero(t){return Math.abs(0-t)<=Number.EPSILON}}class v{constructor(t,e,n,o){this.c0=t,this.c1=e,this.c2=n,this.c3=o,t instanceof x?(this.x=t,this.y=e):void 0!==o?(this.x=new x(t.x,e.x,n.x,o.x),this.y=new x(t.y,e.y,n.y,o.y)):(this.x=new x(t.x,e.x,n.x),this.y=new x(t.y,e.y,n.y))}eval(t,e){return void 0===e&&(e=0),new k.F(this.x.differentiate(e).eval(t),this.y.differentiate(e).eval(t))}split(t){const[e,n]=this.x.split(t),[o,s]=this.y.split(t);return[new v(e,o),new v(n,s)]}differentiate(t){return void 0===t&&(t=1),new v(this.x.differentiate(t),this.y.differentiate(t))}evalDerivative(t){return this.differentiate().eval(t)}getBounds(){const t=this.x.outputRange01(),e=this.y.outputRange01();return X.b.fromPoints(new k.F(Math.min(...t),Math.max(...e)),new k.F(Math.max(...t),Math.min(...e)))}}var C=n(79116),T=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class b extends _{get points(){return[this.p0,this.p1,this.p2,this.p3]}constructor(t,e,n,o){super(new v(t,t.flipped.add(e).scale(3),t.scale(3).sub(e.scale(6)).add(n.scale(3)),t.flipped.add(e.scale(3)).sub(n.scale(3)).add(o)),b.getLength(t,e,n,o)),this.p0=t,this.p1=e,this.p2=n,this.p3=o}split(t){const e=new k.F(this.p0.x+(this.p1.x-this.p0.x)*t,this.p0.y+(this.p1.y-this.p0.y)*t),n=new k.F(this.p1.x+(this.p2.x-this.p1.x)*t,this.p1.y+(this.p2.y-this.p1.y)*t),o=new k.F(this.p2.x+(this.p3.x-this.p2.x)*t,this.p2.y+(this.p3.y-this.p2.y)*t),s=new k.F(e.x+(n.x-e.x)*t,e.y+(n.y-e.y)*t),r=new k.F(n.x+(o.x-n.x)*t,n.y+(o.y-n.y)*t),i=new k.F(s.x+(r.x-s.x)*t,s.y+(r.y-s.y)*t);return[new b(this.p0,e,s,i),new b(i,r,o,this.p3)]}doDraw(t){(0,w.JQ)(t,this.p1,this.p2,this.p3)}static getLength(t,e,n,o){return b.el.setAttribute("d",`M ${t.x} ${t.y} C ${e.x} ${e.y} ${n.x} ${n.y} ${o.x} ${o.y}`),b.el.getTotalLength()}}T([(0,C.V)((()=>document.createElementNS("http://www.w3.org/2000/svg","path")))],b,"el",void 0);var L=n(88104),Z=n(46350);function N(t,e){const n=(0,M.uZ)(0,t.arcLength,e);let o=0;for(const s of t.segments){const t=o;if(o+=s.arcLength,o>=n){const e=(n-t)/s.arcLength;return s.getPoint((0,M.uZ)(0,1,e))}}return{position:k.F.zero,tangent:k.F.up,normal:k.F.up}}var S=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class R extends d.b{desiredSize(){return this.childrenBBox().size}constructor(t){super(t)}percentageToDistance(t){const{arcLength:e}=this.profile(),n=this.startOffset();return n+(e-n-this.endOffset())*t}curveDrawingInfo(){const t=new Path2D,e=this.profile();let n=this.percentageToDistance(this.start()),o=this.percentageToDistance(this.end());n>o&&([n,o]=[o,n]);const s=o-n,r=Math.min(s/2,this.arrowSize());this.startArrow()&&(n+=r/2),this.endArrow()&&(o-=r/2);let i=0,p=null,a=null,c=null,l=null;for(const u of e.segments){const e=i;if(i+=u.arcLength,i<n)continue;const s=(n-e)/u.arcLength,r=(o-e)/u.arcLength,m=(0,M.uZ)(0,1,s),d=(0,M.uZ)(0,1,r),[h,y]=u.draw(t,m,d,null===p);if(null===p&&(p=h.position,a=h.normal.flipped.perpendicular),c=y.position,l=y.normal.flipped.perpendicular,i>o)break}return 1===this.end()&&this.closed()&&t.closePath(),{startPoint:p??k.F.zero,startTangent:a??k.F.right,endPoint:c??k.F.zero,endTangent:l??k.F.right,arrowSize:r,path:t,startOffset:n}}getPointAtDistance(t){return N(this.profile(),t+this.startOffset())}getPointAtPercentage(t){return N(this.profile(),this.percentageToDistance(t))}applyStyle(t){super.applyStyle(t);const{arcLength:e}=this.profile();t.lineDashOffset-=e/2}getComputedLayout(){return this.offsetComputedLayout(super.getComputedLayout())}offsetComputedLayout(t){return t.position=t.position.sub(this.childrenBBox().center),t}getPath(){return this.curveDrawingInfo().path}getCacheBBox(){const t=this.childrenBBox(),e=this.arrowSize(),n=this.lineWidth(),o=this.lineWidthCoefficient();return t.expand(Math.max(0,e,n*o))}lineWidthCoefficient(){return"square"===this.lineCap()?.70715:.5}drawShape(t){super.drawShape(t);const{startPoint:e,startTangent:n,endPoint:o,endTangent:s,arrowSize:r}=this.curveDrawingInfo();r<.001||(t.save(),t.beginPath(),this.endArrow()&&this.drawArrow(t,o,s.flipped,r),this.startArrow()&&this.drawArrow(t,e,n,r),t.fillStyle=(0,w.ho)(this.stroke(),t),t.closePath(),t.fill(),t.restore())}drawArrow(t,e,n,o){const s=n.perpendicular,r=e.add(n.scale(-o/2));(0,w.Ao)(t,r),(0,w.kZ)(t,r.add(n.add(s).scale(o))),(0,w.kZ)(t,r.add(n.sub(s).scale(o))),(0,w.kZ)(t,r),t.closePath()}}S([(0,h.nn)(!1),(0,h.td)()],R.prototype,"closed",void 0),S([(0,h.nn)(0),(0,h.td)()],R.prototype,"start",void 0),S([(0,h.nn)(0),(0,h.td)()],R.prototype,"startOffset",void 0),S([(0,h.nn)(!1),(0,h.td)()],R.prototype,"startArrow",void 0),S([(0,h.nn)(1),(0,h.td)()],R.prototype,"end",void 0),S([(0,h.nn)(0),(0,h.td)()],R.prototype,"endOffset",void 0),S([(0,h.nn)(!1),(0,h.td)()],R.prototype,"endArrow",void 0),S([(0,h.nn)(24),(0,h.td)()],R.prototype,"arrowSize",void 0),S([(0,Z.F)()],R.prototype,"curveDrawingInfo",null);var z=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class A extends R{profile(){const t=this.segment();return{segments:[t],arcLength:t.arcLength,minSin:0}}childrenBBox(){return X.b.fromPoints(...this.segment().points)}desiredSize(){return this.segment().getBBox().size}offsetComputedLayout(t){return t.position=t.position.sub(this.segment().getBBox().center),t}drawOverlay(t,e){const n=this.computedSize(),o=this.childrenBBox().transformCorners(e),s=n.mul(this.offset()).scale(.5).transformAsPoint(e),r=this.overlayInfo(e);t.lineWidth=1,t.strokeStyle="white",t.fillStyle="white",t.stroke(r.curve),t.fillStyle="white",t.globalAlpha=.5,t.beginPath(),t.stroke(r.handleLines),t.globalAlpha=1,t.lineWidth=2;for(const i of[r.startPoint,r.endPoint])(0,w.Ao)(t,i),t.beginPath(),(0,w.Nb)(t,i,4),t.closePath(),t.stroke(),t.fill();t.fillStyle="black";for(const i of r.controlPoints)(0,w.Ao)(t,i),t.beginPath(),(0,w.Nb)(t,i,4),t.closePath(),t.fill(),t.stroke();t.lineWidth=1;t.beginPath(),(0,w.kZ)(t,s.addY(-8)),(0,w.kZ)(t,s.addY(8)),(0,w.kZ)(t,s),(0,w.kZ)(t,s.addX(-8)),t.arc(s.x,s.y,8,0,2*Math.PI),t.stroke(),t.beginPath(),(0,w.pS)(t,o),t.closePath(),t.stroke()}}z([(0,Z.F)()],A.prototype,"childrenBBox",null);var E=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class P extends A{constructor(t){super(t)}segment(){return new b(this.p0(),this.p1(),this.p2(),this.p3())}overlayInfo(t){const[e,n,o,s]=this.segment().transformPoints(t),r=new Path2D;(0,w.Ao)(r,e),(0,w.JQ)(r,n,o,s);const i=new Path2D;return(0,w.Ao)(i,e),(0,w.kZ)(i,n),(0,w.Ao)(i,o),(0,w.kZ)(i,s),{curve:r,startPoint:e,endPoint:s,controlPoints:[n,o],handleLines:i}}}E([(0,L.y)("p0")],P.prototype,"p0",void 0),E([(0,L.y)("p1")],P.prototype,"p1",void 0),E([(0,L.y)("p2")],P.prototype,"p2",void 0),E([(0,L.y)("p3")],P.prototype,"p3",void 0),E([(0,Z.F)()],P.prototype,"segment",null);var I=n(30204),F=n(15498),W=n(76062),B=n(3163);function G(t){if(!O())return t;if(t.startsWith("/cors-proxy/"))return t;const e=new URL(window.location.toString());try{const n=new URL(t,e);if(!n.protocol.startsWith("http"))return t;if(e.host===n.host)return t;if(!function(t){const e=function(){if("true"!==(void 0).VITEST&&j)return[...j];const t=(O(),[]);return j=t,[...j]}();if(0===e.length)return!0;for(const n of e)if(n.toLowerCase().trim()===t)return!0;return!1}(n.host))return t}catch(n){return t}return`/cors-proxy/${encodeURIComponent(t)}`}function O(){return!1}let j;var U=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class q extends F.U{constructor(t){super(t)}desiredSize(){const t=super.desiredSize();if(null===t.x&&null===t.y){const t=this.image();return{x:t.naturalWidth,y:t.naturalHeight}}return t}image(){const t=G(this.src());let e=q.pool[t];return e||(e=document.createElement("img"),e.crossOrigin="anonymous",e.src=t,q.pool[t]=e),e.complete||W.k.collectPromise(new Promise(((t,n)=>{e.addEventListener("load",t),e.addEventListener("error",n)}))),e}imageCanvas(){const t=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});if(!t)throw new Error("Could not create an image canvas");return t}filledImageCanvas(){const t=this.imageCanvas(),e=this.image();return t.canvas.width=e.naturalWidth,t.canvas.height=e.naturalHeight,t.imageSmoothingEnabled=this.smoothing(),t.drawImage(e,0,0),t}draw(t){this.drawShape(t),this.clip()&&t.clip(this.getPath());const e=this.alpha();if(e>0){const n=X.b.fromSizeCentered(this.computedSize());t.save(),e<1&&(t.globalAlpha*=e),t.imageSmoothingEnabled=this.smoothing(),(0,w.AE)(t,this.image(),n),t.restore()}this.drawChildren(t)}applyFlex(){super.applyFlex();const t=this.image();this.element.style.aspectRatio=(this.ratio()??t.naturalWidth/t.naturalHeight).toString()}getColorAtPoint(t){const e=this.computedSize(),n=this.naturalSize(),o=new k.F(t).add(this.computedSize().scale(.5)).mul(n.div(e).safe);return this.getPixelColor(o)}naturalSize(){const t=this.image();return new k.F(t.naturalWidth,t.naturalHeight)}getPixelColor(t){const e=this.filledImageCanvas(),n=new k.F(t),o=e.getImageData(n.x,n.y,1,1).data;return new I.I({r:o[0],g:o[1],b:o[2],a:o[3]/255})}collectAsyncResources(){super.collectAsyncResources(),this.image()}}q.pool={},U([(0,h.td)()],q.prototype,"src",void 0),U([(0,h.nn)(1),(0,h.td)()],q.prototype,"alpha",void 0),U([(0,h.nn)(!0),(0,h.td)()],q.prototype,"smoothing",void 0),U([(0,Z.F)()],q.prototype,"image",null),U([(0,Z.F)()],q.prototype,"imageCanvas",null),U([(0,Z.F)()],q.prototype,"filledImageCanvas",null),U([(0,Z.F)()],q.prototype,"naturalSize",null);var V=n(43595),H=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class $ extends q{constructor(t){super(t)}svgUrl(){return`https://api.iconify.design/${this.icon().replace(":","/")}.svg?color=${encodeURIComponent(this.color().hex())}`}getSrc(){return this.svgUrl()}setSrc(){(0,B.wL)().warn("The Icon Component does not accept setting the `src`. If you need access to `src`, use '<Img/>` instead.")}}H([(0,h.td)()],$.prototype,"icon",void 0),H([(0,h.nn)("white"),(0,V.j)()],$.prototype,"color",void 0),H([(0,Z.F)()],$.prototype,"svgUrl",null);var J=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class Y extends d.b{constructor(t){super(t)}drawShape(t){t.save(),this.applyStyle(t),this.drawRipple(t);const e=this.spacing(),n=this.computedSize().scale(.5),o=n.div(e).floored;for(let s=-o.x;s<=o.x;s++)t.beginPath(),t.moveTo(e.x*s,-n.height),t.lineTo(e.x*s,n.height),t.stroke();for(let s=-o.y;s<=o.y;s++)t.beginPath(),t.moveTo(-n.width,e.y*s),t.lineTo(n.width,e.y*s),t.stroke();t.restore()}}J([(0,h.nn)(80),(0,L.y)("spacing")],Y.prototype,"spacing",void 0);var K=n(20092),Q=n(37060),tt=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class et extends K.N{get startHandleAuto(){return this.auto.startHandle}get endHandleAuto(){return this.auto.endHandle}constructor(t){super(void 0===t.startHandle&&void 0===t.endHandle?{auto:1,...t}:t)}points(){const t=!this.startHandle.isInitial()||!this.endHandle.isInitial(),e=t?this.startHandle():k.F.zero,n=t?this.endHandle():k.F.zero;return{position:this.position(),startHandle:e.transformAsPoint(this.localToParent()),endHandle:n.transformAsPoint(this.localToParent()),auto:{start:this.startHandleAuto(),end:this.endHandleAuto()}}}getDefaultEndHandle(){return this.startHandle().flipped}getDefaultStartHandle(){return this.endHandle().flipped}}tt([(0,h.YS)(k.F),(0,h.td)()],et.prototype,"startHandle",void 0),tt([(0,h.YS)(k.F),(0,h.td)()],et.prototype,"endHandle",void 0),tt([(0,h.r_)(!1),(0,h.nn)((()=>({startHandle:0,endHandle:0}))),(0,h.E2)((t=>"object"!=typeof t||Array.isArray(t)?("number"==typeof t&&(t=[t,t]),{startHandle:t[0],endHandle:t[1]}):t)),(0,Q.I)({startHandle:"startHandleAuto",endHandle:"endHandleAuto"})],et.prototype,"auto",void 0),tt([(0,Z.F)()],et.prototype,"points",null);var nt=n(98911),ot=n(2322),st=n(64238),rt=n(81962),it=n(86226),pt=n(50099),at=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};const ct=(0,it.liteAdaptor)();(0,pt.Q)(ct);const lt=nt.mathjax.document("",{InputJax:new ot.TeX({packages:rt.b}),OutputJax:new st.SVG({fontCache:"local"})});class ut extends q{constructor(t){super(t),this.imageElement=document.createElement("img")}image(){const t=`${this.tex()}::${JSON.stringify(this.options())}`;if(ut.svgContentsPool[t])return this.imageElement.src=ut.svgContentsPool[t],this.imageElement.complete||W.k.collectPromise(new Promise(((t,e)=>{this.imageElement.addEventListener("load",t),this.imageElement.addEventListener("error",e)}))),this.imageElement;const e=this.tex(),n=ct.innerHTML(lt.convert(e,this.options()));if(n.includes("data-mjx-error")){const t=n.match(/data-mjx-error="(.*?)"/);t&&t.length>0&&(0,B.wL)().error(`Invalid MathJax: ${t[1]}`)}const o=`data:image/svg+xml;base64,${btoa(`<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n${n}`)}`;ut.svgContentsPool[t]=o;const s=document.createElement("img");return s.src=o,s.src=o,s.complete||W.k.collectPromise(new Promise(((t,e)=>{s.addEventListener("load",t),s.addEventListener("error",e)}))),s}}ut.svgContentsPool={},at([(0,h.nn)({}),(0,h.td)()],ut.prototype,"options",void 0),at([(0,h.td)()],ut.prototype,"tex",void 0);var mt=n(70989),dt=n(93214);class ht extends g{constructor(t,e){super(),this.from=t,this.to=e,this.vector=e.sub(t),this.length=this.vector.magnitude,this.normal=this.vector.perpendicular.normalized.safe}get arcLength(){return this.length}draw(t,e,n,o){void 0===e&&(e=0),void 0===n&&(n=1),void 0===o&&(o=!1);const s=this.from.add(this.vector.scale(e)),r=this.from.add(this.vector.scale(n));return o&&(0,w.Ao)(t,s),(0,w.kZ)(t,r),[{position:s,tangent:this.normal.flipped,normal:this.normal},{position:r,tangent:this.normal,normal:this.normal}]}getPoint(t){return{position:this.from.add(this.vector.scale(t)),tangent:this.normal.flipped,normal:this.normal}}}class yt extends g{constructor(t,e,n,o,s){super(),this.center=t,this.radius=e,this.from=n,this.to=o,this.counter=s,this.angle=Math.acos((0,M.uZ)(-1,1,n.dot(o))),this.length=Math.abs(this.angle*e)}get arcLength(){return this.length}draw(t,e,n){const o=this.counter?-1:1,s=this.from.radians+e*this.angle*o,r=this.to.radians-(1-n)*this.angle*o;Math.abs(this.angle)>1e-4&&t.arc(this.center.x,this.center.y,this.radius,s,r,this.counter);const i=k.F.fromRadians(s),p=k.F.fromRadians(r);return[{position:this.center.add(i.scale(this.radius)),tangent:this.counter?i:i.flipped,normal:this.counter?i:i.flipped},{position:this.center.add(p.scale(this.radius)),tangent:this.counter?p.flipped:p,normal:this.counter?p.flipped:p}]}getPoint(t){const e=this.counter?-1:1,n=this.from.radians+t*this.angle*e,o=k.F.fromRadians(n);return{position:this.center.add(o.scale(this.radius)),tangent:this.counter?o:o.flipped,normal:this.counter?o:o.flipped}}}var ft=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class kt extends R{constructor(t){super(t),void 0===t.children&&void 0===t.points&&(0,B.wL)().warn({message:"No points specified for the line",remarks:'<p>The line won&#39;t be visible unless you specify at least two points:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span>\n  stroke=<span class="hljs-string">&quot;#fff&quot;</span>\n  lineWidth={<span class="hljs-number">8</span>}\n  points={[\n    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],\n  ]}\n/&gt;\n</code></pre>\n<p>Alternatively, you can define the points using the children:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>\n&lt;/<span class="hljs-title class_">Line</span>&gt;\n</code></pre>\n<p>If you did this intentionally, and want to disable this message, set the\n<code>points</code> property to <code>null</code>:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>} points={<span class="hljs-literal">null</span>} /&gt;\n</code></pre>\n',inspect:this.key})}childrenBBox(){const t=this.points(),e=t?t.map((t=>new k.F((0,dt.P)(t)?t():t))):this.children().filter((t=>!(t instanceof mt.A)||t.isLayoutRoot())).map((t=>t.position()));return X.b.fromPoints(...e)}parsedPoints(){const t=this.points();return t?t.map((t=>new k.F((0,dt.P)(t)?t():t))):this.children().map((t=>t.position()))}profile(){return function(t,e,n){const o={arcLength:0,segments:[],minSin:1};if(0===t.length)return o;if(n){const e=t[0].add(t[t.length-1]).scale(.5);t.unshift(e),t.push(e)}let s=t[0];for(let i=2;i<t.length;i++){const n=t[i-2],r=t[i-1],p=t[i],a=n.sub(r),c=p.sub(r),l=a.normalized.safe,u=c.normalized.safe,m=Math.acos((0,M.uZ)(-1,1,l.dot(u))),d=Math.tan(m/2),h=Math.sin(m/2),y=Math.min(e,d*a.magnitude*(2===i?1:.5),d*c.magnitude*(i===t.length-1?1:.5)),f=0===h?0:y/h,k=0===d?0:y/d,w=l.add(u).scale(.5).normalized.safe.scale(f).add(r),g=l.perpendicular.dot(u)<0,D=new ht(s,r.add(l.scale(k))),_=new yt(w,y,l.perpendicular.scale(g?1:-1),u.perpendicular.scale(g?-1:1),g);o.segments.push(D),o.segments.push(_),o.arcLength+=D.arcLength,o.arcLength+=_.arcLength,o.minSin=Math.min(o.minSin,Math.abs(h)),s=r.add(u.scale(k))}const r=new ht(s,t[t.length-1]);return o.segments.push(r),o.arcLength+=r.arcLength,o}(this.parsedPoints(),this.radius(),this.closed())}lineWidthCoefficient(){const t=this.radius(),e=this.lineJoin();let n=super.lineWidthCoefficient();if(0===t&&"miter"===e){const{minSin:t}=this.profile();t>0&&(n=Math.max(n,.5/t))}return n}drawOverlay(t,e){const n=this.childrenBBox().transformCorners(e),o=this.computedSize().mul(this.offset()).scale(.5).transformAsPoint(e);t.fillStyle="white",t.strokeStyle="black",t.lineWidth=1;const s=new Path2D,r=this.parsedPoints().map((t=>t.transformAsPoint(e)));if(r.length>0){(0,w.Ao)(s,r[0]);for(const e of r)(0,w.kZ)(s,e),t.beginPath(),(0,w.Nb)(t,e,4),t.closePath(),t.fill(),t.stroke()}t.strokeStyle="white",t.stroke(s);t.beginPath(),(0,w.kZ)(t,o.addY(-8)),(0,w.kZ)(t,o.addY(8)),(0,w.kZ)(t,o),(0,w.kZ)(t,o.addX(-8)),t.arc(o.x,o.y,8,0,2*Math.PI),t.stroke(),t.beginPath(),(0,w.pS)(t,n),t.closePath(),t.stroke()}}ft([(0,h.nn)(0),(0,h.td)()],kt.prototype,"radius",void 0),ft([(0,h.nn)(null),(0,h.td)()],kt.prototype,"points",void 0),ft([(0,Z.F)()],kt.prototype,"childrenBBox",null),ft([(0,Z.F)()],kt.prototype,"parsedPoints",null),ft([(0,Z.F)()],kt.prototype,"profile",null);var wt=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class gt extends d.b{constructor(t){super(t)}getPath(){const t=new Path2D,e=this.sides(),n=X.b.fromSizeCentered(this.size());return(0,w.is)(t,n,e),t}getRipplePath(){const t=new Path2D,e=this.sides(),n=this.rippleSize(),o=X.b.fromSizeCentered(this.size()).expand(n);return(0,w.is)(t,o,e),t}}wt([(0,h.nn)(6),(0,h.td)()],gt.prototype,"sides",void 0);var Mt=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class Dt extends _{get points(){return[this.p0,this.p1,this.p2]}constructor(t,e,n){super(new v(t,t.flipped.add(e).scale(2),t.sub(e.scale(2)).add(n)),Dt.getLength(t,e,n)),this.p0=t,this.p1=e,this.p2=n}split(t){const e=new k.F(this.p0.x+(this.p1.x-this.p0.x)*t,this.p0.y+(this.p1.y-this.p0.y)*t),n=new k.F(this.p1.x+(this.p2.x-this.p1.x)*t,this.p1.y+(this.p2.y-this.p1.y)*t),o=new k.F(e.x+(n.x-e.x)*t,e.y+(n.y-e.y)*t);return[new Dt(this.p0,e,o),new Dt(o,n,this.p2)]}static getLength(t,e,n){return Dt.el.setAttribute("d",`M ${t.x} ${t.y} Q ${e.x} ${e.y} ${n.x} ${n.y}`),Dt.el.getTotalLength()}doDraw(t){(0,w.pt)(t,this.p1,this.p2)}}Mt([(0,C.V)((()=>document.createElementNS("http://www.w3.org/2000/svg","path")))],Dt,"el",void 0);var _t=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class Xt extends A{constructor(t){super(t)}segment(){return new Dt(this.p0(),this.p1(),this.p2())}overlayInfo(t){const[e,n,o]=this.segment().transformPoints(t),s=new Path2D;(0,w.Ao)(s,e),(0,w.pt)(s,n,o);const r=new Path2D;return(0,w.Ao)(r,e),(0,w.kZ)(r,n),(0,w.kZ)(r,o),{curve:s,startPoint:e,endPoint:o,controlPoints:[n],handleLines:r}}}function xt(t){return t instanceof b}function vt(t,e,n,o){if(0===t.auto.start&&0===t.auto.end)return;const s=t.position.sub(e.position).magnitude,r=o*s/(s+n.position.sub(t.position).magnitude),i=o-r,p=new k.F(t.position.x-r*(n.position.x-e.position.x),t.position.y-r*(n.position.y-e.position.y)),a=new k.F(t.position.x+i*(n.position.x-e.position.x),t.position.y+i*(n.position.y-e.position.y));t.startHandle=t.startHandle.lerp(p,t.auto.start),t.endHandle=t.endHandle.lerp(a,t.auto.end)}function Ct(t,e,n,o,s){const r=void 0!==s?new b(e,n,o,s):new Dt(e,n,o);t.segments.push(r),t.arcLength+=r.arcLength}function Tt(t,e,n){const o={segments:[],arcLength:0,minSin:1},s=t.length;for(let c=0;c<s;c++){const e=(c-1+s)%s,o=(c+1)%s;vt(t[c],t[e],t[o],n)}const r=t[0],i=t[1];e||1!==r.auto.start||1!==r.auto.end?Ct(o,r.position,r.endHandle,i.startHandle,i.position):Ct(o,r.position,i.startHandle,i.position);for(let c=1;c<s-2;c++){const e=t[c],n=t[c+1];Ct(o,e.position,e.endHandle,n.startHandle,n.position)}const p=t.at(-1),a=t.at(-2);return t.length>2&&(e||1!==p.auto.start||1!==p.auto.end?Ct(o,a.position,a.endHandle,p.startHandle,p.position):Ct(o,a.position,a.endHandle,p.position)),e&&Ct(o,p.position,p.endHandle,r.startHandle,r.position),function(t){for(let e=0;e<t.segments.length;e++){const n=t.segments[e],o=t.segments[(e+1)%t.segments.length];if(!xt(n)||!xt(o))continue;const s=n.p2.sub(n.p3).normalized.safe,r=o.p1.sub(o.p0).normalized.safe,i=s.dot(r);if(!(1-Math.abs(i)>1e-4))continue;const p=Math.acos((0,M.uZ)(-1,1,i)),a=Math.sin(p/2);t.minSin=Math.min(t.minSin,Math.abs(a))}}(o),o}_t([(0,L.y)("p0")],Xt.prototype,"p0",void 0),_t([(0,L.y)("p1")],Xt.prototype,"p1",void 0),_t([(0,L.y)("p2")],Xt.prototype,"p2",void 0),_t([(0,Z.F)()],Xt.prototype,"segment",null);var bt=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class Lt extends R{constructor(t){super(t),(void 0===t.children||t.children.length<2)&&(void 0===t.points||t.points.length<2)&&void 0===t.spawner&&(0,B.wL)().warn({message:"Insufficient number of knots specified for spline. A spline needs at least two knots.",remarks:'<p>The spline won&#39;t be visible unless you specify at least two knots:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Spline</span>\n  stroke=<span class="hljs-string">&quot;#fff&quot;</span>\n  lineWidth={<span class="hljs-number">8</span>}\n  points={[\n    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],\n  ]}\n/&gt;\n</code></pre>\n<p>For more control over the knot handles, you can alternatively provide the knots\nas children to the spline using the <code>Knot</code> component:</p>\n<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Spline</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Knot</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> <span class="hljs-attr">endHandle</span>=<span class="hljs-string">{[-50,</span> <span class="hljs-attr">0</span>]} /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Knot</span> /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Knot</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> <span class="hljs-attr">startHandle</span>=<span class="hljs-string">{[-100,</span> <span class="hljs-attr">50</span>]} /&gt;</span></span>\n&lt;/<span class="hljs-title class_">Spline</span>&gt;\n</code></pre>\n',inspect:this.key})}profile(){return Tt(this.knots(),this.closed(),this.smoothness())}knots(){const t=this.points();return t?t.map((t=>{const e=new k.F((0,dt.P)(t)?t():t);return{position:e,startHandle:e,endHandle:e,auto:{start:1,end:1}}})):this.children().filter(this.isKnot).map((t=>t.points()))}childrenBBox(){const t=this.profile().segments.flatMap((t=>t.points));return X.b.fromPoints(...t)}lineWidthCoefficient(){const t=this.lineJoin();let e=super.lineWidthCoefficient();if("miter"!==t)return e;const{minSin:n}=this.profile();return n>0&&(e=Math.max(e,.5/n)),e}desiredSize(){return this.getTightBBox().size}offsetComputedLayout(t){return t.position=t.position.sub(this.getTightBBox().center),t}getTightBBox(){const t=this.profile().segments.map((t=>t.getBBox()));return X.b.fromBBoxes(...t)}drawOverlay(t,e){const n=this.computedSize(),o=this.childrenBBox().transformCorners(e),s=n.mul(this.offset()).scale(.5).transformAsPoint(e),r=this.profile().segments;t.lineWidth=1,t.strokeStyle="white",t.fillStyle="white";const i=new Path2D;for(let p=0;p<r.length;p++){const t=r[p],[n,o,s,a]=t.transformPoints(e);(0,w.Ao)(i,n),t instanceof b?(0,w.JQ)(i,o,s,a):(0,w.pt)(i,o,s)}t.stroke(i);for(let p=0;p<r.length;p++){const n=r[p];t.fillStyle="white";const[o,s,i,a]=n.transformPoints(e),c=new Path2D;t.globalAlpha=.5,(0,w.Ao)(c,o),(0,w.kZ)(c,s),n instanceof b?((0,w.Ao)(c,i),(0,w.kZ)(c,a),t.beginPath(),t.stroke(c)):((0,w.kZ)(c,i),t.beginPath(),t.stroke(c)),t.globalAlpha=1,t.lineWidth=2,(0,w.Ao)(t,o),t.beginPath(),(0,w.Nb)(t,o,4),t.closePath(),t.stroke(),t.fill(),p===r.length-1&&void 0!==a&&((0,w.Ao)(t,a),t.beginPath(),(0,w.Nb)(t,a,4),t.closePath(),t.stroke(),t.fill()),t.fillStyle="black";for(const e of[s,i])e.magnitude>0&&((0,w.Ao)(t,e),t.beginPath(),(0,w.Nb)(t,e,4),t.closePath(),t.fill(),t.stroke())}t.lineWidth=1;t.beginPath(),(0,w.kZ)(t,s.addY(-8)),(0,w.kZ)(t,s.addY(8)),(0,w.kZ)(t,s),(0,w.kZ)(t,s.addX(-8)),t.arc(s.x,s.y,8,0,2*Math.PI),t.stroke(),t.beginPath(),(0,w.pS)(t,o),t.closePath(),t.stroke()}isKnot(t){return t instanceof et}}bt([(0,h.nn)(.4),(0,h.td)()],Lt.prototype,"smoothness",void 0),bt([(0,h.nn)(null),(0,h.td)()],Lt.prototype,"points",void 0),bt([(0,Z.F)()],Lt.prototype,"profile",null),bt([(0,Z.F)()],Lt.prototype,"knots",null),bt([(0,Z.F)()],Lt.prototype,"childrenBBox",null),bt([(0,Z.F)()],Lt.prototype,"getTightBBox",null);var Zt=n(70419),Nt=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class St extends d.b{constructor(t){let{children:e,...n}=t;super(n),e&&this.text(e)}draw(t){this.requestFontUpdate(),this.applyStyle(t),this.applyText(t),t.font=this.styles.font,"letterSpacing"in t&&(t.letterSpacing=`${this.letterSpacing()}px`);const e=this.element.getBoundingClientRect(),{width:n,height:o}=this.size(),s=document.createRange();let r="";const i=new X.b;for(const p of this.element.childNodes){if(!p.textContent)continue;s.selectNodeContents(p);const a=s.getBoundingClientRect(),c=n/-2+a.left-e.left,l=o/-2+a.top-e.top;i.y===l?(i.width+=a.width,r+=p.textContent):(this.drawText(t,r,i),i.x=c,i.y=l,i.width=a.width,i.height=a.height,r=p.textContent)}this.drawText(t,r,i)}drawText(t,e,n){const o=n.y+n.height/2;t.save(),t.textBaseline="middle",this.lineWidth()<=0?t.fillText(e,n.x,o):this.strokeFirst()?(t.strokeText(e,n.x,o),t.fillText(e,n.x,o)):(t.fillText(e,n.x,o),t.strokeText(e,n.x,o)),t.restore()}formattedText(){return St.formatter.innerText=this.text(),St.formatter.innerText}updateLayout(){this.applyFont(),this.applyFlex(),this.justifyContent.isInitial()&&(this.element.style.justifyContent=this.styles.getPropertyValue("text-align"));if("nowrap"!==this.styles.whiteSpace&&"pre"!==this.styles.whiteSpace)if(this.element.innerText="",St.segmenter)for(const t of St.segmenter.segment(this.formattedText()))this.element.appendChild(document.createTextNode(t.segment));else for(const t of this.formattedText().split(""))this.element.appendChild(document.createTextNode(t));else if("pre"===this.styles.whiteSpace){this.element.innerText="";for(const t of this.text().split("\n"))this.element.appendChild(document.createTextNode(t+"\n"))}else this.element.innerText=this.formattedText()}}Nt([(0,h.nn)(""),(0,h.JI)(M.JC),(0,h.td)()],St.prototype,"text",void 0),Nt([(0,Z.F)()],St.prototype,"formattedText",null),Nt([(0,C.V)((()=>{const t=document.createElement("div");return Zt.h.shadowRoot.append(t),t}))],St,"formatter",void 0),Nt([(0,C.V)((()=>{try{return new Intl.Segmenter(void 0,{granularity:"grapheme"})}catch(t){return null}}))],St,"segmenter",void 0);var Rt=n(56632),zt=n(88733),At=function(t,e,n,o){var s,r=arguments.length,i=r<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,o);else for(var p=t.length-1;p>=0;p--)(s=t[p])&&(i=(r<3?s(i):r>3?s(e,n,i):s(e,n))||i);return r>3&&i&&Object.defineProperty(e,n,i),i};class Et extends F.U{constructor(t){let{play:e,...n}=t;super(n),this.lastTime=-1,e&&this.play()}isPlaying(){return this.playing()}getCurrentTime(){return this.clampTime(this.time())}getDuration(){return this.video().duration}desiredSize(){const t=super.desiredSize();if(null===t.x&&null===t.y){const t=this.video();return{x:t.videoWidth,y:t.videoHeight}}return t}completion(){return this.clampTime(this.time())/this.video().duration}video(){const t=this.src(),e=`${this.key}/${t}`;let n=Et.pool[e];return n||(n=document.createElement("video"),n.src=t,Et.pool[e]=n),n.readyState<2&&W.k.collectPromise(new Promise((t=>{const e=()=>{t(),n.removeEventListener("canplay",e)};n.addEventListener("canplay",e)}))),n}seekedVideo(){const t=this.video(),e=this.clampTime(this.time());return t.paused||t.pause(),this.lastTime===e||this.setCurrentTime(e),t}fastSeekedVideo(){const t=this.video(),e=this.clampTime(this.time());if(this.lastTime===e)return t;const n=this.playing()&&e<t.duration;return n?t.paused&&W.k.collectPromise(t.play()):t.paused||t.pause(),Math.abs(t.currentTime-e)>.2?this.setCurrentTime(e):n||(t.currentTime=e),t}draw(t){this.drawShape(t),this.clip()&&t.clip(this.getPath());const e=this.alpha();if(e>0){const n=this.view().playbackState(),o=n===zt.q.Playing||n===zt.q.Presenting?this.fastSeekedVideo():this.seekedVideo(),s=X.b.fromSizeCentered(this.computedSize());t.save(),e<1&&(t.globalAlpha*=e),t.imageSmoothingEnabled=this.smoothing(),(0,w.AE)(t,o,s),t.restore()}this.drawChildren(t)}applyFlex(){super.applyFlex();const t=this.video();this.element.style.aspectRatio=(this.ratio()??t.videoWidth/t.videoHeight).toString()}setCurrentTime(t){const e=this.video();e.readyState<2||(e.currentTime=t,this.lastTime=t,e.seeking&&W.k.collectPromise(new Promise((t=>{const n=()=>{t(),e.removeEventListener("seeked",n)};e.addEventListener("seeked",n)}))))}play(){const t=(0,Rt.nn)().time,e=t()-this.time();this.playing(!0),this.time((()=>this.clampTime(t()-e)))}pause(){this.playing(!1),this.time.save(),this.video().pause()}seek(t){const e=this.playing();this.time(this.clampTime(t)),e?this.play():this.pause()}clampTime(t){const e=this.video().duration;return this.loop()&&(t%=e),(0,M.uZ)(0,e,t)}collectAsyncResources(){super.collectAsyncResources(),this.seekedVideo()}}Et.pool={},At([(0,h.td)()],Et.prototype,"src",void 0),At([(0,h.nn)(1),(0,h.td)()],Et.prototype,"alpha",void 0),At([(0,h.nn)(!0),(0,h.td)()],Et.prototype,"smoothing",void 0),At([(0,h.nn)(!1),(0,h.td)()],Et.prototype,"loop",void 0),At([(0,h.nn)(0),(0,h.td)()],Et.prototype,"time",void 0),At([(0,h.nn)(!1),(0,h.td)()],Et.prototype,"playing",void 0),At([(0,Z.F)()],Et.prototype,"completion",null),At([(0,Z.F)()],Et.prototype,"video",null),At([(0,Z.F)()],Et.prototype,"seekedVideo",null),At([(0,Z.F)()],Et.prototype,"fastSeekedVideo",null);var Pt=n(5376),It=n(51284),Ft=n(42075),Wt=n(67292);function*Bt(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];for(const o of e)yield o;yield*(0,It.v)(!1,...e)}(0,Ft.G)(Bt,(0,Wt.C)());var Gt=n(80638);function*Ot(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];for(const o of e)(0,Gt.R)(o)?yield*o:o()}function jt(t){const e=(0,B.$r)(),n=(0,Rt.nn)();return e.timeEvents.register(t,n.time())}(0,Ft.G)(Ot,(0,Wt.C)());var Ut=n(97715);function*qt(t,e){yield*Vt(jt(t)),e&&(yield*e)}function*Vt(t,e){void 0===t&&(t=0);const n=(0,Rt.nn)(),o=(0,Ut.te)().framesToSeconds(1),s=n.time()+t;for(;s-o>n.fixed;)yield;n.time(s),e&&(yield*e)}function*Ht(t,e){yield*Vt(t),(0,Gt.R)(e)?yield*e:e()}function $t(t,e){let n=!1;function*o(){const o=(0,Ut.te)();let s=0,r=0;for(e(r),n=!0;;)s>=o.secondsToFrames(t)?(s=0,r++,e(r),n=!0):n=!1,s++,yield}return(0,Ft.G)(o,(0,Wt.C)("every")),{runner:o(),setInterval(e){t=e,n=!1},setCallback(t){e=t,n=!1},*sync(){for(;!n;)yield}}}function*Jt(t,e){for(let n=0;n<t;n++){const t=e(n);t?yield*t:yield}}function*Yt(){}(0,Ft.G)(qt,(0,Wt.C)()),(0,Ft.G)(Vt,(0,Wt.C)()),(0,Ft.G)(Ht,(0,Wt.C)()),(0,Ft.G)(Jt,(0,Wt.C)()),(0,Ft.G)(Yt,(0,Wt.C)());var Kt=n(77396);function*Qt(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),o=1;o<e;o++)n[o-1]=arguments[o];for(const s of n)yield s,yield*Vt(t);yield*(0,It.v)(...n)}function*te(t){const{slides:e}=(0,B.$r)(),n=(0,Rt.nn)();for(e.register(t,n.fixed),yield;e.shouldWait(t);)yield}(0,Ft.G)(Qt,(0,Wt.C)());var ee=n(15688);function ne(t){switch(typeof t){case"string":return t;case"undefined":return"undefined";default:return Number.isNaN(t)?"NaN":JSON.stringify(t)}}function oe(t){const e={message:ne(t)};t&&"object"==typeof t&&(e.object=t),(0,B.wL)().debug(e)}function se(t,e,n){return function(){(0,B.wL)().warn({message:e,remarks:n,stack:(new Error).stack});for(var o=arguments.length,s=new Array(o),r=0;r<o;r++)s[r]=arguments[r];return t.apply(this,s)}}var re=n(49111),ie=n(90031),pe=n(1119),ae=n(37762),ce=n(15649),le=n(11726);function ue(t,e){return void 0===e&&(e=!0),"number"==typeof t?new le.k(e?t:t+(0,B.$r)().meta.seed.get()):(0,B.$r)().random}function me(){let t;return e=>{if(void 0===e)return t;t=e}}function de(t,e){return n=>{t[e]=n}}function he(){return{}}function ye(){return(0,Rt.nn)().time()}function fe(t){return(0,B.$r)().lifecycleEvents.onBeginRender.subscribe(t)}function ke(t){return(0,B.$r)().lifecycleEvents.onFinishRender.subscribe(t)}var we=n(46096),ge=n(81865),Me=n(73662),De=n(97140);function _e(t,e){let n;void 0===e&&(e=null);const o=(0,De.g)(t);return(0,Me.D)((()=>{const t=o();var s;n&&n.promise===t||(n=ge.h.collectPromise(t,(null==(s=n)?void 0:s.value)??e));return n.value}))}var Xe=n(16249),xe=n(60771),ve=n(74741),Ce=n(57292);class Te{static fromRotation(t){return Te.identity.rotate(t)}static fromTranslation(t){return Te.identity.translate(new k.F(t))}static fromScaling(t){return Te.identity.scale(new k.F(t))}get x(){return new k.F(this.values[0],this.values[1])}get y(){return new k.F(this.values[2],this.values[3])}get scaleX(){return this.values[0]}set scaleX(t){this.values[0]=this.x.normalized.scale(t).x}set scaleY(t){this.values[3]=this.y.normalized.scale(t).y}get scaleY(){return this.values[3]}set translateX(t){this.values[4]=t}get translateX(){return this.values[4]}set translateY(t){this.values[5]=t}get translateY(){return this.values[5]}set rotation(t){const e=this.rotate(t-this.rotation);this.values[0]=e.values[0],this.values[1]=e.values[1],this.values[2]=e.values[2],this.values[3]=e.values[3]}get rotation(){return 180*Math.atan2(this.values[1],this.values[0])/Math.PI}set translation(t){const e=new k.F(t);this.values[4]=e.x,this.values[5]=e.y}get translation(){return new k.F(this.values[4],this.values[5])}set scaling(t){const e=new k.F(t),n=new k.F(this.values[0],this.values[1]).normalized,o=new k.F(this.values[2],this.values[3]).normalized;this.values[0]=n.x*e.x,this.values[1]=n.y*e.y,this.values[2]=o.x*e.x,this.values[3]=o.y*e.y}get scaling(){return new k.F(this.values[0],this.values[3])}get inverse(){const t=this.values[0],e=this.values[1],n=this.values[2],o=this.values[3],s=this.values[4],r=this.values[5];let i=t*o-e*n;return i?(i=1/i,new Te(o*i,-e*i,-n*i,t*i,(n*r-o*s)*i,(e*s-t*r)*i)):null}get determinant(){return this.values[0]*this.values[3]-this.values[1]*this.values[2]}get domMatrix(){return new DOMMatrix([this.values[0],this.values[1],this.values[2],this.values[3],this.values[4],this.values[5]])}constructor(t,e,n,o,s,r){if(this.values=new Float32Array(6),0===arguments.length)return void(this.values=new Float32Array([1,0,0,1,0,0]));if(6===arguments.length)return this.values[0]=t,this.values[1]=e,this.values[2]=n,this.values[3]=o,this.values[4]=s,void(this.values[5]=r);if(t instanceof Te)return void(this.values=t.values);if(Array.isArray(t)){if(2===t.length)return this.values[0]=t[0],this.values[1]=t[1],this.values[2]=e[0],this.values[3]=e[1],this.values[4]=n[0],void(this.values[5]=n[1]);if(3===t.length){const e=new k.F(t[0]),n=new k.F(t[1]),o=new k.F(t[2]);return this.values[0]=e.x,this.values[1]=e.y,this.values[2]=n.x,this.values[3]=n.y,this.values[4]=o.x,void(this.values[5]=o.y)}return this.values[0]=t[0],this.values[1]=t[1],this.values[2]=t[2],this.values[3]=t[3],this.values[4]=t[4],void(this.values[5]=t[5])}const i=new k.F(t),p=new k.F(e),a=new k.F(n);this.values[0]=i.x,this.values[1]=i.y,this.values[2]=p.x,this.values[3]=p.y,this.values[4]=a.x,this.values[5]=a.y}column(t){return new k.F(this.values[2*t],this.values[2*t+1])}row(t){return[this.values[t],this.values[t+2],this.values[t+4]]}mul(t){const e=this.values[0],n=this.values[1],o=this.values[2],s=this.values[3],r=this.values[4],i=this.values[5],p=t.values[0],a=t.values[1],c=t.values[2],l=t.values[3],u=t.values[4],m=t.values[5];return new Te(e*p+o*a,n*p+s*a,e*c+o*l,n*c+s*l,e*u+o*m+r,n*u+s*m+i)}rotate(t,e){void 0===e&&(e=!0),e&&(t=t*Math.PI/180);const n=this.values[0],o=this.values[1],s=this.values[2],r=this.values[3],i=this.values[4],p=this.values[5],a=Math.sin(t),c=Math.cos(t);return new Te(n*c+s*a,o*c+r*a,n*-a+s*c,o*-a+r*c,i,p)}scale(t){const e=new k.F(t);return new Te(this.values[0]*e.x,this.values[1]*e.x,this.values[2]*e.y,this.values[3]*e.y,this.values[4],this.values[5])}mulScalar(t){return new Te(this.values[0]*t,this.values[1]*t,this.values[2]*t,this.values[3]*t,this.values[4]*t,this.values[5]*t)}translate(t){const e=new k.F(t);return new Te(this.values[0],this.values[1],this.values[2],this.values[3],this.values[0]*e.x+this.values[2]*e.y+this.values[4],this.values[1]*e.x+this.values[3]*e.y+this.values[5])}add(t){return new Te(this.values[0]+t.values[0],this.values[1]+t.values[1],this.values[2]+t.values[2],this.values[3]+t.values[3],this.values[4]+t.values[4],this.values[5]+t.values[5])}sub(t){return new Te(this.values[0]-t.values[0],this.values[1]-t.values[1],this.values[2]-t.values[2],this.values[3]-t.values[3],this.values[4]-t.values[4],this.values[5]-t.values[5])}toSymbol(){return Te.symbol}equals(t,e){return void 0===e&&(e=Ce.I),Math.abs(this.values[0]-t.values[0])<=e+Number.EPSILON&&Math.abs(this.values[1]-t.values[1])<=e+Number.EPSILON&&Math.abs(this.values[2]-t.values[2])<=e+Number.EPSILON&&Math.abs(this.values[3]-t.values[3])<=e+Number.EPSILON&&Math.abs(this.values[4]-t.values[4])<=e+Number.EPSILON&&Math.abs(this.values[5]-t.values[5])<=e+Number.EPSILON}exactlyEquals(t){return this.values[0]===t.values[0]&&this.values[1]===t.values[1]&&this.values[2]===t.values[2]&&this.values[3]===t.values[3]&&this.values[4]===t.values[4]&&this.values[5]===t.values[5]}}Te.symbol=Symbol.for("@motion-canvas/core/types/Matrix2D"),Te.identity=new Te(1,0,0,1,0,0),Te.zero=new Te(0,0,0,0,0,0);var be=n(98378),Le=n(43188),Ze=n(97074),Ne=n(74534);function*Se(t,e,n,o,s,r){const i="number"==typeof o?o:.001;r="number"==typeof o?r:s;const p=(t,e)=>{"function"==typeof o?o(t,e):"function"==typeof s&&s(t,e)};if((t=t??{mass:.05,stiffness:10,damping:.5}).mass<=0)return void(0,B.wL)().error(new Error("Spring mass must be greater than 0."));if(t.stiffness<0)return void(0,B.wL)().error(new Error("Spring stiffness must be greater or equal to 0."));if(t.damping<0)return void(0,B.wL)().error(new Error("Spring damping must be greater or equal to 0."));const a=(0,Rt.nn)();let c=e,l=t.initialVelocity??0;const u=e=>{if(null===t)return;const o=c-n,s=-t.stiffness*o-t.damping*l;l+=s/t.mass*e,c+=l*e},m=1/120;p(e,0);const d=a.time();let h=d,y=!1;for(;!y;){for(;h<a.fixed;){const t=a.fixed-h;if(m>t?(u(t),h=a.fixed):(u(m),h+=m),Math.abs(n-c)<i&&Math.abs(l)<i){a.time(h),y=!0;break}}y||(p(c,a.fixed-d),yield)}p(n,a.fixed-d),null==r||r(n,a.fixed-d)}function Re(t,e,n,o){return{mass:t,stiffness:e,damping:n,initialVelocity:o}}(0,Ft.G)(Se,(0,Wt.C)());const ze=Re(.13,5.7,1.2,10),Ae=Re(.2,20,.68,0),Ee=Re(.08,4.75,.05,0),Pe=Re(.39,19.85,2.82,0),Ie=Re(.04,10,.7,8),Fe=Re(.03,20,.9,4.8),We=Re(.16,15.35,1.88,0);function Be(){const t=(0,Rt.nn)();for(var e=arguments.length,n=new Array(e),o=0;o<e;o++)n[o]=arguments[o];for(const s of n){const e=t.children.find((t=>t.runner===s));e&&!e.canceled&&(e.cancel(),e.time(t.time()))}}var Ge=n(75168),Oe=n(50580),je=n(5881);const Ue={...o,...s,...r,...i,...p,...a,...c,_Fragment:u,_jsx:m,_jsxs:m,makeScene2D:l.r}},53487:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{v:()=>transform});var _babel_standalone__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(87243),_babel_standalone__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(_babel_standalone__WEBPACK_IMPORTED_MODULE_0__),_site_src_components_Fiddle_runtime__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(16491);function transform(code){try{const result=_babel_standalone__WEBPACK_IMPORTED_MODULE_0__.transform(code,{filename:"fiddle.tsx",presets:["typescript",["react",{runtime:"automatic",importSource:"@motion-canvas/2d/lib"}]],plugins:["mc"]});eval(result.code)}catch(e){return e}return null}_babel_standalone__WEBPACK_IMPORTED_MODULE_0__.registerPlugin("mc",(t=>{let{types:e}=t;return{visitor:{Program(t){t.node.body.unshift(e.variableDeclaration("const",[e.variableDeclarator(e.objectPattern(Object.keys(_site_src_components_Fiddle_runtime__WEBPACK_IMPORTED_MODULE_1__.Z).map((t=>e.objectProperty(e.identifier(t),e.identifier(t),!1,!0)))),e.memberExpression(e.identifier("window"),e.identifier("mc")))]))},ImportDeclaration(t){t.remove()},ExportDefaultDeclaration(t){t.replaceWith(t.node.declaration)}}}}))},70532:(t,e,n)=>{"use strict";n.d(e,{Z:()=>l});var o=n(2784),s=n(89741);const r="tooltip_lI6R",i="active_DOSD";var p=n(6277),a=n(88617),c=n(79322);function l(t){let{children:e}=t;const n=(0,s.Z)(),l=(0,a.rG)(),[u,m]=(0,o.useState)(!1),[d,h]=(0,o.useState)(null),y=(0,o.useRef)(),f=(0,o.useRef)(),k=(0,o.useRef)(),w=(0,o.useCallback)((()=>{if(!f.current||!k.current)return;const t=f.current.getBoundingClientRect();let e=window.innerWidth-t.left-496;e<0&&(e=0),k.current.style.right=`${e}px`,k.current.style.top=`${t.bottom}px`}),[]);return(0,o.useEffect)((()=>{if(!n)return;const t=t=>{var e,n,o;if(!t.target.href||null==(e=y.current)||!e.contains(t.target)||null!=(n=k.current)&&n.contains(t.target))return;const s=new URL(t.target.href,document.baseURI);if(s.pathname===window.location.pathname)return;const r=l(s.pathname+s.hash);null!=r&&null!=(o=r.comment)&&o.summary&&(f.current=t.target,m(!0),h(r.comment),w())},e=t=>{t.target===f.current&&m(!1)};return document.addEventListener("mouseenter",t,!0),document.addEventListener("focus",t,!0),document.addEventListener("mouseleave",e,!0),document.addEventListener("blur",e,!0),document.addEventListener("scroll",w),()=>{document.removeEventListener("mouseenter",t,!0),document.removeEventListener("focus",t,!0),document.removeEventListener("mouseleave",e,!0),document.removeEventListener("blur",e,!0),document.removeEventListener("scroll",w)}}),[n]),(0,o.useEffect)((()=>{w()})),o.createElement("div",{ref:y},e,o.createElement("div",{ref:k,className:(0,p.Z)(r,"padding--md margin-horiz--md",u&&i)},d&&o.createElement(c.Z,{comment:d,full:!1})))}},88617:(t,e,n)=>{"use strict";n.d(e,{Gr:()=>c,RU:()=>i,gs:()=>r,in:()=>p,rG:()=>a});var o=n(2784);const s=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:e,lookup:n,urlLookup:r}=t;return o.createElement(s.Provider,{value:{lookup:n,urlLookup:r}},e)}function i(t){const{lookup:e}=(0,o.useContext)(s);return e[t]}function p(){const{lookup:t}=(0,o.useContext)(s);return e=>{if("number"==typeof(null==e?void 0:e.project))return t[e.project][e.id]}}function a(){const{urlLookup:t,lookup:e}=(0,o.useContext)(s);return n=>{var o;const s=t[n];return s?(null==(o=e[s.projectId])?void 0:o[s.id])??null:null}}function c(t){if(t)return t.href}},80068:(t,e,n)=>{"use strict";n.d(e,{Ld:()=>p,Y0:()=>i,s2:()=>a});var o=n(2784),s=n(50822);const r=o.createContext(null);function i(t){let{children:e}=t;const n=(0,s.p)(),i=(0,o.useMemo)((()=>function(t,e){const{plain:n}=t,o=Object.create(null),s=t.styles.reduce(((t,n)=>{const{languages:o,style:s}=n;return o&&!o.includes(e)||n.types.forEach((e=>{t[e]={...t[e],...s}})),t}),o);return s.root=n,s.plain={...n,backgroundColor:null},s}(n,"typescript")),[n]);return o.createElement(r.Provider,{value:i},e)}function p(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return{className:`token ${t}`,style:e[t]??e.plain}}function a(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return e[t]??e.plain}},57708:(t,e,n)=>{"use strict";n.d(e,{It:()=>m,Wy:()=>l,mN:()=>u});var o=n(2784),s=n(31263),r=n(89741);const i="api-filters",p=s.Z.canUseDOM?localStorage.getItem(i):null,a=p?JSON.parse(p):{inherited:!0,private:!1},c=o.createContext([a,()=>{}]);function l(t){let{children:e}=t;const[n,s]=(0,o.useState)(a),p=(0,r.Z)();return o.createElement(c.Provider,{value:[n,t=>{p&&localStorage.setItem(i,JSON.stringify(t)),s(t)}]},e)}function u(){return(0,o.useContext)(c)}function m(t,e){var n,o;const s=(null==(n=e.flags)?void 0:n.isPrivate)||(null==(o=e.flags)?void 0:o.isProtected);if(!t.private&&s)return!1;const r=!!e.inheritedFrom;return!(!t.inherited&&r)}},26047:(t,e,n)=>{"use strict";n.d(e,{Z:()=>u});var o=n(7896),s=n(2784),r=n(59055);const i="icon_Fw4I";function p(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),s.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"}))}function a(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),s.createElement("path",{d:"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"}))}function c(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),s.createElement("path",{d:"M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"}))}function l(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),s.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"}))}function u(t){const e=(0,s.useMemo)((()=>{switch(t.type){case"tip":return l;case"caution":return a;case"danger":return c;default:return p}}),[t.type]);return s.createElement(s.Fragment,null,s.createElement(r.Z,(0,o.Z)({icon:s.createElement(e,{className:i})},t)))}},94141:(t,e,n)=>{"use strict";n.d(e,{Z:()=>p});var o=n(7896),s=n(2784),r=n(6277);const i="iconEdit_N_05";function p(t){let{className:e,...n}=t;return s.createElement("svg",(0,o.Z)({fill:"currentColor",width:"24px",height:"24px",viewBox:"0 0 24 24",className:(0,r.Z)(i,e),"aria-hidden":"true"},n),s.createElement("path",{d:"M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"}))}},44648:(t,e,n)=>{"use strict";n.d(e,{Z:()=>r});var o=n(7896),s=n(2784);function r(t){return s.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",style:{width:16,height:16,marginTop:"0.1rem"}},t),s.createElement("path",{d:"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z",fill:"currentColor"}))}},29459:(t,e,n)=>{"use strict";n.d(e,{Z:()=>p});var o=n(2784),s=n(52203),r=n(26773),i=n(78128);const p={...s.Z,pre:function(t){var e,n;return(0,o.isValidElement)(t.children)&&null!=(e=t.children.props)&&e.editor?o.createElement(r.Z,null,t.children.props.children):o.createElement(i.Z,(0,o.isValidElement)(t.children)&&"code"===(null==(n=t.children.props)?void 0:n.originalType)?t.children.props:{...t})}}},47733:(t,e,n)=>{"use strict";n.d(e,{Z:()=>p});var o=n(7896),s=n(2784),r=n(77287);const i="root_ZAv1";function p(t){const e=s.Children.toArray(t.children),n=e.find((t=>{var e;return s.isValidElement(t)&&"summary"===(null==(e=t.props)?void 0:e.mdxType)})),p=s.createElement(s.Fragment,null,e.filter((t=>t!==n)));return s.createElement(s.Fragment,null,s.createElement(r.P,(0,o.Z)({},t,{summary:n,className:i}),p))}},46155:(t,e,n)=>{var o={"./locale":99394,"./locale.js":99394};function s(t){var e=r(t);return n(e)}function r(t){if(!n.o(o,t)){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}return o[t]}s.keys=function(){return Object.keys(o)},s.resolve=r,t.exports=s,s.id=46155}}]);
import{H as y,g as c,I as C,J as g,S as N,K as E,i as p,s as d,r as B,u as V,O as _,L as F,Q as J,T as Y,U as H}from"./makeScene2D-f1afe989.js";class I{}class K extends I{constructor(t,e,s,n,a){super(),this.center=t,this.radius=e,this.from=s,this.to=n,this.counter=a,this.angle=Math.acos(y(-1,1,s.dot(n))),this.length=Math.abs(this.angle*e)}get arcLength(){return this.length}draw(t,e,s){const n=this.counter?-1:1,a=this.from.radians+e*this.angle*n,i=this.to.radians-(1-s)*this.angle*n;Math.abs(this.angle)>1e-4&&t.arc(this.center.x,this.center.y,this.radius,a,i,this.counter);const o=c.fromRadians(a),l=c.fromRadians(i);return[{position:this.center.add(o.scale(this.radius)),tangent:this.counter?o:o.flipped,normal:this.counter?o:o.flipped},{position:this.center.add(l.scale(this.radius)),tangent:this.counter?l.flipped:l,normal:this.counter?l.flipped:l}]}getPoint(t){const e=this.counter?-1:1,s=this.from.radians+t*this.angle*e,n=c.fromRadians(s);return{position:this.center.add(n.scale(this.radius)),tangent:this.counter?n:n.flipped,normal:this.counter?n:n.flipped}}}function W(r,t){const e=y(0,r.arcLength,t);let s=0;for(const n of r.segments){const a=s;if(s+=n.arcLength,s>=e){const i=(e-a)/n.arcLength;return n.getPoint(y(0,1,i))}}return{position:c.zero,tangent:c.up,normal:c.up}}class q extends I{constructor(t,e){super(),this.from=t,this.to=e,this.vector=e.sub(t),this.length=this.vector.magnitude,this.normal=this.vector.perpendicular.normalized.safe}get arcLength(){return this.length}draw(t,e=0,s=1,n=!1){const a=this.from.add(this.vector.scale(e)),i=this.from.add(this.vector.scale(s));return n&&C(t,a),g(t,i),[{position:a,tangent:this.normal.flipped,normal:this.normal},{position:i,tangent:this.normal,normal:this.normal}]}getPoint(t){return{position:this.from.add(this.vector.scale(t)),tangent:this.normal.flipped,normal:this.normal}}}function Q(r,t,e){const s={arcLength:0,segments:[],minSin:1};if(r.length===0)return s;if(e){const i=r[0].add(r[r.length-1]).scale(.5);r.unshift(i),r.push(i)}let n=r[0];for(let i=2;i<r.length;i++){const o=r[i-2],l=r[i-1],u=r[i],P=o.sub(l),b=u.sub(l),h=P.normalized.safe,w=b.normalized.safe,D=Math.acos(y(-1,1,h.dot(w))),v=Math.tan(D/2),L=Math.sin(D/2),j=Math.min(t,v*P.magnitude*(i===2?1:.5),v*b.magnitude*(i===r.length-1?1:.5)),A=L===0?0:j/L,S=v===0?0:j/v,k=h.add(w).scale(1/2).normalized.safe.scale(A).add(l),z=h.perpendicular.dot(w)<0,M=new q(n,l.add(h.scale(S))),R=new K(k,j,h.perpendicular.scale(z?1:-1),w.perpendicular.scale(z?-1:1),z);s.segments.push(M),s.segments.push(R),s.arcLength+=M.arcLength,s.arcLength+=R.arcLength,s.minSin=Math.min(s.minSin,Math.abs(L)),n=l.add(w.scale(S))}const a=new q(n,r[r.length-1]);return s.segments.push(a),s.arcLength+=a.arcLength,s}var m=globalThis&&globalThis.__decorate||function(r,t,e,s){var n=arguments.length,a=n<3?t:s===null?s=Object.getOwnPropertyDescriptor(t,e):s,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")a=Reflect.decorate(r,t,e,s);else for(var o=r.length-1;o>=0;o--)(i=r[o])&&(a=(n<3?i(a):n>3?i(t,e,a):i(t,e))||a);return n>3&&a&&Object.defineProperty(t,e,a),a};class f extends N{desiredSize(){return this.childrenBBox().size}constructor(t){super(t)}percentageToDistance(t){const{arcLength:e}=this.profile(),s=this.startOffset(),n=this.endOffset(),a=e-s-n;return s+a*t}curveDrawingInfo(){const t=new Path2D,e=this.profile();let s=this.percentageToDistance(this.start()),n=this.percentageToDistance(this.end());s>n&&([s,n]=[n,s]);const a=n-s,i=Math.min(a/2,this.arrowSize());this.startArrow()&&(s+=i/2),this.endArrow()&&(n-=i/2);let o=0,l=null,u=null,P=null,b=null;for(const h of e.segments){const w=o;if(o+=h.arcLength,o<s)continue;const D=(s-w)/h.arcLength,v=(n-w)/h.arcLength,L=y(0,1,D),j=y(0,1,v),[A,S]=h.draw(t,L,j,l===null);if(l===null&&(l=A.position,u=A.normal.flipped.perpendicular),P=S.position,b=S.normal.flipped.perpendicular,o>n)break}return this.end()===1&&this.closed()&&t.closePath(),{startPoint:l??c.zero,startTangent:u??c.right,endPoint:P??c.zero,endTangent:b??c.right,arrowSize:i,path:t,startOffset:s}}getPointAtDistance(t){return W(this.profile(),t+this.startOffset())}getPointAtPercentage(t){return W(this.profile(),this.percentageToDistance(t))}applyStyle(t){super.applyStyle(t);const{arcLength:e}=this.profile();t.lineDashOffset-=e/2}getComputedLayout(){return this.offsetComputedLayout(super.getComputedLayout())}offsetComputedLayout(t){return t.position=t.position.sub(this.childrenBBox().center),t}getPath(){return this.curveDrawingInfo().path}getCacheBBox(){const t=this.childrenBBox(),e=this.arrowSize(),s=this.lineWidth(),n=this.lineWidthCoefficient();return t.expand(Math.max(0,e,s*n))}lineWidthCoefficient(){return this.lineCap()==="square"?.5*1.4143:.5}drawShape(t){super.drawShape(t);const{startPoint:e,startTangent:s,endPoint:n,endTangent:a,arrowSize:i}=this.curveDrawingInfo();i<.001||(t.save(),t.beginPath(),this.endArrow()&&this.drawArrow(t,n,a.flipped,i),this.startArrow()&&this.drawArrow(t,e,s,i),t.fillStyle=E(this.stroke(),t),t.closePath(),t.fill(),t.restore())}drawArrow(t,e,s,n){const a=s.perpendicular,i=e.add(s.scale(-n/2));C(t,i),g(t,i.add(s.add(a).scale(n))),g(t,i.add(s.sub(a).scale(n))),g(t,i),t.closePath()}}m([p(!1),d()],f.prototype,"closed",void 0);m([p(0),d()],f.prototype,"start",void 0);m([p(0),d()],f.prototype,"startOffset",void 0);m([p(!1),d()],f.prototype,"startArrow",void 0);m([p(1),d()],f.prototype,"end",void 0);m([p(0),d()],f.prototype,"endOffset",void 0);m([p(!1),d()],f.prototype,"endArrow",void 0);m([p(24),d()],f.prototype,"arrowSize",void 0);m([B()],f.prototype,"curveDrawingInfo",null);var T=globalThis&&globalThis.__decorate||function(r,t,e,s){var n=arguments.length,a=n<3?t:s===null?s=Object.getOwnPropertyDescriptor(t,e):s,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")a=Reflect.decorate(r,t,e,s);else for(var o=r.length-1;o>=0;o--)(i=r[o])&&(a=(n<3?i(a):n>3?i(t,e,a):i(t,e))||a);return n>3&&a&&Object.defineProperty(t,e,a),a};class O extends f{constructor(t){super(t),t.children===void 0&&t.points===void 0&&V().warn({message:"No points specified for the line",remarks:`<p>The line won&#39;t be visible unless you specify at least two points:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span>
  stroke=<span class="hljs-string">&quot;#fff&quot;</span>
  lineWidth={<span class="hljs-number">8</span>}
  points={[
    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],
  ]}
/&gt;
</code></pre>
<p>Alternatively, you can define the points using the children:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> /&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>
&lt;/<span class="hljs-title class_">Line</span>&gt;
</code></pre>
<p>If you did this intentionally, and want to disable this message, set the
<code>points</code> property to <code>null</code>:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>} points={<span class="hljs-literal">null</span>} /&gt;
</code></pre>
`,inspect:this.key})}childrenBBox(){const t=this.points(),e=t?t.map(s=>new c(_(s)?s():s)):this.children().filter(s=>!(s instanceof F)||s.isLayoutRoot()).map(s=>s.position());return J.fromPoints(...e)}parsedPoints(){const t=this.points();return t?t.map(e=>new c(_(e)?e():e)):this.children().map(e=>e.position())}profile(){return Q(this.parsedPoints(),this.radius(),this.closed())}lineWidthCoefficient(){const t=this.radius(),e=this.lineJoin();let s=super.lineWidthCoefficient();if(t===0&&e==="miter"){const{minSin:n}=this.profile();n>0&&(s=Math.max(s,.5/n))}return s}drawOverlay(t,e){const s=this.childrenBBox().transformCorners(e),a=this.computedSize().mul(this.offset()).scale(.5).transformAsPoint(e);t.fillStyle="white",t.strokeStyle="black",t.lineWidth=1;const i=new Path2D,o=this.parsedPoints().map(u=>u.transformAsPoint(e));if(o.length>0){C(i,o[0]);for(const u of o)g(i,u),t.beginPath(),Y(t,u,4),t.closePath(),t.fill(),t.stroke()}t.strokeStyle="white",t.stroke(i);const l=8;t.beginPath(),g(t,a.addY(-l)),g(t,a.addY(l)),g(t,a),g(t,a.addX(-l)),t.arc(a.x,a.y,l,0,Math.PI*2),t.stroke(),t.beginPath(),H(t,s),t.closePath(),t.stroke()}}T([p(0),d()],O.prototype,"radius",void 0);T([p(null),d()],O.prototype,"points",void 0);T([B()],O.prototype,"childrenBBox",null);T([B()],O.prototype,"parsedPoints",null);T([B()],O.prototype,"profile",null);export{O as L};

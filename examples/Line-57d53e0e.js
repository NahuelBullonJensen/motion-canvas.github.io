import{G as P,g as p,H as O,I as m,S as I,u as W,J as R,L as E,K as N,O as V,P as F,Q as J,i as u,s as f,q as B}from"./makeScene2D-e0bf4ae8.js";class C{}class Y extends C{constructor(s,e,t,n,r){super(),this.center=s,this.radius=e,this.from=t,this.to=n,this.counter=r,this.angle=Math.acos(P(-1,1,t.dot(n))),this.length=Math.abs(this.angle*e)}get arcLength(){return this.length}draw(s,e,t){const n=this.counter?-1:1,r=this.from.radians+e*this.angle*n,a=this.to.radians-(1-t)*this.angle*n;Math.abs(e-t)>1e-4&&s.arc(this.center.x,this.center.y,this.radius,r,a,this.counter);const i=p.fromRadians(r),l=p.fromRadians(a);return[this.center.add(i.scale(this.radius)),this.counter?i:i.flipped,this.center.add(l.scale(this.radius)),this.counter?l.flipped:l]}getPoint(s){const e=this.counter?-1:1,t=this.from.radians+s*this.angle*e,n=p.fromRadians(t);return[this.center.add(n.scale(this.radius)),this.counter?n:n.flipped]}}function q(o,s){const e=P(0,o.arcLength,s);let t=0;for(const n of o.segments){const r=t;if(t+=n.arcLength,t>=e){const a=(e-r)/n.arcLength,[i,l]=n.getPoint(P(0,1,a));return{position:i,tangent:l}}}return{position:p.zero,tangent:p.up}}class _ extends C{constructor(s,e){super(),this.from=s,this.to=e,this.vector=e.sub(s),this.length=this.vector.magnitude,this.tangent=this.vector.perpendicular.normalized.safe}get arcLength(){return this.length}draw(s,e=0,t=1,n=!1){const r=this.from.add(this.vector.scale(e)),a=this.from.add(this.vector.scale(t));return n&&O(s,r),m(s,a),[r,this.tangent.flipped,a,this.tangent]}getPoint(s){return[this.from.add(this.vector.scale(s)),this.tangent.flipped]}}function G(o,s,e){const t={arcLength:0,segments:[],minSin:1};if(o.length===0)return t;if(e){const a=o[0].add(o[o.length-1]).scale(.5);o.unshift(a),o.push(a)}let n=o[0];for(let a=2;a<o.length;a++){const i=o[a-2],l=o[a-1],g=o[a],v=i.sub(l),b=g.sub(l),d=v.normalized.safe,w=b.normalized.safe,T=Math.acos(P(-1,1,d.dot(w))),y=Math.tan(T/2),L=Math.sin(T/2),j=Math.min(s,y*v.magnitude*(a===2?1:.5),y*b.magnitude*(a===o.length-1?1:.5)),D=L===0?0:j/L,A=y===0?0:j/y,z=d.add(w).scale(1/2).normalized.safe.scale(D).add(l),S=d.perpendicular.dot(w)<0,M=new _(n,l.add(d.scale(A))),k=new Y(z,j,d.perpendicular.scale(S?1:-1),w.perpendicular.scale(S?-1:1),S);t.segments.push(M),t.segments.push(k),t.arcLength+=M.arcLength,t.arcLength+=k.arcLength,t.minSin=Math.min(t.minSin,Math.abs(L)),n=l.add(w.scale(A))}const r=new _(n,o[o.length-1]);return t.segments.push(r),t.arcLength+=r.arcLength,t}var c=globalThis&&globalThis.__decorate||function(o,s,e,t){var n=arguments.length,r=n<3?s:t===null?t=Object.getOwnPropertyDescriptor(s,e):t,a;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")r=Reflect.decorate(o,s,e,t);else for(var i=o.length-1;i>=0;i--)(a=o[i])&&(r=(n<3?a(r):n>3?a(s,e,r):a(s,e))||r);return n>3&&r&&Object.defineProperty(s,e,r),r};class h extends I{desiredSize(){return this.childrenBBox().size}constructor(s){super(s),s.children===void 0&&s.points===void 0&&W().warn({message:"No points specified for the line",remarks:`<p>The line won&#39;t be visible unless you specify at least two points:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span>
  stroke=<span class="hljs-string">&quot;#fff&quot;</span>
  lineWidth={<span class="hljs-number">8</span>}
  points={[
    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],
  ]}
/&gt;
</code></pre>
<p>Alternatively, you can define the points using the children:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> /&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>
&lt;/<span class="hljs-title class_">Line</span>&gt;
</code></pre>
<p>If you did this intentionally, and want to disable this message, set the
<code>points</code> property to <code>null</code>:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>} points={<span class="hljs-literal">null</span>} /&gt;
</code></pre>
`,inspect:this.key})}childrenBBox(){const s=this.points(),e=s?s.map(t=>new p(R(t)?t():t)):this.children().filter(t=>!(t instanceof E)||t.isLayoutRoot()).map(t=>t.position());return N.fromPoints(...e)}parsedPoints(){const s=this.points();return s?s.map(e=>new p(R(e)?e():e)):this.children().map(e=>e.position())}profile(){return G(this.parsedPoints(),this.radius(),this.closed())}percentageToDistance(s){const{arcLength:e}=this.profile(),t=this.startOffset(),n=this.endOffset(),r=e-t-n;return t+r*s}curveDrawingInfo(){const s=new Path2D,e=this.profile();let t=this.percentageToDistance(this.start()),n=this.percentageToDistance(this.end());t>n&&([t,n]=[n,t]);const r=n-t,a=Math.min(r/2,this.arrowSize());this.startArrow()&&(t+=a/2),this.endArrow()&&(n-=a/2);let i=0,l=null,g=null,v=null,b=null;for(const d of e.segments){const w=i;if(i+=d.arcLength,i<t)continue;const T=(t-w)/d.arcLength,y=(n-w)/d.arcLength,L=P(0,1,T),j=P(0,1,y),[D,A,z,S]=d.draw(s,L,j,l===null);if(l===null&&(l=D,g=A),v=z,b=S,i>n)break}return{startPoint:l??p.zero,startTangent:g??p.up,endPoint:v??p.zero,endTangent:b??p.up,arrowSize:a,path:s,startOffset:t}}getPointAtDistance(s){return q(this.profile(),s+this.startOffset())}getPointAtPercentage(s){return q(this.profile(),this.percentageToDistance(s))}applyStyle(s){super.applyStyle(s);const{arcLength:e}=this.profile();s.lineDashOffset-=e/2}getComputedLayout(){const s=super.getComputedLayout();return s.position=s.position.sub(this.childrenBBox().center),s}getPath(){return this.curveDrawingInfo().path}getCacheBBox(){const s=this.childrenBBox(),e=this.arrowSize(),t=this.lineWidth(),n=this.radius(),r=this.lineJoin(),a=this.lineCap();let i=.5;if(n===0&&r==="miter"){const{minSin:l}=this.profile();l>0&&(i=Math.max(i,.5/l))}return a==="square"&&(i=Math.max(i,.5*1.4143)),s.expand(Math.max(0,e,t*i))}drawShape(s){super.drawShape(s);const{startPoint:e,startTangent:t,endPoint:n,endTangent:r,arrowSize:a}=this.curveDrawingInfo();a<.001||(s.save(),s.beginPath(),this.endArrow()&&this.drawArrow(s,n,r,a),this.startArrow()&&this.drawArrow(s,e,t,a),s.fillStyle=V(this.stroke(),s),s.closePath(),s.fill(),s.restore())}drawArrow(s,e,t,n){const r=t.perpendicular,a=e.add(r.scale(-n/2));O(s,a),m(s,a.add(r.add(t).scale(n))),m(s,a.add(r.sub(t).scale(n))),m(s,a),s.closePath()}drawOverlay(s,e){const t=this.childrenBBox().transformCorners(e),r=this.computedSize().mul(this.offset()).scale(.5).transformAsPoint(e);s.fillStyle="white",s.strokeStyle="black",s.lineWidth=1;const a=new Path2D,i=this.parsedPoints().map(g=>g.transformAsPoint(e));if(i.length>0){O(a,i[0]);for(const g of i)m(a,g),s.beginPath(),F(s,g,4),s.closePath(),s.fill(),s.stroke()}s.strokeStyle="white",s.stroke(a);const l=8;s.beginPath(),m(s,r.addY(-l)),m(s,r.addY(l)),m(s,r),m(s,r.addX(-l)),s.arc(r.x,r.y,l,0,Math.PI*2),s.stroke(),s.beginPath(),J(s,t),s.closePath(),s.stroke()}}c([u(0),f()],h.prototype,"radius",void 0);c([u(!1),f()],h.prototype,"closed",void 0);c([u(0),f()],h.prototype,"start",void 0);c([u(0),f()],h.prototype,"startOffset",void 0);c([u(!1),f()],h.prototype,"startArrow",void 0);c([u(1),f()],h.prototype,"end",void 0);c([u(0),f()],h.prototype,"endOffset",void 0);c([u(!1),f()],h.prototype,"endArrow",void 0);c([u(24),f()],h.prototype,"arrowSize",void 0);c([u(null),f()],h.prototype,"points",void 0);c([B()],h.prototype,"childrenBBox",null);c([B()],h.prototype,"parsedPoints",null);c([B()],h.prototype,"profile",null);c([B()],h.prototype,"curveDrawingInfo",null);export{h as L};

import{H as P,g as p,I as O,J as m,S as I,K as C,L as W,O as E,u as N,Q as V,T as F,U as J,i as u,s as f,r as B}from"./makeScene2D-358d6c97.js";class q{}class Y extends q{constructor(t,e,s,n,r){super(),this.center=t,this.radius=e,this.from=s,this.to=n,this.counter=r,this.angle=Math.acos(P(-1,1,s.dot(n))),this.length=Math.abs(this.angle*e)}get arcLength(){return this.length}draw(t,e,s){const n=this.counter?-1:1,r=this.from.radians+e*this.angle*n,a=this.to.radians-(1-s)*this.angle*n;Math.abs(this.angle)>1e-4&&t.arc(this.center.x,this.center.y,this.radius,r,a,this.counter);const o=p.fromRadians(r),l=p.fromRadians(a);return[this.center.add(o.scale(this.radius)),this.counter?o:o.flipped,this.center.add(l.scale(this.radius)),this.counter?l.flipped:l]}getPoint(t){const e=this.counter?-1:1,s=this.from.radians+t*this.angle*e,n=p.fromRadians(s);return{position:this.center.add(n.scale(this.radius)),tangent:this.counter?n:n.flipped}}}function R(i,t){const e=P(0,i.arcLength,t);let s=0;for(const n of i.segments){const r=s;if(s+=n.arcLength,s>=e){const a=(e-r)/n.arcLength;return n.getPoint(P(0,1,a))}}return{position:p.zero,tangent:p.up}}class _ extends q{constructor(t,e){super(),this.from=t,this.to=e,this.vector=e.sub(t),this.length=this.vector.magnitude,this.tangent=this.vector.perpendicular.normalized.safe}get arcLength(){return this.length}draw(t,e=0,s=1,n=!1){const r=this.from.add(this.vector.scale(e)),a=this.from.add(this.vector.scale(s));return n&&O(t,r),m(t,a),[r,this.tangent.flipped,a,this.tangent]}getPoint(t){return{position:this.from.add(this.vector.scale(t)),tangent:this.tangent.flipped}}}function H(i,t,e){const s={arcLength:0,segments:[],minSin:1};if(i.length===0)return s;if(e){const a=i[0].add(i[i.length-1]).scale(.5);i.unshift(a),i.push(a)}let n=i[0];for(let a=2;a<i.length;a++){const o=i[a-2],l=i[a-1],g=i[a],v=o.sub(l),L=g.sub(l),d=v.normalized.safe,w=L.normalized.safe,T=Math.acos(P(-1,1,d.dot(w))),y=Math.tan(T/2),b=Math.sin(T/2),j=Math.min(t,y*v.magnitude*(a===2?1:.5),y*L.magnitude*(a===i.length-1?1:.5)),D=b===0?0:j/b,A=y===0?0:j/y,z=d.add(w).scale(1/2).normalized.safe.scale(D).add(l),S=d.perpendicular.dot(w)<0,M=new _(n,l.add(d.scale(A))),k=new Y(z,j,d.perpendicular.scale(S?1:-1),w.perpendicular.scale(S?-1:1),S);s.segments.push(M),s.segments.push(k),s.arcLength+=M.arcLength,s.arcLength+=k.arcLength,s.minSin=Math.min(s.minSin,Math.abs(b)),n=l.add(w.scale(A))}const r=new _(n,i[i.length-1]);return s.segments.push(r),s.arcLength+=r.arcLength,s}var c=globalThis&&globalThis.__decorate||function(i,t,e,s){var n=arguments.length,r=n<3?t:s===null?s=Object.getOwnPropertyDescriptor(t,e):s,a;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")r=Reflect.decorate(i,t,e,s);else for(var o=i.length-1;o>=0;o--)(a=i[o])&&(r=(n<3?a(r):n>3?a(t,e,r):a(t,e))||r);return n>3&&r&&Object.defineProperty(t,e,r),r};class h extends I{desiredSize(){return this.childrenBBox().size}constructor(t){super(t),this.validateProps(t)}childrenBBox(){const t=this.points(),e=t?t.map(s=>new p(C(s)?s():s)):this.children().filter(s=>!(s instanceof W)||s.isLayoutRoot()).map(s=>s.position());return E.fromPoints(...e)}parsedPoints(){const t=this.points();return t?t.map(e=>new p(C(e)?e():e)):this.children().map(e=>e.position())}profile(){return H(this.parsedPoints(),this.radius(),this.closed())}percentageToDistance(t){const{arcLength:e}=this.profile(),s=this.startOffset(),n=this.endOffset(),r=e-s-n;return s+r*t}curveDrawingInfo(){const t=new Path2D,e=this.profile();let s=this.percentageToDistance(this.start()),n=this.percentageToDistance(this.end());s>n&&([s,n]=[n,s]);const r=n-s,a=Math.min(r/2,this.arrowSize());this.startArrow()&&(s+=a/2),this.endArrow()&&(n-=a/2);let o=0,l=null,g=null,v=null,L=null;for(const d of e.segments){const w=o;if(o+=d.arcLength,o<s)continue;const T=(s-w)/d.arcLength,y=(n-w)/d.arcLength,b=P(0,1,T),j=P(0,1,y),[D,A,z,S]=d.draw(t,b,j,l===null);if(l===null&&(l=D,g=A),v=z,L=S,o>n)break}return this.end()===1&&this.closed()&&t.closePath(),{startPoint:l??p.zero,startTangent:g??p.up,endPoint:v??p.zero,endTangent:L??p.up,arrowSize:a,path:t,startOffset:s}}getPointAtDistance(t){return R(this.profile(),t+this.startOffset())}getPointAtPercentage(t){return R(this.profile(),this.percentageToDistance(t))}applyStyle(t){super.applyStyle(t);const{arcLength:e}=this.profile();t.lineDashOffset-=e/2}getComputedLayout(){return this.offsetComputedLayout(super.getComputedLayout())}offsetComputedLayout(t){return t.position=t.position.sub(this.childrenBBox().center),t}validateProps(t){t.children===void 0&&t.points===void 0&&N().warn({message:"No points specified for the line",remarks:`<p>The line won&#39;t be visible unless you specify at least two points:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span>
  stroke=<span class="hljs-string">&quot;#fff&quot;</span>
  lineWidth={<span class="hljs-number">8</span>}
  points={[
    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],
  ]}
/&gt;
</code></pre>
<p>Alternatively, you can define the points using the children:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> /&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>
&lt;/<span class="hljs-title class_">Line</span>&gt;
</code></pre>
<p>If you did this intentionally, and want to disable this message, set the
<code>points</code> property to <code>null</code>:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>} points={<span class="hljs-literal">null</span>} /&gt;
</code></pre>
`,inspect:this.key})}getPath(){return this.curveDrawingInfo().path}getCacheBBox(){const t=this.childrenBBox(),e=this.arrowSize(),s=this.lineWidth(),n=this.radius(),r=this.lineJoin(),a=this.lineCap();let o=.5;if(n===0&&r==="miter"){const{minSin:l}=this.profile();l>0&&(o=Math.max(o,.5/l))}return a==="square"&&(o=Math.max(o,.5*1.4143)),t.expand(Math.max(0,e,s*o))}drawShape(t){super.drawShape(t);const{startPoint:e,startTangent:s,endPoint:n,endTangent:r,arrowSize:a}=this.curveDrawingInfo();a<.001||(t.save(),t.beginPath(),this.endArrow()&&this.drawArrow(t,n,r,a),this.startArrow()&&this.drawArrow(t,e,s,a),t.fillStyle=V(this.stroke(),t),t.closePath(),t.fill(),t.restore())}drawArrow(t,e,s,n){const r=s.perpendicular,a=e.add(r.scale(-n/2));O(t,a),m(t,a.add(r.add(s).scale(n))),m(t,a.add(r.sub(s).scale(n))),m(t,a),t.closePath()}drawOverlay(t,e){const s=this.childrenBBox().transformCorners(e),r=this.computedSize().mul(this.offset()).scale(.5).transformAsPoint(e);t.fillStyle="white",t.strokeStyle="black",t.lineWidth=1;const a=new Path2D,o=this.parsedPoints().map(g=>g.transformAsPoint(e));if(o.length>0){O(a,o[0]);for(const g of o)m(a,g),t.beginPath(),F(t,g,4),t.closePath(),t.fill(),t.stroke()}t.strokeStyle="white",t.stroke(a);const l=8;t.beginPath(),m(t,r.addY(-l)),m(t,r.addY(l)),m(t,r),m(t,r.addX(-l)),t.arc(r.x,r.y,l,0,Math.PI*2),t.stroke(),t.beginPath(),J(t,s),t.closePath(),t.stroke()}}c([u(0),f()],h.prototype,"radius",void 0);c([u(!1),f()],h.prototype,"closed",void 0);c([u(0),f()],h.prototype,"start",void 0);c([u(0),f()],h.prototype,"startOffset",void 0);c([u(!1),f()],h.prototype,"startArrow",void 0);c([u(1),f()],h.prototype,"end",void 0);c([u(0),f()],h.prototype,"endOffset",void 0);c([u(!1),f()],h.prototype,"endArrow",void 0);c([u(24),f()],h.prototype,"arrowSize",void 0);c([u(null),f()],h.prototype,"points",void 0);c([B()],h.prototype,"childrenBBox",null);c([B()],h.prototype,"parsedPoints",null);c([B()],h.prototype,"profile",null);c([B()],h.prototype,"curveDrawingInfo",null);export{h as L};
